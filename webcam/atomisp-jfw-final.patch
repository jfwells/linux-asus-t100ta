1.TODO: Replace all enum_mbus_pixelcode to enum media_bus_format code DONE
2. replace all V4L2_MBUS_FMT to MEDIA_BUS_FMT_
3. ensure all defines are uint32
--------------
diff --git a/arch/x86/pci/common.c b/arch/x86/pci/common.c
index eccd4d9..66126c3 100644
--- a/arch/x86/pci/common.c
+++ b/arch/x86/pci/common.c
@@ -19,6 +19,7 @@
 #include <asm/smp.h>
 #include <asm/pci_x86.h>
 #include <asm/setup.h>
+#include <linux/module.h>

 unsigned int pci_probe = PCI_PROBE_BIOS | PCI_PROBE_CONF1 | PCI_PROBE_CONF2 |
 				PCI_PROBE_MMCONF;
@@ -81,6 +82,8 @@ struct pci_ops pci_root_ops = {
  */
 DEFINE_RAW_SPINLOCK(pci_config_lock);

+EXPORT_SYMBOL(pci_config_lock);
+
 static int __init can_skip_ioresource_align(const struct dmi_system_id *d)
 {
 	pci_probe |= PCI_CAN_SKIP_ISA_ALIGN;
diff --git a/arch/x86/platform/atom/Makefile b/arch/x86/platform/atom/Makefile
index 40983f5..49c1928 100644
--- a/arch/x86/platform/atom/Makefile
+++ b/arch/x86/platform/atom/Makefile
@@ -1,2 +1,9 @@
 obj-$(CONFIG_PMC_ATOM)		+= pmc_atom.o
 obj-$(CONFIG_PUNIT_ATOM_DEBUG)	+= punit_atom_debug.o
+
+# BOARD files
++obj-y	+= platform_mt9m114.o
++obj-y 	+= platform_ov5640_2.o
++obj-y 	+= platform_ov5640_1.o
++obj-y	+= platform_camera.o
++obj-y	+= byt_plat_clock.o
diff --git a/drivers/media/Kconfig b/drivers/media/Kconfig
index 3ef3d6c..b5be371 100644
--- a/drivers/media/Kconfig
+++ b/drivers/media/Kconfig
@@ -20,10 +20,14 @@ comment "Multimedia core support"
 #
 config MEDIA_CAMERA_SUPPORT
 	bool "Cameras/video grabbers support"
+	select X86_MRFLD
 	---help---
 	  Enable support for webcams and video grabbers.

 	  Say Y when you have a webcam or a video capture grabber board.
+
+config X86_MRFLD
+	tristate

 config MEDIA_ANALOG_TV_SUPPORT
 	bool "Analog TV support"
@@ -213,6 +217,7 @@ config MEDIA_ATTACH
 	depends on MODULES
 	default MODULES

+source "drivers/media/atomisp2/Kconfig"
 source "drivers/media/i2c/Kconfig"
 source "drivers/media/tuners/Kconfig"
 source "drivers/media/dvb-frontends/Kconfig"
diff --git a/drivers/media/Makefile b/drivers/media/Makefile
index e608bbc..350c970 100644
--- a/drivers/media/Makefile
+++ b/drivers/media/Makefile
@@ -21,6 +21,9 @@ endif
 obj-$(CONFIG_VIDEO_DEV) += v4l2-core/
 obj-$(CONFIG_DVB_CORE)  += dvb-core/

+# Atomisp driver
+obj-$(CONFIG_VIDEO_ATOMISP) += atomisp2/
+
 # There are both core and drivers at RC subtree - merge before drivers
 obj-y += rc/

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 521bbf1..ad4088b 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -626,6 +626,20 @@ config VIDEO_S5C73M3
 	---help---
 	  This is a V4L2 sensor-level driver for Samsung S5C73M3
 	  8 Mpixel camera.
+
+config VIDEO_MT9M114
+	tristate "Aptina MT9M114 sensor support"
+	depends on VIDEO_ATOMISP
+	default m
+	---help---
+	  Aptina MT9M114 sensor for ATOMISP
+
+config VIDEO_OV5640
+	tristate "Omnivision OV5640 sensor support"
+	depends on VIDEO_ATOMISP
+	default m
+	---help---
+	  Omnivision OV5640 sensor for ATOMISP

 comment "Flash devices"

diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 07db257..0c2f79e 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -79,3 +79,6 @@ obj-$(CONFIG_VIDEO_IR_I2C)  += ir-kbd-i2c.o
 obj-$(CONFIG_VIDEO_ML86V7667)	+= ml86v7667.o
 obj-$(CONFIG_VIDEO_OV2659)	+= ov2659.o
 obj-$(CONFIG_VIDEO_TC358743)	+= tc358743.o
+obj-$(CONFIG_VIDEO_OV5640) += ov5640_2.o
+obj-$(CONFIG_VIDEO_OV5640) += ov5640_1.o
+obj-$(CONFIG_VIDEO_MT9M114) += mt9m114.o
diff --git a/drivers/media/v4l2-core/videobuf2-dma-contig.c b/drivers/media/v4l2-core/videobuf2-dma-contig.c
index c331272..58e626c 100644
--- a/drivers/media/v4l2-core/videobuf2-dma-contig.c
+++ b/drivers/media/v4l2-core/videobuf2-dma-contig.c
@@ -25,7 +25,7 @@ struct vb2_dc_conf {
 	struct device		*dev;
 };

-struct vb2_dc_buf {
+/* struct vb2_dc_buf {
 	struct device			*dev;
 	void				*vaddr;
 	unsigned long			size;
@@ -34,14 +34,14 @@ struct vb2_dc_buf {
 	struct sg_table			*dma_sgt;
 	struct frame_vector		*vec;

-	/* MMAP related */
+	 MMAP related
 	struct vb2_vmarea_handler	handler;
 	atomic_t			refcount;
 	struct sg_table			*sgt_base;

-	/* DMABUF related */
+	 DMABUF related
 	struct dma_buf_attachment	*db_attach;
-};
+};*/

 /*********************************************/
 /*        scatterlist table functions        */
@@ -55,8 +55,9 @@ static unsigned long vb2_dc_get_contiguous_size(struct sg_table *sgt)
 	unsigned long size = 0;

 	for_each_sg(sgt->sgl, s, sgt->nents, i) {
-		if (sg_dma_address(s) != expected)
-			break;
+		//TODO SARAT super big hack to get large resolutions to work. Actual fix is to switch to dma-sg backend for vb2.
+		//if (sg_dma_address(s) != expected)
+		//	break;
 		expected = sg_dma_address(s) + sg_dma_len(s);
 		size += sg_dma_len(s);
 	}
@@ -67,6 +68,7 @@ static unsigned long vb2_dc_get_contiguous_size(struct sg_table *sgt)
 /*         callbacks for all buffers         */
 /*********************************************/

+
 static void *vb2_dc_cookie(void *buf_priv)
 {
 	struct vb2_dc_buf *buf = buf_priv;
diff --git a/include/media/videobuf2-dma-contig.h b/include/media/videobuf2-dma-contig.h
index c33dfa6..5276f62 100644
--- a/include/media/videobuf2-dma-contig.h
+++ b/include/media/videobuf2-dma-contig.h
@@ -15,6 +15,26 @@

 #include <media/videobuf2-v4l2.h>
 #include <linux/dma-mapping.h>
+struct vb2_dc_buf {
+	struct device			*dev;
+	void				*vaddr;
+	unsigned long			size;
+	dma_addr_t			dma_addr;
+	enum dma_data_direction		dma_dir;
+	struct sg_table			*dma_sgt;
+
+	/* MMAP related */
+	struct vb2_vmarea_handler	handler;
+	atomic_t			refcount;
+	struct sg_table			*sgt_base;
+
+	/* USERPTR related */
+	struct vm_area_struct		*vma;
+
+	/* DMABUF related */
+	struct dma_buf_attachment	*db_attach;
+};
+

 static inline dma_addr_t
 vb2_dma_contig_plane_dma_addr(struct vb2_buffer *vb, unsigned int plane_no)
diff --git a/arch/x86/platform/atom/byt_plat_clock.c b/arch/x86/platform/atom/byt_plat_clock.c
new file mode 100644
index 0000000..7c811c2
--- /dev/null
+++ b/arch/x86/platform/atom/byt_plat_clock.c
@@ -0,0 +1,181 @@
+/*
+ * byt_plat_clock.c - VLV2 platform clock driver
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Author: Asutosh Pathak <asutosh.pathak@intel.com>
+ * Author: Chandra Sekhar Anagani <chandra.sekhar.anagani@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ */
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/atomisp_platform.h>
+
+
+/* Helper macros to manipulate bitfields */
+#define REG_MASK(n)		(((1 << (n##_BIT_LEN)) - 1) << (n##_BIT_POS))
+#define REG_SET_FIELD(r, n, v)	(((r) & ~REG_MASK(n)) | \
+				 (((v) << (n##_BIT_POS)) & REG_MASK(n)))
+#define REG_GET_FIELD(r, n)	(((r) & REG_MASK(n)) >> n##_BIT_POS)
+/*
+ * vlv2 platform has 6 platform clocks, controlled by 4 byte registers
+ * Total size required for mapping is 6*4 = 24 bytes
+ */
+#define PMC_MAP_SIZE			24
+
+static DEFINE_MUTEX(clk_mutex);
+static void __iomem *pmc_base;
+
+/*
+ * byt_plat_set_clock_freq - Set clock frequency to a specified platform clock
+ * @clk_num: Platform clock number (i.e. 0, 1, 2, ...,5)
+ * @freq_type: Clock frequency (0-25 MHz(XTAL), 1-19.2 MHz(PLL) )
+ */
+int byt_plat_set_clock_freq(int clk_num, int freq_type)
+{
+	void __iomem *addr;
+
+	if (clk_num < 0 && clk_num > MAX_CLK_COUNT) {
+		pr_err("Clock number out of range (%d)\n", clk_num);
+		return -EINVAL;
+	}
+
+	if (freq_type != CLK_FREQ_TYPE_XTAL &&
+	    freq_type != CLK_FREQ_TYPE_PLL) {
+		pr_err("wrong clock type\n");
+		return -EINVAL;
+	}
+
+	if (!pmc_base) {
+		pr_err("memio map is not set\n");
+		return -EINVAL;
+	}
+
+	addr = pmc_base + PLT_CLK_CTL_OFFSET(clk_num);
+
+	mutex_lock(&clk_mutex);
+	writel(REG_SET_FIELD(readl(addr), CLK_FREQ_TYPE, freq_type), addr);
+	mutex_unlock(&clk_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(byt_plat_set_clock_freq);
+
+/*
+ * byt_plat_get_clock_freq - Get the status of specified platform clock
+ * @clk_num: Platform clock number (i.e. 0, 1, 2, ...,5)
+ *
+ * Returns 0 for 25 MHz(XTAL) and 1 for 19.2 MHz(PLL)
+ */
+int byt_plat_get_clock_freq(int clk_num)
+{
+	u32 ret;
+
+	if (clk_num < 0 && clk_num > MAX_CLK_COUNT) {
+		pr_err("Clock number out of range (%d)\n", clk_num);
+		return -EINVAL;
+	}
+
+	if (!pmc_base) {
+		pr_err("memio map is not set\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&clk_mutex);
+	ret = REG_GET_FIELD(readl(pmc_base + PLT_CLK_CTL_OFFSET(clk_num)),
+			    CLK_FREQ_TYPE);
+	mutex_unlock(&clk_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(byt_plat_get_clock_freq);
+
+/*
+ * byt_plat_configure_clock - Configure the specified platform clock
+ * @clk_num: Platform clock number (i.e. 0, 1, 2, ...,5)
+ * @conf:      Clock gating:
+ *		0   - Clock gated on D3 state
+ *		1   - Force on
+ *		2,3 - Force off
+ */
+int byt_plat_configure_clock(int clk_num, u32 conf)
+{
+	void __iomem *addr;
+
+	if (clk_num < 0 && clk_num > MAX_CLK_COUNT) {
+		pr_err("Clock number out of range (%d)\n", clk_num);
+		return -EINVAL;
+	}
+
+	if (conf != CLK_CONFG_D3_GATED &&
+	    conf != CLK_CONFG_FORCE_ON &&
+	    conf != CLK_CONFG_FORCE_OFF) {
+		pr_err("Invalid clock configuration requested\n");
+		return -EINVAL;
+	}
+
+	if (!pmc_base) {
+		pr_err("memio map is not set\n");
+		return -EINVAL;
+	}
+
+	addr = pmc_base + PLT_CLK_CTL_OFFSET(clk_num);
+
+	mutex_lock(&clk_mutex);
+	writel(REG_SET_FIELD(readl(addr), CLK_CONFG, conf), addr);
+	mutex_unlock(&clk_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(byt_plat_configure_clock);
+
+/*
+ * byt_plat_get_clock_status - Get the status of specified platform clock
+ * @clk_num: Platform clock number (i.e. 0, 1, 2, ...,5)
+ *
+ * Returns 1 - On, 0 - Off
+ */
+int byt_plat_get_clock_status(int clk_num)
+{
+	int ret;
+
+	if (clk_num < 0 && clk_num > MAX_CLK_COUNT) {
+		pr_err("Clock number out of range (%d)\n", clk_num);
+		return -EINVAL;
+	}
+
+	if (!pmc_base) {
+		pr_err("memio map is not set\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&clk_mutex);
+	ret = (int)REG_GET_FIELD(readl(pmc_base + PLT_CLK_CTL_OFFSET(clk_num)),
+				 CLK_CONFG);
+	mutex_unlock(&clk_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(byt_plat_get_clock_status);
+
+int byt_plat_clk_init(void)
+{
+        pmc_base = ioremap_nocache(VLV2_PMC_CLK_BASE_ADDRESS, PMC_MAP_SIZE);
+        if (!pmc_base) {
+                return -ENOMEM;
+        }
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(byt_plat_clk_init);
+
diff --git a/arch/x86/platform/atom/platform_camera.c b/arch/x86/platform/atom/platform_camera.c
new file mode 100644
index 0000000..0fad35e
--- /dev/null
+++ b/arch/x86/platform/atom/platform_camera.c
@@ -0,0 +1,312 @@
+/*
+ * platform_camera.c: Camera platform library file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/atomisp_platform.h>
+#include <media/v4l2-subdev.h>
+#include "platform_camera.h"
+#include "platform_mt9m114.h"
+#include "platform_ov5640_1.h"
+#include "platform_ov5640_2.h"
+
+
+static const struct intel_v4l2_subdev_id v4l2_ids[] = {
+	 {I2C_MT9M114_NAME, SOC_CAMERA, ATOMISP_CAMERA_PORT_SECONDARY, 1},
+	 {I2C_OV5640_2_NAME, SOC_CAMERA, ATOMISP_CAMERA_PORT_THIRD, 2},
+	 {I2C_OV5640_1_NAME, SOC_CAMERA, ATOMISP_CAMERA_PORT_PRIMARY, 2},
+	{},
+ };
+
+
+#define GPIO_NAME_LEN 16
+struct gpio_table_entry {
+	int	pin_no;
+	char	pin_name[GPIO_NAME_LEN];
+};
+
+static const struct gpio_table_entry gpio_table[] = {
+	{ANVL_GPIO_CAM2_PWDN_NUM, ANVL_GPIO_CAM2_PWDN},
+	{ANVL_GPIO_CAM2_RST_NUM, ANVL_GPIO_CAM2_RST},
+	{ANVL_GPIO_CAM1_PWDN_NUM, ANVL_GPIO_CAM1_PWDN},
+	{ANVL_GPIO_CAM1_RST_NUM, ANVL_GPIO_CAM1_RST},
+	{ANVL_GPIO_CAM3_PWDN_NUM, ANVL_GPIO_CAM3_PWDN},
+	{ANVL_GPIO_CAM3_RST_NUM, ANVL_GPIO_CAM3_RST},
+	{}
+};
+
+static int __gpio_direction_output(int pin, int value)
+{
+	volatile void __iomem *gpio_base = NULL;
+	int GPIO_OFFSET = 0;
+	int temp = 0;
+	switch(pin)
+	{
+	  case 21:
+	    GPIO_OFFSET = GPIONC_21_OFFSET;
+	    break;
+	  case 22:
+	    GPIO_OFFSET = GPIONC_22_OFFSET;
+	    break;
+	  case 24:
+	    GPIO_OFFSET = GPIONC_24_OFFSET;
+	    break;
+	  case 25:
+	    GPIO_OFFSET = GPIONC_25_OFFSET;
+	    break;
+	  case 26:
+	    GPIO_OFFSET = GPIONC_26_OFFSET;
+	    break;
+	  default:
+	    return -EINVAL;
+	}
+
+	gpio_base = ioremap_nocache(IOBASEADDR+GPIO_OFFSET,0xF);
+	if(gpio_base == NULL)
+	{
+	  return -EINVAL;
+	}
+
+	//configure the pin to output pin
+	temp=readl(gpio_base+8);
+	temp = 0x2;
+
+	writel(temp,gpio_base+8);
+
+
+	temp=readl(gpio_base);
+
+	if(value)
+	  temp=temp|0x00000080; //set it high
+	else
+	  temp=temp|0x00000100;	//set it low
+
+	writel(temp,gpio_base);
+
+
+	iounmap(gpio_base);
+
+	return 0;
+}
+
+static int get_gpio_by_name(const char *name)
+{
+	const struct gpio_table_entry *pentry = gpio_table;
+	int i;
+	int arraysize = sizeof(gpio_table)/sizeof(gpio_table[0]);
+
+	if (!pentry)
+		return -1;
+	for (i = 0; i < arraysize; i++, pentry++) {
+		if (!strncmp(name, pentry->pin_name, GPIO_NAME_LEN))
+			return pentry->pin_no;
+	}
+	return -1;
+}
+
+/*
+ * One-time gpio initialization.
+ * @name: gpio name: coded in SFI table
+ * @gpio: gpio pin number (bypass @name)
+ * @dir: GPIOF_DIR_IN or GPIOF_DIR_OUT
+ * @value: if dir = GPIOF_DIR_OUT, this is the init value for output pin
+ * if dir = GPIOF_DIR_IN, this argument is ignored
+ * return: a positive pin number if succeeds, otherwise a negative value
+ */
+int camera_sensor_gpio(int gpio, char *name, int dir, int value)
+{
+	int ret, pin;
+	TIMING_ENTER
+	if (gpio == -1) {
+		pin = get_gpio_by_name(name);
+		if (pin == -1) {
+			pr_err("%s: failed to get gpio(name: %s)\n",
+						__func__, name);
+			return -EINVAL;
+		}
+	} else {
+		pin = gpio;
+	}
+
+	if (dir == GPIOF_DIR_OUT)
+		ret = __gpio_direction_output(pin, value);
+	else
+		ret = gpio_direction_input(pin);
+
+	if (ret) {
+		pr_err("%s: failed to set gpio(pin %d) direction\n",
+							__func__, pin);
+		gpio_free(pin);
+	}
+	TIMING_END
+	return ret ? ret : pin;
+}
+
+/*
+ * Configure MIPI CSI physical parameters.
+ * @port: ATOMISP_CAMERA_PORT_PRIMARY or ATOMISP_CAMERA_PORT_SECONDARY
+ * @lanes: for ATOMISP_CAMERA_PORT_PRIMARY, there could be 2 or 4 lanes
+ * for ATOMISP_CAMERA_PORT_SECONDARY, there is only one lane.
+ * @format: MIPI CSI pixel format, see include/linux/atomisp_platform.h
+ * @bayer_order: MIPI CSI bayer order, see include/linux/atomisp_platform.h
+ */
+int camera_sensor_csi(struct v4l2_subdev *sd, int port,
+			int lanes, int flag)
+{
+	struct i2c_client *client;
+	struct camera_mipi_info *csi = NULL;
+	TIMING_ENTER
+
+	client = v4l2_get_subdevdata(sd);
+	if (flag) {
+		csi = kzalloc(sizeof(*csi), GFP_KERNEL);
+		if (!csi) {
+			dev_err(&client->dev, "out of memory\n");
+			return -ENOMEM;
+		}
+		csi->port = port;
+		csi->num_lanes = lanes;
+		v4l2_set_subdev_hostdata(sd, (void *)csi);
+	} else {
+		csi = v4l2_get_subdev_hostdata(sd);
+		kfree(csi);
+	}
+	TIMING_END
+	return 0;
+}
+
+
+
+static struct atomisp_platform_data *v4l2_subdev_table_head;
+
+static void intel_ignore_i2c_device_register(int bus,
+					     struct i2c_board_info *idev)
+{
+	const struct intel_v4l2_subdev_id *vdev = v4l2_ids;
+	struct intel_v4l2_subdev_i2c_board_info *info;
+	static struct intel_v4l2_subdev_table *subdev_table;
+	enum intel_v4l2_subdev_type type = 0;
+	enum atomisp_camera_port port;
+	int num_lanes;
+	static int i;
+
+	while (vdev->name[0]) {
+		if (!strncmp(vdev->name, idev->type, 16)) {
+			/* compare name */
+			type = vdev->type;
+			port = vdev->port;
+			num_lanes = vdev->num_lanes;
+			break;
+		}
+		vdev++;
+	}
+
+	if (!type) /* not found */
+		return;
+
+	info = kzalloc(sizeof(struct intel_v4l2_subdev_i2c_board_info),
+		       GFP_KERNEL);
+	if (!info) {
+		pr_err("fail to alloc mem for ignored i2c dev %s\n",
+		       idev->type);
+		return;
+	}
+
+	info->i2c_adapter_id = bus;
+	/* set platform data */
+	memcpy(&info->board_info, idev, sizeof(*idev));
+
+	if (v4l2_subdev_table_head == NULL) {
+		subdev_table = kzalloc(sizeof(struct intel_v4l2_subdev_table)
+			* ARRAY_SIZE(v4l2_ids), GFP_KERNEL);
+
+		if (!subdev_table) {
+			pr_err("fail to alloc mem for v4l2_subdev_table %s\n",
+			       idev->type);
+			kfree(info);
+			return;
+		}
+
+		v4l2_subdev_table_head = kzalloc(
+			sizeof(struct atomisp_platform_data), GFP_KERNEL);
+		if (!v4l2_subdev_table_head) {
+			pr_err("fail to alloc mem for v4l2_subdev_table %s\n",
+			       idev->type);
+			kfree(info);
+			kfree(subdev_table);
+			return;
+		}
+		v4l2_subdev_table_head->subdevs = subdev_table;
+	}
+
+	memcpy(&subdev_table[i].v4l2_subdev, info, sizeof(*info));
+	subdev_table[i].type = type;
+	subdev_table[i].port = port;
+	subdev_table[i].num_lanes = num_lanes;
+
+	i++;
+	return;
+}
+
+
+struct atomisp_platform_data *__intel_get_v4l2_subdev_table(void)
+{
+	if (v4l2_subdev_table_head)
+		return v4l2_subdev_table_head;
+	else {
+		pr_err("no camera device in the table\n");
+		return NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(__intel_get_v4l2_subdev_table);
+
+
+static struct i2c_board_info i2c_board_mt9m114[] = {
+	{
+		I2C_BOARD_INFO(I2C_MT9M114_NAME,0x48),
+	},
+};
+
+static struct i2c_board_info i2c_board_ov5640_1[] = {
+	{
+		I2C_BOARD_INFO(I2C_OV5640_1_NAME,0x32),
+	},
+};
+
+static struct i2c_board_info i2c_board_ov5640_2[] = {
+	{
+		I2C_BOARD_INFO(I2C_OV5640_2_NAME,0x34),
+	},
+};
+
+
+
+static int __init platform_init(void)
+{
+
+	i2c_board_mt9m114[0].platform_data = mt9m114_platform_data();
+	intel_ignore_i2c_device_register(ANVL_I2C_BUS_NUM, i2c_board_mt9m114);
+
+	i2c_board_ov5640_2[0].platform_data = ov5640_2_platform_data();
+	intel_ignore_i2c_device_register(ANVL_I2C_BUS_NUM, i2c_board_ov5640_2);
+
+	i2c_board_ov5640_1[0].platform_data = ov5640_1_platform_data();
+	intel_ignore_i2c_device_register(ANVL_I2C_BUS_NUM, i2c_board_ov5640_1);
+
+	return 0;
+}
+arch_initcall(platform_init);
+
+MODULE_LICENSE("GPL");
+
+
diff --git a/arch/x86/platform/atom/platform_camera.h b/arch/x86/platform/atom/platform_camera.h
new file mode 100644
index 0000000..14e9f82
--- /dev/null
+++ b/arch/x86/platform/atom/platform_camera.h
@@ -0,0 +1,50 @@
+/*
+ * platform_camera.h: CAMERA platform library header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_CAMERA_H_
+#define _PLATFORM_CAMERA_H_
+
+#include <linux/atomisp_platform.h>
+
+/*extern const struct intel_v4l2_subdev_id v4l2_ids[] __attribute__((weak));*/
+
+/* MFLD iCDK camera sensor GPIOs */
+
+
+#define ANVL_GPIO_CAM2_PWDN 		"cam_mt_power"  //Power down signal for J3 ov5640 sensor
+#define ANVL_GPIO_CAM2_RST			"cam_mt_reset"  //Power reset signal for 1.2MP sensor
+#define ANVL_GPIO_CAM1_PWDN			"cam_ov1_power" //Power down signal for J2 ov5640 sensor
+#define ANVL_GPIO_CAM1_RST 			"cam_ov1_reset" //Power reset signal for J2 ov5640 sensor
+#define ANVL_GPIO_CAM3_PWDN 		"cam_ov2_power"
+#define ANVL_GPIO_CAM3_RST 			"cam_ov2_reset" //Power reset signal for J3 ov5640 sensor
+
+#define ANVL_GPIO_CAM2_RST_NUM 		25		//Power reset signal for 1.2MP sensor
+#define ANVL_GPIO_CAM2_PWDN_NUM 	22		//Power down signal for J3 ov5640 sensor
+#define ANVL_GPIO_CAM1_PWDN_NUM		21		//Power down signal for J2 ov5640 sensor
+#define ANVL_GPIO_CAM1_RST_NUM 		24		//Power reset signal for J2 ov5640 sensor
+#define ANVL_GPIO_CAM3_PWDN_NUM 	21
+#define ANVL_GPIO_CAM3_RST_NUM 		26		//Power reset signal for J3 ov5640 sensor
+
+#define ANVL_I2C_BUS_NUM 		3
+#define IOBASEADDR				0xFED0C000
+#define GPIONC_21_OFFSET		0x1060		//Power down signal for J2 ov5640 sensor
+#define GPIONC_22_OFFSET		0x10A0		//Power down signal for J3 ov5640 sensor
+#define GPIONC_24_OFFSET		0x1020		//Power reset signal for J2 ov5640 sensor
+#define GPIONC_25_OFFSET		0x1050		//Power reset signal for 1.2MP sensor
+#define GPIONC_26_OFFSET		0x1090		//Power reset signal for J3 ov5640 sensor
+
+extern int camera_sensor_gpio(int gpio, char *name, int dir, int value);
+extern int camera_sensor_csi(struct v4l2_subdev *sd, int port,
+			int lanes, int flag);
+
+extern struct atomisp_platform_data *intel_get_v4l2_subdev_table(void)  __attribute__((weak));;
+
+#endif
diff --git a/arch/x86/platform/atom/platform_mt9m114.c b/arch/x86/platform/atom/platform_mt9m114.c
new file mode 100644
index 0000000..2da38df
--- /dev/null
+++ b/arch/x86/platform/atom/platform_mt9m114.c
@@ -0,0 +1,230 @@
+/*
+ * platform_mt9m114.c: mt9m114 platform data initilization file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/atomisp_platform.h>
+
+#include <media/v4l2-subdev.h>
+#include <linux/regulator/consumer.h>
+#include "platform_camera.h"
+#include "platform_mt9m114.h"
+
+
+#define VPROG1_VAL 2800000
+static int camera_reset;
+static int camera_power_down;
+static int camera_vprog1_on;
+
+#ifdef CONFIG_BOARD_CTP
+static struct regulator *vprog1_reg;
+#endif
+
+/*
+ * MFLD PR2 secondary camera sensor - MT9M114 platform data
+ */
+static int mt9m114_gpio_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+	TIMING_ENTER
+	ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM2_RST,
+				 GPIOF_DIR_OUT, 1);
+	if (ret < 0)
+		return ret;
+
+	if (flag) {
+		//Reset the camera sensor
+		camera_sensor_gpio(-1, ANVL_GPIO_CAM2_RST,
+					 GPIOF_DIR_OUT, 0);
+		msleep(60);
+		camera_sensor_gpio(-1, ANVL_GPIO_CAM2_RST,
+					 GPIOF_DIR_OUT, 1);
+	} else
+		camera_sensor_gpio(-1, ANVL_GPIO_CAM2_RST,
+					 GPIOF_DIR_OUT, 1);
+	TIMING_END
+	return 0;
+}
+
+static int mt9e013_reset_value;
+static int mt9m114_power_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	//Do nothing for now
+#ifdef CONFIG_BOARD_CTP
+	int reg_err;
+	return 0;
+#endif
+#ifndef CONFIG_BOARD_CTP
+	int ret;
+	return 0;
+	/* Note here, there maybe a workaround to avoid I2C SDA issue */
+	if (camera_power_down < 0) {
+		ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM2_PWDN,
+					GPIOF_DIR_OUT, 1);
+#ifndef CONFIG_BOARD_REDRIDGE
+		if (ret < 0)
+			return ret;
+#endif
+		camera_power_down = ret;
+	}
+
+	if (camera_reset < 0) {
+		ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM2_RST,
+					 GPIOF_DIR_OUT, 1);
+		if (ret < 0)
+			return ret;
+		camera_reset = ret;
+	}
+#endif
+	if (flag) {
+#ifndef CONFIG_BOARD_CTP
+#if 0
+		if (!mt9e013_reset_value) {
+			if (mt9e013_reset)
+				mt9e013_reset(sd);
+			mt9e013_reset_value = 1;
+		}
+#endif
+#ifdef CONFIG_BOARD_REDRIDGE
+		gpio_direction_output(camera_reset, 0);
+#endif
+		gpio_set_value(camera_reset, 0);
+#endif
+		if (!camera_vprog1_on) {
+			camera_vprog1_on = 1;
+#ifdef CONFIG_BOARD_CTP
+			reg_err = regulator_enable(vprog1_reg);
+			if (reg_err) {
+				printk(KERN_ALERT "Failed to enable regulator vprog1\n");
+				return reg_err;
+			}
+#endif
+		}
+#ifndef CONFIG_BOARD_CTP
+#ifdef CONFIG_BOARD_REDRIDGE
+		if (camera_power_down >= 0)
+			gpio_set_value(camera_power_down, 1);
+#else
+		gpio_set_value(camera_power_down, 1);
+#endif
+#endif
+	} else {
+		if (camera_vprog1_on) {
+			camera_vprog1_on = 0;
+#ifdef CONFIG_BOARD_CTP
+			reg_err = regulator_disable(vprog1_reg);
+			if (reg_err) {
+				printk(KERN_ALERT "Failed to disable regulator vprog1\n");
+				return reg_err;
+			}
+#endif
+		}
+#ifndef CONFIG_BOARD_CTP
+#ifdef CONFIG_BOARD_REDRIDGE
+		if (camera_power_down >= 0)
+			gpio_set_value(camera_power_down, 0);
+#else
+		gpio_set_value(camera_power_down, 0);
+#endif
+
+		mt9e013_reset_value = 0;
+#endif
+	}
+
+	return 0;
+}
+
+struct intel_v4l2_subdev_table *mt9m114_camera_data(void)
+{
+	const struct atomisp_platform_data *pdata;
+	struct intel_v4l2_subdev_table *subdevs;
+
+	pdata = __intel_get_v4l2_subdev_table();
+	if (pdata == NULL) {
+			pr_err("no platform data available\n");
+			return NULL;
+		}
+	for (subdevs = pdata->subdevs; subdevs->type; ++subdevs) {
+		struct i2c_board_info *board_info =	&subdevs->v4l2_subdev.board_info;
+		//printk("camera_intel_platform_data check %s\n",board_info->type);
+		if(strcmp(board_info->type, I2C_MT9M114_NAME) == 0)
+			return subdevs;
+	}
+	return NULL;
+
+}
+static int mt9m114_csi_configure(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+	/* soc sensor, there is no raw bayer order (set to -1) */
+	struct intel_v4l2_subdev_table *subdev;
+
+		subdev = mt9m114_camera_data();
+		if(subdev == NULL){
+			pr_err("Error in getting OV5640_1 camera data\n");
+			return -EINVAL;
+		}
+	TIMING_ENTER
+	ret = camera_sensor_csi(sd, subdev->port, subdev->num_lanes, flag);
+	TIMING_END;
+	return ret;
+}
+
+#ifdef CONFIG_BOARD_CTP
+static int mt9m114_platform_init(struct i2c_client *client)
+{
+	int ret;
+
+	vprog1_reg = regulator_get(&client->dev, "vprog1");
+	if (IS_ERR(vprog1_reg)) {
+		dev_err(&client->dev, "regulator_get failed\n");
+		return PTR_ERR(vprog1_reg);
+	}
+	ret = regulator_set_voltage(vprog1_reg, VPROG1_VAL, VPROG1_VAL);
+	if (ret) {
+		dev_err(&client->dev, "regulator voltage set failed\n");
+		regulator_put(vprog1_reg);
+	}
+	return ret;
+}
+
+static int mt9m114_platform_deinit(void)
+{
+	regulator_put(vprog1_reg);
+	return 0;
+}
+#endif
+
+static struct camera_sensor_platform_data mt9m114_sensor_platform_data = {
+	.gpio_ctrl	= mt9m114_gpio_ctrl,
+	.power_ctrl	= mt9m114_power_ctrl,
+	.csi_cfg	= mt9m114_csi_configure,
+#ifdef CONFIG_BOARD_CTP
+	.platform_init = mt9m114_platform_init,
+	.platform_deinit = mt9m114_platform_deinit,
+#endif
+};
+
+
+void *mt9m114_platform_data(void)
+{
+	camera_reset = -1;
+	camera_power_down = -1;
+
+	return &mt9m114_sensor_platform_data;
+}
+
+
+
diff --git a/arch/x86/platform/atom/platform_mt9m114.h b/arch/x86/platform/atom/platform_mt9m114.h
new file mode 100644
index 0000000..30fdde8
--- /dev/null
+++ b/arch/x86/platform/atom/platform_mt9m114.h
@@ -0,0 +1,20 @@
+/*
+ * platform_mt9m114.h: mt9m114 platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MT9M114_H_
+#define _PLATFORM_MT9M114_H_
+#define I2C_MT9M114_NAME "mt9m114"
+
+
+void *mt9m114_platform_data(void);
+struct intel_v4l2_subdev_table *mt9m114_camera_data(void);
+
+#endif
diff --git a/arch/x86/platform/atom/platform_ov5640_1.c b/arch/x86/platform/atom/platform_ov5640_1.c
new file mode 100644
index 0000000..13d716e
--- /dev/null
+++ b/arch/x86/platform/atom/platform_ov5640_1.c
@@ -0,0 +1,116 @@
+/*
+ * platform_ov5640_1.c: ov5640_1 platform data initilization file
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/atomisp_platform.h>
+#include <asm/io.h>
+#include <media/v4l2-subdev.h>
+#include "platform_camera.h"
+#include "platform_ov5640_1.h"
+
+
+static int camera_reset;
+static int camera_power_down;
+
+/*
+ * GRACELAND DV1 primary camera sensor - OV5640_1 platform data
+ */
+
+static int ov5640_1_gpio_ctrl(struct v4l2_subdev *sd, int flag)
+{
+
+	if (flag) {
+	  camera_sensor_gpio(ANVL_GPIO_CAM1_RST_NUM, ANVL_GPIO_CAM1_RST,GPIOF_DIR_OUT, 0);
+	  msleep(20);
+	  camera_sensor_gpio(ANVL_GPIO_CAM1_RST_NUM, ANVL_GPIO_CAM1_RST,GPIOF_DIR_OUT, 1);
+	} else
+	{
+	  camera_sensor_gpio(ANVL_GPIO_CAM1_RST_NUM, ANVL_GPIO_CAM1_RST,GPIOF_DIR_OUT, 0);
+	}
+
+	return 0;
+}
+
+static int ov5640_1_power_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+
+	if (flag) {
+	  if (camera_power_down < 0) {
+               ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM1_PWDN,
+                                       GPIOF_DIR_OUT, 1);
+		pr_debug("ov5640_1 - gpio power down to up  ov5640_1 - primary\n");
+		camera_power_down = ret;
+	  }
+	  if (camera_reset < 0) {
+               ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM1_RST,
+                                        GPIOF_DIR_OUT, 1);
+		pr_debug("ov5640_1 - gpio power reset  ov5640_1-primary\n");
+            	camera_reset = ret;
+	  }
+            /* delay 20ms to wait sensor power up stable.*/
+	  msleep(20);
+	}
+
+	return 0;
+}
+
+struct intel_v4l2_subdev_table *ov5640_1_camera_data(void)
+{
+	const struct atomisp_platform_data *pdata;
+	struct intel_v4l2_subdev_table *subdevs;
+
+	pdata = __intel_get_v4l2_subdev_table();
+	if (pdata == NULL) {
+			pr_err("no platform data available\n");
+			return NULL;
+		}
+	for (subdevs = pdata->subdevs; subdevs->type; ++subdevs) {
+		struct i2c_board_info *board_info =	&subdevs->v4l2_subdev.board_info;
+		//printk("camera_intel_platform_data check %s\n",board_info->type);
+		if(strcmp(board_info->type, I2C_OV5640_1_NAME) == 0)
+			return subdevs;
+	}
+	return NULL;
+
+}
+static int ov5640_1_csi_configure(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+	struct intel_v4l2_subdev_table *subdev;
+
+	subdev = ov5640_1_camera_data();
+	if(subdev == NULL){
+		pr_err("Error in getting OV5640_1 camera data\n");
+		return -EINVAL;
+	}
+	ret =  camera_sensor_csi(sd, subdev->port, subdev->num_lanes, flag);
+	if (ret != 0) {
+		pr_err("Error in configure camera csi  - OV5640_1-primary\n");
+		return ret;
+	}
+	return ret;
+}
+
+static struct camera_sensor_platform_data ov5640_1_sensor_platform_data = {
+	.gpio_ctrl      = ov5640_1_gpio_ctrl,
+	.power_ctrl     = ov5640_1_power_ctrl,
+	.csi_cfg        = ov5640_1_csi_configure,
+};
+
+void *ov5640_1_platform_data(void)
+{
+	camera_reset = -1;
+	camera_power_down = -1;
+	return &ov5640_1_sensor_platform_data;
+}
diff --git a/arch/x86/platform/atom/platform_ov5640_1.h b/arch/x86/platform/atom/platform_ov5640_1.h
new file mode 100644
index 0000000..a848016
--- /dev/null
+++ b/arch/x86/platform/atom/platform_ov5640_1.h
@@ -0,0 +1,19 @@
+/*
+ * platform_ov5640_1.h: ov5640_1 platform data header file
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_OV5640_1_H_
+#define _PLATFORM_OV5660_1_H_
+#define I2C_OV5640_1_NAME "ov5640-1"
+
+void *ov5640_1_platform_data(void);
+struct intel_v4l2_subdev_table *ov5640_1_camera_data(void);
+
+#endif
diff --git a/arch/x86/platform/atom/platform_ov5640_2.c b/arch/x86/platform/atom/platform_ov5640_2.c
new file mode 100644
index 0000000..23ea03f
--- /dev/null
+++ b/arch/x86/platform/atom/platform_ov5640_2.c
@@ -0,0 +1,121 @@
+/*
+ * platform_ov5640_2.c: ov5640_2 platform data initilization file
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/atomisp_platform.h>
+#include <asm/io.h>
+#include <media/v4l2-subdev.h>
+#include "platform_camera.h"
+#include "platform_ov5640_2.h"
+
+
+static int camera_2_reset;
+static int camera_2_power_down;
+
+/*
+ * GRACELAND DV1 primary camera sensor - OV5640 platform data
+ */
+
+void ov5640_2_powerdown_camera_1(void)
+{
+	camera_sensor_gpio(-1, ANVL_GPIO_CAM1_PWDN,GPIOF_DIR_OUT, 0);
+        camera_sensor_gpio(-1, ANVL_GPIO_CAM1_RST,GPIOF_DIR_OUT, 0);
+}
+static int ov5640_2_gpio_ctrl(struct v4l2_subdev *sd, int flag)
+{
+
+	if (flag)
+	{
+	  camera_sensor_gpio(ANVL_GPIO_CAM3_RST_NUM, ANVL_GPIO_CAM3_RST,GPIOF_DIR_OUT, 0);
+	  msleep(20);
+	  camera_sensor_gpio(ANVL_GPIO_CAM3_RST_NUM, ANVL_GPIO_CAM3_RST,GPIOF_DIR_OUT, 1);
+	}
+	else {
+	  camera_sensor_gpio(ANVL_GPIO_CAM3_RST_NUM, ANVL_GPIO_CAM3_RST,GPIOF_DIR_OUT, 0);
+	}
+
+	return 0;
+}
+
+static int ov5640_2_power_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+
+	if (flag) {
+	  if (camera_2_power_down < 0) {
+	    ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM3_PWDN,
+                                       GPIOF_DIR_OUT, 1);
+	    pr_debug("ov5640_2 - gpio power down to up  ov5640_2\n");
+	    camera_2_power_down = ret;
+	  }
+	  if (camera_2_reset < 0) {
+	    ret = camera_sensor_gpio(-1, ANVL_GPIO_CAM3_RST,
+                                        GPIOF_DIR_OUT, 1);
+	    pr_debug("ov5640_2 - gpio power reset  ov5640_2\n");
+            camera_2_reset = ret;
+	  }
+
+            /*delay 20ms to wait sensor power up stable.*/
+	  msleep(20);
+	}
+
+	return 0;
+}
+struct intel_v4l2_subdev_table *ov5640_2_camera_data(void)
+{
+	const struct atomisp_platform_data *pdata;
+	struct intel_v4l2_subdev_table *subdevs;
+
+	pdata = __intel_get_v4l2_subdev_table();
+	if (pdata == NULL) {
+			pr_err("no platform data available\n");
+			return NULL;
+		}
+	for (subdevs = pdata->subdevs; subdevs->type; ++subdevs) {
+		struct i2c_board_info *board_info =	&subdevs->v4l2_subdev.board_info;
+		//printk("camera_intel_platform_data check %s\n",board_info->type);
+		if(strcmp(board_info->type, I2C_OV5640_2_NAME) == 0)
+			return subdevs;
+	}
+	return NULL;
+
+}
+static int ov5640_2_csi_configure(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+	struct intel_v4l2_subdev_table *subdev;
+		subdev = ov5640_2_camera_data();
+		if(subdev == NULL){
+			pr_err("Error in getting OV5640_1 camera data\n");
+			return -EINVAL;
+		}
+	ret =  camera_sensor_csi(sd, subdev->port, subdev->num_lanes, flag);
+	if (ret != 0) {
+		pr_err("Error in configure camera csi  - OV5640-THIRD\n");
+		return ret;
+	}
+	return ret;
+}
+
+static struct camera_sensor_platform_data ov5640_2_sensor_platform_data = {
+	.gpio_ctrl      = ov5640_2_gpio_ctrl,
+	.power_ctrl     = ov5640_2_power_ctrl,
+	.csi_cfg        = ov5640_2_csi_configure,
+};
+
+void *ov5640_2_platform_data(void)
+{
+	camera_2_reset = -1;
+	camera_2_power_down = -1;
+	return &ov5640_2_sensor_platform_data;
+}
diff --git a/arch/x86/platform/atom/platform_ov5640_2.h b/arch/x86/platform/atom/platform_ov5640_2.h
new file mode 100644
index 0000000..8e44bee
--- /dev/null
+++ b/arch/x86/platform/atom/platform_ov5640_2.h
@@ -0,0 +1,20 @@
+/*
+ * platform_ov5640.h: ov5640 platform data header file
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_OV5460_2_H_
+#define _PLATFORM_OV5460_2_H_
+#define I2C_OV5640_2_NAME "ov5640-2"
+
+void *ov5640_2_platform_data(void);
+void ov5640_2_powerdown_camera_1(void);
+struct intel_v4l2_subdev_table *ov5640_2_camera_data(void);
+
+#endif

diff --git a/drivers/media/atomisp2/Kconfig b/drivers/media/atomisp2/Kconfig
new file mode 100644
index 0000000..62c5883
--- /dev/null
+++ b/drivers/media/atomisp2/Kconfig
@@ -0,0 +1,19 @@
+config VIDEO_ATOMISP
+	tristate "Intel Atom Image Signal Processor CSS2.0 Driver"
+	depends on MEDIA_SUPPORT && VIDEO_V4L2 && MEDIA_CAMERA_SUPPORT
+	default m
+	select MEDIA_CONTROLLER
+	select VIDEO_V4L2_SUBDEV_API
+	select VIDEO_MT9M114
+	select VIDEO_OV5640
+	select VIDEOBUF2_CORE
+	select DMA_SHARED_BUFFER
+	select VIDEOBUF2_MEMOPS
+	select VIDEOBUF2_DMA_CONTIG
+	select PM_RUNTIME
+
+	---help---
+	  Say Y here if your platform support camera imaging subsystem on
+	  the Intel Atom SoC platform.
+	  To compile this driver as a module, choose M here: the
+	  module will be called atomisp.
diff --git a/drivers/media/atomisp2/Makefile b/drivers/media/atomisp2/Makefile
new file mode 100644
index 0000000..ec8d6df
--- /dev/null
+++ b/drivers/media/atomisp2/Makefile
@@ -0,0 +1,191 @@
+css_folder = css2400
+css_platform_folder = hive_isp_css_2400_system
+css_platform_folder_generated = hive_isp_css_2400_system_generated
+base = base
+runtime = runtime
+kernels = isp/kernels
+
+atomisp-objs := \
+		atomisp_compat.o \
+		atomisp_ioctl.o \
+		atomisp_cmd.o \
+		atomisp_fops.o \
+		atomisp_subdev.o \
+		atomisp_csi2.o \
+		atomisp_tpg.o \
+		atomisp_file.o \
+		atomisp_v4l2.o \
+		atomisp_acc.o \
+		mmu/isp_mmu.o \
+		mmu/sh_mmu_mrfld.o \
+		mmu/sh_mmu_mfld.o \
+		hmm/hmm.o \
+		hmm/hmm_bo.o \
+		hmm/hmm_bo_dev.o \
+		hmm/hmm_vm.o \
+		hrt/hive_isp_css_mm_hrt.o \
+		hmm/hmm_reserved_pool.o \
+		hmm/hmm_dynamic_pool.o
+	#	hrt/device_access.o \
+		hrt/memory_access.o \
+
+atomisp-objs += \
+		$(css_folder)/sh_css.o \
+		$(css_folder)/sh_css_hrt.o \
+		$(css_folder)/sh_css_params.o \
+		$(css_folder)/sh_css_sp.o \
+		$(css_folder)/sh_css_metrics.o \
+		$(css_folder)/sh_css_firmware.o \
+		$(css_folder)/sh_css_mipi.o \
+		$(css_folder)/sh_css_param_shading.o \
+		$(css_folder)/hive_isp_css_shared/host/tag.o \
+		$(css_folder)/ia_css_memory_access.o \
+		$(css_folder)/ia_css_device_access.o \
+		$(css_folder)/sh_css_param_dvs.o \
+
+atomisp-objs += $(css_folder)/$(css_platform_folder)/host/gdc.o \
+		$(css_folder)/$(css_platform_folder)/host/irq.o \
+		$(css_folder)/$(css_platform_folder)/host/mmu.o \
+		$(css_folder)/$(css_platform_folder)/host/dma.o \
+		$(css_folder)/$(css_platform_folder)/host/sp.o \
+		$(css_folder)/$(css_platform_folder)/host/isp.o \
+		$(css_folder)/$(css_platform_folder)/host/fifo_monitor.o \
+		$(css_folder)/$(css_platform_folder)/host/gp_device.o \
+		$(css_folder)/$(css_platform_folder)/host/input_system.o \
+		$(css_folder)/$(css_platform_folder)/host/input_formatter.o \
+        $(css_folder)/$(css_platform_folder)/host/input_system.o \
+
+atomisp-objs += $(css_folder)/$(css_platform_folder_generated)/ia_css_isp_params.o \
+		$(css_folder)/$(css_platform_folder_generated)/ia_css_isp_configs.o \
+		$(css_folder)/$(css_platform_folder_generated)/ia_css_isp_states.o \
+
+atomisp-objs +=	$(css_folder)/$(base)/circbuf/src/circbuf.o \
+		$(css_folder)/$(base)/refcount/src/refcount.o \
+		$(css_folder)/camera/pipe/src/pipe_binarydesc.o \
+		$(css_folder)/camera/pipe/src/pipe_util.o \
+		$(css_folder)/camera/pipe/src/pipe_stagedesc.o \
+		$(css_folder)/camera/util/src/util.o \
+
+atomisp-objs += $(css_folder)/$(runtime)/binary/src/binary.o \
+		$(css_folder)/$(runtime)/bufq/src/bufq.o \
+        $(css_folder)/$(runtime)/debug/src/ia_css_debug.o \
+        $(css_folder)/$(runtime)/eventq/src/eventq.o \
+        $(css_folder)/$(runtime)/isp_param/src/isp_param.o \
+        $(css_folder)/$(runtime)/isys/src/isys_init.o \
+        $(css_folder)/$(runtime)/isys/src/rx.o \
+        $(css_folder)/$(runtime)/frame/src/frame.o \
+        $(css_folder)/$(runtime)/rmgr/src/rmgr.o \
+        $(css_folder)/$(runtime)/rmgr/src/rmgr_vbuf.o \
+        $(css_folder)/$(runtime)/pipeline/src/pipeline.o \
+        $(css_folder)/$(runtime)/event/src/event.o \
+        $(css_folder)/$(runtime)/inputfifo/src/inputfifo.o \
+        $(css_folder)/$(runtime)/spctrl/src/spctrl.o \
+        $(css_folder)/$(runtime)/queue/src/queue.o \
+        $(css_folder)/$(runtime)/queue/src/queue_access.o \
+        $(css_folder)/$(runtime)/ifmtr/src/ifmtr.o \
+
+atomisp-objs += $(css_folder)/$(kernels)/aa/aa_2/ia_css_aa2.host.o \
+	   $(css_folder)/$(kernels)/anr/anr_2/ia_css_anr2.host.o \
+       $(css_folder)/$(kernels)/anr/anr_2/ia_css_anr2_table.host.o \
+       $(css_folder)/$(kernels)/anr/anr_1.0/ia_css_anr.host.o \
+	   $(css_folder)/$(kernels)/bh/bh_2/ia_css_bh.host.o \
+	   $(css_folder)/$(kernels)/bnr/bnr_1.0/ia_css_bnr.host.o \
+	   $(css_folder)/$(kernels)/cnr/cnr_2/ia_css_cnr2.host.o \
+       $(css_folder)/$(kernels)/cnr/cnr_1.0/ia_css_cnr.host.o \
+	   $(css_folder)/$(kernels)/copy_output/copy_output_1.0/ia_css_copy_output.host.o \
+	   $(css_folder)/$(kernels)/crop/crop_1.0/ia_css_crop.host.o \
+	   $(css_folder)/$(kernels)/csc/csc_1.0/ia_css_csc.host.o \
+	   $(css_folder)/$(kernels)/ctc/ctc_1.0/ia_css_ctc.host.o \
+       $(css_folder)/$(kernels)/ctc/ctc_1.0/ia_css_ctc_table.host.o \
+       $(css_folder)/$(kernels)/ctc/ctc_2/ia_css_ctc2.host.o \
+	   $(css_folder)/$(kernels)/de/de_2/ia_css_de2.host.o \
+       $(css_folder)/$(kernels)/de/de_1.0/ia_css_de.host.o \
+       $(css_folder)/$(kernels)/dp/dp_1.0/ia_css_dp.host.o \
+	   $(css_folder)/$(kernels)/dvs/dvs_1.0/ia_css_dvs.host.o \
+	   $(css_folder)/$(kernels)/fpn/fpn_1.0/ia_css_fpn.host.o \
+	   $(css_folder)/$(kernels)/gc/gc_1.0/ia_css_gc.host.o \
+       $(css_folder)/$(kernels)/gc/gc_1.0/ia_css_gc_table.host.o \
+       $(css_folder)/$(kernels)/gc/gc_2/ia_css_gc2.host.o \
+       $(css_folder)/$(kernels)/gc/gc_2/ia_css_gc2_table.host.o \
+       $(css_folder)/$(kernels)/iterator/iterator_1.0/ia_css_iterator.host.o \
+       $(css_folder)/$(kernels)/macc/macc_1.0/ia_css_macc.host.o \
+       $(css_folder)/$(kernels)/macc/macc_1.0/ia_css_macc_table.host.o \
+       $(css_folder)/$(kernels)/ob/ob_1.0/ia_css_ob.host.o \
+       $(css_folder)/$(kernels)/output/output_1.0/ia_css_output.host.o \
+       $(css_folder)/$(kernels)/qplane/qplane_2/ia_css_qplane.host.o \
+       $(css_folder)/$(kernels)/raw/raw_1.0/ia_css_raw.host.o \
+       $(css_folder)/$(kernels)/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.o \
+       $(css_folder)/$(kernels)/ref/ref_1.0/ia_css_ref.host.o \
+       $(css_folder)/$(kernels)/sc/sc_1.0/ia_css_sc.host.o \
+       $(css_folder)/$(kernels)/s3a/s3a_1.0/ia_css_s3a.host.o \
+       $(css_folder)/$(kernels)/tnr/tnr_1.0/ia_css_tnr.host.o \
+       $(css_folder)/$(kernels)/uds/uds_1.0/ia_css_uds.host.o \
+       $(css_folder)/$(kernels)/vf/vf_1.0/ia_css_vf.host.o \
+       $(css_folder)/$(kernels)/wb/wb_1.0/ia_css_wb.host.o \
+       $(css_folder)/$(kernels)/xnr/xnr_1.0/ia_css_xnr.host.o \
+       $(css_folder)/$(kernels)/xnr/xnr_1.0/ia_css_xnr_table.host.o \
+       $(css_folder)/$(kernels)/ynr/ynr_1.0/ia_css_ynr.host.o \
+       $(css_folder)/$(kernels)/ynr/ynr_2/ia_css_ynr2.host.o \
+
+obj-$(CONFIG_VIDEO_ATOMISP) = atomisp.o
+
+INCLUDES := -I$(srctree)/$(src)/include \
+	    -I$(srctree)/$(src)/ \
+	    -I$(src) \
+	    -I$(src)/hrt \
+	    -I$(srctree)/drivers/staging/intel_media/bc_video
+
+INCLUDES += -I$(srctree)/$(src)/$(css_folder) \
+		-I$(srctree)/$(src)/$(css_folder)/hrt \
+		-I$(srctree)/$(src)/$(css_folder)/$(base)/circbuf/interface \
+		-I$(srctree)/$(src)/$(css_folder)/$(base)/refcount/interface \
+		-I$(srctree)/$(src)/$(css_folder)/camera/pipe/interface \
+		-I$(srctree)/$(src)/$(css_folder)/camera/util/interface \
+		-I$(srctree)/$(src)/$(css_folder)/$(css_platform_folder) \
+	    -I$(srctree)/$(src)/$(css_folder)/$(css_platform_folder)/host \
+	    -I$(srctree)/$(src)/$(css_folder)/$(css_platform_folder_generated) \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_include \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_include/host \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_include/device_access \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_include/memory_access \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_shared \
+	    -I$(srctree)/$(src)/$(css_folder)/hive_isp_css_shared/host \
+	    -I$(srctree)/$(src)/$(css_folder)/$(kernels) \
+	    -I$(srctree)/$(src)/$(css_folder)/$(kernels)/bh/bh_2 \
+ 	    -I$(srctree)/$(src)/$(css_folder)/$(kernels)/raw_aa_binning/raw_aa_binning_1.0 \
+ 	    -I$(srctree)/$(src)/$(css_folder)/isp/modes \
+ 	    -I$(srctree)/$(src)/$(css_folder)/$(runtime)/binary/interface \
+ 	    -I$(srctree)/$(src)/$(css_folder)/$(runtime)/bufq/interface \
+ 	    -I$(srctree)/$(src)/$(css_folder)/$(runtime)/debug/interface \
+ 	    -I$(srctree)/$(src)/$(css_folder)/$(runtime)/event/interface \
+ 	    -I$(srctree)/$(src)/$(css_folder)/$(runtime)/eventq/interface \
+        -I$(srctree)/$(src)/$(css_folder)/$(runtime)/frame/interface \
+        -I$(srctree)/$(src)/$(css_folder)/$(runtime)/ifmtr/interface \
+        -I$(srctree)/$(src)/$(css_folder)/$(runtime)/inputfifo/interface \
+        -I$(srctree)/$(src)/$(css_folder)/$(runtime)/isp_param/interface \
+        -I$(srctree)/$(src)/$(css_folder)/$(runtime)/isys/interface \
+        -I$(srctree)/$(src)/$(css_folder)/$(runtime)/pipeline/interface \
+        -I$(srctree)/$(src)/$(css_folder)/$(runtime)/queue/interface \
+        -I$(srctree)/$(src)/$(css_folder)/$(runtime)/rmgr/interface \
+        -I$(srctree)/$(src)/$(css_folder)/$(runtime)/spctrl/interface \
+
+DEFINES := -DHRT_HW -DHRT_ISP_CSS_CUSTOM_HOST -DHRT_USE_VIR_ADDRS -DHRT_KERNEL -D__HOST__
+DEFINES += -DUSE_DYNAMIC_BIN
+DEFINES += -DISP_POWER_GATING
+DEFINES += -DUSE_INTERRUPTS
+#DEFINES += -DUSE_SSSE3
+DEFINES += -DPUNIT_CAMERA_BUSY
+ifndef CONFIG_64BIT
+DEFINES += -DUSE_KMEM_CACHE
+endif
+#Disable this define if using BYT D0
+DEFINES += -DISOF_SILICON_BUG_WORKAROUND
+DEFINES += -DCSS_2
+DEFINES += -DSYSTEM_hive_isp_css_2400_system
+
+EXTRA_CFLAGS := $(INCLUDES) $(DEFINES) -fno-common #-Werror
+
+# sparse (0.4.4) doesn't understand _Bool at all.  This will eliminate lots of
+# spurious "Initializer entry defined twice" errors for CSS code containing
+# arrays of Boolean type.
+CHECKFLAGS += -D_Bool=int
diff --git a/drivers/media/atomisp2/atomisp-regs.h b/drivers/media/atomisp2/atomisp-regs.h
new file mode 100644
index 0000000..2698215
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp-regs.h
@@ -0,0 +1,147 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef ATOMISP_REGS_H
+#define ATOMISP_REGS_H
+
+/* common register definitions */
+#define PUNIT_PORT		0x04
+
+#define PCICMDSTS		0x01
+#define INTR			0x0f
+#define MSI_CAPID		0x24
+#define MSI_ADDRESS		0x25
+#define MSI_DATA		0x26
+#define INTR_CTL		0x27
+
+#define PCI_MSI_CAPID		0x90
+#define PCI_MSI_ADDR		0x94
+#define PCI_MSI_DATA		0x98
+#define PCI_INTERRUPT_CTRL	0x9C
+#define PCI_I_CONTROL		0xfc
+
+/* MFLD specific register definitions */
+#define MFLD_IUNITPHY_PORT	0x09
+
+#define MFLD_CSI_RCOMP		0x00
+#define MFLD_CSI_AFE		0x02
+#define MFLD_CSI_CONTROL	0x03
+#define MFLD_CG_DIS		0x36
+#define MFLD_OR1		0x72
+
+#define MFLD_PCI_PMCS		0xd4
+#define MFLD_PCI_CG_DIS		0xd8
+
+/*
+ * Enables the combining of adjacent 32-byte read requests to the same
+ * cache line. When cleared, each 32-byte read request is sent as a
+ * separate request on the IB interface.
+ */
+#define MFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING	BIT(16)
+
+/*
+ * Enables the combining of adjacent 32-byte write requests to the same
+ * cache line. When cleared, each 32-byte write request is sent as a
+ * separate request on the IB interface.
+ */
+#define MFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING	BIT(17)
+
+/* Ensure the correct bits are set for the clock gating disable regster */
+#define MFLD_PCI_CG_DIS_DISABLED_ISPCLK		BIT(0)
+#define MFLD_PCI_CG_DIS_DISABLED_PERF_MON	BIT(2)
+#define MFLD_PCI_CG_DIS_DISABLED_NOA_MON	BIT(3)
+
+/* The MIPI1 and MIPI4 interface and lanes configuration */
+#define MFLD_CSI_CONTROL_DIS_MIPI1_IF	BIT(8)
+#define MFLD_CSI_CONTROL_DIS_MIPI4_IF	BIT(9)
+#define MFLD_CSI_CONTROL_EN_MIPI1_LANE	BIT(10)
+#define MFLD_CSI_CONTROL_EN_MIPI4_LANE	(BIT(11) | BIT(12) | BIT(13) | BIT(14))
+
+#define MFLD_MAX_ZOOM_FACTOR	64
+
+/* MRFLD specific register definitions */
+#define MRFLD_CSI_AFE		0x39
+#define MRFLD_CSI_CONTROL	0x3a
+#define MRFLD_CSI_RCOMP		0x3d
+
+#define MRFLD_PCI_PMCS		0x84
+#define MRFLD_PCI_CSI_ACCESS_CTRL_VIOL	0xd4
+#define MRFLD_PCI_CSI_AFE_HS_CONTROL	0xdc
+#define MRFLD_PCI_CSI_AFE_RCOMP_CONTROL	0xe0
+#define MRFLD_PCI_CSI_CONTROL		0xe8
+#define MRFLD_PCI_CSI_AFE_TRIM_CONTROL	0xe4
+#define MRFLD_PCI_CSI_DEADLINE_CONTROL	0xec
+#define MRFLD_PCI_CSI_RCOMP_CONTROL	0xf4
+
+/*
+ * Enables the combining of adjacent 32-byte read requests to the same
+ * cache line. When cleared, each 32-byte read request is sent as a
+ * separate request on the IB interface.
+ */
+#define MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING	0x1
+
+/*
+ * Enables the combining of adjacent 32-byte write requests to the same
+ * cache line. When cleared, each 32-byte write request is sent as a
+ * separate request on the IB interface.
+ */
+#define MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING	0x2
+
+#define MRFLD_CSI_RECEIVER_SELECTION_REG       0x8081c
+
+#define MRFLD_MAX_ZOOM_FACTOR	1024
+
+/* MRFLD ISP POWER related */
+#define MRFLD_ISPSSPM0         0x39
+#define MRFLD_ISPSSPM0_ISPSSC_OFFSET   0
+#define MRFLD_ISPSSPM0_ISPSSS_OFFSET   24
+#define MRFLD_ISPSSPM0_ISPSSC_MASK 0x3
+#define MRFLD_ISPSSPM0_IUNIT_POWER_ON  0
+#define MRFLD_ISPSSPM0_IUNIT_POWER_OFF 0x3
+
+/* MRFLD CSI lane configuration related */
+#define MRFLD_PORT_CONFIG_NUM  8
+#define MRFLD_PORT_NUM         3
+#define MRFLD_PORT3_ENABLE_SHIFT       2
+#define MRFLD_PORT1_LANES_SHIFT        3
+#define MRFLD_PORT2_LANES_SHIFT        7
+#define MRFLD_PORT3_LANES_SHIFT        8
+#define MRFLD_PORT_CONFIGCODE_SHIFT    16
+#define MRFLD_PORT_CONFIG_MASK 0x000f03ff
+#define MRFLD_ALL_CSI_PORTS_OFF_MASK   0x7
+
+#define ISPSSPM1				0x3a
+#define ISP_FREQ_STAT_MASK			(0x1f << ISP_FREQ_STAT_OFFSET)
+#define ISP_REQ_FREQ_MASK			0x1f
+#define ISP_FREQ_VALID_MASK			(0x1 << ISP_FREQ_VALID_OFFSET)
+#define ISP_FREQ_STAT_OFFSET			0x18
+#define ISP_REQ_GUAR_FREQ_OFFSET		0x8
+#define ISP_REQ_FREQ_OFFSET			0x0
+#define ISP_FREQ_VALID_OFFSET			0x7
+#define ISP_FREQ_RULE_ANY			0x0
+
+#define ISP_FREQ_400MHZ				0x190
+#define ISP_FREQ_320MHZ				0x140
+#define ISP_FREQ_266MHZ				0x10a
+#define ISP_FREQ_200MHZ				0xc8
+#define HPLL_FREQ				0x640
+
+#endif /* ATOMISP_REGS_H */
diff --git a/drivers/media/atomisp2/atomisp_acc.c b/drivers/media/atomisp2/atomisp_acc.c
new file mode 100644
index 0000000..fc59b67
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_acc.c
@@ -0,0 +1,646 @@
+/*
+ * Support for Clovertrail PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/*
+ * This file implements loadable acceleration firmware API,
+ * including ioctls to map and unmap acceleration parameters and buffers.
+ */
+
+#include <linux/init.h>
+
+#include "atomisp_acc.h"
+#include "atomisp_internal.h"
+#include "atomisp_compat.h"
+
+#include "hrt/hive_isp_css_mm_hrt.h"
+#include "memory_access/memory_access.h"
+#include "ia_css.h"
+
+/* Assume max number of ACC stages */
+#define MAX_ACC_STAGES	20
+
+static const struct {
+	unsigned int flag;
+	enum ia_css_pipe_id pipe_id;
+} acc_flag_to_pipe[] = {
+	{ ATOMISP_ACC_FW_LOAD_FL_PREVIEW, IA_CSS_PIPE_ID_PREVIEW },
+	{ ATOMISP_ACC_FW_LOAD_FL_COPY, IA_CSS_PIPE_ID_COPY },
+	{ ATOMISP_ACC_FW_LOAD_FL_VIDEO, IA_CSS_PIPE_ID_VIDEO },
+	{ ATOMISP_ACC_FW_LOAD_FL_CAPTURE, IA_CSS_PIPE_ID_CAPTURE }
+};
+
+/*
+ * Allocate struct atomisp_acc_fw along with space for firmware.
+ * The returned struct atomisp_acc_fw is cleared (firmware region is not).
+ */
+static struct atomisp_acc_fw *acc_alloc_fw(unsigned int fw_size)
+{
+	struct atomisp_acc_fw *acc_fw;
+	/*struct atomisp_acc_fw *acc_fw;*/
+	acc_fw = kzalloc(sizeof(*acc_fw), GFP_KERNEL);
+	if (!acc_fw)
+		return NULL;
+
+	acc_fw->fw = vmalloc(fw_size);
+	if (!acc_fw->fw) {
+		kfree(acc_fw);
+		return NULL;
+	}
+	/*acc_fw = kzalloc(sizeof(*acc_fw), GFP_KERNEL);*/
+	return acc_fw;
+}
+
+static void acc_free_fw(struct atomisp_acc_fw *acc_fw)
+{
+	vfree(acc_fw->fw);
+	kfree(acc_fw);
+}
+
+static struct atomisp_acc_fw *
+acc_get_fw(struct atomisp_device *isp, unsigned int handle)
+{
+	struct atomisp_acc_fw *acc_fw;
+	/*struct atomisp_acc_fw *acc_fw;*/
+	list_for_each_entry(acc_fw, &isp->acc.fw, list)
+		if (acc_fw->handle == handle)
+			return acc_fw;
+
+	return NULL;
+}
+
+static struct atomisp_map *acc_get_map(struct atomisp_device *isp,
+				       unsigned long css_ptr, size_t length)
+{
+	struct atomisp_map *atomisp_map;
+	/*struct atomisp_map *atomisp_map;*/
+	list_for_each_entry(atomisp_map, &isp->acc.memory_maps, list) {
+		if (atomisp_map->ptr == css_ptr &&
+		    atomisp_map->length == length)
+			return atomisp_map;
+	}
+	return NULL;
+}
+
+static int acc_stop_acceleration(struct atomisp_device *isp)
+{
+	void *acc_stages;
+	/*list_for_each_entry(atomisp_map, &isp->acc.memory_maps, list) {*/
+	struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[0];
+		/*if (atomisp_map->ptr == css_ptr &&*/
+		    /*atomisp_map->length == length)*/
+	dev_dbg(isp->dev, ">%s\n", __func__);
+	if (!isp->acc.pipeline) {
+		dev_dbg(isp->dev, "<%s: no acc pipe to stop\n", __func__);
+		return -ENOENT;
+	}
+			/*return atomisp_map;*/
+	if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED) {
+		dev_dbg(isp->dev, "<%s: acc stream not started\n", __func__);
+		return -ENOENT;
+	}
+	/*}*/
+	/*return NULL;*/
+	mutex_unlock(&isp->mutex);
+	if (wait_for_completion_interruptible(&isp->acc.acc_done) != 0) {
+		dev_err(isp->dev, "<%s: completion interrupted\n", __func__);
+		mutex_lock(&isp->mutex);
+		return -ERESTARTSYS;
+}
+	mutex_lock(&isp->mutex);
+	dev_dbg(isp->dev, "wait for acc pipeline done finished\n");
+	/*if (ia_css_acceleration_stop() != IA_CSS_SUCCESS)*/
+	del_timer_sync(&isp->wdt);
+	cancel_work_sync(&isp->wdt_work);
+		/*dev_err(isp->dev, "cannot stop acceleration pipeline\n");*/
+	/*
+	 * back up the acc stages pointer and release the memory
+	 * after css stop.
+	 */
+	acc_stages =
+		isp_subdev->css2_basis.pipe_configs[IA_CSS_PIPE_ID_ACC].
+		acc_stages;
+	ia_css_stop(isp_subdev, false);
+	isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_DISABLED;
+	kfree(acc_stages);
+
+	isp->acc.pipeline = NULL;
+	dev_dbg(isp->dev, "<%s\n", __func__);
+	return 0;
+}
+
+void atomisp_acc_init(struct atomisp_device *isp)
+{
+	INIT_LIST_HEAD(&isp->acc.fw);
+	INIT_LIST_HEAD(&isp->acc.memory_maps);
+	ida_init(&isp->acc.ida);
+}
+
+void atomisp_acc_cleanup(struct atomisp_device *isp)
+{
+	ida_destroy(&isp->acc.ida);
+}
+
+void atomisp_acc_release(struct atomisp_device *isp)
+{
+	struct atomisp_acc_fw *acc_fw, *ta;
+	struct atomisp_map *atomisp_map, *tm;
+
+	/* Stop acceleration if already running */
+	if (isp->acc.pipeline)
+		acc_stop_acceleration(isp);
+
+	/* Unload all loaded acceleration binaries */
+	list_for_each_entry_safe(acc_fw, ta, &isp->acc.fw, list) {
+		list_del(&acc_fw->list);
+		ida_remove(&isp->acc.ida, acc_fw->handle);
+		acc_free_fw(acc_fw);
+	}
+
+	/* Free all mapped memory blocks */
+	list_for_each_entry_safe(atomisp_map, tm, &isp->acc.memory_maps, list) {
+		list_del(&atomisp_map->list);
+		mmgr_free(atomisp_map->ptr);
+		kfree(atomisp_map);
+	}
+}
+
+int atomisp_acc_load_to_pipe(struct atomisp_device *isp,
+			     struct atomisp_acc_fw_load_to_pipe *user_fw)
+{
+	static const unsigned int pipeline_flags =
+		ATOMISP_ACC_FW_LOAD_FL_PREVIEW |
+		ATOMISP_ACC_FW_LOAD_FL_COPY |
+		ATOMISP_ACC_FW_LOAD_FL_VIDEO |
+		ATOMISP_ACC_FW_LOAD_FL_CAPTURE |
+		ATOMISP_ACC_FW_LOAD_FL_ACC;
+
+	struct atomisp_acc_fw *acc_fw;
+	int handle;
+
+	if (!user_fw->data || user_fw->size == 0)
+		return -EINVAL;
+
+	/* Binary has to be enabled at least for one pipeline */
+	if (!(user_fw->flags & pipeline_flags))
+		return -EINVAL;
+
+	/* We do not support other flags yet */
+	if (user_fw->flags & ~pipeline_flags)
+		return -EINVAL;
+
+	if (user_fw->type < ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT ||
+	    user_fw->type > ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE)
+		return -EINVAL;
+
+	if (isp->acc.pipeline || isp->acc.extension_mode)
+		return -EBUSY;
+
+	acc_fw = acc_alloc_fw(user_fw->size);
+	if (!acc_fw)
+		return -ENOMEM;
+
+	if (copy_from_user(acc_fw->fw, user_fw->data, user_fw->size)) {
+		acc_free_fw(acc_fw);
+		return -EFAULT;
+	}
+
+	if (!ida_pre_get(&isp->acc.ida, GFP_KERNEL) ||
+	    ida_get_new_above(&isp->acc.ida, 1, &handle)) {
+		acc_free_fw(acc_fw);
+		return -ENOSPC;
+	}
+
+	user_fw->fw_handle = handle;
+	acc_fw->handle = handle;
+	acc_fw->flags = user_fw->flags;
+	acc_fw->type = user_fw->type;
+	/*
+	 * correct isp firmware type in order ISP firmware can be appended
+	 * to correct pipe properly
+	 */
+	if (acc_fw->fw->type == ia_css_isp_firmware) {
+		switch (acc_fw->type) {
+		case ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT:
+			acc_fw->fw->info.isp.type = IA_CSS_ACC_OUTPUT;
+			break;
+
+		case ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER:
+			acc_fw->fw->info.isp.type = IA_CSS_ACC_VIEWFINDER;
+			break;
+
+		case ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE:
+			acc_fw->fw->info.isp.type = IA_CSS_ACC_STANDALONE;
+			break;
+		}
+	}
+
+	list_add_tail(&acc_fw->list, &isp->acc.fw);
+	return 0;
+}
+
+int atomisp_acc_load(struct atomisp_device *isp,
+		     struct atomisp_acc_fw_load *user_fw)
+{
+	struct atomisp_acc_fw_load_to_pipe ltp;
+	int r;
+
+	memset(&ltp, 0, sizeof(ltp));
+	ltp.flags = ATOMISP_ACC_FW_LOAD_FL_ACC;
+	ltp.type = ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE;
+	ltp.size = user_fw->size;
+	ltp.data = user_fw->data;
+	r = atomisp_acc_load_to_pipe(isp, &ltp);
+	user_fw->fw_handle = ltp.fw_handle;
+
+	return r;
+}
+
+int atomisp_acc_unload(struct atomisp_device *isp, unsigned int *handle)
+{
+	struct atomisp_acc_fw *acc_fw;
+
+	if (isp->acc.pipeline || isp->acc.extension_mode)
+		return -EBUSY;
+
+	acc_fw = acc_get_fw(isp, *handle);
+	if (!acc_fw)
+		return -EINVAL;
+
+	list_del(&acc_fw->list);
+	ida_remove(&isp->acc.ida, acc_fw->handle);
+	acc_free_fw(acc_fw);
+
+	return 0;
+}
+
+/* Set the binary arguments */
+static int acc_set_parameters(struct atomisp_acc_fw *acc_fw)
+{	//No longer included from irci_master_20140310_2300 onwards
+	//struct ia_css_data sec;
+
+	enum ia_css_isp_memories mem;
+
+	for (mem = 0; mem < N_IA_CSS_ISP_MEMORIES; mem++) {
+		if (acc_fw->args[mem].length == 0)
+			continue;
+
+
+
+		//No longer included from irci_master_20140310_2300 onwards
+		/*sec.address = acc_fw->args[mem].css_ptr;
+		  sec.size = acc_fw->args[mem].length;
+		if (sh_css_acc_set_firmware_parameters(acc_fw->fw, mem, sec)
+			!= IA_CSS_SUCCESS)
+			return -EIO;*/
+		 acc_fw->fw->mem_initializers.params[mem]->address = acc_fw->args[mem].css_ptr;
+		 acc_fw->fw->mem_initializers.params[mem]->size = acc_fw->args[mem].length;
+
+	}
+
+	return 0;
+}
+
+int atomisp_acc_start(struct atomisp_device *isp, unsigned int *handle)
+{
+	struct atomisp_acc_fw *acc_fw;
+	enum ia_css_err err;
+	struct ia_css_pipe_config *pipe_config;
+
+	struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[0];
+	const struct ia_css_stream_config *s_config =
+			&isp_subdev->css2_basis.stream_config;
+	int ret = 0;
+
+	dev_dbg(isp->dev, ">%s\n", __func__);
+	if (isp->acc.pipeline || isp->acc.extension_mode)
+		return -EBUSY;
+
+	/* Invalidate caches for all cores. FIXME: should flush only necessary buffers */
+	wbinvd_on_all_cpus();
+
+	if (isp_subdev->css2_basis.stream) {
+		dev_dbg(isp->dev, "%s: destroy basis stream\n", __func__);
+		if (isp_subdev->css2_basis.stream_state ==
+		    CSS2_STREAM_STARTED) {
+			ret = ia_css_stream_stop(isp_subdev->css2_basis.stream);
+			if (ret != IA_CSS_SUCCESS) {
+				dev_err(isp->dev, "stop stream failed.\n");
+				return -EBUSY;
+			}
+		}
+
+		ret = ia_css_stream_destroy(isp_subdev->css2_basis.stream);
+		if (ret != IA_CSS_SUCCESS) {
+			dev_err(isp->dev, "destroy stream failed.\n");
+			return -EBUSY;
+		}
+		isp_subdev->css2_basis.stream = NULL;
+	}
+
+	pipe_config = &isp_subdev->css2_basis.pipe_configs[IA_CSS_PIPE_ID_ACC];
+	ia_css_pipe_config_defaults(pipe_config);
+	pipe_config->acc_stages = kzalloc(MAX_ACC_STAGES *
+				sizeof(struct ia_css_fw_info *), GFP_KERNEL);
+	if (!pipe_config->acc_stages)
+		return -ENOMEM;
+	pipe_config->mode = IA_CSS_PIPE_MODE_ACC;
+	pipe_config->num_acc_stages = 0;
+
+	list_for_each_entry(acc_fw, &isp->acc.fw, list) {
+		if (*handle != 0 && *handle != acc_fw->handle)
+			continue;
+
+		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE)
+			continue;
+
+		/* Add the binary into the pipeline */
+		pipe_config->acc_stages[pipe_config->num_acc_stages++] =
+								acc_fw->fw;
+		if (acc_set_parameters(acc_fw)) {
+			dev_err(isp->dev, "acc_set_parameters failed\n");
+			ret = -EINVAL;
+			goto err;
+		}
+	}
+		/* Refuse creating pipelines with no binaries */
+	if (pipe_config->num_acc_stages < 1) {
+		/* Refuse creating pipelines with no binaries */
+		dev_err(isp->dev, "%s: no acc binary available\n", __func__);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	err = ia_css_pipe_create(pipe_config,
+			&isp_subdev->css2_basis.pipes[IA_CSS_PIPE_ID_ACC]);
+	if (err) {
+		dev_err(isp->dev, "%s: ia_css_pipe_create failed %d\n",
+				__func__, err);
+		ret = -EBADE;
+		goto err;
+	}
+
+	memset(&isp_subdev->css2_basis.stream_config, 0,
+		sizeof(struct ia_css_stream_config));
+	err = ia_css_stream_create(s_config, 1,
+				&isp_subdev->css2_basis.
+				pipes[IA_CSS_PIPE_ID_ACC],
+				&isp_subdev->css2_basis.stream);
+	if (err != IA_CSS_SUCCESS) {
+		dev_err(isp->dev, "%s: create stream error %d.\n",
+			__func__, err);
+		ia_css_pipe_destroy(isp_subdev->css2_basis.
+				    pipes[IA_CSS_PIPE_ID_ACC]);
+		isp_subdev->css2_basis.pipes[IA_CSS_PIPE_ID_ACC] = NULL;
+		err = -EINVAL;
+		goto err;
+	}
+
+	isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_ENABLED;
+	init_completion(&isp->acc.acc_done);
+	atomic_set(&isp->wdt_count, 0);
+	mod_timer(&isp->wdt, jiffies + ATOMISP_ISP_TIMEOUT_DURATION);
+	isp->fr_status = ATOMISP_FRAME_STATUS_OK;
+	isp->sw_contex.invalid_frame = false;
+	isp_subdev->params.dvs_proj_data_valid = false;
+	isp->acc.pipeline = isp_subdev->css2_basis.pipes[IA_CSS_PIPE_ID_ACC];
+
+	dev_dbg(isp->dev, ">ia_css_start\n");
+	err = ia_css_start(isp_subdev, false);
+	if (err != IA_CSS_SUCCESS) {
+		dev_err(isp->dev, "%s: start css error %d.\n", __func__, err);
+		ret = ia_css_stream_destroy(isp_subdev->css2_basis.stream);
+		isp_subdev->css2_basis.stream = NULL;
+		ia_css_pipe_destroy(isp_subdev->css2_basis.
+				    pipes[IA_CSS_PIPE_ID_ACC]);
+		isp_subdev->css2_basis.pipes[IA_CSS_PIPE_ID_ACC] = NULL;
+		err = -EINVAL;
+		goto err;
+	}
+	dev_dbg(isp->dev, "<ia_css_start\n");
+	dev_dbg(isp->dev, "<%s\n", __func__);
+	return 0;
+err:
+	kfree(pipe_config->acc_stages);
+	dev_dbg(isp->dev, "<%s err %d\n", __func__, ret);
+	return ret;
+}
+
+int atomisp_acc_wait(struct atomisp_device *isp, unsigned int *handle)
+{
+	if (*handle && !acc_get_fw(isp, *handle))
+		return -EINVAL;
+
+	return acc_stop_acceleration(isp);
+}
+
+int atomisp_acc_map(struct atomisp_device *isp, struct atomisp_acc_map *map)
+{
+	int pgnr;
+	//hrt_vaddress cssptr; [KB]
+	ia_css_ptr cssptr;
+	struct atomisp_map *atomisp_map;
+
+	if (map->flags || !map->user_ptr || map->css_ptr)
+		return -EINVAL;
+
+	if (isp->acc.pipeline)
+		return -EBUSY;
+
+	pgnr = DIV_ROUND_UP(map->length, PAGE_SIZE);
+	/*cssptr = (hrt_vaddress)hrt_isp_css_mm_alloc_user_ptr(
+			map->length, (unsigned int)map->user_ptr,
+			pgnr, HRT_USR_PTR, NULL, false); [KB] */
+	cssptr = hrt_isp_css_mm_alloc_user_ptr(
+				map->length, map->user_ptr,
+				pgnr, HRT_USR_PTR, NULL, false);
+	if (!cssptr)
+		return -ENOMEM;
+
+	atomisp_map = kmalloc(sizeof(*atomisp_map), GFP_KERNEL);
+	if (!atomisp_map) {
+		mmgr_free(cssptr);
+		return -ENOMEM;
+	}
+	atomisp_map->ptr = cssptr;
+	atomisp_map->length = map->length;
+	list_add(&atomisp_map->list, &isp->acc.memory_maps);
+
+	dev_dbg(isp->dev, "%s: userptr %p, css_address 0x%x, size %d\n",
+		__func__, map->user_ptr, cssptr, map->length);
+	map->css_ptr = cssptr;
+	return 0;
+}
+
+int atomisp_acc_unmap(struct atomisp_device *isp, struct atomisp_acc_map *map)
+{
+	struct atomisp_map *atomisp_map;
+
+	if (map->flags)
+		return -EINVAL;
+
+	if (isp->acc.pipeline)
+		return -EBUSY;
+
+	atomisp_map = acc_get_map(isp, map->css_ptr, map->length);
+	if (!atomisp_map)
+		return -EINVAL;
+
+	list_del(&atomisp_map->list);
+	mmgr_free(atomisp_map->ptr);
+	kfree(atomisp_map);
+
+	return 0;
+}
+
+int atomisp_acc_s_mapped_arg(struct atomisp_device *isp,
+			     struct atomisp_acc_s_mapped_arg *arg)
+{
+	struct atomisp_acc_fw *acc_fw;
+
+	if (arg->memory >= N_IA_CSS_ISP_MEMORIES)
+		return -EINVAL;
+
+	if (isp->acc.pipeline)
+		return -EBUSY;
+
+	acc_fw = acc_get_fw(isp, arg->fw_handle);
+	if (!acc_fw)
+		return -EINVAL;
+
+	if (arg->css_ptr != 0 || arg->length != 0) {
+		/* Unless the parameter is cleared, check that it exists */
+		if (!acc_get_map(isp, arg->css_ptr, arg->length))
+			return -EINVAL;
+	}
+
+	acc_fw->args[arg->memory].length = arg->length;
+	acc_fw->args[arg->memory].css_ptr = arg->css_ptr;
+
+	dev_dbg(isp->dev, "%s: mem %d, address %p, size %ld\n",
+			__func__, arg->memory, (void *)arg->css_ptr,
+			(unsigned long)arg->length);//[KB]
+	return 0;
+}
+
+/*
+ * Appends the loaded acceleration binary extensions to the
+ * current ISP mode. Must be called just before ia_css_start().
+ */
+int atomisp_acc_load_extensions(struct atomisp_device *isp)
+{
+	struct atomisp_acc_fw *acc_fw;
+	/* FIXME: Function should take isp_subdev as parameter */
+	struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[0];
+	bool ext_loaded = false;
+
+	int ret = 0, i;
+
+	if (isp->acc.pipeline || isp->acc.extension_mode)
+		return -EBUSY;
+
+	/* Invalidate caches for all cores. FIXME: should flush only necessary buffers */
+	wbinvd_on_all_cpus();
+
+	list_for_each_entry(acc_fw, &isp->acc.fw, list) {
+		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&
+		    acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)
+			continue;
+
+		for (i = 0; i < ARRAY_SIZE(acc_flag_to_pipe); i++) {
+			if (acc_fw->flags & acc_flag_to_pipe[i].flag) {
+				unsigned int pipe_id =
+					acc_flag_to_pipe[i].pipe_id;
+				struct ia_css_pipe_config *pipe_cfg =
+					&isp_subdev->css2_basis.
+					pipe_configs[pipe_id];
+				/* Add the binary into the pipeline */
+				pipe_cfg->acc_extension = acc_fw->fw;
+				isp_subdev->css2_basis.update_pipe[pipe_id] =
+				    true;
+				ext_loaded = true;
+			}
+		}
+
+		ret = acc_set_parameters(acc_fw);
+		if (ret < 0)
+			goto error;
+	}
+
+	if (!ext_loaded)
+		return ret;
+
+	if (ia_css_update_stream(isp_subdev) != IA_CSS_SUCCESS) {
+		dev_err(isp->dev, "%s: update stream failed.\n", __func__);
+		ret = -ENOMEM;
+			goto error;
+	}
+
+	isp->acc.extension_mode = true;
+	return 0;
+
+error:
+	list_for_each_entry_continue_reverse(acc_fw, &isp->acc.fw, list) {
+		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&
+		    acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)
+			continue;
+
+		for (i = ARRAY_SIZE(acc_flag_to_pipe) - 1; i >= 0; i--) {
+			unsigned int pipe_id =
+				acc_flag_to_pipe[i].pipe_id;
+			struct ia_css_pipe_config *pipe_cfg =
+				&isp_subdev->css2_basis.pipe_configs[pipe_id];
+
+			if  (acc_fw->flags & acc_flag_to_pipe[i].flag)
+				pipe_cfg->acc_extension = NULL;
+		}
+	}
+	return ret;
+}
+
+void atomisp_acc_unload_extensions(struct atomisp_device *isp)
+{
+	struct atomisp_acc_fw *acc_fw;
+	/* FIXME: Function should take isp_subdev as parameter */
+	struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[0];
+
+	int i;
+
+	if (!isp->acc.extension_mode)
+		return;
+
+	list_for_each_entry_reverse(acc_fw, &isp->acc.fw, list) {
+		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&
+		    acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)
+			continue;
+
+		for (i = ARRAY_SIZE(acc_flag_to_pipe) - 1; i >= 0; i--) {
+			unsigned int pipe_id =
+				acc_flag_to_pipe[i].pipe_id;
+			struct ia_css_pipe_config *pipe_cfg =
+				&isp_subdev->css2_basis.pipe_configs[pipe_id];
+				/* Remove the binary from the pipeline */
+			if  (acc_fw->flags & acc_flag_to_pipe[i].flag)
+				pipe_cfg->acc_extension = NULL;
+		}
+	}
+
+	isp->acc.extension_mode = false;
+}
diff --git a/drivers/media/atomisp2/atomisp_acc.h b/drivers/media/atomisp2/atomisp_acc.h
new file mode 100644
index 0000000..3aecbd1
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_acc.h
@@ -0,0 +1,111 @@
+/*
+ * Support for Clovertrail PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ATOMISP_ACC_H__
+#define __ATOMISP_ACC_H__
+
+#include <linux/atomisp.h>
+#include "ia_css_types.h"
+#include "atomisp_internal.h"
+
+/*
+ * Interface functions for AtomISP driver acceleration API implementation.
+ */
+
+struct atomisp_device;
+
+/*
+ * Initialize acceleration interface.
+ * Must be called once when the driver is loaded.
+ */
+void atomisp_acc_init(struct atomisp_device *isp);
+
+void atomisp_acc_cleanup(struct atomisp_device *isp);
+
+/*
+ * Free up any allocated resources.
+ * Must be called each time when the device is closed.
+ * Note that there isn't corresponding open() call;
+ * this function may be called sequentially multiple times.
+ * Must be called to free up resources before driver is unloaded.
+ */
+void atomisp_acc_release(struct atomisp_device *isp);
+
+/* Load acceleration binary. DEPRECATED. */
+int atomisp_acc_load(struct atomisp_device *isp,
+		     struct atomisp_acc_fw_load *fw);
+
+/* Load acceleration binary with specified properties */
+int atomisp_acc_load_to_pipe(struct atomisp_device *isp,
+			     struct atomisp_acc_fw_load_to_pipe *fw);
+
+/* Unload specified acceleration binary */
+int atomisp_acc_unload(struct atomisp_device *isp,
+		       unsigned int *handle);
+
+/*
+ * Map a memory region into ISP memory space.
+ */
+int atomisp_acc_map(struct atomisp_device *isp,
+		    struct atomisp_acc_map *map);
+
+/*
+ * Unmap a mapped memory region.
+ */
+int atomisp_acc_unmap(struct atomisp_device *isp,
+		      struct atomisp_acc_map *map);
+
+/*
+ * Set acceleration binary argument to a previously mapped memory region.
+ */
+int atomisp_acc_s_mapped_arg(struct atomisp_device *isp,
+			     struct atomisp_acc_s_mapped_arg *arg);
+
+
+/*
+ * Start acceleration.
+ * Return immediately, acceleration is left running in background.
+ * Specify either acceleration binary or pipeline which to start.
+ */
+int atomisp_acc_start(struct atomisp_device *isp,
+		      unsigned int *handle);
+
+/*
+ * Wait until acceleration finishes.
+ * This MUST be called after each acceleration has been started.
+ * Specify either acceleration binary or pipeline handle.
+ */
+int atomisp_acc_wait(struct atomisp_device *isp,
+		     unsigned int *handle);
+
+/*
+ * Appends the loaded acceleration binary extensions to the
+ * current ISP mode. Must be called just before sh_css_start().
+ */
+int atomisp_acc_load_extensions(struct atomisp_device *isp);
+
+/*
+ * Must be called after streaming is stopped:
+ * unloads any loaded acceleration extensions.
+ */
+void atomisp_acc_unload_extensions(struct atomisp_device *isp);
+
+#endif /* __ATOMISP_ACC_H__ */
diff --git a/drivers/media/atomisp2/atomisp_cmd.c b/drivers/media/atomisp2/atomisp_cmd.c
new file mode 100644
index 0000000..ee756a2
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_cmd.c
@@ -0,0 +1,5220 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifdef ENABLE_DEV_DEBUG
+#define DEBUG
+#endif
+
+#include <linux/firmware.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/kfifo.h>
+#include <linux/pm_runtime.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+
+#include <media/v4l2-event.h>
+
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_fops.h"
+#include "atomisp_internal.h"
+#include "atomisp_ioctl.h"
+#include "atomisp-regs.h"
+#include "atomisp_tables.h"
+#include "atomisp_acc.h"
+#include "atomisp_compat.h"
+
+#include "hrt/hive_isp_css_mm_hrt.h"
+
+#include "ia_css_debug.h"
+#include "sh_css_hrt.h"
+#include "sh_css_defs.h"
+#include "system_global.h"
+#include "sh_css_internal.h"
+#include "sh_css_sp.h"
+#include "gp_device.h"
+#include "device_access.h"
+#include "irq.h"
+
+#include "ia_css_types.h"
+
+#include "hrt/bits.h"
+
+
+/* We should never need to run the flash for more than 2 frames.
+ * At 15fps this means 133ms. We set the timeout a bit longer.
+ * Each flash driver is supposed to set its own timeout, but
+ * just in case someone else changed the timeout, we set it
+ * here to make sure we don't damage the flash hardware. */
+#define FLASH_TIMEOUT 800 /* ms */
+
+/*
+ * atomisp_kernel_malloc: chooses whether kmalloc() or vmalloc() is preferable.
+ *
+ * It is also a wrap functions to pass into css framework.
+ */
+void *atomisp_kernel_malloc(size_t bytes)
+{
+	/* vmalloc() is preferable if allocating more than 1 page */
+	if (bytes > PAGE_SIZE)
+		return vmalloc(bytes);
+
+	return kmalloc(bytes, GFP_KERNEL);
+}
+
+/*
+ * Free buffer allocated with atomisp_kernel_malloc()/atomisp_kernel_zalloc
+ * helper
+ */
+void atomisp_kernel_free(void *ptr)
+{
+	/* Verify if buffer was allocated by vmalloc() or kmalloc() */
+	if (is_vmalloc_addr(ptr))
+		vfree(ptr);
+	else
+		kfree(ptr);
+}
+
+/*
+ * get sensor:dis71430/ov2720 related info from v4l2_subdev->priv data field.
+ * subdev->priv is set in mrst.c
+ */
+struct camera_mipi_info *atomisp_to_sensor_mipi_info(struct v4l2_subdev *sd)
+{
+	return (struct camera_mipi_info *)v4l2_get_subdev_hostdata(sd);
+}
+
+/*
+ * get struct atomisp_video_pipe from v4l2 video_device
+ */
+struct atomisp_video_pipe *atomisp_to_video_pipe(struct video_device *dev)
+{
+	return (struct atomisp_video_pipe *)
+	    container_of(dev, struct atomisp_video_pipe, vdev);
+}
+
+/*
+ * get struct atomisp_sub_device from atomisp_video_pipe
+ */
+struct atomisp_sub_device *atomisp_to_sub_device(struct atomisp_video_pipe
+						 *atomisp_pipe)
+{
+	return atomisp_pipe->isp_subdev;
+}
+
+/* This is just a draft rules, should be tuned when sensor is ready*/
+static struct atomisp_freq_scaling_rule dfs_rules[] = {
+	{
+		.width = ISP_FREQ_RULE_ANY,
+		.height = ISP_FREQ_RULE_ANY,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_VIDEO,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.fps = 60,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_VIDEO,
+	},
+	{
+		.width = 4192,
+		.height = 3104,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
+	},
+	{
+		.width = 4096,
+		.height = 3072,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
+	},
+	{
+		.width = 3648,
+		.height = 2736,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
+	},
+	{
+		.width = ISP_FREQ_RULE_ANY,
+		.height = ISP_FREQ_RULE_ANY,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.fps = 60,
+		.isp_freq = ISP_FREQ_320MHZ,
+		.run_mode = ATOMISP_RUN_MODE_VIDEO,
+	},
+};
+
+const struct atomisp_format_bridge atomisp_output_fmts[] = {
+        {
+                .pixelformat = V4L2_PIX_FMT_YUV420,
+                .depth = 12,
+                .mbus_code = 0x8001,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_YUV420,
+                .description = "YUV420, planner"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_YVU420,
+                .depth = 12,
+                .mbus_code = 0x8002,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_YV12,
+                .description = "YVU420, planner"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_YUV422P,
+                .depth = 16,
+                .mbus_code = 0x8003,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_YUV422,
+                .description = "YUV422, planar"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_YUV444,
+                .depth = 24,
+                .mbus_code = 0x8004,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_YUV444,
+                .description = "YUV444"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_NV12,
+                .depth = 12,
+                .mbus_code = 0x8005,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_NV12,
+                .description = "NV12, interleaved"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_NV21,
+                .depth = 12,
+                .mbus_code = 0x8006,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_NV21,
+                .description = "NV21, interleaved"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_NV16,
+                .depth = 16,
+                .mbus_code = 0x8007,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_NV16,
+                .description = "NV16, interleaved"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_YUYV,
+                .depth = 16,
+                .mbus_code = 0x8008,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_YUYV,
+                .description = "YUYV, interleaved"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_UYVY,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_UYVY,
+                .description = "UYVY, interleaved"
+        }, { /* This one is for parallel sensors! DO NOT USE! */
+                .pixelformat = V4L2_PIX_FMT_UYVY,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_UYVY8_2X8,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_UYVY,
+                .description = "UYVY, interleaved"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SBGGR16,
+                .depth = 16,
+                .mbus_code = 0x8009,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 16"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SBGGR8,
+                .depth = 8,
+                .mbus_code = MEDIA_BUS_FMT_SBGGR8_1X8,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 8"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SGBRG8,
+                .depth = 8,
+                .mbus_code = MEDIA_BUS_FMT_SGBRG8_1X8,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 8"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SGRBG8,
+                .depth = 8,
+                .mbus_code = MEDIA_BUS_FMT_SGRBG8_1X8,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 8"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SRGGB8,
+                .depth = 8,
+                .mbus_code = MEDIA_BUS_FMT_SRGGB8_1X8,
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SBGGR10,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_SBGGR10_1X10,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 10"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SGBRG10,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_SGBRG10_1X10,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 10"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SGRBG10,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_SGRBG10_1X10,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 10"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SRGGB10,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_SRGGB10_1X10,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 10"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SBGGR12,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_SBGGR12_1X12,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 12"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SGBRG12,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_SBGGR12_1X12,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 12"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SGRBG12,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_SBGGR12_1X12,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 12"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_SRGGB12,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_SBGGR12_1X12,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RAW,
+                .description = "Bayer 12"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_RGB32,
+                .depth = 32,
+                .mbus_code = 0x800a,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RGBA888,
+                .description = "32 RGB 8-8-8-8"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_RGB24,
+                .depth = 32,
+                .mbus_code = 0x800b, /* TODO verify this MBUS code */
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RGBA888,
+                .description = "24 RGB 8-8-8"
+        }, {
+                .pixelformat = V4L2_PIX_FMT_RGB565,
+                .depth = 16,
+                .mbus_code = MEDIA_BUS_FMT_RGB565_2X8_LE,
+                .sh_fmt = IA_CSS_FRAME_FORMAT_RGB565,
+                .description = "16 RGB 5-6-5"
+        },
+};
+
+const struct atomisp_format_bridge *atomisp_get_format_bridge(
+        unsigned int pixelformat)
+{
+        unsigned int i;
+
+        for (i = 0; i < ARRAY_SIZE(atomisp_output_fmts); i++) {
+                if (atomisp_output_fmts[i].pixelformat == pixelformat)
+                        return &atomisp_output_fmts[i];
+        }
+
+        return NULL;
+}
+
+const struct atomisp_format_bridge *atomisp_get_format_bridge_from_mbus(
+        enum media_bus_format mbus_code)
+{
+        unsigned int i;
+        trace_printk("mbus code requested 0X%X\n", mbus_code);
+        for (i = 0; i < ARRAY_SIZE(atomisp_output_fmts); i++) {
+                if (mbus_code == atomisp_output_fmts[i].mbus_code)
+                        return &atomisp_output_fmts[i];
+        }
+
+        return NULL;
+}
+
+int atomisp_enum_fmt_cap(struct file *file, void *fh,
+        struct v4l2_fmtdesc *f)
+{
+        if (f->index >= ARRAY_SIZE(atomisp_output_fmts))
+                return -EINVAL;
+
+        f->pixelformat = atomisp_output_fmts[f->index].pixelformat;
+        memset(f->description, 0, sizeof(f->description));
+        strncpy(f->description, atomisp_output_fmts[f->index].description,
+                strlen(atomisp_output_fmts[f->index].description));
+
+        return 0;
+}
+
+#define ISP_FREQ_RULE_MAX (ARRAY_SIZE(dfs_rules))
+
+static unsigned short atomisp_get_sensor_fps(struct atomisp_sub_device *isp_subdev)
+{
+	struct v4l2_subdev_frame_interval frame_interval;
+	unsigned short fps;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+		video, g_frame_interval, &frame_interval)) {
+		fps = 0;
+	} else {
+		if (frame_interval.interval.numerator)
+			fps = frame_interval.interval.denominator /
+			    frame_interval.interval.numerator;
+		else
+			fps = 0;
+	}
+	return fps;
+}
+/*
+ * DFS progress is shown as follows:
+ * 1. Target frequency is calculated according to FPS/Resolution/ISP running
+ * mode.
+ * 2. Ratio is calucated in formula: 2 * (HPLL / target frequency) - 1
+ * 3. Set ratio to ISPFREQ40, 1 to FREQVALID and ISPFREQGUAR40
+ *    to 200MHz in ISPSSPM1.
+ * 4. Wait for FREQVALID to be cleared by P-Unit.
+ * 5. Wait for field ISPFREQSTAT40 in ISPSSPM1 turn to ratio set in 3.
+ */
+static int write_target_freq_to_hw(int new_freq)
+{
+	int ratio, timeout;
+	u32 isp_sspm1 = 0;
+	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+	if (isp_sspm1 & ISP_FREQ_VALID_MASK) {
+		v4l2_dbg(6, dbg_level, &atomisp_dev,
+			  "clearing ISPSSPM1 valid bit.\n");
+		intel_mid_msgbus_write32(PUNIT_PORT, ISPSSPM1,
+				    isp_sspm1 & ~(1 << ISP_FREQ_VALID_OFFSET));
+	}
+
+	ratio = 2 * (HPLL_FREQ / new_freq) - 1;
+	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+	isp_sspm1 &= ~(0x1F << ISP_REQ_FREQ_OFFSET);
+	intel_mid_msgbus_write32(PUNIT_PORT, ISPSSPM1,
+				   isp_sspm1
+				   | ratio << ISP_REQ_FREQ_OFFSET
+				   | 1 << ISP_FREQ_VALID_OFFSET
+				   | 0xF << ISP_REQ_GUAR_FREQ_OFFSET);
+
+	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+	timeout = 10;
+	while ((isp_sspm1 & ISP_FREQ_VALID_MASK) && timeout) {
+		isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+		v4l2_dbg(6, dbg_level, &atomisp_dev,
+			"waiting for ISPSSPM1 valid bit to be 0.\n");
+		udelay(100);
+		timeout--;
+	}
+	if (timeout == 0) {
+		v4l2_err(&atomisp_dev, "DFS failed due to HW error.\n");
+		return -EINVAL;
+	}
+
+	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+	timeout = 10;
+	while (((isp_sspm1 >> ISP_FREQ_STAT_OFFSET) != ratio) && timeout) {
+		isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
+		v4l2_dbg(6, dbg_level, &atomisp_dev,
+				"waiting for ISPSSPM1 status bit to be 0x%x.\n",
+				 new_freq);
+		udelay(100);
+		timeout--;
+	}
+	if (timeout == 0) {
+		v4l2_warn(&atomisp_dev, "DFS target freq is rejected by HW.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+int atomisp_freq_scaling(struct atomisp_device *isp, enum atomisp_dfs_mode mode)
+{
+	unsigned int new_freq;
+	struct atomisp_freq_scaling_rule curr_rules;
+	int i, ret;
+	unsigned short fps = 0;
+	struct atomisp_sub_device *isp_subdev = NULL;
+
+	if (isp->sw_contex.power_state != ATOM_ISP_POWER_UP) {
+		v4l2_err(&atomisp_dev, "DFS cannot proceed due to no power.\n");
+		return -EINVAL;
+	}
+
+	/* ISP will run at full speed in multi stream mode */
+	if (atomisp_subdev_streaming_count(isp) > 1) {
+		new_freq = ISP_FREQ_400MHZ;
+		goto done;
+	}
+
+	if (mode == ATOMISP_DFS_MODE_LOW) {
+		new_freq = ISP_FREQ_200MHZ;
+		goto done;
+	}
+
+	if (mode == ATOMISP_DFS_MODE_MAX) {
+		new_freq = ISP_FREQ_400MHZ;
+		goto done;
+	}
+
+	/* check which stream is enabled */
+	for (i = 0; i < isp->num_of_streams; i++)
+		if (isp->isp_subdev[i].streaming ==
+		    ATOMISP_DEVICE_STREAMING_ENABLED) {
+			isp_subdev = &isp->isp_subdev[i];
+			break;
+		}
+
+	if (!isp_subdev) {
+		dev_err(isp->dev,
+			"DFS auto mode can not be done due to no streaming.\n");
+		return -EINVAL;
+	}
+
+	fps = atomisp_get_sensor_fps(isp_subdev);
+	if (fps == 0)
+		return -EINVAL;
+
+	curr_rules.width = isp_subdev->fmt[isp_subdev->capture_pad].fmt.width;
+	curr_rules.height = isp_subdev->fmt[isp_subdev->capture_pad].fmt.height;
+	curr_rules.fps = fps;
+	curr_rules.run_mode = isp_subdev->run_mode->val;
+	/*
+	 * For continuous vf mode, we need to make the capture setting applied
+	 * since preview mode, because there is no chance to do this when
+	 * starting image capture.
+	 */
+
+	if (isp_subdev->params.continuous_vf)
+		curr_rules.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE;
+
+	/* search for the target frequency by looping freq rules*/
+	for (i = 0; i < ISP_FREQ_RULE_MAX; i++) {
+		if (curr_rules.width != dfs_rules[i].width
+			&& dfs_rules[i].width != ISP_FREQ_RULE_ANY)
+			continue;
+		if (curr_rules.height != dfs_rules[i].height
+			&& dfs_rules[i].height != ISP_FREQ_RULE_ANY)
+			continue;
+		if (curr_rules.fps != dfs_rules[i].fps
+			&& dfs_rules[i].fps != ISP_FREQ_RULE_ANY)
+			continue;
+		if (curr_rules.run_mode != dfs_rules[i].run_mode
+			&& dfs_rules[i].run_mode != ISP_FREQ_RULE_ANY)
+			continue;
+		break;
+	}
+	if (i == ISP_FREQ_RULE_MAX)
+		new_freq = ISP_FREQ_320MHZ;
+	else
+		new_freq = dfs_rules[i].isp_freq;
+
+done:
+	/* workround to get isp works at 400Mhz for byt due to perf issue */
+	if (IS_MRFLD)
+		new_freq = ISP_FREQ_400MHZ;
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "DFS target frequency=%d.\n", new_freq);
+	if (new_freq == isp->sw_contex.running_freq) {
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "ignoring DFS target freq.\n");
+		return 0;
+	}
+	ret = write_target_freq_to_hw(new_freq);
+	if (!ret)
+		isp->sw_contex.running_freq = new_freq;
+	return ret;
+}
+
+static void switch_to_full_firmware(struct atomisp_device *isp)
+{
+	if (fastboot)
+	{
+                if(isp->firmware_switched == false)
+        	{
+	                /*
+		         * Function calls should implement their own locks
+                	*/
+                	release_firmware(isp->firmware);
+                	isp->firmware = NULL;
+                	isp->firmware_load_complete = false;
+                	/*Wait for the big firmware to load*/
+
+                	/* Load isp firmware from user space */
+                	/*Switch the pointers*/
+               		isp->firmware = isp->aux_firmware;
+                	isp->firmware_switched = true;
+                	if(isp->firmware != NULL)
+                	{
+	                	//Fixing the issue where insmod failed because firmware data is accessed before we even check whether firmware load completed or not
+                        	isp->css_fw.data = (void *)isp->firmware->data;
+                        	isp->css_fw.bytes = isp->firmware->size;
+                	}
+                	isp->firmware_load_complete = true;
+                	wake_up_interruptible(&atomisp_wait_queue);
+        	}
+
+        }
+}
+
+/*
+ * reset and restore ISP
+ */
+int atomisp_reset(struct atomisp_device *isp)
+{
+	/* Reset ISP by power-cycling it */
+	int ret = 0;
+	v4l2_dbg(2, dbg_level, &atomisp_dev, "%s\n",__func__);
+
+	if (isp->switch_fw_on_streamoff == true) ia_css_unload_firmware(true);
+
+	ia_css_uninit();
+	ret = pm_runtime_put_sync(isp->dev);
+
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "can not disable ISP power\n");
+	} else {
+		ret = pm_runtime_get_sync(isp->dev);
+		if (ret < 0)
+			v4l2_err(&atomisp_dev, "can not enable ISP power\n");
+	}
+
+        /*
+        *Switch firmware if flag set during ioctl
+        */
+        if (isp->switch_fw_on_streamoff == true) {
+		switch_to_full_firmware(isp);
+                v4l2_dbg(2, dbg_level, &atomisp_dev, "Firmware switch Complete. Also switched to BUFFERED_SENSOR Mode for multistreaming\n");
+                isp->switch_fw_on_streamoff = false;
+	}
+	ret = atomisp_css_init(isp);
+
+	return ret;
+}
+
+#ifdef ISP_IRQ_HELPER
+/*
+ * interrupt enable/disable functions
+ */
+static void enable_isp_irq(enum hrt_isp_css_irq irq, bool enable)
+{
+	if (enable) {
+		irq_enable_channel(IRQ0_ID, irq);
+		/*sh_css_hrt_irq_enable(irq, true, false);*/
+		switch (irq) { /*We only have sp interrupt right now*/
+		case hrt_isp_css_irq_sp:
+			/*sh_css_hrt_irq_enable_sp(true);*/
+			cnd_sp_irq_enable(SP0_ID, true);
+			break;
+		default:
+			break;
+		}
+
+	} else {
+		/*sh_css_hrt_irq_disable(irq);*/
+		irq_disable_channel(IRQ0_ID, irq);
+		switch (irq) {
+		case hrt_isp_css_irq_sp:
+			/*sh_css_hrt_irq_enable_sp(false);*/
+			cnd_sp_irq_enable(SP0_ID, false);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+/*
+ * interrupt clean function
+ */
+static void clear_isp_irq(enum hrt_isp_css_irq irq)
+{
+	irq_clear_all(IRQ0_ID);
+}
+#endif
+
+void atomisp_msi_irq_init(struct atomisp_device *isp, struct pci_dev *dev)
+{
+	u32 msg32;
+	u16 msg16;
+
+	pci_read_config_dword(dev, PCI_MSI_CAPID, &msg32);
+	msg32 |= 1 << MSI_ENABLE_BIT;
+	pci_write_config_dword(dev, PCI_MSI_CAPID, msg32);
+
+	msg32 = (1 << INTR_IER) | (1 << INTR_IIR);
+	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, msg32);
+
+	pci_read_config_word(dev, PCI_COMMAND, &msg16);
+	msg16 |= (PCI_COMMAND_MEMORY |
+		  PCI_COMMAND_MASTER |
+		  PCI_COMMAND_INTX_DISABLE);
+	pci_write_config_word(dev, PCI_COMMAND, msg16);
+}
+
+void atomisp_msi_irq_uninit(struct atomisp_device *isp, struct pci_dev *dev)
+{
+	u32 msg32;
+	u16 msg16;
+
+	pci_read_config_dword(dev, PCI_MSI_CAPID, &msg32);
+	msg32 &=  ~(1 << MSI_ENABLE_BIT);
+	pci_write_config_dword(dev, PCI_MSI_CAPID, msg32);
+
+	msg32 = 0x0;
+	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, msg32);
+
+	pci_read_config_word(dev, PCI_COMMAND, &msg16);
+	msg16 &= ~(PCI_COMMAND_MASTER |
+		   PCI_COMMAND_INTX_DISABLE);
+	pci_write_config_word(dev, PCI_COMMAND, msg16);
+}
+
+static void atomisp_sof_event(struct atomisp_sub_device *isp_subdev)
+{
+	struct v4l2_event event;
+
+	event.type = V4L2_EVENT_FRAME_SYNC;
+	event.u.frame_sync.frame_sequence = atomic_read(&isp_subdev->sof_count);
+
+	if(isp_subdev->subdev.devnode != NULL)
+		v4l2_event_queue(isp_subdev->subdev.devnode, &event);
+}
+
+static void atomisp_3a_stats_ready_event(struct atomisp_sub_device *isp_subdev)
+{
+	struct v4l2_event event = {0};
+
+	event.type = V4L2_EVENT_ATOMISP_3A_STATS_READY;
+	event.u.frame_sync.frame_sequence = atomic_read(&isp_subdev->sequence);
+
+	v4l2_event_queue(isp_subdev->subdev.devnode, &event);
+}
+
+static void print_csi_rx_errors(struct atomisp_device *isp)
+{
+	u32 infos = 0;
+
+	ia_css_rx_get_irq_info(&infos);
+
+	dev_err(isp->dev, "CSI Receiver errors:\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
+		dev_err(isp->dev, "  buffer overrun");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT)
+		dev_err(isp->dev, "  start-of-transmission error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)
+		dev_err(isp->dev, "  start-of-transmission sync error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_CONTROL)
+		dev_err(isp->dev, "  control error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)
+		dev_err(isp->dev, "  2 or more ECC errors");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_CRC)
+		dev_err(isp->dev, "  CRC mismatch");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)
+		dev_err(isp->dev, "  unknown error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)
+		dev_err(isp->dev, "  frame sync error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)
+		dev_err(isp->dev, "  frame data error");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)
+		dev_err(isp->dev, "  data timeout");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)
+		dev_err(isp->dev, "  unknown escape command entry");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
+		dev_err(isp->dev, "  line sync error");
+}
+
+/* interrupt handling function*/
+irqreturn_t atomisp_isr(int irq, void *dev)
+{
+	u32 msg_ret;
+	struct atomisp_device *isp = (struct atomisp_device *)dev;
+	unsigned int irq_infos = 0;
+	unsigned long flags;
+	int err;
+	int i, streaming;
+
+	err = ia_css_irq_translate(&irq_infos);
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "ENTER atomisp_isr, irq:0x%x\n", irq_infos);
+
+	if (err != IA_CSS_SUCCESS) {
+		v4l2_warn(&atomisp_dev, "%s:failed to translate irq (err = %d,"
+			  " infos = %d)\n", __func__, err, irq_infos);
+		v4l2_err(&atomisp_dev, "ERROR ia_css_irq_translate failed\n");
+		return IRQ_NONE;
+	}
+
+	/* Clear irq reg at PENWELL B0 */
+	pci_read_config_dword(isp->pdev, PCI_INTERRUPT_CTRL, &msg_ret);
+	msg_ret |= 1 << INTR_IIR;
+	pci_write_config_dword(isp->pdev, PCI_INTERRUPT_CTRL, msg_ret);
+
+	spin_lock_irqsave(&isp->lock, flags);
+
+	for (i = 0, streaming = 0; i < isp->num_of_streams; i++)
+		streaming += isp->isp_subdev[i].streaming ==
+		    ATOMISP_DEVICE_STREAMING_ENABLED;
+	if (!streaming)
+ 		goto out_nowake;
+
+	for(i = 0; i < isp->num_of_streams; i++) {
+		struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[i];
+
+		if (irq_infos & IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF) {
+			atomic_inc(&isp_subdev->sof_count);
+			atomisp_sof_event(isp_subdev);
+
+		/* If sequence_temp and sequence are the same
+		 * there where no frames lost so we can increase sequence_temp.
+		 * If not then processing of frame is still in progress and
+		 * driver needs to keep old sequence_temp value.
+		 * NOTE: There is assumption here that ISP will not start
+		 * processing next frame from sensor before old one is
+		 * completely done. */
+			if (atomic_read(&isp_subdev->sequence) == atomic_read(
+						&isp_subdev->sequence_temp))
+				atomic_set(&isp_subdev->sequence_temp,
+						atomic_read(&isp_subdev->sof_count));
+
+			/* signal streamon after delayed init is done */
+			if (isp_subdev->delayed_init == ATOMISP_DELAYED_INIT_WORK_DONE) {
+				isp_subdev->delayed_init = ATOMISP_DELAYED_INIT_DONE;
+				complete(&isp_subdev->init_done);
+			}
+		}
+
+		if (irq_infos & IA_CSS_IRQ_INFO_EVENTS_READY)
+			atomic_set(&isp_subdev->sequence,
+					atomic_read(&isp_subdev->sequence_temp));
+	}
+
+	if ((irq_infos & IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR) ||
+		(irq_infos & IA_CSS_IRQ_INFO_IF_ERROR)) {
+		/* handle mipi receiver error */
+		u32 rx_infos;
+
+		print_csi_rx_errors(isp);
+		ia_css_rx_get_irq_info(&rx_infos);
+		ia_css_rx_clear_irq_info(rx_infos);
+		/* TODO: handle SH_CSS_RX_IRQ_INFO_BUFFER_OVERRUN */
+	}
+
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	return IRQ_WAKE_THREAD;
+
+out_nowake:
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Background:
+ * The IUNITPHY register CSI_CONTROL bit definition was changed since PNW C0.
+ * For PNW A0 and B0, CSI4_TERM_EN_COUNT is bit 23:20 (4 bits).
+ * Starting from PWN C0, including all CLV and CLV+ steppings,
+ * CSI4_TERM_EN_COUNT is bit 30:24 (7 bits).
+ *
+ * ------------------------------------------
+ * Silicon	Stepping	PCI revision
+ * Penwell	A0		0x00
+ * Penwell	B0		0x04
+ * Penwell	C0		0x06
+ * Penwell	D0		0x06
+ * Penwell	D1		0x06
+ * Penwell	D2		0x06
+ * Cloverview	A0		0x06
+ * Cloverview	B0		0x05
+ * Cloverview	C0		0x04
+ * Cloverview+	A0		0x08
+ * Cloverview+	B0		0x0C
+ *
+ */
+
+#define TERM_EN_COUNT_1LANE_OFFSET		16	/* bit 22:16 */
+#define TERM_EN_COUNT_1LANE_MASK		0x7f0000
+#define TERM_EN_COUNT_4LANE_OFFSET		24	/* bit 30:24 */
+#define TERM_EN_COUNT_4LANE_MASK		0x7f000000
+#define TERM_EN_COUNT_4LANE_PWN_B0_OFFSET	20	/* bit 23:20 */
+#define TERM_EN_COUNT_4LANE_PWN_B0_MASK		0xf00000
+
+void atomisp_set_term_en_count(struct atomisp_device *isp)
+{
+	uint32_t val;
+	int pwn_b0 = 0;
+
+	/* For MRFLD, there is no Tescape-clock cycles control. */
+	if (IS_MRFLD)
+		return;
+
+	/*if (isp->pdev->device == 0x0148 && isp->pdev->revision < 0x6 &&
+		IS_MRFLD)
+		pwn_b0 = 1;*/
+
+	val = intel_mid_msgbus_read32(MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL);
+
+	/* set TERM_EN_COUNT_1LANE to 0xf */
+	val &= ~TERM_EN_COUNT_1LANE_MASK;
+	val |= 0xf << TERM_EN_COUNT_1LANE_OFFSET;
+
+	/* set TERM_EN_COUNT_4LANE to 0xf */
+	val &= pwn_b0 ? ~TERM_EN_COUNT_4LANE_PWN_B0_MASK :
+				~TERM_EN_COUNT_4LANE_MASK;
+	val |= 0xf << (pwn_b0 ? TERM_EN_COUNT_4LANE_PWN_B0_OFFSET :
+				TERM_EN_COUNT_4LANE_OFFSET);
+
+	intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL, val);
+}
+
+void atomisp_clear_css_buffer_counters(struct atomisp_sub_device *isp_subdev)
+{
+	memset(isp_subdev->s3a_bufs_in_css, 0, sizeof(isp_subdev->s3a_bufs_in_css));
+	isp_subdev->dis_bufs_in_css = 0;
+	isp_subdev->video_out_capture.buffers_in_css = 0;
+	isp_subdev->video_out_vf.buffers_in_css = 0;
+	isp_subdev->video_out_preview.buffers_in_css = 0;
+}
+
+void atomisp_clear_frame_counters(struct atomisp_sub_device *isp_subdev)
+{
+        isp_subdev->video_out_capture.field_sequence = 0;
+        isp_subdev->video_out_vf.field_sequence = 0;
+        isp_subdev->video_out_preview.field_sequence = 0;
+        isp_subdev->video_out_capture.previous_frame_exp_id = 0;
+        isp_subdev->video_out_vf.previous_frame_exp_id = 0;
+        isp_subdev->video_out_preview.previous_frame_exp_id = 0;
+}
+
+/* return total number of buffers in css */
+static int __buffers_in_css(struct atomisp_sub_device *isp_subdev)
+{
+	int i;
+	int sum = 0;
+
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+		sum += isp_subdev->s3a_bufs_in_css[i];
+
+	sum += isp_subdev->dis_bufs_in_css;
+	sum += isp_subdev->video_out_capture.buffers_in_css;
+	sum += isp_subdev->video_out_vf.buffers_in_css;
+	sum += isp_subdev->video_out_preview.buffers_in_css;
+
+	return sum;
+}
+
+bool atomisp_buffers_queued(struct atomisp_sub_device *isp_subdev)
+{
+	return isp_subdev->video_out_capture.buffers_in_css ||
+		isp_subdev->video_out_vf.buffers_in_css ||
+		isp_subdev->video_out_preview.buffers_in_css ?
+		    true : false;
+}
+
+/* 0x100000 is the start of dmem inside SP */
+#define SP_DMEM_BASE	0x100000
+#if 0
+void dump_sp_dmem(unsigned int addr, unsigned int size)
+{
+	unsigned int data = 0;
+	unsigned int size32 = (size + (sizeof(u32) - 1)) / sizeof(u32);
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "atomisp_io_base:0x%x\n",(unsigned int)atomisp_io_base);
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "%s, addr:0x%x, size: %d, size32: %d\n",
+		 __func__, addr, size, size32);
+	if (size32 * 4 + addr > 0x4000) {
+		v4l2_err(&atomisp_dev,
+			 "illegal size (%d) or addr (0x%x)\n",
+			 size32, addr);
+		return;
+	}
+	addr += SP_DMEM_BASE;
+	do {
+		data = _hrt_master_port_uload_32(addr);
+
+		/* printk/dtrace */
+#if 1
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "%s, \t [0x%x]:0x%x\n",
+			 __func__, addr, data);
+#else
+		atomisp_dtrace(2,"%s, \t [0x%x]:0x%x\n",
+				__func__, addr, data);
+#endif
+		addr += sizeof(unsigned int);
+		size32 -= 1;
+	} while(size32 > 0);
+}
+#endif
+
+static bool is_NTSC_format(struct ia_css_frame *frame)
+{
+	return frame->info.res.height==240?true:false;
+}
+
+static enum v4l2_field get_field_type(struct ia_css_frame *frame)
+{
+	if(frame->frame_nr == 1)
+		return is_NTSC_format(frame)?V4L2_FIELD_BOTTOM:V4L2_FIELD_TOP;
+	else if(frame->frame_nr == 2)
+		return is_NTSC_format(frame)?V4L2_FIELD_TOP:V4L2_FIELD_BOTTOM;
+	return V4L2_FIELD_NONE;
+}
+
+static struct atomisp_vb2 *atomisp_css_frame_to_vb2(
+	struct atomisp_video_pipe *pipe, struct ia_css_frame *frame)
+{
+	struct atomisp_vb2 *buf;
+	int i;
+
+	for (i = 0; pipe->vb2q.bufs[i]; i++) {
+		buf = container_of(pipe->vb2q.bufs[i], struct atomisp_vb2, vb);
+		if (buf->cssframe == frame){
+			if (pipe->pix.field ==V4L2_FIELD_ALTERNATE){
+				buf->vb.v4l2_buf.field = get_field_type(frame);
+				if ((buf->vb.v4l2_buf.field == V4L2_FIELD_TOP && !is_NTSC_format(frame)) || (buf->vb.v4l2_buf.field == V4L2_FIELD_BOTTOM && is_NTSC_format(frame))){
+                                                buf->vb.v4l2_buf.sequence = ++pipe->field_sequence;
+				}
+				else if ((buf->vb.v4l2_buf.field == V4L2_FIELD_BOTTOM && !is_NTSC_format(frame)) || (buf->vb.v4l2_buf.field == V4L2_FIELD_TOP && is_NTSC_format(frame))){
+					int exp_id_diff = frame->exp_id - pipe->previous_frame_exp_id - 1;
+					if( exp_id_diff == 0 || exp_id_diff == -EXP_ID_WRAPAROUND)
+						buf->vb.v4l2_buf.sequence = pipe->field_sequence;
+					else
+						buf->vb.v4l2_buf.sequence = pipe->field_sequence + exp_id_diff>0?exp_id_diff:(exp_id_diff + EXP_ID_WRAPAROUND);
+				}
+				pipe->previous_frame_exp_id = frame->exp_id;
+				v4l2_dbg(4, dbg_level, &atomisp_dev, "Buffer sequence = %d, Buffer exp_id = %d, Buffer field = %d\n", buf->vb.v4l2_buf.sequence, frame->exp_id, buf->vb.v4l2_buf.field);
+			}
+			return buf;
+		}
+	}
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA ERROR return NULL from atomisp_css_frame_to_vb2\n");
+	return NULL;
+}
+
+static void get_buf_timestamp(struct timeval *tv)
+{
+	/* This function is duplicated from v4l2_get_timestamp */
+	struct timespec ts;
+	ktime_get_ts(&ts);
+	tv->tv_sec = ts.tv_sec;
+	tv->tv_usec = ts.tv_nsec / NSEC_PER_USEC;
+}
+
+/* Returns queued buffers back to video-core */
+void atomisp_flush_bufs_and_wakeup(struct atomisp_sub_device *isp_subdev)
+{
+}
+
+
+/* find atomisp_video_pipe with css pipe id, buffer type and atomisp run_mode */
+static struct atomisp_video_pipe *__atomisp_get_pipe(struct atomisp_sub_device *isp_subdev,
+		enum ia_css_pipe_id css_pipe_id,
+		enum ia_css_buffer_type buf_type)
+{
+	/* video is same in online as in continuouscapture mode */
+	if (!isp_subdev->enable_vfpp->val) {
+		return &isp_subdev->video_out_capture;
+	} else if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+		if (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)
+			return &isp_subdev->video_out_capture;
+		else if(buf_type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME)
+	        return &isp_subdev->video_out_vf;
+		return &isp_subdev->video_out_preview;
+	} else if (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME) {
+		if (css_pipe_id == IA_CSS_PIPE_ID_PREVIEW)
+			return &isp_subdev->video_out_preview;
+		return &isp_subdev->video_out_capture;
+	/* statistic buffers are needed only in css capture & preview pipes */
+	} else if (buf_type == IA_CSS_BUFFER_TYPE_3A_STATISTICS ||
+		   buf_type == IA_CSS_BUFFER_TYPE_DIS_STATISTICS) {
+		if (css_pipe_id == IA_CSS_PIPE_ID_PREVIEW)
+			return &isp_subdev->video_out_preview;
+		return &isp_subdev->video_out_capture;
+	}
+	return &isp_subdev->video_out_vf;
+}
+
+static void atomisp_buf_done(struct atomisp_sub_device *isp_subdev, int error,
+			enum ia_css_buffer_type buf_type,
+			enum ia_css_pipe_id css_pipe_id, bool q_buffers)
+{
+	struct atomisp_vb2 *vb2 = NULL;
+	struct atomisp_video_pipe *pipe = NULL;
+	struct ia_css_buffer buffer;
+	bool requeue = false;
+	int err, pipe_index;
+	struct ia_css_frame *frame = NULL;
+	struct atomisp_device *isp = isp_subdev->isp;
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA ENTER atomisp_buf_done\n");
+
+	if (buf_type != IA_CSS_BUFFER_TYPE_3A_STATISTICS &&
+	    buf_type != IA_CSS_BUFFER_TYPE_DIS_STATISTICS &&
+	    buf_type != IA_CSS_BUFFER_TYPE_OUTPUT_FRAME &&
+	    buf_type != IA_CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME &&
+	    buf_type != IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME) {
+		v4l2_err(&atomisp_dev,
+			"%s, unsupported buffer type: %d\n",
+			__func__, buf_type);
+		return;
+	}
+
+	memset(&buffer, 0, sizeof(struct ia_css_buffer));
+	buffer.type = buf_type;
+	pipe_index = (unsigned int)css_pipe_id;
+	err = ia_css_pipe_dequeue_buffer(isp_subdev->css2_basis.pipes[pipe_index],
+					&buffer);
+	if (err){
+		v4l2_err(&atomisp_dev,
+			"sh_css_dequeue_buffer failed: 0x%x\n",
+			err);
+		return;
+	}
+
+	/* need to know the atomisp pipe for frame buffers */
+	pipe = __atomisp_get_pipe(isp_subdev, css_pipe_id,
+				  buffer.type);
+	if (pipe == NULL) {
+		dev_err(isp->dev, "error getting atomisp pipe\n");
+		return;
+	}
+
+	switch (buf_type) {
+	case IA_CSS_BUFFER_TYPE_3A_STATISTICS:
+		/* ignore error in case of 3a statistics for now */
+		if (isp->sw_contex.invalid_s3a) {
+			requeue = true;
+			isp->sw_contex.invalid_s3a = 0;
+			break;
+		}
+		/* update the 3A data to ISP context */
+		if (isp_subdev->params.s3a_user_stat &&
+			isp_subdev->params.s3a_output_bytes && !error) {
+			/* To avoid racing with atomisp_3a_stat() */
+			ia_css_get_3a_statistics(isp_subdev->params.s3a_user_stat,
+						 buffer.data.stats_3a);
+			isp_subdev->params.s3a_buf_data_valid = true;
+		}
+		isp_subdev->s3a_bufs_in_css[css_pipe_id]--;
+		atomisp_3a_stats_ready_event(isp_subdev);
+		break;
+	case IA_CSS_BUFFER_TYPE_DIS_STATISTICS:
+		/* ignore error in case of dis statistics for now */
+		if (isp->sw_contex.invalid_dis) {
+			requeue = true;
+			isp->sw_contex.invalid_dis = 0;
+			break;
+		}
+		if (isp_subdev->params.dvs_stat && !error) {
+			/* To avoid racing with atomisp_get_dis_stat()*/
+			ia_css_get_dvs_statistics(isp_subdev->params.dvs_stat,
+						  buffer.data.stats_dvs);
+
+			isp_subdev->params.dvs_proj_data_valid = true;
+		}
+		isp_subdev->dis_bufs_in_css--;
+		break;
+	case IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
+		if (!buffer.data.frame->valid) {
+			error = true;
+			/*isp->sw_contex.invalid_vf_frame = 0;*/
+			v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "%s css has marked this vf frame as invalid\n",
+				 __func__);
+		}
+
+		pipe->buffers_in_css--;
+		frame = buffer.data.frame;
+		if (isp_subdev->params.flash_state == ATOMISP_FLASH_ONGOING) {
+			if (frame->flash_state
+			    == IA_CSS_FRAME_FLASH_STATE_PARTIAL)
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s thumb partially flashed\n", __func__);
+			else if (frame->flash_state
+				 == IA_CSS_FRAME_FLASH_STATE_FULL)
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s thumb completely flashed\n", __func__);
+			else
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s thumb no flash in this frame\n", __func__);
+		}
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME, about to call atomisp_css_frame_to_vb2\n");
+		vb2 = atomisp_css_frame_to_vb2(pipe, buffer.data.frame);
+		if (!vb2)
+			v4l2_dbg(4, dbg_level, &atomisp_dev, "ERROR dequeued frame unknown!");
+		break;
+	case IA_CSS_BUFFER_TYPE_OUTPUT_FRAME:
+		if (!buffer.data.frame->valid) {
+			error = true;
+			/*isp->sw_contex.invalid_frame = 0;*/
+			v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "%s css has marked this frame as invalid\n",
+				 __func__);
+		}
+		pipe->buffers_in_css--;
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA CSS_BUFFER_TYPE_OUTPUT, buffers_in_css--=%d, about to call atomisp_css_frame_to_vb2\n", pipe->buffers_in_css);
+		vb2 = atomisp_css_frame_to_vb2(pipe, buffer.data.frame);
+		frame = buffer.data.frame;
+		if (!vb2) {
+			v4l2_dbg(4, dbg_level, &atomisp_dev, "ERROR dequeued output frame NULL!\n");
+			break;
+		}
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "setting isp->frame_status to OK\n");
+		if (isp_subdev->params.flash_state == ATOMISP_FLASH_ONGOING) {
+			if (frame->flash_state
+			    == IA_CSS_FRAME_FLASH_STATE_PARTIAL) {
+				isp_subdev->frame_status[vb2->vb.v4l2_buf.index] =
+				    ATOMISP_FRAME_STATUS_FLASH_PARTIAL;
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s partially flashed\n",
+					 __func__);
+			} else if (frame->flash_state
+				   == IA_CSS_FRAME_FLASH_STATE_FULL) {
+				isp_subdev->frame_status[vb2->vb.v4l2_buf.index] =
+				    ATOMISP_FRAME_STATUS_FLASH_EXPOSED;
+				isp_subdev->params.num_flash_frames--;
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s completely flashed\n",
+					 __func__);
+			} else {
+				isp_subdev->frame_status[vb2->vb.v4l2_buf.index] =
+				    ATOMISP_FRAME_STATUS_OK;
+				v4l2_dbg(3, dbg_level, &atomisp_dev,
+					 "%s no flash in this frame\n",
+					 __func__);
+			}
+
+			/* Check if flashing sequence is done */
+			if (isp_subdev->frame_status[vb2->vb.v4l2_buf.index] == ATOMISP_FRAME_STATUS_FLASH_EXPOSED)
+				isp_subdev->params.flash_state = ATOMISP_FLASH_DONE;
+		} else {
+			isp_subdev->frame_status[vb2->vb.v4l2_buf.index] = ATOMISP_FRAME_STATUS_OK;
+		}
+
+		if (!vb2)
+			v4l2_err(&atomisp_dev, "dequeued frame unknown!\n");
+		else
+			isp_subdev->params.last_frame_status = isp_subdev->frame_status[vb2->vb.v4l2_buf.index];
+		break;
+	default:
+		break;
+	}
+
+	if (vb2) {
+		get_buf_timestamp(&vb2->vb.v4l2_buf.timestamp);
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA calling vb2_buffer_done, buf index=%d, fd=%d, VB2_BUF_STATE=%d (should be active=3), vaddr=%X, length=%u\n", vb2->vb.v4l2_buf.index,vb2->vb.v4l2_buf.m.fd, vb2->vb.state, vb2->cssframe->data, vb2->cssframe->data_bytes);
+		vb2_buffer_done(&vb2->vb, VB2_BUF_STATE_DONE);
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA Finished, now VB2_BUF_STATE=%d (should be DONE=4)\n", vb2->vb.state);
+	}	else {
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "ERROR atomisp_buf_done vb2 is NULL\n");
+	}
+
+	/*
+	 * Requeue should only be done for 3a and dis buffers.
+	 * Queue/dequeue order will change if driver recycles image buffers.
+	 */
+	if (requeue) {
+		err = ia_css_pipe_enqueue_buffer(isp_subdev->css2_basis.pipes[pipe_index], &buffer);
+		if (err)
+			v4l2_err(&atomisp_dev,"%s, q to css fails: %d\n",
+					__func__, err);
+		return;
+	}
+	if (!error && q_buffers){
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA End of atomisp_buf_done, About to call atomisp_qbuffers_to_css\n");
+		atomisp_qbuffers_to_css(isp_subdev, false);
+	}
+}
+
+void atomisp_delayed_init_work(struct work_struct *work)
+{
+	struct atomisp_sub_device *isp_subdev = container_of(work,
+						  struct atomisp_sub_device,
+						  delayed_init_work);
+	isp_subdev->delayed_init = ATOMISP_DELAYED_INIT_DONE;
+}
+
+static void __atomisp_css_recover(struct atomisp_device *isp)
+{
+	enum ia_css_pipe_id css_pipe_id;
+	struct atomisp_sub_device *isp_subdev;
+	int i, ret;
+
+		if (!isp->sw_contex.file_input)
+			ia_css_irq_enable(
+				IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF, false);
+
+		for (i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->delayed_init == ATOMISP_DELAYED_INIT_QUEUED)
+				cancel_work_sync(&isp_subdev->delayed_init_work);
+
+			complete(&isp_subdev->init_done);
+			isp_subdev->delayed_init = ATOMISP_DELAYED_INIT_NOT_QUEUED;
+
+			css_pipe_id = atomisp_get_css_pipe_id(isp_subdev);
+
+			if (isp_subdev->streaming ==
+			    ATOMISP_DEVICE_STREAMING_ENABLED) {
+				isp_subdev->streaming =
+				    ATOMISP_DEVICE_STREAMING_STOPPING;
+
+				if (ia_css_stop(isp_subdev, true))
+					v4l2_warn(&atomisp_dev,
+						  "stop css failed, reset may"
+						  "be failed.\n");
+
+				/* stream off sensor */
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].
+					camera, video, s_stream, 0);
+				if (ret)
+					dev_warn(isp->dev,
+						 "can't stop streaming"
+						 "on sensor!\n");
+
+				atomisp_clear_css_buffer_counters(isp_subdev);
+				isp_subdev->streaming =
+				    ATOMISP_DEVICE_STREAMING_STARTING;
+			}
+		}
+
+		atomisp_acc_unload_extensions(isp);
+
+		/* clear irq */
+		/*enable_isp_irq(hrt_isp_css_irq_sp, false);*/
+		/*clear_isp_irq(hrt_isp_css_irq_sp);*/
+
+		/* reset ISP and restore its state */
+		isp->isp_timeout = true;
+		atomisp_reset(isp);
+		isp->isp_timeout = false;
+
+		if (atomisp_acc_load_extensions(isp) < 0)
+			dev_err(isp->dev, "acc extension failed to reload\n");
+
+
+		for( i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming !=
+			    ATOMISP_DEVICE_STREAMING_STARTING)
+					continue;
+
+				ia_css_input_set_mode(isp_subdev,
+				      get_input_mode(isp->inputs[isp_subdev->input_curr].type, isp));
+
+				if (ia_css_start(isp_subdev, true) !=
+				    IA_CSS_SUCCESS)
+					v4l2_warn(&atomisp_dev,
+					  "re-start css failed, reset may be"
+					  "failed.\n");
+				else
+					isp_subdev->streaming =
+					    ATOMISP_DEVICE_STREAMING_ENABLED;
+		}
+
+		if (!isp->sw_contex.file_input) {
+			atomisp_control_irq_sof(isp);
+
+			atomisp_set_term_en_count(isp);
+
+			if (IS_MRFLD &&
+			atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_AUTO) < 0)
+				dev_dbg(isp->dev, "dfs failed!\n");
+		} else {
+			if (IS_MRFLD &&
+			atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_MAX) < 0)
+				dev_dbg(isp->dev, "dfs failed!\n");
+		}
+
+		for (i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming !=
+			    ATOMISP_DEVICE_STREAMING_ENABLED)
+					continue;
+
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].
+					camera, video, s_stream, 1);
+				if (ret)
+					dev_warn(isp->dev,
+						 "can't start streaming on"
+						 "sensor!\n");
+				/*
+				 * FIXME!
+				 * only one stream on continous mode now
+				 */
+				if (isp_subdev->params.continuous_vf &&
+				 isp_subdev->run_mode->val !=
+				    ATOMISP_RUN_MODE_VIDEO &&
+				    isp_subdev->delayed_init ==
+				    ATOMISP_DELAYED_INIT_NOT_QUEUED) {
+					INIT_COMPLETION(isp_subdev->init_done);
+					isp_subdev->delayed_init =
+					    ATOMISP_DELAYED_INIT_QUEUED;
+					queue_work(isp_subdev->delayed_init_workq,
+						   &isp_subdev->delayed_init_work);
+				}
+				/*
+				 * dequeueing buffers is not needed. CSS will
+				 * recycle buffers that it has.
+				 */
+				atomisp_flush_bufs_and_wakeup(isp_subdev);
+			}
+			dev_err(isp->dev, "timeout recovery handling done\n");
+}
+
+void atomisp_wdt_work(struct work_struct *work)
+{
+	struct atomisp_device *isp = container_of(work, struct atomisp_device,
+						  wdt_work);
+	char debug_context[64];
+	int i;
+	struct atomisp_sub_device *isp_subdev = NULL;
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA WARNING: timer not reset, entering atomisp_wdt_work\n");
+
+	dev_err(isp->dev, "timeout %d of %d\n",
+		atomic_read(&isp->wdt_count) + 1,
+		ATOMISP_ISP_MAX_TIMEOUT_COUNT);
+
+	mutex_lock(&isp->mutex);
+	if (!atomisp_subdev_streaming_count(isp)) {
+		mutex_unlock(&isp->mutex);
+		return;
+	}
+
+	switch (atomic_inc_return(&isp->wdt_count)) {
+	case ATOMISP_ISP_MAX_TIMEOUT_COUNT:
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "atomisp_wdt_work: ATOMISP_ISP_MAX_TIMEOUT_COUNT\n");
+		for (i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming ==
+			    ATOMISP_DEVICE_STREAMING_ENABLED) {
+				atomisp_clear_css_buffer_counters(isp_subdev);
+				atomisp_flush_bufs_and_wakeup(isp_subdev);
+				complete(&isp_subdev->init_done);
+			}
+		}
+
+		atomic_set(&isp->wdt_count, 0);
+		isp->isp_fatal_error = true;
+
+		mutex_unlock(&isp->mutex);
+		return;
+	default:
+		ia_css_debug_dump_sp_sw_debug_info();
+		ia_css_debug_dump_debug_info(debug_context);
+		for (i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming ==
+		    		ATOMISP_DEVICE_STREAMING_ENABLED) {
+				dev_err(isp->dev, "%s, pipe[%d] buffers in css: %d\n", __func__,
+					isp_subdev->video_out_capture.pipe_type,
+					isp_subdev->video_out_capture.buffers_in_css);
+				dev_err(isp->dev, "%s, pipe[%d] buffers in css: %d\n", __func__,
+					isp_subdev->video_out_vf.pipe_type,
+					isp_subdev->video_out_vf.buffers_in_css);
+				dev_err(isp->dev, "%s, pipe[%d] buffers in css: %d\n", __func__,
+					isp_subdev->video_out_preview.pipe_type,
+					isp_subdev->video_out_preview.buffers_in_css);
+				dev_err(isp->dev, "%s, s3a buffers in css preview pipe: %d\n",
+					__func__,
+					isp_subdev->s3a_bufs_in_css[IA_CSS_PIPE_ID_PREVIEW]);
+				dev_err(isp->dev, "%s, s3a buffers in css capture pipe: %d\n",
+					__func__,
+					isp_subdev->s3a_bufs_in_css[IA_CSS_PIPE_ID_CAPTURE]);
+				dev_err(isp->dev, "%s, s3a buffers in css video pipe: %d\n",
+					__func__, isp_subdev->s3a_bufs_in_css[IA_CSS_PIPE_ID_VIDEO]);
+				dev_err(isp->dev, "%s, dis buffers in css: %d\n",
+					__func__, isp_subdev->dis_bufs_in_css);
+			}
+		}
+		ia_css_debug_dump_sp_state();
+		ia_css_debug_dump_isp_state();
+	}
+
+	__atomisp_css_recover(isp);
+
+	mutex_unlock(&isp->mutex);
+}
+
+void atomisp_css_flush(struct atomisp_device *isp)
+{
+        if (!atomisp_subdev_streaming_count(isp))
+                return;
+
+        /* Disable wdt */
+        del_timer_sync(&isp->wdt);
+        cancel_work_sync(&isp->wdt_work);
+
+        /* Start recover */
+        __atomisp_css_recover(isp);
+
+        /* Restore wdt */
+        if (isp->sw_contex.file_input)
+                isp->wdt_duration = ATOMISP_ISP_FILE_TIMEOUT_DURATION;
+        else
+                isp->wdt_duration = ATOMISP_ISP_TIMEOUT_DURATION;
+
+        mod_timer(&isp->wdt, jiffies + isp->wdt_duration);
+
+        dev_dbg(isp->dev, "atomisp css flush done\n");
+}
+
+void atomisp_wdt(unsigned long isp_addr)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)isp_addr;
+
+	queue_work(isp->wdt_work_queue, &isp->wdt_work);
+}
+
+void atomisp_setup_flash(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (isp_subdev->params.flash_state != ATOMISP_FLASH_REQUESTED &&
+	    isp_subdev->params.flash_state != ATOMISP_FLASH_DONE)
+		return;
+
+	if (isp_subdev->params.num_flash_frames) {
+		struct v4l2_control ctrl;
+
+		/* make sure the timeout is set before setting flash mode */
+		ctrl.id = V4L2_CID_FLASH_TIMEOUT;
+		ctrl.value = FLASH_TIMEOUT;
+
+		if (v4l2_subdev_call(isp->flash, core, s_ctrl, &ctrl)) {
+			v4l2_err(&atomisp_dev, "flash timeout configure failed\n");
+			return;
+		}
+		ia_css_stream_request_flash(isp_subdev->css2_basis.stream);
+		isp_subdev->params.flash_state = ATOMISP_FLASH_ONGOING;
+	} else {
+		/* Flashing all frames is done */
+		isp_subdev->params.flash_state = ATOMISP_FLASH_IDLE;
+	}
+}
+
+//DIFFERENT - EXTRA
+static struct atomisp_sub_device *__get_atomisp_subdev(
+					struct ia_css_pipe *css_pipe,
+					struct atomisp_device *isp) {
+	int i, j;
+	struct atomisp_sub_device *isp_subdev;
+
+	for (i = 0; i < isp->num_of_streams; i++) {
+		isp_subdev = &isp->isp_subdev[i];
+		if (isp_subdev->streaming !=
+		    ATOMISP_DEVICE_STREAMING_DISABLED) {
+			for (j = 0; j < IA_CSS_PIPE_ID_NUM; j++)
+				if (isp_subdev->css2_basis.pipes[j] &&
+				    isp_subdev->css2_basis.pipes[j] == css_pipe)
+					return isp_subdev;
+		}
+	}
+
+	return NULL;
+}
+
+irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr)
+{
+	struct atomisp_device *isp = isp_ptr;
+	struct atomisp_css_event current_event;
+	unsigned long flags;
+	bool frame_done_found[isp->num_of_streams];
+	bool css_pipe_done[isp->num_of_streams];
+	bool reset_wdt_timer = false;
+	struct atomisp_sub_device *isp_subdev;
+	int i, streaming;
+	DEFINE_KFIFO(events, struct atomisp_css_event, ATOMISP_CSS_EVENTS_MAX);
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "ENTER DMA atomisp_isr_thread\n");
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s\n", __func__);
+	memset(frame_done_found, 0, sizeof(frame_done_found));
+	memset(css_pipe_done, 0, sizeof(css_pipe_done));
+	mutex_lock(&isp->mutex);
+
+	spin_lock_irqsave(&isp->lock, flags);
+	for (i = 0, streaming = 0; i < isp->num_of_streams; i++)
+		streaming += isp->isp_subdev[i].streaming ==
+		    ATOMISP_DEVICE_STREAMING_ENABLED;
+	spin_unlock_irqrestore(&isp->lock, flags);
+	if (!streaming)
+		goto out;
+
+	while (ia_css_dequeue_event(&current_event.event)
+				 == IA_CSS_SUCCESS) {
+		enum  ia_css_pipe_id temp_id;
+		ia_css_temp_pipe_to_pipe_id(current_event.event.pipe, &temp_id);
+		isp_subdev = __get_atomisp_subdev(current_event.event.pipe, isp);
+
+		if (!isp_subdev) {
+			/* EOF Event does not have the css_pipe returned */
+			if (current_event.event.type !=
+			    IA_CSS_EVENT_TYPE_PORT_EOF) {
+				v4l2_dbg(6, dbg_level, &atomisp_dev,
+				         "%s:no subdev. event:%d\n", __func__,
+		                         current_event.event.type);
+				goto out;
+			}
+		}
+
+		switch (current_event.event.type) {
+		case IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE:
+			v4l2_dbg(6, dbg_level, &atomisp_dev, "IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE, frame_done_found=true, about to call atomisp_buf_done\n");
+			frame_done_found[isp_subdev->index] = true;
+			atomisp_buf_done(isp_subdev, 0,
+					 IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
+					 temp_id,
+					 true);
+			reset_wdt_timer = true;
+			break;
+		case IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE:
+			atomisp_buf_done(isp_subdev, 0,
+					 IA_CSS_BUFFER_TYPE_3A_STATISTICS,
+					 temp_id,
+					 css_pipe_done[isp_subdev->index]);
+			break;
+		case IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE:
+			atomisp_buf_done(isp_subdev, 0,
+					 IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME,
+					 temp_id,
+					 true);
+			reset_wdt_timer = true;
+			break;
+		case IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE:
+			atomisp_buf_done(isp_subdev, 0,
+					 IA_CSS_BUFFER_TYPE_DIS_STATISTICS,
+					 temp_id,
+					 css_pipe_done[isp_subdev->index]);
+			break;
+		case IA_CSS_EVENT_TYPE_PIPELINE_DONE:
+			css_pipe_done[isp_subdev->index] = true;
+		case IA_CSS_EVENT_TYPE_PORT_EOF:
+		case IA_CSS_EVENT_TYPE_FRAME_TAGGED:
+			break;
+		default:
+			dev_err(isp->dev, "unhandled css stored event: 0x%x\n",
+					current_event.event.type);
+			break;
+		}
+	}
+
+	/*
+	 * css2.0 bug: no buffer flush mechanism for css buffer queue, but
+	 * need to ensure there is no buffer in css after stream off
+	 *
+	 * before calling ia_css_stream_stop(), we will wait all the buffers are
+	 * dequeued from css, then call ia_css_stream_destroy()
+	 */
+	for (i = 0; i < isp->num_of_streams; i++) {
+		isp_subdev = &isp->isp_subdev[i];
+		if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STOPPING
+		    && !__buffers_in_css(isp_subdev))
+			complete(&isp_subdev->buf_done);
+	}
+
+	for (i = 0; i < isp->num_of_streams; i++) {
+		isp_subdev = &isp->isp_subdev[i];
+		if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED) {
+			if (frame_done_found[isp_subdev->index] &&
+			    isp_subdev->params.css_update_params_needed) {
+				atomisp_css_update_isp_params(isp_subdev);
+				isp_subdev->params.css_update_params_needed = false;
+				frame_done_found[isp_subdev->index] = false;
+			}
+
+			atomisp_setup_flash(isp_subdev);
+			/*
+		 	* If there are no buffers queued
+		 	* then delete wdt timer.
+		 	*/
+			if (!atomisp_buffers_queued(isp_subdev)) {
+				del_timer(&isp->wdt);
+			} else {
+				/* SOF irq should not reset wdt timer. */
+				if (reset_wdt_timer) {
+					mod_timer(&isp->wdt, jiffies +
+					  isp->wdt_duration);
+					atomic_set(&isp->wdt_count, 0);
+				}
+			}
+		}
+	}
+
+out:
+	mutex_unlock(&isp->mutex);
+
+	/* s_stream will be called later outside of this thread */
+	/* Calling s_stream now causes RGB FIFO to fail */
+	if(!isp->sw_contex.file_input){
+		for (i = 0; i < isp->num_of_streams; i++) {
+			isp_subdev = &isp->isp_subdev[i];
+			if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED
+				&& css_pipe_done[isp_subdev->index]
+				&& isp->sw_contex.file_input)
+				v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].
+						 camera, video, s_stream, 1);
+ 		}
+	}
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * utils for buffer allocation/free
+ */
+
+int atomisp_get_frame_pgnr(const struct ia_css_frame *frame, u32 *p_pgnr)
+{
+	if (!frame) {
+		v4l2_err(&atomisp_dev,
+			    "%s: NULL frame pointer ERROR.\n",
+			    __func__);
+		return -EINVAL;
+	}
+
+	*p_pgnr = DIV_ROUND_UP(frame->data_bytes, PAGE_SIZE);
+	return 0;
+}
+
+/*
+ * Get internal fmt according to V4L2 fmt
+ */
+static enum ia_css_frame_format v4l2_fmt_to_sh_fmt(u32 fmt)
+{
+	switch (fmt) {
+	case V4L2_PIX_FMT_YUV420:
+		return IA_CSS_FRAME_FORMAT_YUV420;
+	case V4L2_PIX_FMT_YVU420:
+		return IA_CSS_FRAME_FORMAT_YV12;
+	case V4L2_PIX_FMT_YUV422P:
+		return IA_CSS_FRAME_FORMAT_YUV422;
+	case V4L2_PIX_FMT_YUV444:
+		return IA_CSS_FRAME_FORMAT_YUV444;
+	case V4L2_PIX_FMT_NV12:
+		return IA_CSS_FRAME_FORMAT_NV12;
+	case V4L2_PIX_FMT_NV21:
+		return IA_CSS_FRAME_FORMAT_NV21;
+	case V4L2_PIX_FMT_NV16:
+		return IA_CSS_FRAME_FORMAT_NV16;
+	case V4L2_PIX_FMT_NV61:
+		return IA_CSS_FRAME_FORMAT_NV61;
+	case V4L2_PIX_FMT_UYVY:
+		return IA_CSS_FRAME_FORMAT_UYVY;
+	case V4L2_PIX_FMT_YUYV:
+		return IA_CSS_FRAME_FORMAT_YUYV;
+	case V4L2_PIX_FMT_RGB24:
+		return IA_CSS_FRAME_FORMAT_RGBA888;
+	case V4L2_PIX_FMT_RGB32:
+		return IA_CSS_FRAME_FORMAT_RGBA888;
+	case V4L2_PIX_FMT_RGB565:
+		return IA_CSS_FRAME_FORMAT_RGB565;
+	case V4L2_PIX_FMT_SBGGR16:
+	case V4L2_PIX_FMT_SBGGR10:
+	case V4L2_PIX_FMT_SGBRG10:
+	case V4L2_PIX_FMT_SGRBG10:
+	case V4L2_PIX_FMT_SRGGB10:
+	case V4L2_PIX_FMT_SBGGR12:
+	case V4L2_PIX_FMT_SGBRG12:
+	case V4L2_PIX_FMT_SGRBG12:
+	case V4L2_PIX_FMT_SRGGB12:
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+		return IA_CSS_FRAME_FORMAT_RAW;
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * raw format match between SH format and V4L2 format
+ */
+static int raw_output_format_match_input(u32 input, u32 output)
+{
+	if ((input == IA_CSS_STREAM_FORMAT_RAW_12) &&
+	    ((output == V4L2_PIX_FMT_SRGGB12) ||
+	     (output == V4L2_PIX_FMT_SGRBG12) ||
+	     (output == V4L2_PIX_FMT_SBGGR12) ||
+	     (output == V4L2_PIX_FMT_SGBRG12)))
+		return 0;
+
+	if ((input == IA_CSS_STREAM_FORMAT_RAW_10) &&
+	    ((output == V4L2_PIX_FMT_SRGGB10) ||
+	     (output == V4L2_PIX_FMT_SGRBG10) ||
+	     (output == V4L2_PIX_FMT_SBGGR10) ||
+	     (output == V4L2_PIX_FMT_SGBRG10)))
+		return 0;
+
+	if ((input == IA_CSS_STREAM_FORMAT_RAW_8) &&
+	    ((output == V4L2_PIX_FMT_SRGGB8) ||
+	     (output == V4L2_PIX_FMT_SGRBG8) ||
+	     (output == V4L2_PIX_FMT_SBGGR8) ||
+	     (output == V4L2_PIX_FMT_SGBRG8)))
+		return 0;
+
+	if ((input == IA_CSS_STREAM_FORMAT_RAW_16) &&
+	    (output == V4L2_PIX_FMT_SBGGR16))
+		return 0;
+
+	return -EINVAL;
+}
+
+static u32 get_pixel_depth(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+	case V4L2_PIX_FMT_YVU420:
+		return 12;
+	case V4L2_PIX_FMT_YUV422P:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_SBGGR16:
+	case V4L2_PIX_FMT_SBGGR12:
+	case V4L2_PIX_FMT_SGBRG12:
+	case V4L2_PIX_FMT_SGRBG12:
+	case V4L2_PIX_FMT_SRGGB12:
+	case V4L2_PIX_FMT_SBGGR10:
+	case V4L2_PIX_FMT_SGBRG10:
+	case V4L2_PIX_FMT_SGRBG10:
+	case V4L2_PIX_FMT_SRGGB10:
+		return 16;
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_YUV444:
+		return 24;
+	case V4L2_PIX_FMT_RGB32:
+		return 32;
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+		return 8;
+	default:
+		return 8 * 2;	/* raw type now */
+	}
+}
+
+static int is_pixelformat_raw(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_SBGGR16:
+	case V4L2_PIX_FMT_SBGGR12:
+	case V4L2_PIX_FMT_SGBRG12:
+	case V4L2_PIX_FMT_SGRBG12:
+	case V4L2_PIX_FMT_SRGGB12:
+	case V4L2_PIX_FMT_SBGGR10:
+	case V4L2_PIX_FMT_SGBRG10:
+	case V4L2_PIX_FMT_SGRBG10:
+	case V4L2_PIX_FMT_SRGGB10:
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+int atomisp_is_mbuscode_raw(uint32_t code)
+{
+	const struct atomisp_format_bridge *b =
+		atomisp_get_format_bridge_from_mbus(code);
+
+	BUG_ON(!b);
+
+	return is_pixelformat_raw(b->pixelformat);
+}
+
+static int get_sh_input_format(u32 pixelformat)
+{
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+		return IA_CSS_STREAM_FORMAT_YUV420_8;
+
+	case V4L2_PIX_FMT_YUV422P:
+		return IA_CSS_STREAM_FORMAT_YUV422_8;
+
+	case V4L2_PIX_FMT_RGB565:
+		return IA_CSS_STREAM_FORMAT_RGB_565;
+	case V4L2_PIX_FMT_RGB24:
+		return IA_CSS_STREAM_FORMAT_RGB_888;
+	case V4L2_PIX_FMT_BGR666:
+		return IA_CSS_STREAM_FORMAT_RGB_666;
+
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+		return IA_CSS_STREAM_FORMAT_RAW_8;
+
+	case V4L2_PIX_FMT_SBGGR10:
+	case V4L2_PIX_FMT_SGBRG10:
+	case V4L2_PIX_FMT_SGRBG10:
+	case V4L2_PIX_FMT_SRGGB10:
+		return IA_CSS_STREAM_FORMAT_RAW_10;
+
+	case V4L2_PIX_FMT_SBGGR12:
+	case V4L2_PIX_FMT_SGBRG12:
+	case V4L2_PIX_FMT_SGRBG12:
+	case V4L2_PIX_FMT_SRGGB12:
+		return IA_CSS_STREAM_FORMAT_RAW_12;
+
+	case V4L2_PIX_FMT_SBGGR16:
+		return IA_CSS_STREAM_FORMAT_RAW_16;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * ISP features control function
+ */
+
+/*
+ * Set ISP capture mode based on current settings
+ */
+static void atomisp_update_capture_mode(struct atomisp_sub_device *isp_subdev)
+{
+	struct ia_css_isp_config isp_config;
+	enum ia_css_capture_mode capture_mode;
+
+	if (!isp_subdev->css2_basis.stream) {
+		v4l2_err(&atomisp_dev,
+			 "%s called after streamoff, skipping.\n",
+			 __func__);
+		return;
+	}
+	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+	isp_config.capture_config = &isp_subdev->params.capture_config;
+	ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+
+	if (isp_subdev->params.low_light)
+		capture_mode = IA_CSS_CAPTURE_MODE_LOW_LIGHT;
+	else if (isp_subdev->params.gdc_cac_en)
+		capture_mode = IA_CSS_CAPTURE_MODE_ADVANCED;
+	else
+		capture_mode = IA_CSS_CAPTURE_MODE_PRIMARY;
+	if (capture_mode != isp_subdev->params.capture_config.mode) {
+		isp_subdev->params.capture_config.mode = capture_mode;
+		isp_subdev->params.config.capture_config = &isp_subdev->params.capture_config;
+	}
+}
+
+/*
+ * Function to enable/disable lens geometry distortion correction (GDC) and
+ * chromatic aberration correction (CAC)
+ */
+int atomisp_gdc_cac(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	if (flag == 0) {
+		*value = isp_subdev->params.gdc_cac_en;
+		return 0;
+	}
+
+	isp_subdev->params.gdc_cac_en = !!*value;
+	if (isp_subdev->params.gdc_cac_en) {
+		isp_subdev->params.config.morph_table = isp->inputs[isp_subdev->input_curr].morph_table;
+		isp_subdev->params.css_update_params_needed = true;
+		atomisp_update_capture_mode(isp_subdev);
+	}
+	return 0;
+}
+
+/*
+ * Function to enable/disable low light mode including ANR
+ */
+int atomisp_low_light(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value)
+{
+	if (flag == 0) {
+		*value = isp_subdev->params.low_light;
+		return 0;
+	}
+
+	isp_subdev->params.low_light = (*value != 0);
+	atomisp_update_capture_mode(isp_subdev);
+	return 0;
+}
+
+/*
+ * Function to enable/disable extra noise reduction (XNR) in low light
+ * condition
+ */
+int atomisp_xnr(struct atomisp_sub_device *isp_subdev, int flag, int *xnr_enable)
+{
+	struct ia_css_isp_config isp_config;
+	if (!xnr_enable)
+		return 0;
+
+	if (flag == 0) {
+		*xnr_enable = isp_subdev->params.xnr_en;
+		return 0;
+	}
+
+	if (!isp_subdev->css2_basis.stream) {
+		v4l2_err(&atomisp_dev,
+			 "%s called after streamoff, skipping.\n",
+			 __func__);
+		return -EINVAL;
+	}
+	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+	isp_config.capture_config = &isp_subdev->params.capture_config;
+	ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+
+	if (isp_subdev->params.capture_config.enable_xnr != !!*xnr_enable)
+		isp_subdev->params.capture_config.enable_xnr = !!*xnr_enable;
+
+	return 0;
+}
+
+/*
+ * Function to load the larger FW
+ */
+int atomisp_fw(struct atomisp_device *isp, int flag, int *data){
+		int ret = 0;
+
+		if (fastboot){
+				v4l2_dbg(3, dbg_level, &atomisp_dev, "Starting firmware switch\n");
+				if (isp->firmware_switched == false){
+						ret = firmware_load_helper(&(isp->aux_firmware), isp);
+						if (atomisp_subdev_streaming_count(isp) == 0) {
+								atomisp_destroy_pipes_stream_force(isp->isp_subdev);
+								ia_css_unload_firmware(true);
+								atomisp_css_uninit(isp);
+								switch_to_full_firmware(isp);
+								ret = atomisp_css_init(isp);
+								v4l2_dbg(2, dbg_level, &atomisp_dev, "Firmware switch Complete. Also switched to BUFFERED_SENSOR Mode for multistreaming\n");
+								return 0;
+						}
+						else {
+								v4l2_dbg(2, dbg_level, &atomisp_dev, "Cannot switch firmware now. Device is currently streaming. Switch will happen in the next streamoff\n");
+								isp->switch_fw_on_streamoff = true;
+								/*
+								 * do switch in atomisp_reset() of streamoff
+								 */
+								return -EBUSY;
+						}
+				}
+				else{
+						v4l2_dbg(2, dbg_level, &atomisp_dev, "Firmware already switched\n");
+						return 0;
+				}
+		}
+		else{
+				v4l2_dbg(2, dbg_level, &atomisp_dev, "fastboot disabled\n");
+				return -EINVAL;
+		}
+}
+
+
+/*
+ * Function to configure bayer noise reduction
+ */
+int atomisp_nr(struct atomisp_sub_device *isp_subdev, int flag,
+	       struct atomisp_nr_config *arg)
+{
+	if (arg == NULL)
+		return -EINVAL;
+
+	if (sizeof(*arg) != sizeof(isp_subdev->params.config.nr_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_nr_config nr_config;
+		struct ia_css_isp_config isp_config;
+
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&nr_config, 0, sizeof(struct ia_css_nr_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+
+		/* Get nr config from current setup */
+		isp_config.nr_config = &nr_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		memcpy(arg, &nr_config, sizeof(*arg));
+	} else {
+		/* Set nr config to isp parameters */
+		if (!isp_subdev->params.config.nr_config)
+			isp_subdev->params.config.nr_config = &isp_subdev->params.nr_config;
+		memcpy(isp_subdev->params.config.nr_config, arg,
+			sizeof(struct ia_css_nr_config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+	return 0;
+}
+
+/*
+ * Function to configure temporal noise reduction (TNR)
+ */
+int atomisp_tnr(struct atomisp_sub_device *isp_subdev, int flag,
+		struct atomisp_tnr_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.tnr_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+
+	/* Get tnr config from current setup */
+	if (flag == 0) {
+		struct ia_css_tnr_config tnr_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&tnr_config, 0, sizeof(struct ia_css_tnr_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.tnr_config = &tnr_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+
+		/* Get tnr config from current setup */
+		memcpy(config, &isp_config.tnr_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.tnr_config)
+			isp_subdev->params.config.tnr_config = &isp_subdev->params.tnr_config;
+		/* Set tnr config to isp parameters */
+		memcpy(isp_subdev->params.config.tnr_config, config,
+			sizeof(struct ia_css_tnr_config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to get histogram data for image frame
+ */
+int atomisp_histogram(struct atomisp_sub_device *isp_subdev, int flag, void *config)
+{
+#if defined(CONFIG_CSS_ONE)
+	struct atomisp_histogram *arg = (struct atomisp_histogram *)config;
+	struct ia_css_histogram *histogram;
+	int ret = 0;
+	unsigned int *buffer;
+
+	if (arg == NULL)
+		return -EINVAL;
+
+	if (sizeof(*arg) != sizeof(*histogram)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		buffer = kzalloc(2048 * sizeof(unsigned int), GFP_KERNEL);
+		if (buffer == NULL) {
+			v4l2_err(&atomisp_dev,
+					"buffer allocate error\n");
+			return -ENOMEM;
+		}
+
+		ret = ia_css_histogram_allocate(2048, &histogram);
+		if (ret != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev,
+					"ia_css_histogram_allocate failed\n");
+			goto buffer_free;
+		}
+
+		if (isp->vf_frame == NULL) {
+			v4l2_err(&atomisp_dev,
+					"No frame for histogram\n");
+			ret = -EINVAL;
+			goto histogram_free;
+		}
+
+		ret = ia_css_histogram_start(isp_subdev->vf_frame, histogram);
+		if (ret != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev,
+					"ia_css_get_y_histogram failed\n");
+			goto histogram_free;
+		}
+		ia_css_wait_for_completion();
+
+		ret = hmm_load(histogram->data, buffer,
+			histogram->num_elements * sizeof(unsigned int));
+		if (ret) {
+			v4l2_err(&atomisp_dev, "hmm_load failed\n");
+			goto histogram_free;
+		}
+
+		ret = copy_to_user(arg->data, buffer,
+			histogram->num_elements * sizeof(unsigned int));
+		if (ret) {
+			v4l2_err(&atomisp_dev,
+					"copy to user failed\n");
+			ret = -EFAULT;
+			goto histogram_free;
+		}
+
+		ret = 0;
+		arg->num_elements = histogram->num_elements;
+
+histogram_free:
+		ia_css_histogram_free(histogram);
+buffer_free:
+		kfree(buffer);
+
+		return ret;
+	}
+
+	isp_subdev->params.config.histogram_elenum = arg->num_elements;
+#endif
+	return 0;
+}
+
+/*
+ * Function to configure black level compensation
+ */
+int atomisp_black_level(struct atomisp_sub_device *isp_subdev, int flag,
+			struct atomisp_ob_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.ob_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_ob_config ob_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&ob_config, 0, sizeof(struct ia_css_ob_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.ob_config = &ob_config;
+		/* Get ob config from current setup */
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		memcpy(config, &ob_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.ob_config)
+			isp_subdev->params.config.ob_config = &isp_subdev->params.ob_config;
+		/* Set ob config to isp parameters */
+		memcpy(isp_subdev->params.config.ob_config, config,
+			sizeof(struct ia_css_ob_config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to configure edge enhancement
+ */
+int atomisp_ee(struct atomisp_sub_device *isp_subdev, int flag,
+	       struct atomisp_ee_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.ee_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_ee_config ee_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&ee_config, 0, sizeof(struct ia_css_ee_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		/* Get ee config from current setup */
+		isp_config.ee_config = &ee_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		memcpy(config, &ee_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.ee_config)
+			isp_subdev->params.config.ee_config = &isp_subdev->params.ee_config;
+		/* Set ee config to isp parameters */
+		memcpy(isp_subdev->params.config.ee_config, config,
+		       sizeof(*isp_subdev->params.config.ee_config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to update Gamma table for gamma, brightness and contrast config
+ */
+int atomisp_gamma(struct atomisp_sub_device *isp_subdev, int flag,
+		  struct atomisp_gamma_table *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.gamma_table)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_gamma_table tab;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&tab, 0, sizeof(struct ia_css_gamma_table));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		/* Get gamma table from current setup */
+		isp_config.gamma_table = &tab;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		memcpy(config, &tab, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.gamma_table)
+			isp_subdev->params.config.gamma_table = &isp_subdev->params.gamma_table;
+		/* Set gamma table to isp parameters */
+		memcpy(isp_subdev->params.config.gamma_table, config,
+		       sizeof(*isp_subdev->params.config.gamma_table));
+	}
+
+	return 0;
+}
+
+/*
+ * Function to update Ctc table for Chroma Enhancement
+ */
+int atomisp_ctc(struct atomisp_sub_device *isp_subdev, int flag,
+		struct atomisp_ctc_table *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.ctc_table)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_ctc_table tab;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&tab, 0, sizeof(struct ia_css_ctc_table));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		/* Get ctc table from current setup */
+		isp_config.ctc_table = &tab;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		memcpy(config, &tab, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.ctc_table)
+			isp_subdev->params.config.ctc_table = &isp_subdev->params.ctc_table;
+		/* Set ctc table to isp parameters */
+		memcpy(isp_subdev->params.config.ctc_table, config,
+			sizeof(*isp_subdev->params.config.ctc_table));
+	}
+
+	return 0;
+}
+
+/*
+ * Function to update gamma correction parameters
+ */
+int atomisp_gamma_correction(struct atomisp_sub_device *isp_subdev, int flag,
+	struct atomisp_gc_config *config)
+{
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.gc_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_gc_config gc_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&gc_config, 0, sizeof(struct ia_css_gc_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.gc_config = &gc_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		/* Get gamma correction params from current setup */
+		memcpy(config, &gc_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.gc_config)
+			isp_subdev->params.config.gc_config = &isp_subdev->params.gc_config;
+		/* Set gamma correction params to isp parameters */
+		memcpy(isp_subdev->params.config.gc_config, config, sizeof(*config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+void atomisp_free_internal_buffers(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct ia_css_morph_table *tab;
+
+	tab = isp->inputs[isp_subdev->input_curr].morph_table;
+	if (tab) {
+		ia_css_morph_table_free(tab);
+		isp->inputs[isp_subdev->input_curr].morph_table = NULL;
+	}
+
+	if (isp_subdev->raw_output_frame) {
+		ia_css_frame_free(isp_subdev->raw_output_frame);
+		isp_subdev->raw_output_frame = NULL;
+	}
+}
+
+void atomisp_free_3a_dvs_buffers(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_s3a_buf *s3a_buf, *_s3a_buf;
+	struct atomisp_dvs_buf *dvs_buf, *_dvs_buf;
+
+	/* 3A statistics use vmalloc, DIS use kmalloc */
+	if (isp_subdev->params.curr_grid_info.dvs_grid.enable) {
+		ia_css_dvs_coefficients_free(isp_subdev->params.dvs_coeff);
+		ia_css_dvs_statistics_free(isp_subdev->params.dvs_stat);
+		isp_subdev->params.dvs_coeff = NULL;
+		isp_subdev->params.dvs_stat = NULL;
+		isp_subdev->params.dvs_hor_proj_bytes = 0;
+		isp_subdev->params.dvs_ver_proj_bytes = 0;
+		isp_subdev->params.dvs_hor_coef_bytes = 0;
+		isp_subdev->params.dvs_ver_coef_bytes = 0;
+		isp_subdev->params.dvs_proj_data_valid = false;
+		list_for_each_entry_safe(dvs_buf, _dvs_buf,
+					 &isp_subdev->dvs_stats, list) {
+			ia_css_isp_dvs_statistics_free(dvs_buf->dvs_stat);
+			list_del(&dvs_buf->list);
+			kfree(dvs_buf);
+		}
+	}
+	if (isp_subdev->params.curr_grid_info.s3a_grid.enable) {
+		ia_css_3a_statistics_free(isp_subdev->params.s3a_user_stat);
+		isp_subdev->params.s3a_user_stat = NULL;
+		isp_subdev->params.s3a_buf_data_valid = false;
+		isp_subdev->params.s3a_output_bytes = 0;
+		list_for_each_entry_safe(s3a_buf, _s3a_buf,
+					 &isp_subdev->s3a_stats, list) {
+			ia_css_isp_3a_statistics_free(s3a_buf->s3a_stat);
+			list_del(&s3a_buf->list);
+			kfree(s3a_buf);
+		}
+	}
+}
+
+static void atomisp_update_grid_info(struct atomisp_sub_device *isp_subdev)
+{
+	int err;
+	struct ia_css_pipe_info p_info;
+	struct ia_css_grid_info old_info;
+
+	memset(&p_info, 0, sizeof(struct ia_css_pipe_info));
+	memset(&old_info, 0, sizeof(struct ia_css_grid_info));
+	ia_css_pipe_get_info(isp_subdev->css2_basis.pipes[isp_subdev->css2_basis.curr_pipe],
+			     &p_info);
+	memcpy(&old_info,&isp_subdev->params.curr_grid_info,sizeof(struct ia_css_grid_info));
+	memcpy(&isp_subdev->params.curr_grid_info, &p_info.grid_info,
+	       		sizeof(struct ia_css_grid_info));
+
+	/* If the grid info has not changed and the buffers for 3A and
+	 * DIS statistics buffers are allocated or buffer size would be zero
+	 * then no need to do anything. */
+	if ((!memcmp(&old_info, &isp_subdev->params.curr_grid_info,
+		     sizeof(old_info)) &&
+	    isp_subdev->params.s3a_user_stat && isp_subdev->params.dvs_stat) ||
+		isp_subdev->params.curr_grid_info.s3a_grid.width == 0 ||
+		isp_subdev->params.curr_grid_info.s3a_grid.height == 0) {
+		return;
+	}
+
+	/* We must free all buffers because they no longer match
+	   the grid size. */
+	atomisp_free_3a_dvs_buffers(isp_subdev);
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "grid info changed. re-allocate status buffer.\n");
+	err = atomisp_alloc_css_stat_bufs(isp_subdev);
+	if (err) {
+		v4l2_err(&atomisp_dev,
+			 "stat_buf allocate error\n");
+		goto err_3a;
+	}
+
+	isp_subdev->params.s3a_user_stat =
+	    ia_css_3a_statistics_allocate(&isp_subdev->params.curr_grid_info.s3a_grid);
+	if (!isp_subdev->params.s3a_user_stat)
+		goto err_3a;
+
+	/* 3A statistics. These can be big, so we use vmalloc. */
+	isp_subdev->params.s3a_output_bytes =
+	    isp_subdev->params.curr_grid_info.s3a_grid.width *
+	    isp_subdev->params.curr_grid_info.s3a_grid.height *
+	    sizeof(*isp_subdev->params.s3a_user_stat->data);
+
+	isp_subdev->params.s3a_buf_data_valid = false;
+	if (isp_subdev->params.curr_grid_info.dvs_grid.enable) {
+		/* DIS coefficients. */
+		isp_subdev->params.dvs_coeff =
+		    ia_css_dvs_coefficients_allocate(
+				&isp_subdev->params.curr_grid_info.dvs_grid);
+		if (!isp_subdev->params.dvs_coeff)
+			goto err_dvs;
+
+		isp_subdev->params.dvs_hor_coef_bytes =
+		    isp_subdev->params.curr_grid_info.dvs_grid.num_hor_coefs*
+		    IA_CSS_DVS_NUM_COEF_TYPES *
+		    sizeof(*isp_subdev->params.dvs_coeff->hor_coefs);
+
+		isp_subdev->params.dvs_ver_coef_bytes =
+		    isp_subdev->params.curr_grid_info.dvs_grid.num_ver_coefs *
+		    IA_CSS_DVS_NUM_COEF_TYPES *
+		    sizeof(*isp_subdev->params.dvs_coeff->ver_coefs);
+
+		/* DIS projections. */
+		isp_subdev->params.dvs_proj_data_valid = false;
+		isp_subdev->params.dvs_stat = ia_css_dvs_statistics_allocate(&isp_subdev->params.curr_grid_info.dvs_grid);
+		if (!isp_subdev->params.dvs_stat)
+			goto err_dvs;
+		isp_subdev->params.dvs_hor_proj_bytes =
+		    isp_subdev->params.curr_grid_info.dvs_grid.aligned_height *
+		    IA_CSS_DVS_NUM_COEF_TYPES *
+		    sizeof(*isp_subdev->params.dvs_stat->hor_proj);
+
+		isp_subdev->params.dvs_ver_proj_bytes =
+		    isp_subdev->params.curr_grid_info.dvs_grid.aligned_width *
+		    IA_CSS_DVS_NUM_COEF_TYPES *
+		    sizeof(*isp_subdev->params.dvs_stat->ver_proj);
+	}
+	return;
+
+	/* Failure for 3A buffers does not influence DIS buffers */
+err_3a:
+	if (isp_subdev->params.s3a_output_bytes != 0) {
+		/* For SOC sensor happens s3a_output_bytes == 0,
+		 *  using if condition to exclude false error log */
+		v4l2_err(&atomisp_dev, "Failed allocate memory for 3A statistics\n");
+	}
+	atomisp_free_3a_dvs_buffers(isp_subdev);
+	return;
+
+err_dvs:
+	v4l2_err(&atomisp_dev, "Failed allocate memory for DIS statistics\n");
+	atomisp_free_3a_dvs_buffers(isp_subdev);
+}
+
+static void atomisp_curr_user_grid_info(struct atomisp_sub_device *isp_subdev,
+				    struct atomisp_grid_info *info)
+{
+#ifndef ATOMISP_CSS2
+	info->isp_in_width          =
+	    isp_subdev->params.curr_grid_info.isp_in_width;
+	info->isp_in_height         =
+	    isp_subdev->params.curr_grid_info.isp_in_height;
+	info->s3a_width             =
+	    isp_subdev->params.curr_grid_info.s3a_grid.width;
+	info->s3a_height            =
+		isp_subdev->params.curr_grid_info.s3a_grid.height;
+	info->s3a_bqs_per_grid_cell =
+		isp_subdev->params.curr_grid_info.s3a_grid.bqs_per_grid_cell;
+
+	info->dis_width          =
+	    isp_subdev->params.curr_grid_info.dvs_grid.width;
+	info->dis_aligned_width  =
+		isp_subdev->params.curr_grid_info.dvs_grid.aligned_width;
+	info->dis_height         =
+	    isp_subdev->params.curr_grid_info.dvs_grid.height;
+	info->dis_aligned_height =
+		isp_subdev->params.curr_grid_info.dvs_grid.aligned_height;
+	info->dis_bqs_per_grid_cell =
+		isp_subdev->params.curr_grid_info.dvs_grid.bqs_per_grid_cell;
+	info->dis_hor_coef_num      =
+		isp_subdev->params.curr_grid_info.dvs_grid.num_hor_coefs;
+	info->dis_ver_coef_num      =
+		isp_subdev->params.curr_grid_info.dvs_grid.num_ver_coefs;
+#else
+	memcpy(info, &isp_subdev->params.curr_grid_info.s3a_grid,
+	       sizeof(struct ia_css_3a_grid_info));
+
+#endif
+}
+
+static int atomisp_compare_grid(struct atomisp_sub_device *isp_subdev,
+				struct atomisp_grid_info *atomgrid)
+{
+	struct atomisp_grid_info tmp = {0};
+
+	atomisp_curr_user_grid_info(isp_subdev, &tmp);
+	return memcmp(atomgrid, &tmp, sizeof(tmp));
+}
+
+/*
+ * Function to update Gdc table for gdc
+ */
+int atomisp_gdc_cac_table(struct atomisp_sub_device *isp_subdev, int flag,
+			  struct atomisp_morph_table *config)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	int ret;
+	int i;
+
+	if (flag == 0) {
+		struct ia_css_morph_table tab;
+		struct ia_css_isp_config isp_config;
+		memset(&tab, 0, sizeof(struct ia_css_morph_table));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		/* Get gdc table from current setup */
+		isp_subdev->params.config.morph_table = &tab;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_subdev->params.config);
+
+		config->width = tab.width;
+		config->height = tab.height;
+
+		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+			ret = copy_to_user(config->coordinates_x[i],
+				tab.coordinates_x[i], tab.height *
+				tab.width * sizeof(*tab.coordinates_x[i]));
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+					"Failed to copy to User for x\n");
+				return -EFAULT;
+			}
+			ret = copy_to_user(config->coordinates_y[i],
+				tab.coordinates_y[i], tab.height *
+				tab.width * sizeof(*tab.coordinates_y[i]));
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+					"Failed to copy to User for y\n");
+				return -EFAULT;
+			}
+		}
+	} else {
+		struct ia_css_morph_table *table =
+			isp->inputs[isp_subdev->input_curr].morph_table;
+
+		/* free first if we have one */
+		if (table) {
+			ia_css_morph_table_free(table);
+			isp->inputs[isp_subdev->input_curr].morph_table = NULL;
+		}
+
+		/* allocate new one */
+		table = ia_css_morph_table_allocate(config->width,
+						  config->height);
+
+		if (!table) {
+			v4l2_err(&atomisp_dev, "out of memory\n");
+			return -EINVAL;
+		}
+
+		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+			ret = copy_from_user(table->coordinates_x[i],
+				config->coordinates_x[i],
+				config->height * config->width *
+				sizeof(*config->coordinates_x[i]));
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+				"Failed to copy from User for x, ret %d\n",
+				ret);
+				ia_css_morph_table_free(table);
+				return -EFAULT;
+			}
+			ret = copy_from_user(table->coordinates_y[i],
+				config->coordinates_y[i],
+				config->height * config->width *
+				sizeof(*config->coordinates_y[i]));
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+				"Failed to copy from User for y, ret is %d\n",
+				ret);
+				ia_css_morph_table_free(table);
+				return -EFAULT;
+			}
+		}
+		isp->inputs[isp_subdev->input_curr].morph_table = table;
+		if (isp_subdev->params.gdc_cac_en)
+			isp_subdev->params.config.morph_table = table;
+	}
+
+	return 0;
+}
+
+int atomisp_macc_table(struct atomisp_sub_device *isp_subdev, int flag,
+		       struct atomisp_macc_config *config)
+{
+	struct ia_css_macc_table *macc_table;
+	struct ia_css_macc_table tmp_macc_table;
+	struct ia_css_isp_config isp_config;
+
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(config->table) != sizeof(*macc_table)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+	memset(&tmp_macc_table, 0, sizeof(struct ia_css_macc_table));
+	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+	switch (config->color_effect) {
+	case V4L2_COLORFX_NONE:
+		macc_table = NULL;
+		return 0;
+	case V4L2_COLORFX_SKY_BLUE:
+		macc_table = &blue_macc_table;
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		macc_table = &green_macc_table;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN_LOW:
+		macc_table = &skin_low_macc_table;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		macc_table = &skin_medium_macc_table;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN_HIGH:
+		macc_table = &skin_high_macc_table;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		/* Get macc table from current setup */
+		memcpy(&config->table, macc_table,
+		       sizeof(struct ia_css_macc_table));
+	} else {
+		memcpy(macc_table, &config->table,
+		       sizeof(struct ia_css_macc_table));
+		if (config->color_effect == isp_subdev->params.color_effect)
+			isp_subdev->params.config.macc_table = macc_table;
+	}
+
+	return 0;
+}
+
+int atomisp_set_dis_vector(struct atomisp_sub_device *isp_subdev,
+			   struct atomisp_dis_vector *vector)
+{
+	if (!isp_subdev->params.config.motion_vector)
+		isp_subdev->params.config.motion_vector =
+			&isp_subdev->params.motion_vector;
+
+	memset(isp_subdev->params.config.motion_vector,
+	       		0, sizeof(struct ia_css_vector));
+	isp_subdev->params.motion_vector.x = vector->x;
+	isp_subdev->params.motion_vector.y = vector->y;
+
+	isp_subdev->params.dvs_proj_data_valid = false;
+	isp_subdev->params.css_update_params_needed = true;
+	return 0;
+}
+
+/*
+ * Function to set/get image stablization statistics
+ */
+int atomisp_get_dis_stat(struct atomisp_sub_device *isp_subdev,
+			 struct atomisp_dis_statistics *stats)
+{
+	unsigned long flags;
+	int error;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (stats->vertical_projections   == NULL ||
+	    stats->horizontal_projections == NULL ||
+	    isp_subdev->params.dvs_stat->hor_proj == NULL ||
+	    isp_subdev->params.dvs_stat->ver_proj == NULL)
+		return -EINVAL;
+
+	/* isp needs to be streaming to get DIS statistics */
+	spin_lock_irqsave(&isp->lock, flags);
+	if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED) {
+		spin_unlock_irqrestore(&isp->lock, flags);
+		return -EINVAL;
+	}
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	if (!isp_subdev->params.video_dis_en)
+		return -EINVAL;
+
+	if (atomisp_compare_grid(isp_subdev, &stats->grid_info) != 0)
+		/* If the grid info in the argument differs from the current
+		   grid info, we tell the caller to reset the grid size and
+		   try again. */
+		return -EAGAIN;
+
+	if (!isp_subdev->params.dvs_proj_data_valid)
+		return -EBUSY;
+
+	error = copy_to_user(stats->vertical_projections,
+			     isp_subdev->params.dvs_stat->ver_proj,
+			     isp_subdev->params.dvs_ver_proj_bytes);
+
+	error |= copy_to_user(stats->horizontal_projections,
+			     isp_subdev->params.dvs_stat->hor_proj,
+			     isp_subdev->params.dvs_hor_proj_bytes);
+
+	if (error)
+		return -EFAULT;
+
+	return 0;
+}
+
+int atomisp_set_dis_coefs(struct atomisp_sub_device *isp_subdev,
+			  struct atomisp_dis_coefficients *coefs)
+{
+	int error;
+
+	if (coefs->horizontal_coefficients == NULL ||
+	    coefs->vertical_coefficients   == NULL ||
+	    isp_subdev->params.dvs_coeff->hor_coefs == NULL ||
+	    isp_subdev->params.dvs_coeff->ver_coefs == NULL)
+		return -EINVAL;
+
+	error = copy_from_user(isp_subdev->params.dvs_coeff->hor_coefs,
+			       coefs->horizontal_coefficients,
+			       isp_subdev->params.dvs_hor_coef_bytes);
+	if (error)
+		return -EFAULT;
+	error = copy_from_user(isp_subdev->params.dvs_coeff->ver_coefs,
+			       coefs->vertical_coefficients,
+			       isp_subdev->params.dvs_ver_coef_bytes);
+	if (error)
+		return -EFAULT;
+	isp_subdev->params.config.dvs_coefs = isp_subdev->params.dvs_coeff;
+	isp_subdev->params.dvs_proj_data_valid = false;
+
+	return 0;
+}
+
+/*
+ * Function to set/get 3A stat from isp
+ */
+int atomisp_3a_stat(struct atomisp_sub_device *isp_subdev, int flag,
+		    struct atomisp_3a_statistics *config)
+{
+	unsigned long ret;
+
+	if (flag != 0)
+		return -EINVAL;
+
+	/* sanity check to avoid writing into unallocated memory. */
+	if (isp_subdev->params.s3a_output_bytes == 0)
+		return -EINVAL;
+
+	if (atomisp_compare_grid(isp_subdev, &config->grid_info) != 0) {
+		/* If the grid info in the argument differs from the current
+		   grid info, we tell the caller to reset the grid size and
+		   try again. */
+		return -EAGAIN;
+	}
+
+	/* This is done in the atomisp_s3a_buf_done() */
+	if(!isp_subdev->params.s3a_buf_data_valid) {
+		v4l2_err(&atomisp_dev, "3a statistics is not valid.\n");
+		return -EAGAIN;
+	}
+
+	ret = copy_to_user(config->data,
+			   isp_subdev->params.s3a_user_stat->data,
+			   isp_subdev->params.s3a_output_bytes);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "copy to user failed: copied %lu bytes\n", ret);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static int __atomisp_set_general_isp_parameters(struct atomisp_sub_device *isp_subdev,
+					struct atomisp_parameters *arg)
+{
+	if (arg->wb_config) {
+		if (!isp_subdev->params.config.wb_config)
+			isp_subdev->params.config.wb_config = &isp_subdev->params.wb_config;
+		memset(isp_subdev->params.config.wb_config, 0 , sizeof(struct ia_css_wb_config));
+		if (copy_from_user(isp_subdev->params.config.wb_config, arg->wb_config,
+				   sizeof(struct ia_css_wb_config))) {
+			isp_subdev->params.config.wb_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->ob_config) {
+		if (!isp_subdev->params.config.ob_config)
+			isp_subdev->params.config.ob_config = &isp_subdev->params.ob_config;
+		memset(isp_subdev->params.config.ob_config, 0 , sizeof(struct ia_css_ob_config));
+		if (copy_from_user(isp_subdev->params.config.ob_config, arg->ob_config,
+				   sizeof(struct ia_css_ob_config))) {
+			isp_subdev->params.config.ob_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->dp_config) {
+		if (!isp_subdev->params.config.dp_config)
+			isp_subdev->params.config.dp_config = &isp_subdev->params.dp_config;
+		memset(isp_subdev->params.config.dp_config, 0 , sizeof(struct ia_css_dp_config));
+		if (copy_from_user(isp_subdev->params.config.dp_config, arg->dp_config,
+				   sizeof(struct ia_css_dp_config))) {
+			isp_subdev->params.config.dp_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->de_config) {
+		if (!isp_subdev->params.config.de_config)
+			isp_subdev->params.config.de_config = &isp_subdev->params.de_config;
+		memset(isp_subdev->params.config.de_config, 0 , sizeof(struct ia_css_de_config));
+		if (copy_from_user(isp_subdev->params.config.de_config, arg->de_config,
+				   sizeof(struct ia_css_de_config))) {
+			isp_subdev->params.config.de_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->ce_config) {
+		if (!isp_subdev->params.config.ce_config)
+			isp_subdev->params.config.ce_config = &isp_subdev->params.ce_config;
+		memset(isp_subdev->params.config.ce_config, 0 , sizeof(struct ia_css_ce_config));
+		if (copy_from_user(isp_subdev->params.config.ce_config, arg->ce_config,
+				   sizeof(struct ia_css_ce_config))) {
+			isp_subdev->params.config.ce_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->nr_config) {
+		if (!isp_subdev->params.config.nr_config)
+			isp_subdev->params.config.nr_config = &isp_subdev->params.nr_config;
+		memset(isp_subdev->params.config.nr_config, 0 , sizeof(struct ia_css_nr_config));
+		if (copy_from_user(isp_subdev->params.config.nr_config, arg->nr_config,
+				   sizeof(struct ia_css_nr_config))) {
+			isp_subdev->params.config.nr_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->ee_config) {
+		if (!isp_subdev->params.config.ee_config)
+			isp_subdev->params.config.ee_config = &isp_subdev->params.ee_config;
+		memset(isp_subdev->params.config.ee_config, 0 , sizeof(struct ia_css_ee_config));
+		if (copy_from_user(isp_subdev->params.config.ee_config, arg->ee_config,
+				   sizeof(struct ia_css_ee_config))) {
+			isp_subdev->params.config.ee_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->tnr_config) {
+		if (!isp_subdev->params.config.tnr_config)
+			isp_subdev->params.config.tnr_config = &isp_subdev->params.tnr_config;
+		memset(isp_subdev->params.config.tnr_config, 0 , sizeof(struct ia_css_tnr_config));
+		if (copy_from_user(isp_subdev->params.config.tnr_config, arg->tnr_config,
+				   sizeof(struct ia_css_tnr_config))) {
+			isp_subdev->params.config.tnr_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->cc_config) {
+		if (!isp_subdev->params.config.cc_config)
+				isp_subdev->params.config.cc_config = &isp_subdev->params.cc_config;
+		memset(isp_subdev->params.config.cc_config, 0 , sizeof(struct ia_css_cc_config));
+		if (copy_from_user(isp_subdev->params.config.cc_config, arg->cc_config, sizeof(struct ia_css_cc_config))) {
+			isp_subdev->params.config.cc_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->macc_config) {
+		if (!isp_subdev->params.config.macc_table)
+				isp_subdev->params.config.macc_table = &isp_subdev->params.macc_table;
+		memset(isp_subdev->params.config.macc_table, 0 , sizeof(struct ia_css_macc_table));
+		if (copy_from_user(isp_subdev->params.config.macc_table,
+				   &arg->macc_config->table,
+				   sizeof(struct ia_css_macc_table))) {
+			isp_subdev->params.config.macc_table = NULL;
+			return -EFAULT;
+		}
+		isp_subdev->params.color_effect = arg->macc_config->color_effect;
+	}
+
+	if (arg->gc_config) {
+		if (!isp_subdev->params.config.gc_config)
+			isp_subdev->params.config.gc_config = &isp_subdev->params.gc_config;
+		memset(isp_subdev->params.config.gc_config, 0 , sizeof(struct ia_css_gc_config));
+		if (copy_from_user(isp_subdev->params.config.gc_config, arg->gc_config,
+				   sizeof(*arg->gc_config))) {
+			isp_subdev->params.config.gc_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	if (arg->a3a_config) {
+		if (!isp_subdev->params.config.s3a_config)
+			isp_subdev->params.config.s3a_config = &isp_subdev->params.s3a_config;
+		memset(isp_subdev->params.config.s3a_config, 0 , sizeof(struct ia_css_3a_config));
+		if (copy_from_user(isp_subdev->params.config.s3a_config, arg->a3a_config,
+				   sizeof(*arg->a3a_config))) {
+			isp_subdev->params.config.s3a_config = NULL;
+			return -EFAULT;
+		}
+	}
+
+	return 0;
+}
+
+static int __atomisp_set_lsc_table(struct atomisp_sub_device *isp_subdev,
+			struct atomisp_shading_table *user_st)
+{
+	unsigned int i;
+	unsigned int len_table;
+	struct ia_css_shading_table *shading_table;
+	struct ia_css_shading_table *old_shading_table;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (!user_st)
+		return 0;
+
+	old_shading_table = isp->inputs[isp_subdev->input_curr].shading_table;
+
+	/* user config is to disable the shading table. */
+	if (!user_st->enable) {
+		shading_table = NULL;
+		goto set_lsc;
+	}
+
+	/* Setting a new table. Validate first - all tables must be set */
+	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
+		if (!user_st->data[i])
+			return -EINVAL;
+	}
+
+	/* Shading table size per color */
+	if (user_st->width > SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR ||
+		user_st->height > SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR)
+		return -EINVAL;
+
+	shading_table = ia_css_shading_table_alloc(user_st->width,
+			user_st->height);
+	if (!shading_table)
+			return -ENOMEM;
+
+	len_table = user_st->width * user_st->height * ATOMISP_SC_TYPE_SIZE;
+	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
+		if (copy_from_user(shading_table->data[i],
+			user_st->data[i], len_table)) {
+			ia_css_shading_table_free(shading_table);
+			return -EFAULT;
+		}
+
+	}
+	shading_table->sensor_width = user_st->sensor_width;
+	shading_table->sensor_height = user_st->sensor_height;
+	shading_table->fraction_bits = user_st->fraction_bits;
+
+set_lsc:
+	/* set LSC to CSS */
+	isp->inputs[isp_subdev->input_curr].shading_table = shading_table;
+	isp_subdev->params.config.shading_table = shading_table;
+	isp_subdev->params.sc_en = shading_table != NULL;
+
+	if (old_shading_table)
+		ia_css_shading_table_free(old_shading_table);
+
+	return 0;
+}
+
+static int __atomisp_set_morph_table(struct atomisp_sub_device *isp_subdev,
+				struct atomisp_morph_table *user_morph_table)
+{
+	int ret = -EFAULT;
+	unsigned int i;
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct ia_css_morph_table *morph_table;
+	struct ia_css_morph_table *old_morph_table;
+
+	if (!user_morph_table)
+		return 0;
+
+	old_morph_table = isp->inputs[isp_subdev->input_curr].morph_table;
+
+	morph_table = ia_css_morph_table_allocate(user_morph_table->width,
+				user_morph_table->height);
+	if (!morph_table)
+		return -ENOMEM;
+
+	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+		if (copy_from_user(morph_table->coordinates_x[i],
+			user_morph_table->coordinates_x[i],
+			user_morph_table->height * user_morph_table->width *
+			sizeof(*user_morph_table->coordinates_x[i])))
+			goto error;
+
+		if (copy_from_user(morph_table->coordinates_y[i],
+			user_morph_table->coordinates_y[i],
+			user_morph_table->height * user_morph_table->width *
+			sizeof(*user_morph_table->coordinates_y[i])))
+			goto error;
+	}
+
+	isp->inputs[isp_subdev->input_curr].morph_table = morph_table;
+	if (isp_subdev->params.gdc_cac_en)
+		isp_subdev->params.config.morph_table = morph_table;
+
+	if (old_morph_table)
+		ia_css_morph_table_free(old_morph_table);
+
+	return 0;
+
+error:
+	if (morph_table)
+		ia_css_morph_table_free(morph_table);
+	return ret;
+}
+
+/*
+* Function to configure ISP parameters
+*/
+int atomisp_set_parameters(struct atomisp_sub_device *isp_subdev,
+			struct atomisp_parameters *arg)
+{
+	int ret;
+
+	ret = __atomisp_set_general_isp_parameters(isp_subdev, arg);
+	if (ret)
+		return ret;
+
+	ret = __atomisp_set_lsc_table(isp_subdev, arg->shading_table);
+	if (ret)
+		return ret;
+
+	ret = __atomisp_set_morph_table(isp_subdev, arg->morph_table);
+	if (ret)
+		return ret;
+
+	/* indicate to CSS that we have parametes to be updated */
+	isp_subdev->params.css_update_params_needed = true;
+
+	if (isp_subdev->css2_basis.stream
+		&& (isp_subdev->css2_basis.stream_state != CSS2_STREAM_STARTED
+		|| isp_subdev->run_mode->val
+			== ATOMISP_RUN_MODE_STILL_CAPTURE)) {
+		atomisp_css_update_isp_params(isp_subdev);
+		isp_subdev->params.css_update_params_needed = false;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to set/get isp parameters to isp
+ */
+int atomisp_param(struct atomisp_sub_device *isp_subdev, int flag,
+		  struct atomisp_parm *config)
+{
+	/* Read parameter for 3A bianry info */
+	if (flag == 0) {
+		if (&config->info == NULL) {
+			v4l2_err(&atomisp_dev,
+				    "ERROR: NULL pointer in grid_info\n");
+			return -EINVAL;
+		}
+		atomisp_curr_user_grid_info(isp_subdev, &config->info);
+		return 0;
+	}
+
+	if (sizeof(config->wb_config) != sizeof(isp_subdev->params.config.wb_config))
+		goto INVALID_PARM;
+	if (sizeof(config->cc_config) != sizeof(isp_subdev->params.config.cc_config))
+		goto INVALID_PARM;
+	if (sizeof(config->ob_config) != sizeof(isp_subdev->params.config.ob_config))
+		goto INVALID_PARM;
+	if (sizeof(config->de_config) != sizeof(isp_subdev->params.config.de_config))
+		goto INVALID_PARM;
+	if (sizeof(config->ce_config) != sizeof(isp_subdev->params.config.ce_config))
+		goto INVALID_PARM;
+	if (sizeof(config->dp_config) != sizeof(isp_subdev->params.config.dp_config))
+		goto INVALID_PARM;
+	if (sizeof(config->nr_config) != sizeof(isp_subdev->params.config.nr_config))
+		goto INVALID_PARM;
+	if (sizeof(config->ee_config) != sizeof(isp_subdev->params.config.ee_config))
+		goto INVALID_PARM;
+	if (sizeof(config->tnr_config) != sizeof(isp_subdev->params.config.tnr_config))
+		goto INVALID_PARM;
+
+	memcpy(&isp_subdev->params.wb_config, &config->wb_config,
+	       sizeof(struct ia_css_wb_config));
+	memcpy(&isp_subdev->params.cc_config, &config->cc_config,
+	       sizeof(struct ia_css_cc_config));
+	memcpy(&isp_subdev->params.ob_config, &config->ob_config,
+	       sizeof(struct ia_css_ob_config));
+	memcpy(&isp_subdev->params.dp_config, &config->dp_config,
+	       sizeof(struct ia_css_dp_config));
+	memcpy(&isp_subdev->params.de_config, &config->de_config,
+	       sizeof(struct ia_css_de_config));
+	memcpy(&isp_subdev->params.ce_config, &config->ce_config,
+	       sizeof(struct ia_css_ce_config));
+	memcpy(&isp_subdev->params.nr_config, &config->nr_config,
+	       sizeof(struct ia_css_nr_config));
+	memcpy(&isp_subdev->params.ee_config, &config->ee_config,
+	       sizeof(struct ia_css_ee_config));
+	memcpy(&isp_subdev->params.tnr_config, &config->tnr_config,
+	       sizeof(struct ia_css_tnr_config));
+
+	isp_subdev->params.config.wb_config = &isp_subdev->params.wb_config;
+	isp_subdev->params.config.cc_config = &isp_subdev->params.cc_config;
+	isp_subdev->params.config.ob_config = &isp_subdev->params.ob_config;
+	isp_subdev->params.config.dp_config = &isp_subdev->params.dp_config;
+	isp_subdev->params.config.de_config = &isp_subdev->params.de_config;
+	isp_subdev->params.config.ce_config = &isp_subdev->params.ce_config;
+	isp_subdev->params.config.nr_config = &isp_subdev->params.nr_config;
+	isp_subdev->params.config.ee_config = &isp_subdev->params.ee_config;
+	isp_subdev->params.config.tnr_config = &isp_subdev->params.tnr_config;
+
+	if (isp_subdev->params.color_effect == V4L2_COLORFX_NEGATIVE) {
+		config->cc_config.matrix[3] = -config->cc_config.matrix[3];
+		config->cc_config.matrix[4] = -config->cc_config.matrix[4];
+		config->cc_config.matrix[5] = -config->cc_config.matrix[5];
+		config->cc_config.matrix[6] = -config->cc_config.matrix[6];
+		config->cc_config.matrix[7] = -config->cc_config.matrix[7];
+		config->cc_config.matrix[8] = -config->cc_config.matrix[8];
+	}
+
+	if (isp_subdev->params.color_effect != V4L2_COLORFX_SEPIA &&
+	    isp_subdev->params.color_effect != V4L2_COLORFX_BW) {
+		memcpy(&isp_subdev->params.cc_config, &config->cc_config,
+		       sizeof(struct ia_css_cc_config));
+		isp_subdev->params.config.cc_config = &isp_subdev->params.cc_config;
+	}
+
+	isp_subdev->params.css_update_params_needed = true;
+
+	return 0;
+
+INVALID_PARM:
+	v4l2_err(&atomisp_dev,
+		"%s: incompatible param.\n", __func__);
+	return -EINVAL;
+}
+
+/*
+ * Function to configure color effect of the image
+ */
+int atomisp_color_effect(struct atomisp_sub_device *isp_subdev, int flag, __s32 *effect)
+{
+	struct ia_css_cc_config *cc_config = NULL;
+	struct ia_css_macc_table *macc_table = NULL;
+	struct ia_css_ctc_table *ctc_table = NULL;
+	int ret = 0;
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct v4l2_control control;
+
+	if (flag == 0) {
+		*effect = isp_subdev->params.color_effect;
+		return 0;
+	}
+
+
+	control.id = V4L2_CID_COLORFX;
+	control.value = *effect;
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				core, s_ctrl, &control);
+	/*
+	 * if set color effect to sensor successfully, return
+	 * 0 directly.
+	 */
+	if (!ret) {
+		isp_subdev->params.color_effect = (u32)*effect;
+		return 0;
+	}
+
+	if (*effect == isp_subdev->params.color_effect)
+		return 0;
+
+	/*
+	 * set macc enable to false by default:
+	 * when change from macc to sepia/mono,
+	 * isp_subdev->params.macc_en should be set to false.
+	 */
+	isp_subdev->params.macc_en = false;
+
+	switch (*effect) {
+	case V4L2_COLORFX_NONE:
+		macc_table = NULL;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_SEPIA:
+		cc_config = &sepia_cc_config;
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		cc_config = &nega_cc_config;
+		break;
+	case V4L2_COLORFX_BW:
+		cc_config = &mono_cc_config;
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		macc_table = &blue_macc_table;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		macc_table = &green_macc_table;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN_LOW:
+		macc_table = &skin_low_macc_table;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		macc_table = &skin_medium_macc_table;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN_HIGH:
+		macc_table = &skin_high_macc_table;
+		isp_subdev->params.macc_en = true;
+		break;
+	case V4L2_COLORFX_VIVID:
+		ctc_table = &vivid_ctc_table;
+		break;
+	default:
+		return -EINVAL;
+	}
+	atomisp_update_capture_mode(isp_subdev);
+
+	if (cc_config)
+		isp_subdev->params.config.cc_config = cc_config;
+	if (macc_table)
+		isp_subdev->params.config.macc_table = macc_table;
+	if (ctc_table)
+		isp_subdev->params.config.ctc_table = ctc_table;
+	isp_subdev->params.color_effect = (u32)*effect;
+	isp_subdev->params.css_update_params_needed = true;
+	return 0;
+}
+
+/*
+ * Function to configure bad pixel correction
+ */
+int atomisp_bad_pixel(struct atomisp_sub_device *isp_subdev, int flag, __s32 *value)
+{
+
+	if (flag == 0) {
+		*value = isp_subdev->params.bad_pixel_en;
+		return 0;
+	}
+	isp_subdev->params.bad_pixel_en = !!*value;
+
+	return 0;
+}
+
+/*
+ * Function to configure bad pixel correction params
+ */
+int atomisp_bad_pixel_param(struct atomisp_sub_device *isp_subdev, int flag,
+			    struct atomisp_dp_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.dp_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_dp_config dp_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&dp_config, 0, sizeof(struct ia_css_dp_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.dp_config = &dp_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		/* Get bad pixel from current setup */
+		memcpy(config, isp_subdev->params.config.dp_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.dp_config)
+			isp_subdev->params.config.dp_config = &isp_subdev->params.dp_config;
+		/* Set bad pixel to isp parameters */
+		memcpy(isp_subdev->params.config.dp_config, config, sizeof(*config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to enable/disable video image stablization
+ */
+int atomisp_video_stable(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value)
+{
+	if (flag == 0)
+		*value = isp_subdev->params.video_dis_en;
+	else
+		isp_subdev->params.video_dis_en = !!*value;
+
+	return 0;
+}
+
+/*
+ * Function to configure fixed pattern noise
+ */
+int atomisp_fixed_pattern(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value)
+{
+
+	if (flag == 0) {
+		*value = isp_subdev->params.fpn_en;
+		return 0;
+	}
+
+	if (*value == 0) {
+		isp_subdev->params.fpn_en = 0;
+		return 0;
+	}
+
+	/* Add function to get black from from sensor with shutter off */
+	return 0;
+}
+
+static unsigned int
+atomisp_bytesperline_to_padded_width(unsigned int bytesperline,
+				     enum ia_css_frame_format format)
+{
+	switch (format) {
+	case IA_CSS_FRAME_FORMAT_UYVY:
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_RAW:
+	case IA_CSS_FRAME_FORMAT_RGB565:
+		return bytesperline/2;
+	case IA_CSS_FRAME_FORMAT_RGBA888:
+		return bytesperline/4;
+	/* The following cases could be removed, but we leave them
+	   in to document the formats that are included. */
+	case IA_CSS_FRAME_FORMAT_NV11:
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV16:
+	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV61:
+	case IA_CSS_FRAME_FORMAT_YV12:
+	case IA_CSS_FRAME_FORMAT_YV16:
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+	case IA_CSS_FRAME_FORMAT_YUV422:
+	case IA_CSS_FRAME_FORMAT_YUV422_16:
+	case IA_CSS_FRAME_FORMAT_YUV444:
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+	case IA_CSS_FRAME_FORMAT_BINARY_8:
+	default:
+		return bytesperline;
+	}
+}
+
+static int
+atomisp_v4l2_framebuffer_to_ia_css_frame(const struct v4l2_framebuffer *arg,
+					 struct ia_css_frame **result)
+{
+	struct ia_css_frame *res;
+	unsigned int padded_width;
+	enum ia_css_frame_format sh_format;
+	char *tmp_buf = NULL;
+	int ret = 0;
+
+	sh_format = v4l2_fmt_to_sh_fmt(arg->fmt.pixelformat);
+	padded_width = atomisp_bytesperline_to_padded_width(
+					arg->fmt.bytesperline, sh_format);
+
+	/* Note: the padded width on an ia_css_frame is in elements, not in
+	   bytes. The RAW frame we use here should always be a 16bit RAW
+	   frame. This is why we bytesperline/2 is equal to the padded with */
+	if (ia_css_frame_allocate(&res, arg->fmt.width, arg->fmt.height,
+				  sh_format, padded_width, 0)) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	tmp_buf = vmalloc(arg->fmt.sizeimage);
+	if (!tmp_buf) {
+		ret = -ENOMEM;
+		goto err;
+	}
+	if (copy_from_user(tmp_buf, (void __user __force *)arg->base,
+			   arg->fmt.sizeimage)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (hmm_store(res->data, tmp_buf, arg->fmt.sizeimage)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+err:
+	if (ret && res)
+		ia_css_frame_free(res);
+	if (tmp_buf)
+		vfree(tmp_buf);
+	if (ret == 0)
+		*result = res;
+	return ret;
+}
+
+/*
+ * Function to configure fixed pattern noise table
+ */
+int atomisp_fixed_pattern_table(struct atomisp_sub_device *isp_subdev,
+				struct v4l2_framebuffer *arg)
+{
+	struct ia_css_frame *raw_black_frame = NULL;
+	int ret;
+
+	if (arg == NULL)
+		return -EINVAL;
+
+	ret = atomisp_v4l2_framebuffer_to_ia_css_frame(arg, &raw_black_frame);
+	if (ret)
+		return ret;
+
+	if (sh_css_set_black_frame(isp_subdev->css2_basis.stream, raw_black_frame) != IA_CSS_SUCCESS)
+		ret = -ENOMEM;
+
+	ia_css_frame_free(raw_black_frame);
+	return ret;
+}
+
+/*
+ * Function to configure false color correction
+ */
+int atomisp_false_color(struct atomisp_sub_device *isp_subdev, int flag, __s32 *value)
+{
+	/* Get nr config from current setup */
+	if (flag == 0) {
+		*value = isp_subdev->params.false_color;
+		return 0;
+	}
+
+	/* Set nr config to isp parameters */
+	if (*value) {
+		isp_subdev->params.config.de_config = NULL;
+	} else {
+		if (!isp_subdev->params.config.de_config)
+			isp_subdev->params.config.de_config = &isp_subdev->params.de_config;
+		isp_subdev->params.config.de_config->pixelnoise = 0;
+	}
+	isp_subdev->params.css_update_params_needed = true;
+	isp_subdev->params.false_color = *value;
+	return 0;
+}
+
+/*
+ * Function to configure bad pixel correction params
+ */
+int atomisp_false_color_param(struct atomisp_sub_device *isp_subdev, int flag,
+			      struct atomisp_de_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.de_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_de_config de_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&de_config, 0, sizeof(struct ia_css_de_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.de_config = &de_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		/* Get false color from current setup */
+		memcpy(config, &de_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.de_config)
+			isp_subdev->params.config.de_config = &isp_subdev->params.de_config;
+		/* Set false color to isp parameters */
+		memcpy(isp_subdev->params.config.de_config, config, sizeof(*config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to configure white balance params
+ */
+int atomisp_white_balance_param(struct atomisp_sub_device *isp_subdev, int flag,
+	struct atomisp_wb_config *config)
+{
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.wb_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_wb_config wb_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&wb_config, 0, sizeof(struct ia_css_wb_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.wb_config = &wb_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		/* Get white balance from current setup */
+		memcpy(config, &wb_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.wb_config)
+			isp_subdev->params.config.wb_config = &isp_subdev->params.wb_config;
+		/* Set white balance to isp parameters */
+		memcpy(isp_subdev->params.config.wb_config, config, sizeof(*config));
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+int atomisp_3a_config_param(struct atomisp_sub_device *isp_subdev, int flag,
+			    struct atomisp_3a_config *config)
+{
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s %d\n", __func__, flag);
+	if (config == NULL)
+		return -EINVAL;
+
+	if (sizeof(*config) != sizeof(isp_subdev->params.config.s3a_config)) {
+		v4l2_err(&atomisp_dev,
+			"%s: incompatible param.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (flag == 0) {
+		struct ia_css_3a_config s3a_config;
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&s3a_config, 0, sizeof(struct ia_css_3a_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.s3a_config = &s3a_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		/* Get white balance from current setup */
+		memcpy(config, &s3a_config, sizeof(*config));
+	} else {
+		if (!isp_subdev->params.config.s3a_config)
+			isp_subdev->params.config.s3a_config = &isp_subdev->params.s3a_config;
+		/* Set white balance to isp parameters */
+		memcpy(isp_subdev->params.config.s3a_config, config, sizeof(*config));
+		isp_subdev->params.css_update_params_needed = true;
+		/* isp_subdev->params.s3a_buf_data_valid = false; */
+	}
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s %d\n", __func__, flag);
+	return 0;
+}
+
+/*
+ * Function to enable/disable lens shading correction
+ */
+int atomisp_shading_correction(struct atomisp_sub_device *isp_subdev, int flag,
+				       __s32 *value)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	if (flag == 0) {
+		*value = isp_subdev->params.sc_en;
+		return 0;
+	}
+
+	if (*value == 0)
+		isp_subdev->params.config.shading_table = NULL;
+	else
+		isp_subdev->params.config.shading_table =
+		    isp->inputs[isp_subdev->input_curr].shading_table;
+
+	isp_subdev->params.sc_en = *value;
+
+	return 0;
+}
+
+/*
+ * Function to setup digital zoom
+ */
+int atomisp_digital_zoom(struct atomisp_sub_device *isp_subdev, int flag, __s32 *value)
+{
+	u32 zoom;
+	unsigned int max_zoom =
+		IS_MRFLD ? MRFLD_MAX_ZOOM_FACTOR : MFLD_MAX_ZOOM_FACTOR;
+
+	if (flag == 0) {
+		struct ia_css_dz_config dz_config;  /**< Digital Zoom */
+		struct ia_css_isp_config isp_config;
+		if (!isp_subdev->css2_basis.stream) {
+			v4l2_err(&atomisp_dev,
+				 "%s called after streamoff, skipping.\n",
+				 __func__);
+			return -EINVAL;
+		}
+		memset(&dz_config, 0, sizeof(struct ia_css_dz_config));
+		memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
+		isp_config.dz_config = &dz_config;
+		ia_css_stream_get_isp_config(isp_subdev->css2_basis.stream, &isp_config);
+		*value = max_zoom - dz_config.dx;
+	} else {
+		if (*value < 0)
+			return -EINVAL;
+
+		zoom = max_zoom - min_t(u32, max_zoom, (*value));
+
+		if (!isp_subdev->params.config.dz_config)
+			isp_subdev->params.config.dz_config = &isp_subdev->params.dz_config;
+
+		if (zoom == isp_subdev->params.config.dz_config->dx &&
+			 zoom == isp_subdev->params.config.dz_config->dy) {
+			v4l2_dbg(3, dbg_level, &atomisp_dev, "same zoom scale. skipped.\n");
+			return 0;
+		}
+
+		memset(isp_subdev->params.config.dz_config, 0, sizeof(struct ia_css_dz_config));
+		isp_subdev->params.dz_config.dx = zoom;
+		isp_subdev->params.dz_config.dy = zoom;
+		v4l2_dbg(3, dbg_level, &atomisp_dev, "%s, zoom: %d\n",
+			 __func__, zoom);
+
+		isp_subdev->params.css_update_params_needed = true;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to get sensor specific info for current resolution,
+ * which will be used for auto exposure conversion.
+ */
+int atomisp_get_sensor_mode_data(struct atomisp_sub_device *isp_subdev,
+				 struct atomisp_sensor_mode_data *config)
+{
+	struct camera_mipi_info *mipi_info;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	mipi_info = atomisp_to_sensor_mipi_info(
+		isp->inputs[isp_subdev->input_curr].camera);
+	if (mipi_info == NULL)
+		return -EINVAL;
+
+	memcpy(config, &mipi_info->data, sizeof(*config));
+	return 0;
+}
+
+int atomisp_get_fmt(struct video_device *vdev, struct v4l2_format *f)
+{
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+	    f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		v4l2_err(&atomisp_dev,
+			    "unsupported v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	memset(f, 0, sizeof(struct v4l2_format));
+	f->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	/* VIDIOC_S_FMT already called,*/
+	/* return fmt set by app */
+	if (pipe->pix.width != 0) {
+		memcpy(&f->fmt.pix, &pipe->pix,
+			sizeof(struct v4l2_pix_format));
+	} else {
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "Pipe width was 0, setting default 640x480\n");
+		f->fmt.pix.width = 640;
+		f->fmt.pix.height = 480;
+		f->fmt.pix.pixelformat = atomisp_output_fmts[0].pixelformat;
+		f->fmt.pix.bytesperline =
+			get_pixel_depth(f->fmt.pix.pixelformat) *
+						f->fmt.pix.width;
+		f->fmt.pix.sizeimage = f->fmt.pix.height *
+						f->fmt.pix.bytesperline;
+		f->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
+	}
+
+	return 0;
+}
+
+
+/* This function looks up the closest available resolution. */
+int atomisp_try_fmt(struct video_device *vdev, struct v4l2_format *f,
+						bool *res_overflow)
+{
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct v4l2_mbus_framefmt snr_mbus_fmt;
+	const struct atomisp_format_bridge *fmt;
+	int ret;
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		v4l2_err(&atomisp_dev, "Wrong v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	if (isp->inputs[isp_subdev->input_curr].camera == NULL)
+		return -EINVAL;
+
+	fmt = atomisp_get_format_bridge(f->fmt.pix.pixelformat);
+	if (fmt == NULL) {
+		v4l2_err(&atomisp_dev, "unsupported pixelformat!\n");
+		fmt = atomisp_output_fmts;
+	}
+
+	if (isp->inputs[isp_subdev->input_curr].type == TEST_PATTERN)
+		return 0;
+	snr_mbus_fmt.code = fmt->mbus_code;
+	snr_mbus_fmt.width = f->fmt.pix.width;
+	snr_mbus_fmt.height = f->fmt.pix.height;
+
+	dev_dbg(isp->dev, "try_mbus_fmt: asking for %ux%u\n",
+		snr_mbus_fmt.width, snr_mbus_fmt.height);
+
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+			video, try_mbus_fmt, &snr_mbus_fmt);
+	if (ret)
+		return ret;
+
+	dev_dbg(isp->dev, "try_mbus_fmt: got %ux%u mbus code = %d\n",
+		snr_mbus_fmt.width, snr_mbus_fmt.height, snr_mbus_fmt.code);
+	fmt = atomisp_get_format_bridge_from_mbus(snr_mbus_fmt.code);
+
+	if (fmt == NULL){
+		v4l2_err(&atomisp_dev, "unknown sensor format.\n");
+		return -EINVAL;
+	}
+
+	f->fmt.pix.pixelformat = fmt->pixelformat;
+
+	if (snr_mbus_fmt.width < f->fmt.pix.width
+	    && snr_mbus_fmt.height < f->fmt.pix.height) {
+		f->fmt.pix.width = snr_mbus_fmt.width;
+		f->fmt.pix.height = snr_mbus_fmt.width;
+		/* Set the flag when resolution requested is
+		 * beyond the max value supported by sensor
+		 */
+		if (res_overflow != NULL)
+			*res_overflow = true;
+	}
+
+	/* app vs isp */
+	f->fmt.pix.width = rounddown(
+		clamp_t(u32, f->fmt.pix.width, ATOM_ISP_MIN_WIDTH,
+			ATOM_ISP_MAX_WIDTH), ATOM_ISP_STEP_WIDTH);
+	f->fmt.pix.height = rounddown(
+		clamp_t(u32, f->fmt.pix.height, ATOM_ISP_MIN_HEIGHT,
+			ATOM_ISP_MAX_HEIGHT), ATOM_ISP_STEP_HEIGHT);
+
+	return 0;
+}
+
+static int
+atomisp_try_fmt_file(struct atomisp_device *isp, struct v4l2_format *f)
+{
+	u32 width = f->fmt.pix.width;
+	u32 height = f->fmt.pix.height;
+	u32 pixelformat = f->fmt.pix.pixelformat;
+	enum v4l2_field field = f->fmt.pix.field;
+	u32 depth;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		v4l2_err(&atomisp_dev, "Wrong v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	if (!atomisp_get_format_bridge(pixelformat)) {
+		v4l2_err(&atomisp_dev, "Wrong output pixelformat\n");
+		return -EINVAL;
+	}
+
+	depth = get_pixel_depth(pixelformat);
+
+	if (!field || field == V4L2_FIELD_ANY)
+		field = V4L2_FIELD_NONE;
+	else if (field != V4L2_FIELD_NONE) {
+		v4l2_err(&atomisp_dev, "Wrong output field\n");
+		return -EINVAL;
+	}
+
+	f->fmt.pix.field = field;
+	f->fmt.pix.width = clamp_t(u32,
+				   rounddown(width, (u32)ATOM_ISP_STEP_WIDTH),
+				   ATOM_ISP_MIN_WIDTH, ATOM_ISP_MAX_WIDTH);
+	f->fmt.pix.height = clamp_t(u32, rounddown(height,
+						   (u32)ATOM_ISP_STEP_HEIGHT),
+				    ATOM_ISP_MIN_HEIGHT, ATOM_ISP_MAX_HEIGHT);
+	f->fmt.pix.bytesperline = (width * depth) >> 3;
+
+	return 0;
+}
+
+static mipi_port_ID_t __get_mipi_port(enum atomisp_camera_port port)
+{
+	switch (port) {
+	case ATOMISP_CAMERA_PORT_PRIMARY:
+		return MIPI_PORT0_ID;
+	case ATOMISP_CAMERA_PORT_SECONDARY:
+		return MIPI_PORT1_ID;
+	case ATOMISP_CAMERA_PORT_THIRD:
+		if (MIPI_PORT1_ID + 1 != N_MIPI_PORT_ID)
+			return MIPI_PORT1_ID + 1;
+		/* go through down for else case */
+	default:
+		v4l2_err(&atomisp_dev, "unsupported port: %d\n", port);
+		return MIPI_PORT0_ID;
+	}
+}
+
+static void __enable_continuous_vf(struct atomisp_sub_device *isp_subdev, bool enable)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	ia_css_capture_set_mode(isp_subdev, IA_CSS_CAPTURE_MODE_PRIMARY);
+	ia_css_capture_enable_online(isp_subdev, !enable);
+	ia_css_preview_enable_online(isp_subdev, !enable);
+	ia_css_enable_continuous(isp_subdev, enable);
+
+	sh_css_enable_cont_capt(enable, enable);
+	if (!enable) {
+		ia_css_enable_raw_binning(isp_subdev, false);
+		ia_css_input_set_two_pixels_per_clock(isp_subdev, false);
+	}
+
+	ia_css_input_set_mode(isp_subdev, get_input_mode(isp->inputs[isp_subdev->input_curr].type, isp));
+}
+
+
+void atomisp_configure_viewfinder(struct atomisp_sub_device *isp_subdev, int width,
+		int height, unsigned int source_pad)
+{
+	if (isp_subdev->fmt_auto->val
+			|| !isp_subdev->enable_vfpp->val) {
+		struct v4l2_rect vf_size;
+		struct v4l2_mbus_framefmt vf_ffmt;
+
+		memset(&vf_size, 0, sizeof(vf_size));
+		if (width < 640 || height < 480) {
+			vf_size.width = width;
+			vf_size.height = height;
+		} else {
+			vf_size.width = 640;
+			vf_size.height = 480;
+		}
+
+		memset(&vf_ffmt, 0, sizeof(vf_ffmt));
+		/* FIXME: proper format name for this one. See
+		   atomisp_output_fmts[] in atomisp_v4l2.c */
+		vf_ffmt.code = 0x8001;
+
+		atomisp_subdev_set_selection(isp_subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SOURCE_VF,
+				V4L2_SEL_TGT_COMPOSE, 0, &vf_size);
+		atomisp_subdev_set_ffmt(isp_subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SOURCE_VF, &vf_ffmt);
+
+		//CSS2.0 supports NV12 as VF format
+		isp_subdev->video_out_vf.sh_fmt = IA_CSS_FRAME_FORMAT_NV12;
+
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO
+				|| !isp_subdev->enable_vfpp->val)
+			ia_css_video_configure_viewfinder(isp_subdev,
+					vf_size.width, vf_size.height,
+					isp_subdev->video_out_vf.sh_fmt);
+		else if (source_pad != ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW)
+			ia_css_capture_configure_viewfinder(isp_subdev,
+					vf_size.width, vf_size.height,
+					isp_subdev->video_out_vf.sh_fmt);
+	}
+}
+
+void atomisp_set_continuous_vf(struct atomisp_sub_device *isp_subdev, enum ia_css_stream_format sh_input_format,
+		unsigned int width, unsigned int height, int *raw_override_p)
+{
+
+	/* get input format */
+	sh_input_format = isp_subdev->css2_basis.stream_config.format;
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "ENTER %s continuous_vf enable?=%d\n",__func__,isp_subdev->params.continuous_vf);
+	if (isp_subdev->params.continuous_vf) {
+		if (isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {
+			__enable_continuous_vf(isp_subdev, true);
+			/* enable only if resolution is equal or above 5M */
+			if (width >= 2576 || height >= 1936) {
+				ia_css_enable_raw_binning(isp_subdev, true);
+				ia_css_input_set_two_pixels_per_clock(isp_subdev, false);
+			}
+		} else {
+			__enable_continuous_vf(isp_subdev, false);
+		}
+	}
+	else if (sh_input_format == IA_CSS_STREAM_FORMAT_RGB_565
+			|| sh_input_format == IA_CSS_STREAM_FORMAT_RGB_888) {
+		/* make sure it sets the right configurations for RGB passthrough FIFO */
+		__enable_continuous_vf(isp_subdev, false);
+		*raw_override_p = 1;
+	}
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "EXIT %s\n",__func__);
+}
+
+
+int atomisp_set_frame_function_pointers(struct atomisp_sub_device *isp_subdev,
+		configure_output_t *configure_output, get_frame_info_t *get_frame_info,
+		configure_pp_input_t *configure_pp_input, unsigned int source_pad,
+		const struct atomisp_format_bridge *format, int raw_override,
+		struct ia_css_frame_info *raw_output_info)
+{
+	if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO
+			|| !isp_subdev->enable_vfpp->val) {
+		*configure_output = ia_css_video_configure_output;
+		*get_frame_info = ia_css_video_get_output_frame_info;
+	} else if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW) {
+		*configure_output = ia_css_preview_configure_output;
+		*get_frame_info = ia_css_preview_get_output_frame_info;
+		*configure_pp_input = ia_css_preview_configure_pp_input;
+	} else {
+		if (format->sh_fmt == IA_CSS_FRAME_FORMAT_RAW || raw_override) {
+			ia_css_capture_set_mode(isp_subdev, IA_CSS_CAPTURE_MODE_RAW);
+		}  else {
+			if (fastboot){
+				ia_css_capture_set_mode(isp_subdev, IA_CSS_CAPTURE_MODE_RAW);
+			}
+			else{
+				ia_css_capture_set_mode(isp_subdev, IA_CSS_CAPTURE_MODE_PRIMARY);
+			}
+		}
+		if (!isp_subdev->params.continuous_vf) {
+			ia_css_capture_enable_online(isp_subdev,
+					isp_subdev->params.online_process);
+		}
+
+		*configure_output = ia_css_capture_configure_output;
+		*get_frame_info = ia_css_capture_get_output_frame_info;
+		*configure_pp_input = ia_css_capture_configure_pp_input;
+
+		if (!isp_subdev->params.online_process && !isp_subdev->params.continuous_vf) {
+			if (ia_css_capture_get_output_raw_frame_info(isp_subdev,
+						raw_output_info)) {
+				return -EINVAL;
+			}
+		}
+		if (!isp_subdev->params.continuous_vf &&
+				isp_subdev->run_mode->val
+				!= ATOMISP_RUN_MODE_STILL_CAPTURE) {
+			v4l2_err(&atomisp_dev,
+					"Need to set the running mode first\n");
+			isp_subdev->run_mode->val =
+				ATOMISP_RUN_MODE_STILL_CAPTURE;
+		}
+	}
+	return 0;
+}
+
+enum ia_css_err configure_pp_input_nop(struct atomisp_sub_device *asd,
+                           unsigned int width, unsigned int height)
+{
+        return 0;
+}
+
+static int atomisp_set_fmt_to_isp(struct video_device *vdev,
+				   struct ia_css_frame_info *output_info,
+				   struct ia_css_frame_info *raw_output_info,
+				   int width, int height,
+				  unsigned int pixelformat,
+				  unsigned int source_pad)
+{
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	const struct atomisp_format_bridge *format;
+	struct v4l2_rect *isp_sink_crop;
+	/*
+	 * Initialized to take care of the warning
+	 */
+	configure_output_t configure_output = 0;
+	get_frame_info_t get_frame_info = 0;
+	configure_pp_input_t configure_pp_input = configure_pp_input_nop;
+
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	int ret;
+	int raw_override = 0;
+	enum ia_css_stream_format sh_input_format = IA_CSS_STREAM_FORMAT_YUV422_8;
+
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "ENTER atomisp_set_fmt_to_isp\n");
+
+	isp_sink_crop = atomisp_subdev_get_rect(
+		isp_subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,
+		ATOMISP_SUBDEV_PAD_SINK, V4L2_SEL_TGT_CROP);
+
+	format = atomisp_get_format_bridge(pixelformat);
+	if (format == NULL)
+		return -EINVAL;
+
+	/*
+	 * Configure viewfinder also if enable_vfpp is disabled: the
+	 * CSS still requires viewfinder configuration.
+	 */
+	atomisp_configure_viewfinder(isp_subdev, width, height, source_pad );
+
+	atomisp_set_continuous_vf(isp_subdev, sh_input_format, width, height, &raw_override);
+
+	ia_css_disable_vf_pp(isp_subdev, !isp_subdev->enable_vfpp->val);
+
+	/* video same in continuouscapture and online modes */
+	ret = atomisp_set_frame_function_pointers(isp_subdev, &configure_output, &get_frame_info,
+                        &configure_pp_input, source_pad, format, raw_override, raw_output_info);
+
+	if( ret < 0) {
+		return ret;
+	}
+
+	ret = configure_output(isp_subdev, width, height, format->sh_fmt);
+	if (ret) {
+		dev_err(isp->dev, "configure_output %ux%u, format %8.8x\n",
+			width, height, format->sh_fmt);
+		return -EINVAL;
+	}
+
+        if (isp_subdev->params.continuous_vf && configure_pp_input == ia_css_preview_configure_pp_input) {
+                /* for isp 2.2, configure pp input is available for continuous
+ *                  * mode */
+                ret = configure_pp_input(isp_subdev, isp_sink_crop->width, isp_sink_crop->height);
+                if (ret) {
+                        dev_err(isp->dev, "configure_pp_input %ux%u\n",
+                                isp_sink_crop->width,
+                                isp_sink_crop->height);
+                        return -EINVAL;
+                }
+        } else {
+                ret = configure_pp_input(isp_subdev, isp_sink_crop->width, isp_sink_crop->height);
+                if (ret) {
+                        dev_err(isp->dev, "configure_pp_input %ux%u\n",isp_sink_crop->width, isp_sink_crop->height);
+                        return -EINVAL;
+                }
+        }
+
+	ret = get_frame_info(isp_subdev, output_info);
+	if (ret) {
+		dev_err(isp->dev, "get_frame_info %ux%u\n", width, height);
+		return -EINVAL;
+	}
+
+	atomisp_update_grid_info(isp_subdev);
+
+	/* Free the raw_dump buffer first */
+	ia_css_frame_free(isp_subdev->raw_output_frame);
+	isp_subdev->raw_output_frame = NULL;
+
+	if (!isp_subdev->params.continuous_vf && !isp_subdev->params.online_process &&
+	    !isp->sw_contex.file_input &&
+	    ia_css_frame_allocate_from_info(&isp_subdev->raw_output_frame,
+					       raw_output_info))
+		return -ENOMEM;
+
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "EXIT atomisp_set_fmt_to_isp\n");
+	return 0;
+}
+
+static void atomisp_get_dis_envelop(struct atomisp_sub_device *isp_subdev,
+			    unsigned int width, unsigned int height,
+			    unsigned int *dvs_env_w,
+			    unsigned int *dvs_env_h)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	/* if subdev type is SOC camera,we do not need to set DVS */
+	if (isp->inputs[isp_subdev->input_curr].type == SOC_CAMERA)
+		isp_subdev->params.video_dis_en = 0;
+
+	if (isp_subdev->params.video_dis_en &&
+	    isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+		/* envelope is 20% of the output resolution */
+		/*
+		 * dvs envelope cannot be round up.
+		 * it would cause ISP timeout and color switch issue
+		 */
+		*dvs_env_w = rounddown(width / 5, ATOM_ISP_STEP_WIDTH);
+		*dvs_env_h = rounddown(height / 5, ATOM_ISP_STEP_HEIGHT);
+	}
+
+	isp_subdev->params.dvs_proj_data_valid = false;
+	isp_subdev->params.css_update_params_needed = true;
+}
+
+static int atomisp_set_fmt_to_subdev(struct atomisp_sub_device *isp_subdev,
+			  struct v4l2_format *f, unsigned int pixelformat,
+			  unsigned int padding_w, unsigned int padding_h,
+			  unsigned int dvs_env_w, unsigned int dvs_env_h)
+{
+	const struct atomisp_format_bridge *format;
+	struct v4l2_mbus_framefmt ffmt;
+	int ret;
+	struct atomisp_device *isp = isp_subdev->isp;
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "ENTER %s \n",__func__);
+
+	format = atomisp_get_format_bridge(pixelformat);
+	if (format == NULL) {
+		trace_printk("atomisp_get_format_bridge failed");
+		return -EINVAL;
+	}
+
+	if (!isp->sw_contex.file_input) {
+	v4l2_fill_mbus_format(&ffmt, &f->fmt.pix, format->mbus_code);
+	ffmt.height += padding_h + dvs_env_h;
+	ffmt.width += padding_w + dvs_env_w;
+
+	dev_dbg(isp->dev, "s_mbus_fmt: ask %ux%u (padding %ux%u, dvs %ux%u) mbus code 0x%0x\n",
+		ffmt.width, ffmt.height, padding_w, padding_h,
+		dvs_env_w, dvs_env_h,format->mbus_code);
+
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera, video,
+			       s_mbus_fmt, &ffmt);
+	if (ret) {
+		trace_printk("v4l2_subdev_call s_mbus_fmt failed");
+		return ret;
+	}
+
+	dev_dbg(isp->dev, "sensor width: %d, height: %d\n",
+			ffmt.width, ffmt.height);
+	}
+	else {	/* file input case */
+		ffmt.width = f->fmt.pix.width;
+		ffmt.height = f->fmt.pix.height;
+		ffmt.code = format->mbus_code;
+	}
+
+	if (ffmt.width < ATOM_ISP_STEP_WIDTH ||
+	    ffmt.height < ATOM_ISP_STEP_HEIGHT)
+			return -EINVAL;
+
+	return atomisp_subdev_set_ffmt(isp_subdev, NULL,
+				       V4L2_SUBDEV_FORMAT_ACTIVE,
+				       ATOMISP_SUBDEV_PAD_SINK, &ffmt);
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "EXIT %s \n",__func__);
+}
+
+uint16_t atomisp_set_source_pad(enum atomisp_pipe_type pipe_type, uint16_t *source_pad)
+{
+	switch (pipe_type) {
+	case ATOMISP_PIPE_CAPTURE:
+		*source_pad = ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE;
+		break;
+	case ATOMISP_PIPE_VIEWFINDER:
+		*source_pad = ATOMISP_SUBDEV_PAD_SOURCE_VF;
+		break;
+	case ATOMISP_PIPE_PREVIEW:
+		*source_pad = ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+void atomisp_set_viewfinder_frame_info(struct v4l2_format *f, struct atomisp_sub_device *isp_subdev,
+		uint16_t source_pad, const struct atomisp_format_bridge *format_bridge,
+		struct ia_css_frame_info *output_info)
+{
+	isp_subdev->video_pipe_vf_enable = true;
+
+	if (isp_subdev->fmt_auto->val) {
+		struct v4l2_rect *capture_comp =
+			atomisp_subdev_get_rect(
+					isp_subdev, NULL,
+					V4L2_SUBDEV_FORMAT_ACTIVE,
+					ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE,
+					V4L2_SEL_TGT_COMPOSE);
+		struct v4l2_rect r;
+
+		memset(&r, 0, sizeof(r));
+
+		r.width = f->fmt.pix.width;
+		r.height = f->fmt.pix.height;
+
+		if (capture_comp->width < r.width
+				|| capture_comp->height < r.height) {
+			r.width = capture_comp->width;
+			r.height = capture_comp->height;
+		}
+
+		atomisp_subdev_set_selection(
+				isp_subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE, source_pad,
+				V4L2_SEL_TGT_COMPOSE, 0, &r);
+
+		f->fmt.pix.width = r.width;
+		f->fmt.pix.height = r.height;
+	}
+
+	if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+		ia_css_video_configure_viewfinder(isp_subdev,
+				f->fmt.pix.width, f->fmt.pix.height,
+				format_bridge->sh_fmt);
+		ia_css_video_get_viewfinder_frame_info(isp_subdev, output_info);
+	} else {
+		ia_css_capture_configure_viewfinder(isp_subdev,
+				f->fmt.pix.width, f->fmt.pix.height,
+				format_bridge->sh_fmt);
+		ia_css_capture_get_viewfinder_frame_info(isp_subdev, output_info);
+	}
+}
+
+static enum ia_css_stream_format convert_pixel_format_to_stream_format(unsigned int pixelformat)
+{
+	switch(pixelformat)
+	{
+		case V4L2_PIX_FMT_YUV422P:
+			return IA_CSS_STREAM_FORMAT_YUV422_8;
+		case V4L2_PIX_FMT_RGB565:
+			return IA_CSS_STREAM_FORMAT_RGB_565;
+		case V4L2_PIX_FMT_RGB24:
+			return IA_CSS_STREAM_FORMAT_RGB_888;
+		case V4L2_PIX_FMT_UYVY:
+			return IA_CSS_STREAM_FORMAT_YUV422_8;
+		case V4L2_PIX_FMT_SGRBG10:
+		    return IA_CSS_STREAM_FORMAT_RAW_10;
+		default:
+			return -EINVAL;
+	}
+}
+
+static enum ia_css_frame_format convert_pixel_format_to_frame_format(unsigned int pixelformat)
+{
+	switch(pixelformat)
+	{
+		case V4L2_PIX_FMT_YUV422P:
+			return IA_CSS_FRAME_FORMAT_YUV422;
+		case V4L2_PIX_FMT_RGB565:
+			return IA_CSS_FRAME_FORMAT_RGB565;
+		case V4L2_PIX_FMT_RGB24:
+			return IA_CSS_FRAME_FORMAT_RGBA888;
+		case V4L2_PIX_FMT_UYVY:
+			return IA_CSS_FRAME_FORMAT_UYVY;
+		case V4L2_PIX_FMT_NV12:
+			return IA_CSS_FRAME_FORMAT_NV12;
+		case V4L2_PIX_FMT_SGRBG10:
+		    return IA_CSS_FRAME_FORMAT_RAW;
+		default:
+			return -EINVAL;
+	}
+}
+
+unsigned int atomisp_try_mipi_frame_buffer_size(struct atomisp_sub_device *isp_subdev, unsigned int width, unsigned int height, unsigned int pixelformat)
+{
+        unsigned int input_buffer_size = width * height * DIV_ROUND_UP(get_pixel_depth(pixelformat),8);
+
+        if(!(input_buffer_size <= ATOMISP_MIPI_BUFFER_SIZE * HIVE_ISP_DDR_WORD_BYTES))
+        {
+                return -EINVAL;
+        }
+
+        return 0;
+}
+
+int atomisp_configure_isp_subdev_input(struct v4l2_format *format,
+		struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	enum ia_css_stream_format css_fmt;
+	struct v4l2_mbus_framefmt snr_mbus_fmt;
+	int ret;
+	unsigned int width = format->fmt.pix.width;
+	unsigned int height = format->fmt.pix.height;
+	const struct atomisp_format_bridge *format_bridge;
+
+        v4l2_dbg(6 , dbg_level, &atomisp_dev, " >%s \n", __func__);
+	css_fmt = convert_pixel_format_to_stream_format(format->fmt.pix.pixelformat);
+	format_bridge = atomisp_get_format_bridge(format->fmt.pix.pixelformat);
+
+	if(css_fmt == -EINVAL)
+	{
+		dev_err(isp->dev, "pixelformat error!!\n");
+		return css_fmt;
+	}
+
+	if (format_bridge == NULL) {
+		dev_err(isp->dev, "atomisp_get_format_bridge failed");
+		return -EINVAL;
+	}
+
+	isp_subdev->css2_basis.stream_config.input_res.width = width;
+        isp_subdev->css2_basis.stream_config.input_res.height = height;
+
+        isp_subdev->css2_basis.stream_config.effective_res.width = width;
+        isp_subdev->css2_basis.stream_config.effective_res.height = height;
+
+        isp_subdev->css2_basis.stream_config.format =
+                (enum ia_css_stream_format)css_fmt;
+
+        if(atomisp_try_mipi_frame_buffer_size(isp_subdev, width, height, format->fmt.pix.pixelformat))
+        {
+                v4l2_err(&atomisp_dev, "ERROR: Input frame buffer size is larger than the allocated intermediate MIPI buffers:[%x0x]\n",ATOMISP_MIPI_BUFFER_SIZE);
+                return -EINVAL;
+        }
+
+	//configure sensor output format&resolution
+	v4l2_fill_mbus_format(&snr_mbus_fmt, &format->fmt.pix,
+			format_bridge->mbus_code);
+
+	ret = v4l2_subdev_call(
+			isp->inputs[isp_subdev->input_curr].camera,
+			video, s_mbus_fmt, &snr_mbus_fmt);
+	if (ret) {
+		v4l2_err(&atomisp_dev, "ERROR v4l2_subdev_call, s_mbus_fmt\n");
+	}
+
+        v4l2_dbg(6 , dbg_level, &atomisp_dev, " <%s \n", __func__);
+	return 0;
+}
+
+static void atomisp_configure_isp_port(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct camera_mipi_info *mipi_info;
+	mipi_info = atomisp_to_sensor_mipi_info(
+			isp->inputs[isp_subdev->input_curr].camera);
+	isp_subdev->css2_basis.stream_config.source.port.port = __get_mipi_port(mipi_info->port);
+	isp_subdev->css2_basis.stream_config.source.port.num_lanes = mipi_info->num_lanes;
+	isp_subdev->css2_basis.stream_config.source.port.timeout = 0xffff4;
+}
+
+static void atomisp_configure_isp_subdev_misc(struct atomisp_sub_device *isp_subdev, uint16_t source_pad)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+
+        v4l2_dbg(6 , dbg_level, &atomisp_dev, " >%s \n", __func__);
+	ia_css_input_set_mode(isp_subdev, get_input_mode(isp->inputs[isp_subdev->input_curr].type, isp));
+	ia_css_capture_set_mode(isp_subdev, IA_CSS_CAPTURE_MODE_RAW);
+
+	/* Only main stream pipe will be here */
+	isp_subdev->capture_pad = source_pad;
+        v4l2_dbg(6 , dbg_level, &atomisp_dev, " <%s \n", __func__);
+}
+
+static int atomisp_configure_isp_subdev_output(struct v4l2_format *format,
+		struct atomisp_sub_device *isp_subdev, struct ia_css_frame_info *output_info)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	unsigned int width = format->fmt.pix.width;
+	unsigned int height = format->fmt.pix.height;
+	enum ia_css_frame_format frame_format;
+
+        v4l2_dbg(6 , dbg_level, &atomisp_dev, " >%s \n", __func__);
+	frame_format = convert_pixel_format_to_frame_format(format->fmt.pix.pixelformat);
+
+	if(frame_format == -EINVAL)
+		dev_err(isp->dev, "pixelformat error!!\n");
+
+	if (ia_css_capture_configure_output(isp_subdev, width, height, frame_format))
+	{
+		v4l2_err(&atomisp_dev, "ERROR: css_capture_configure_output failed\n");
+		return -EINVAL;
+	}
+
+	//This should create a port if it does not exist
+	if (ia_css_capture_get_output_frame_info(isp_subdev, output_info)) {
+		v4l2_err(&atomisp_dev, "ERROR: ia_css_capture_get_output_frame_info failed\n");
+	}
+	trace_printk("Returned from get_css_frame_info, output_info.padded_width=%d\n", output_info->padded_width);
+
+	if(output_info->padded_width!= width)
+	{
+		v4l2_dbg(4,dbg_level,&atomisp_dev,"padded width is not equal to set width. Resetting the requested format\n");
+		format->fmt.pix.width = output_info->padded_width;
+	}
+
+        v4l2_dbg(6 , dbg_level, &atomisp_dev, " <%s \n", __func__);
+	return 0;
+}
+
+/*
+ * Check whether main resolution configured smaller
+ * than snapshot resolution. If so, force main resolution
+ * to be the same as snapshot resolution
+ */
+void atomisp_check_resolution(uint16_t source_pad,struct video_device *vdev, struct v4l2_format *f)
+{
+
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE) {
+		struct v4l2_rect *r;
+
+		r = atomisp_subdev_get_rect(
+				isp_subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SOURCE_VF, V4L2_SEL_TGT_COMPOSE);
+
+		if (r->width && r->height
+				&& (r->width > f->fmt.pix.width
+					|| r->height > f->fmt.pix.height))
+			dev_warn(isp->dev,
+					"Main Resolution config smaller then Vf Resolution. Force to be equal with Vf Resolution.");
+	}
+}
+/*
+ * Get sensor resolution and format
+ */
+void atomisp_get_sensor_attributes(struct video_device *vdev, struct v4l2_format *f,
+		bool *res_overflow, struct v4l2_format *snr_fmt)
+{
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	/* get sensor resolution and format */
+	if (!isp->sw_contex.file_input) {
+		atomisp_try_fmt(vdev, snr_fmt, res_overflow);
+		f->fmt.pix.width = snr_fmt->fmt.pix.width;
+		f->fmt.pix.height = snr_fmt->fmt.pix.height;
+	}
+	else {
+		snr_fmt->fmt.pix.width = f->fmt.pix.width;
+		snr_fmt->fmt.pix.height = f->fmt.pix.height;
+	}
+}
+
+/*
+ * Set mbus codes for bypass mode configuration, but do
+ * nothing else.
+ */
+void atomisp_set_bypass_mode_mbus_codes(struct atomisp_sub_device *isp_subdev, struct v4l2_format *snr_fmt,
+		struct v4l2_format *f, struct v4l2_mbus_framefmt *isp_sink_fmt,
+		uint16_t source_pad)
+{
+	struct v4l2_mbus_framefmt isp_source_fmt;
+	struct atomisp_format_bridge *snr_fmt_bridge = atomisp_get_format_bridge(snr_fmt->fmt.pix.pixelformat);
+	struct atomisp_format_bridge *fmt_bridge = atomisp_get_format_bridge(f->fmt.pix.pixelformat);
+
+	if(snr_fmt_bridge != NULL)
+		atomisp_subdev_get_ffmt(isp_subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SINK)->code = snr_fmt_bridge->mbus_code;
+
+	isp_sink_fmt = atomisp_subdev_get_ffmt(isp_subdev, NULL,
+			V4L2_SUBDEV_FORMAT_ACTIVE,
+			ATOMISP_SUBDEV_PAD_SINK);
+
+	memset(&isp_source_fmt, 0, sizeof(isp_source_fmt));
+	if(fmt_bridge != NULL)
+		isp_source_fmt.code = fmt_bridge->mbus_code;
+	atomisp_subdev_set_ffmt(isp_subdev, NULL,
+			V4L2_SUBDEV_FORMAT_ACTIVE,
+			source_pad, &isp_source_fmt);
+}
+
+/*
+ * construct resolution supported by isp
+ */
+void atomisp_construct_supported_resolution(bool res_overflow, struct atomisp_sub_device *isp_subdev,
+		struct v4l2_format *f, 	unsigned int padding_w, unsigned int padding_h)
+{
+	if (res_overflow && !isp_subdev->params.continuous_vf) {
+		f->fmt.pix.width = rounddown(
+				clamp_t(u32, f->fmt.pix.width - padding_w,
+					ATOM_ISP_MIN_WIDTH,
+					ATOM_ISP_MAX_WIDTH), ATOM_ISP_STEP_WIDTH);
+		f->fmt.pix.height = rounddown(
+				clamp_t(u32, f->fmt.pix.height - padding_h,
+					ATOM_ISP_MIN_HEIGHT,
+					ATOM_ISP_MAX_HEIGHT), ATOM_ISP_STEP_HEIGHT);
+
+	}
+}
+
+/*
+ * Try to enable YUV downscaling if ISP input is 10 % (either
+ * width or height) bigger than the desired result.
+ */
+void atomisp_yuv_downscaling(struct v4l2_rect *isp_sink_crop, struct v4l2_format *f,
+		struct atomisp_device *isp, struct atomisp_sub_device *isp_subdev,
+		uint16_t source_pad, unsigned int padding_w, unsigned int padding_h)
+{
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "ENTER %s run_mode=%d , width=%d, height=%d\n",__func__,isp_subdev->run_mode->val,f->fmt.pix.width,f->fmt.pix.height);
+	if (isp_sink_crop->width * 9 / 10 < f->fmt.pix.width
+			|| isp_sink_crop->height * 9 / 10 < f->fmt.pix.height
+			|| isp->sw_contex.file_input
+			|| (isp->sw_contex.bypass
+				&& isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO
+				&& isp_subdev->enable_vfpp->val)
+			|| (!isp->sw_contex.bypass
+				&& isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)) {
+		isp_sink_crop->width = f->fmt.pix.width;
+		isp_sink_crop->height = f->fmt.pix.height;
+		atomisp_subdev_set_selection(isp_subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SINK,
+				V4L2_SEL_TGT_CROP,
+				V4L2_SEL_FLAG_KEEP_CONFIG,
+				isp_sink_crop);
+		v4l2_dbg(5, dbg_level, &atomisp_dev, "%s: isp_sink_crop width=%d, height=%d\n",__func__,isp_sink_crop->width,isp_sink_crop->width);
+		atomisp_subdev_set_selection(isp_subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				source_pad, V4L2_SEL_TGT_COMPOSE,
+				0, isp_sink_crop);
+	} else {
+		struct v4l2_rect main_compose;
+
+		memset(&main_compose, 0, sizeof(main_compose));
+
+		main_compose.width = isp_sink_crop->width - padding_w;
+		main_compose.height =
+			DIV_ROUND_UP(main_compose.width * f->fmt.pix.height,
+					f->fmt.pix.width);
+		if (main_compose.height > isp_sink_crop->height - padding_h) {
+			main_compose.height = isp_sink_crop->height - padding_h;
+			main_compose.width =
+				DIV_ROUND_UP(main_compose.height *
+						f->fmt.pix.width,
+						f->fmt.pix.height);
+		}
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "%s: main_compose width=%d, height=%d\n",__func__,main_compose.width,main_compose.height);
+		atomisp_subdev_set_selection(isp_subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE,
+				V4L2_SEL_TGT_COMPOSE, 0,
+				&main_compose);
+	}
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "EXIT %s \n",__func__);
+}
+
+void atomisp_set_video_pipe(struct video_device *vdev, struct v4l2_format *format,
+			struct ia_css_frame_info output_info, struct atomisp_sub_device *isp_subdev,
+			const struct atomisp_format_bridge *format_bridge)
+{
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+
+	pipe->pix.width = format->fmt.pix.width;
+	pipe->pix.height = format->fmt.pix.height;
+	pipe->pix.pixelformat = format->fmt.pix.pixelformat;
+	pipe->pix.bytesperline =
+		DIV_ROUND_UP(format_bridge->depth * output_info.padded_width,
+			     8);
+	pipe->pix.sizeimage =
+	    PAGE_ALIGN(format->fmt.pix.height * pipe->pix.bytesperline);
+	if (format->fmt.pix.field == V4L2_FIELD_ANY)
+		format->fmt.pix.field = V4L2_FIELD_NONE;
+	pipe->pix.field = format->fmt.pix.field;
+
+	format->fmt.pix = pipe->pix;
+	format->fmt.pix.priv = PAGE_ALIGN(pipe->pix.width *
+				     pipe->pix.height * 2);
+
+	/*
+	 * If in video 480P case, no GFX throttle
+	 */
+	if (pipe->pipe_type == ATOMISP_PIPE_CAPTURE) {
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&
+		    format->fmt.pix.width == 720 && format->fmt.pix.height == 480) {
+			isp->need_gfx_throttle = false;
+		}
+		else {
+			isp->need_gfx_throttle = true;
+		}
+	}
+}
+int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *format)
+{
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	const struct atomisp_format_bridge *format_bridge;
+	struct ia_css_frame_info output_info, raw_output_info;
+	struct v4l2_format snr_fmt = *format;
+	unsigned int dvs_env_w = 0,
+		     dvs_env_h = 0;
+	unsigned int padding_w = pad_w,
+		     padding_h = pad_h;
+	bool res_overflow = false;
+	struct v4l2_mbus_framefmt isp_sink_fmt;
+	struct v4l2_rect isp_sink_crop;
+	uint16_t source_pad;
+	int ret;
+
+	trace_printk("ENTER DMA atomisp_set_fmt\n");
+
+	if (format->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+	    format->type != V4L2_BUF_TYPE_PRIVATE) {
+		v4l2_err(&atomisp_dev, "Wrong v4l2 buf type\n");
+		trace_printk("Wrong v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	format_bridge = atomisp_get_format_bridge(format->fmt.pix.pixelformat);
+	if (format_bridge == NULL) {
+		trace_printk("Format bridge is NULL\n");
+		return -EINVAL;
+	}
+
+	pipe->sh_fmt = format_bridge->sh_fmt;
+	pipe->pix.pixelformat = format->fmt.pix.pixelformat;
+
+	ret = atomisp_set_source_pad(pipe->pipe_type, &source_pad);
+	if( ret < 0 ) {
+		dev_err(isp->dev, "can't get source pad");
+		return ret;
+	}
+
+	atomisp_configure_isp_port(isp_subdev);
+
+	dev_dbg(isp->dev, "setting resolution %ux%u on pad %u\n",
+		format->fmt.pix.width, format->fmt.pix.height, source_pad);
+
+	if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_VF
+	    || (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW
+		&& isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)) {
+                atomisp_set_viewfinder_frame_info(format, isp_subdev, source_pad, format_bridge, &output_info);
+		goto done;
+	}
+
+	if(source_pad == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE && !(isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO) && !(source_pad == ATOMISP_SUBDEV_PAD_SOURCE_VF) && !isp->sw_contex.file_input)
+	{
+
+		if (!isp_subdev->css2_basis.stream_config.input_res.width) {
+		if(-EINVAL == atomisp_configure_isp_subdev_input(format, isp_subdev)) {
+			return -EINVAL;
+		}
+		}
+		atomisp_configure_isp_subdev_misc(isp_subdev, source_pad);
+
+		if(-EINVAL == atomisp_configure_isp_subdev_output(format, isp_subdev, &output_info)) {
+			return -EINVAL;
+		}
+
+		goto done;
+	}
+
+	/* Check main resolution against configured resolution*/
+	atomisp_check_resolution(source_pad, vdev, format);
+
+	/* V4L2_BUF_TYPE_PRIVATE will set offline processing */
+	if (format->type == V4L2_BUF_TYPE_PRIVATE)
+		isp_subdev->params.online_process = 0;
+	else
+		isp_subdev->params.online_process = 1;
+
+	/* Pipeline configuration done through subdevs. Bail out now. */
+	if (!isp_subdev->fmt_auto->val)
+		goto done;
+
+	/* get sensor resolution and format */
+	atomisp_get_sensor_attributes(vdev, format, &res_overflow, &snr_fmt);
+
+
+	/* Set mbus codes for bypass mode configuration */
+	atomisp_set_bypass_mode_mbus_codes(isp_subdev, &snr_fmt,
+			format, &isp_sink_fmt, source_pad);
+
+	if (isp->sw_contex.bypass)
+		padding_w = 0, padding_h = 0;
+
+	/* construct resolution supported by isp */
+	atomisp_construct_supported_resolution(res_overflow, isp_subdev, format,
+			padding_w, padding_h);
+
+	atomisp_get_dis_envelop(isp_subdev, format->fmt.pix.width, format->fmt.pix.height,
+				&dvs_env_w, &dvs_env_h);
+
+	/*
+	 * set format info to sensor
+	 * In case of continuous_vf, resolution is set only if it is higher than
+	 * existing value. This because preview pipe will be configured after
+	 * capture pipe and usually has lower resolution than capture pipe.
+	 */
+
+	if (!isp_subdev->params.continuous_vf ||
+	    isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||
+	    (isp_sink_fmt.width < (format->fmt.pix.width + padding_w + dvs_env_w) &&
+	     isp_sink_fmt.height < (format->fmt.pix.height + padding_h +
+				    dvs_env_h))) {
+			/*ret = atomisp_set_fmt_to_subdev(isp_subdev, format, format->fmt.pix.pixelformat,
+					     padding_w, padding_h,
+					     dvs_env_w, dvs_env_h);*/
+		if (ret) {
+			trace_printk("atomisp_set_fmt_to_subdev failed\n");
+			return -EINVAL;
+		}
+	}
+
+	isp_sink_crop = *atomisp_subdev_get_rect(isp_subdev, NULL,
+						 V4L2_SUBDEV_FORMAT_ACTIVE,
+						 ATOMISP_SUBDEV_PAD_SINK,
+						 V4L2_SEL_TGT_CROP);
+
+
+	/* Try to enable YUV downscaling if ISP input is 10 % (either
+	 * width or height) bigger than the desired result. */
+	atomisp_yuv_downscaling(&isp_sink_crop, format, isp, isp_subdev, source_pad,
+			padding_w, padding_h);
+
+	/* set format to isp */
+	ret = atomisp_set_fmt_to_isp(vdev, &output_info, &raw_output_info,
+				     format->fmt.pix.width, format->fmt.pix.height,
+				     format->fmt.pix.pixelformat, source_pad);
+	if (ret) {
+		trace_printk("atomisp_set_fmt_to_isp failed\n");
+		return -EINVAL;
+	}
+done:
+	atomisp_update_run_mode(isp_subdev);
+	atomisp_set_video_pipe(vdev, format, output_info, isp_subdev, format_bridge);
+	trace_printk("EXIT DMA atomisp_set_fmt\n");
+	return 0;
+}
+
+int atomisp_set_fmt_file(struct video_device *vdev, struct v4l2_format *f)
+{
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	enum ia_css_stream_format sh_input_format;
+	int ret = 0;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		v4l2_err(&atomisp_dev,
+				"Wrong v4l2 buf type for output\n");
+		return -EINVAL;
+	}
+
+	ret = atomisp_try_fmt_file(isp, f);
+	if (ret)
+		return ret;
+
+		pipe->pix = f->fmt.pix;
+	sh_input_format = get_sh_input_format(
+						pipe->pix.pixelformat);
+	if (sh_input_format == -EINVAL) {
+		v4l2_err(&atomisp_dev,
+				"Wrong v4l2 format for output\n");
+		return -EINVAL;
+	}
+
+	isp_subdev->css2_basis.stream_config.format = sh_input_format;
+	isp_subdev->css2_basis.stream_config.mode = IA_CSS_INPUT_MODE_FIFO;
+	isp_subdev->css2_basis.stream_config.bayer_order = 0; /* TODO set real value */
+	isp_subdev->css2_basis.stream_config.source.port.port = __get_mipi_port(ATOMISP_CAMERA_PORT_PRIMARY);
+	isp_subdev->css2_basis.stream_config.source.port.num_lanes = 2;
+	isp_subdev->css2_basis.stream_config.source.port.timeout = 0xffff4;
+	return 0;
+}
+
+void atomisp_free_all_shading_tables(struct atomisp_device *isp)
+{
+	int i;
+
+	for (i = 0; i < isp->input_cnt; i++) {
+		if (isp->inputs[i].shading_table == NULL)
+			continue;
+		ia_css_shading_table_free(isp->inputs[i].shading_table);
+		isp->inputs[i].shading_table = NULL;
+	}
+}
+
+int atomisp_set_shading_table(struct atomisp_sub_device *isp_subdev,
+		struct atomisp_shading_table *user_shading_table)
+{
+	struct ia_css_shading_table *shading_table;
+	struct ia_css_shading_table *free_table;
+	unsigned int len_table;
+	int i;
+	int ret = 0;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (!user_shading_table)
+		return -EINVAL;
+
+	if (user_shading_table->flags & ATOMISP_SC_FLAG_QUERY) {
+		user_shading_table->enable = isp_subdev->params.sc_en;
+		return 0;
+	}
+
+	if (!user_shading_table->enable) {
+		isp_subdev->params.config.shading_table = NULL;
+		isp_subdev->params.sc_en = 0;
+		return 0;
+	}
+
+	/* If enabling, all tables must be set */
+	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
+		if (!user_shading_table->data[i])
+			return -EINVAL;
+	}
+
+	/* Shading table size per color */
+	if (user_shading_table->width > SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR ||
+	    user_shading_table->height > SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR)
+		return -EINVAL;
+
+	shading_table = ia_css_shading_table_alloc(user_shading_table->width,
+						   user_shading_table->height);
+	if (!shading_table)
+		return -ENOMEM;
+
+	len_table = user_shading_table->width * user_shading_table->height *
+		    ATOMISP_SC_TYPE_SIZE;
+	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
+		ret = copy_from_user(shading_table->data[i],
+				     user_shading_table->data[i], len_table);
+		if (ret) {
+			free_table = shading_table;
+			ret = -EFAULT;
+			goto out;
+		}
+	}
+	shading_table->sensor_width = user_shading_table->sensor_width;
+	shading_table->sensor_height = user_shading_table->sensor_height;
+	shading_table->fraction_bits = user_shading_table->fraction_bits;
+
+	free_table = isp->inputs[isp_subdev->input_curr].shading_table;
+	isp->inputs[isp_subdev->input_curr].shading_table = shading_table;
+	isp_subdev->params.config.shading_table = shading_table;
+	isp_subdev->params.sc_en = 1;
+
+out:
+	if (free_table != NULL)
+		ia_css_shading_table_free(free_table);
+
+	return ret;
+}
+
+/*Turn off ISP dphy */
+int atomisp_ospm_dphy_down(struct atomisp_device *isp)
+{
+	u32 pwr_cnt = 0;
+	int timeout = 100;
+	bool idle;
+	u32 reg;
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "%s\n", __func__);
+
+	/* if ISP timeout, we can force powerdown */
+	if (isp->isp_timeout)
+		goto done;
+
+	if (!atomisp_dev_users(isp))
+		goto done;
+
+	idle = sh_css_hrt_system_is_idle();
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "%s system_is_idle:%d\n", __func__, idle);
+	while (!idle && timeout--) {
+		udelay(20);
+		idle = sh_css_hrt_system_is_idle();
+	}
+
+	if (timeout < 0) {
+		v4l2_err(&atomisp_dev,
+			 "Timeout to stop ISP HW\n");
+		/* force power down here */
+	}
+
+done:
+	if (IS_MRFLD) {
+		/*
+		 * MRFLD IUNIT DPHY is located in an always-power-on island
+		 * MRFLD HW design need all CSI ports are disabled before
+		 * powering down the IUNIT.
+		 */
+		pci_read_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, &reg);
+		reg |= MRFLD_ALL_CSI_PORTS_OFF_MASK;
+		pci_write_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, reg);
+	} else {
+		/* power down DPHY */
+		pwr_cnt = intel_mid_msgbus_read32(MFLD_IUNITPHY_PORT,
+							MFLD_CSI_CONTROL);
+		pwr_cnt |= 0x300;
+		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT,
+						MFLD_CSI_CONTROL, pwr_cnt);
+	}
+
+	isp->sw_contex.power_state = ATOM_ISP_POWER_DOWN;
+	return 0;
+}
+
+/*Turn on ISP dphy */
+int atomisp_ospm_dphy_up(struct atomisp_device *isp)
+{
+	u32 pwr_cnt = 0;
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "%s\n", __func__);
+
+	/* MRFLD IUNIT DPHY is located in an always-power-on island */
+	if (!IS_MRFLD) {
+		/* power on DPHY */
+		pwr_cnt = intel_mid_msgbus_read32(MFLD_IUNITPHY_PORT,
+							MFLD_CSI_CONTROL);
+		pwr_cnt &= ~0x300;
+		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT,
+						MFLD_CSI_CONTROL, pwr_cnt);
+	}
+
+	isp->sw_contex.power_state = ATOM_ISP_POWER_UP;
+
+	return 0;
+}
+
+
+int atomisp_exif_makernote(struct atomisp_sub_device *isp_subdev,
+			   struct atomisp_makernote_info *config)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct v4l2_control ctrl;
+
+	ctrl.id = V4L2_CID_FOCAL_ABSOLUTE;
+	if (v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				 core, g_ctrl, &ctrl))
+		v4l2_warn(&atomisp_dev, "failed to g_ctrl for focal length\n");
+	else
+		config->focal_length = ctrl.value;
+
+	ctrl.id = V4L2_CID_FNUMBER_ABSOLUTE;
+	if (v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				core, g_ctrl, &ctrl))
+		v4l2_warn(&atomisp_dev, "failed to g_ctrl for f-number\n");
+	else
+		config->f_number_curr = ctrl.value;
+
+	ctrl.id = V4L2_CID_FNUMBER_RANGE;
+	if (v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				core, g_ctrl, &ctrl))
+		v4l2_warn(&atomisp_dev,
+				"failed to g_ctrl for f number range\n");
+	else
+		config->f_number_range = ctrl.value;
+
+	return 0;
+}
+
+int atomisp_offline_capture_configure(struct atomisp_sub_device *isp_subdev,
+			      struct atomisp_cont_capture_conf *cvf_config)
+{
+	isp_subdev->params.offline_parm = *cvf_config;
+	if (isp_subdev->params.offline_parm.num_captures) {
+		if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_DISABLED) {
+			int num_raw_frames =
+				min_t(int, ATOMISP_CONT_RAW_FRAMES,
+				      isp_subdev->params.offline_parm.num_captures
+				      + 3);
+
+			ia_css_stream_set_buffer_depth(isp_subdev->css2_basis.stream,
+							num_raw_frames);
+		}
+
+		isp_subdev->params.continuous_vf = true;
+	} else {
+		isp_subdev->params.continuous_vf = false;
+		__enable_continuous_vf(isp_subdev, false);
+	}
+
+	return 0;
+}
+
+int atomisp_flash_enable(struct atomisp_sub_device *isp_subdev, int num_frames)
+{
+	if (num_frames < 0) {
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "%s ERROR: num_frames: %d\n", __func__, num_frames);
+		return -EINVAL;
+	}
+	/* a requested flash is still in progress. */
+	if (num_frames && isp_subdev->params.flash_state != ATOMISP_FLASH_IDLE) {
+		v4l2_dbg(3, dbg_level, &atomisp_dev, "%s flash busy: %d frames left: %d\n",__func__,
+				isp_subdev->params.flash_state,
+				isp_subdev->params.num_flash_frames);
+		return -EBUSY;
+	}
+
+	isp_subdev->params.num_flash_frames = num_frames;
+	isp_subdev->params.flash_state = ATOMISP_FLASH_REQUESTED;
+	return 0;
+}
+
+/* Added msgbus functions */
+static DEFINE_SPINLOCK(msgbus_lock);
+
+static struct pci_dev *pci_root;
+
+int intel_mid_msgbus_init(void)
+{
+        pci_root = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
+        if (!pci_root) {
+                v4l2_err(&atomisp_dev, "%s: Error: msgbus PCI handle NULL", __func__);
+                return -ENODEV;
+        }
+        return 0;
+}
+
+u32 intel_mid_msgbus_read32_raw(u32 cmd)
+{
+        unsigned long irq_flags;
+        u32 data;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        pci_read_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, &data);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+
+        return data;
+}
+
+void intel_mid_msgbus_write32_raw(u32 cmd, u32 data)
+{
+        unsigned long irq_flags;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+}
+
+u32 intel_mid_msgbus_read32(u8 port, u32 addr)
+{
+        unsigned long irq_flags;
+        u32 data;
+        u32 cmd;
+        u32 cmdext;
+
+        cmd = (PCI_ROOT_MSGBUS_READ << 24) | (port << 16) |
+                ((addr & 0xff) << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+        cmdext = addr & 0xffffff00;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+
+        if (cmdext) {
+                /* This resets to 0 automatically, no need to write 0 */
+                pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_EXT_REG,
+                        cmdext);
+        }
+
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        pci_read_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, &data);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+
+        return data;
+}
+
+void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data)
+{
+        unsigned long irq_flags;
+        u32 cmd;
+        u32 cmdext;
+
+        cmd = (PCI_ROOT_MSGBUS_WRITE << 24) | (port << 16) |
+                ((addr & 0xFF) << 8) | PCI_ROOT_MSGBUS_DWORD_ENABLE;
+        cmdext = addr & 0xffffff00;
+
+        spin_lock_irqsave(&msgbus_lock, irq_flags);
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
+
+        if (cmdext) {
+                /* This resets to 0 automatically, no need to write 0 */
+                pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_EXT_REG,
+                        cmdext);
+        }
+
+        pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
+        spin_unlock_irqrestore(&msgbus_lock, irq_flags);
+}
diff --git a/drivers/media/atomisp2/atomisp_cmd.h b/drivers/media/atomisp2/atomisp_cmd.h
new file mode 100644
index 0000000..5ce57c2
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_cmd.h
@@ -0,0 +1,363 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__ATOMISP_CMD_H__
+#define	__ATOMISP_CMD_H__
+
+#include <linux/atomisp.h>
+#include <linux/interrupt.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-subdev.h>
+
+#include "atomisp_internal.h"
+#include "ia_css_types.h"
+#include "ia_css.h"
+
+struct atomisp_device;
+struct sh_css_frame;
+
+#define MSI_ENABLE_BIT		16
+#define INTR_DISABLE_BIT	10
+#define BUS_MASTER_ENABLE	2
+#define MEMORY_SPACE_ENABLE	1
+#define INTR_IER		24
+#define INTR_IIR		16
+
+/* Added pci variables */
+/*
+ * Access to message bus through these 2 registers
+ * in CUNIT(0:0:0) PCI configuration space.
+ * MSGBUS_CTRL_REG(0xD0):
+ *   31:24      = message bus opcode
+ *   23:16      = message bus port
+ *   15:8       = message bus address
+ *   7:4        = message bus byte enables
+ * MSGBUS_DTAT_REG(0xD4):
+ *   hold the data for write or read
+ */
+#define PCI_ROOT_MSGBUS_CTRL_REG        0xD0
+#define PCI_ROOT_MSGBUS_DATA_REG        0xD4
+#define PCI_ROOT_MSGBUS_CTRL_EXT_REG    0xD8
+#define PCI_ROOT_MSGBUS_READ            0x10
+#define PCI_ROOT_MSGBUS_WRITE           0x11
+#define PCI_ROOT_MSGBUS_DWORD_ENABLE    0xf0
+
+
+
+/*
+ * Helper function
+ */
+void dump_sp_dmem(unsigned int addr, unsigned int size);
+struct camera_mipi_info *atomisp_to_sensor_mipi_info(struct v4l2_subdev *sd);
+struct atomisp_video_pipe *atomisp_to_video_pipe(struct video_device *dev);
+struct atomisp_sub_device *atomisp_to_sub_device(struct atomisp_video_pipe
+						 *atomisp_pipe);
+int atomisp_reset(struct atomisp_device *isp);
+bool atomisp_buffers_queued(struct atomisp_sub_device *isp_subdev);
+void atomisp_flush_bufs_and_wakeup(struct atomisp_sub_device *isp_subdev);
+void atomisp_clear_css_buffer_counters(struct atomisp_sub_device *isp_subdev);
+void atomisp_clear_frame_counters(struct atomisp_sub_device *isp_subdev);
+
+/* Added intel_mid_msgbus function declarations */
+int intel_mid_msgbus_init(void);
+extern u32 intel_mid_msgbus_read32_raw(u32 cmd);
+extern void intel_mid_msgbus_write32_raw(u32 cmd, u32 data);
+extern u32 intel_mid_msgbus_read32(u8 port, u32 addr);
+extern void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data);
+
+void *atomisp_kernel_malloc(size_t bytes);
+void atomisp_kernel_free(void *ptr);
+
+/*
+ * Interrupt functions
+ */
+void atomisp_msi_irq_init(struct atomisp_device *isp, struct pci_dev *dev);
+void atomisp_msi_irq_uninit(struct atomisp_device *isp, struct pci_dev *dev);
+void atomisp_wdt_work(struct work_struct *work);
+void atomisp_wdt(unsigned long isp_addr);
+void atomisp_setup_flash(struct atomisp_sub_device *isp_subdev);
+irqreturn_t atomisp_isr(int irq, void *dev);
+irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr);
+const struct atomisp_format_bridge *get_atomisp_format_bridge_from_mbus(
+	enum media_bus_format mbus_code);
+int atomisp_is_mbuscode_raw(uint32_t code);
+int atomisp_get_frame_pgnr(const struct ia_css_frame *frame, u32 *p_pgnr);
+unsigned int atomisp_try_mipi_frame_buffer_size(struct atomisp_sub_device *isp_subdev, unsigned int width, unsigned int height, unsigned int pixelformat);
+void atomisp_delayed_init_work(struct work_struct *work);
+
+/*
+ * CSI-2 receiver configuration
+ */
+void atomisp_set_term_en_count(struct atomisp_device *isp);
+
+/*
+ * Get internal fmt according to V4L2 fmt
+ */
+
+bool atomisp_is_viewfinder_support(struct atomisp_sub_device *isp_subdev);
+
+/*
+ * ISP features control function
+ */
+
+/*
+ * Function to enable/disable lens geometry distortion correction (GDC) and
+ * chromatic aberration correction (CAC)
+ */
+int atomisp_gdc_cac(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+/*
+ * Function to enable/disable low light mode (including ANR)
+ */
+int atomisp_low_light(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+/*
+ * Function to enable/disable extra noise reduction (XNR) in low light
+ * condition
+ */
+int atomisp_xnr(struct atomisp_sub_device *isp_subdev, int flag, int *arg);
+/*
+ * Function to load the larger FW
+ */
+int atomisp_fw(struct atomisp_device *isp, int flag, int *data);
+
+/*
+ * Function to configure noise reduction
+ */
+int atomisp_nr(struct atomisp_sub_device *isp_subdev, int flag,
+	       struct atomisp_nr_config *config);
+
+/*
+ * Function to configure temporal noise reduction (TNR)
+ */
+int atomisp_tnr(struct atomisp_sub_device *isp_subdev, int flag,
+		struct atomisp_tnr_config *config);
+
+/*
+ * Function to get histogram data for image frame
+ */
+int atomisp_histogram(struct atomisp_sub_device *isp_subdev,
+	int flag, void *config);
+
+/*
+ * Function to configure black level compensation
+ */
+int atomisp_black_level(struct atomisp_sub_device *isp_subdev, int flag,
+			struct atomisp_ob_config *config);
+
+/*
+ * Function to configure edge enhancement
+ */
+int atomisp_ee(struct atomisp_sub_device *isp_subdev, int flag,
+	       struct atomisp_ee_config *config);
+
+/*
+ * Function to update Gamma table for gamma, brightness and contrast config
+ */
+int atomisp_gamma(struct atomisp_sub_device *isp_subdev, int flag,
+		  struct atomisp_gamma_table *config);
+/*
+ * Function to update Ctc table for Chroma Enhancement
+ */
+int atomisp_ctc(struct atomisp_sub_device *isp_subdev, int flag,
+		struct atomisp_ctc_table *config);
+
+/*
+ * Function to update gamma correction parameters
+ */
+int atomisp_gamma_correction(struct atomisp_sub_device *isp_subdev, int flag,
+	struct atomisp_gc_config *config);
+
+/*
+ * Function to update Gdc table for gdc
+ */
+int atomisp_gdc_cac_table(struct atomisp_sub_device *isp_subdev, int flag,
+
+			  struct atomisp_morph_table *config);
+
+/*
+ * Function to update table for macc
+ */
+int atomisp_macc_table(struct atomisp_sub_device *isp_subdev, int flag,
+		       struct atomisp_macc_config *config);
+/*
+ * Function to get DIS statistics.
+ */
+int atomisp_get_dis_stat(struct atomisp_sub_device *isp_subdev,
+			 struct atomisp_dis_statistics *stats);
+
+/*
+ * Function to set the DIS coefficients.
+ */
+int atomisp_set_dis_coefs(struct atomisp_sub_device *isp_subdev,
+			  struct atomisp_dis_coefficients *coefs);
+
+/*
+ * Function to set the DIS motion vector.
+ */
+int atomisp_set_dis_vector(struct atomisp_sub_device *isp_subdev,
+			   struct atomisp_dis_vector *vector);
+
+/*
+ * Function to set/get 3A stat from isp
+ */
+int atomisp_3a_stat(struct atomisp_sub_device *isp_subdev, int flag,
+		    struct atomisp_3a_statistics *config);
+
+int atomisp_set_parameters(struct atomisp_sub_device *isp_subdev,
+		struct atomisp_parameters *arg);
+
+/*
+ * Function to set/get isp parameters to isp
+ */
+int atomisp_param(struct atomisp_sub_device *isp_subdev, int flag,
+		  struct atomisp_parm *config);
+
+/*
+ * Function to configure color effect of the image
+ */
+int atomisp_color_effect(struct atomisp_sub_device *isp_subdev, int flag, __s32 *effect);
+
+/*
+ * Function to configure bad pixel correction
+ */
+int atomisp_bad_pixel(struct atomisp_sub_device *isp_subdev, int flag, __s32 *value);
+
+/*
+ * Function to configure bad pixel correction params
+ */
+int atomisp_bad_pixel_param(struct atomisp_sub_device *isp_subdev, int flag,
+			    struct atomisp_dp_config *config);
+
+/*
+ * Function to enable/disable video image stablization
+ */
+int atomisp_video_stable(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+/*
+ * Function to configure fixed pattern noise
+ */
+int atomisp_fixed_pattern(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+/*
+ * Function to configure fixed pattern noise table
+ */
+int atomisp_fixed_pattern_table(struct atomisp_sub_device *isp_subdev,
+				struct v4l2_framebuffer *config);
+
+/*
+ * Function to configure vf overlay image
+ */
+int atomisp_vf_overlay(struct atomisp_sub_device *isp_subdev, int flag,
+		       struct atomisp_overlay *overlay);
+
+/*
+ * Function to configure false color correction
+ */
+int atomisp_false_color(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+/*
+ * Function to configure false color correction params
+ */
+int atomisp_false_color_param(struct atomisp_sub_device *isp_subdev, int flag,
+			      struct atomisp_de_config *config);
+
+/*
+ * Function to configure white balance params
+ */
+int atomisp_white_balance_param(struct atomisp_sub_device *isp_subdev, int flag,
+				struct atomisp_wb_config *config);
+
+int atomisp_3a_config_param(struct atomisp_sub_device *isp_subdev, int flag,
+			    struct atomisp_3a_config *config);
+
+/*
+ * Function to enable/disable lens shading correction
+ */
+int atomisp_shading_correction(struct atomisp_sub_device *isp_subdev, int flag,
+				       __s32 *value);
+
+/*
+ * Function to setup digital zoom
+ */
+int atomisp_digital_zoom(struct atomisp_sub_device *isp_subdev, int flag, __s32 * value);
+
+int atomisp_get_sensor_mode_data(struct atomisp_sub_device *isp_subdev,
+				 struct atomisp_sensor_mode_data *config);
+
+int atomisp_get_fmt(struct video_device *vdev, struct v4l2_format *f);
+
+
+/* This function looks up the closest available resolution. */
+int atomisp_try_fmt(struct video_device *vdev, struct v4l2_format *f,
+						bool *res_overflow);
+
+int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *format);
+int atomisp_set_fmt_file(struct video_device *vdev, struct v4l2_format *f);
+
+void atomisp_free_all_shading_tables(struct atomisp_device *isp);
+int atomisp_set_shading_table(struct atomisp_sub_device *isp_subdev,
+			      struct atomisp_shading_table *shading_table);
+
+int atomisp_offline_capture_configure(struct atomisp_sub_device *isp_subdev,
+				struct atomisp_cont_capture_conf *cvf_config);
+
+int atomisp_ospm_dphy_down(struct atomisp_device *isp);
+int atomisp_ospm_dphy_up(struct atomisp_device *isp);
+int atomisp_exif_makernote(struct atomisp_sub_device *isp_subdev,
+			   struct atomisp_makernote_info *config);
+
+void atomisp_free_internal_buffers(struct atomisp_sub_device *isp_subdev);
+void atomisp_free_3a_dvs_buffers(struct atomisp_sub_device *isp_subdev);
+
+int  atomisp_flash_enable(struct atomisp_sub_device *isp_subdev, int num_frames);
+
+int atomisp_freq_scaling(struct atomisp_device *vdev,
+			 enum atomisp_dfs_mode mode);
+
+/*
+* typedefs
+*/
+
+typedef enum ia_css_err (*configure_output_t)(struct atomisp_sub_device *isp_subdev,
+		unsigned int width,
+		unsigned int height,
+		enum ia_css_frame_format sh_fmt);
+typedef enum ia_css_err (*get_frame_info_t)(struct atomisp_sub_device *isp_subdev,
+		struct ia_css_frame_info *finfo);
+typedef enum ia_css_err (*configure_pp_input_t)(struct atomisp_sub_device *isp_subdev,
+		unsigned int width,
+		unsigned int height);
+
+void atomisp_css_flush(struct atomisp_device *isp);
+
+extern const struct atomisp_format_bridge atomisp_output_fmts[];
+
+const struct atomisp_format_bridge *atomisp_get_format_bridge(
+        unsigned int pixelformat);
+const struct atomisp_format_bridge *atomisp_get_format_bridge_from_mbus(
+        enum media_bus_format mbus_code);
+int atomisp_enum_fmt_cap(struct file *file, void *fh,
+        struct v4l2_fmtdesc *f);
+#endif /* __ATOMISP_CMD_H__ */
diff --git a/drivers/media/atomisp2/atomisp_common.h b/drivers/media/atomisp2/atomisp_common.h
new file mode 100644
index 0000000..f759157
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_common.h
@@ -0,0 +1,79 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__ATOMISP_COMMON_H__
+#define	__ATOMISP_COMMON_H__
+
+#include <linux/atomisp.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/videobuf2-core.h>
+
+#include "ia_css.h"
+
+extern int dbg_level;
+extern int mipicsi_flag;
+extern int pad_w;
+extern int pad_h;
+
+extern bool fastboot;
+extern bool multistream_enabled;
+
+extern int atomisp_pci_vendor;
+extern int atomisp_pci_device;
+
+#define MFLD_MAX_ZOOM_FACTOR	64
+
+#define MRFLD_MAX_ZOOM_FACTOR	1024
+
+#define IS_MRFLD ((atomisp_pci_device & 0xfff8) == 0x0F38)
+
+struct atomisp_format_bridge {
+	unsigned int pixelformat;
+	unsigned int depth;
+	enum media_bus_format mbus_code;
+	enum ia_css_frame_format sh_fmt;
+	unsigned char description[32];	/* the same as struct v4l2_fmtdesc */
+};
+
+struct atomisp_fmt {
+	u32 pixelformat;
+	u32 depth;
+	u32 bytesperline;
+	u32 framesize;
+	u32 imagesize;
+	u32 width;
+	u32 height;
+	u32 bayer_order;
+};
+
+struct atomisp_vb2 {
+	struct vb2_buffer vb; /* Must be first */
+	struct list_head list;
+	struct ia_css_frame *cssframe;
+};
+
+/*
+ * supported V4L2 fmts and resolutions
+ */
+extern struct v4l2_device atomisp_dev;
+#endif
diff --git a/drivers/media/atomisp2/atomisp_compat.c b/drivers/media/atomisp2/atomisp_compat.c
new file mode 100644
index 0000000..9624655
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_compat.c
@@ -0,0 +1,1242 @@
+/*
+ * Support for Clovertrail PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css.h"
+#include "atomisp_compat.h"
+#include "atomisp_fops.h"
+#include "ia_css_types.h"
+
+#include <linux/delay.h>
+#include "hrt/hive_isp_css_mm_hrt.h"
+#include <linux/pci.h>
+
+/*
+ *   to serialize MMIO access , this is due to ISP2400 silicon issue Sighting
+ *    #4684168, if concurrency access happened, system may hard hang.
+ *    Sighting #4600742 also points to system hard hang upon access to IUNIT MMIO.
+ *
+ */
+static DEFINE_SPINLOCK(mmio_lock);
+extern raw_spinlock_t pci_config_lock;
+
+#ifdef ISOF_SILICON_BUG_WORKAROUND
+#define MMIO_LOCK spin_lock_irqsave(&mmio_lock, flags);
+#define PCI_CONFIG_LOCK raw_spin_lock(&pci_config_lock);
+#define MMIO_UNLOCK spin_unlock_irqrestore(&mmio_lock, flags);
+#define PCI_CONFIG_UNLOCK raw_spin_unlock(&pci_config_lock);
+#else
+#define MMIO_LOCK
+#define PCI_CONFIG_LOCK
+#define MMIO_UNLOCK
+#define PCI_CONFIG_UNLOCK
+#endif
+
+enum frame_info_type {
+	VF_FRAME,
+	OUTPUT_FRAME,
+	RAW_FRAME,
+};
+
+static void atomisp_ISP_parameters_clean_up(struct atomisp_sub_device *isp_subdev,
+				     struct ia_css_isp_config *config)
+{
+	if (config->wb_config) {
+		memset(isp_subdev->params.config.wb_config, 0 ,
+		       sizeof(struct ia_css_wb_config));
+		config->wb_config = NULL;
+	}
+	if (config->cc_config) {
+		memset(isp_subdev->params.config.cc_config, 0 ,
+		       sizeof(struct ia_css_cc_config));
+		config->cc_config = NULL;
+	}
+	if (config->tnr_config) {
+		memset(isp_subdev->params.config.tnr_config, 0 ,
+		       sizeof(struct ia_css_tnr_config));
+		config->tnr_config = NULL;
+	}
+	if (config->ob_config) {
+		memset(isp_subdev->params.config.ob_config, 0 ,
+		       sizeof(struct ia_css_ob_config));
+		config->ob_config = NULL;
+	}
+	if (config->nr_config) {
+		memset(isp_subdev->params.config.nr_config, 0 ,
+		       sizeof(struct ia_css_nr_config));
+		config->nr_config = NULL;
+	}
+	if (config->ee_config) {
+		memset(isp_subdev->params.config.ee_config, 0 ,
+		       sizeof(struct ia_css_ee_config));
+		config->ee_config = NULL;
+	}
+	if (config->de_config) {
+		memset(isp_subdev->params.config.de_config, 0 ,
+		       sizeof(struct ia_css_de_config));
+		config->de_config = NULL;
+	}
+	if (config->gc_config) {
+		memset(isp_subdev->params.config.gc_config, 0 ,
+		       sizeof(struct ia_css_gc_config));
+		config->gc_config = NULL;
+	}
+	if (config->ecd_config) {
+		memset(isp_subdev->params.config.ecd_config, 0 ,
+		       sizeof(struct ia_css_ecd_config));
+		config->ecd_config = NULL;
+	}
+	if (config->ynr_config) {
+		memset(isp_subdev->params.config.ynr_config, 0 ,
+		       sizeof(struct ia_css_ynr_config));
+		config->ynr_config = NULL;
+	}
+	if (config->fc_config) {
+		memset(isp_subdev->params.config.fc_config, 0 ,
+		       sizeof(struct ia_css_fc_config));
+		config->fc_config = NULL;
+	}
+	if (config->cnr_config) {
+		memset(isp_subdev->params.config.cnr_config, 0 ,
+		       sizeof(struct ia_css_cnr_config));
+		config->cnr_config = NULL;
+	}
+	if (config->macc_config) {
+		memset(isp_subdev->params.config.macc_config, 0 ,
+		       sizeof(struct ia_css_macc_config));
+		config->macc_config = NULL;
+	}
+	if (config->ctc_config) {
+		memset(isp_subdev->params.config.ctc_config, 0 ,
+		       sizeof(struct ia_css_ctc_config));
+		config->ctc_config = NULL;
+	}
+	if (config->aa_config) {
+		memset(isp_subdev->params.config.aa_config, 0 ,
+		       sizeof(struct ia_css_aa_config));
+		config->aa_config = NULL;
+	}
+	if (config->ce_config) {
+		memset(isp_subdev->params.config.ce_config, 0 ,
+		       sizeof(struct ia_css_ce_config));
+		config->ce_config = NULL;
+	}
+	if (config->dvs_6axis_config) {
+		config->dvs_6axis_config = NULL;
+	}
+	if (config->yuv2rgb_cc_config) {
+		memset(isp_subdev->params.config.yuv2rgb_cc_config, 0 ,
+		       sizeof(struct ia_css_cc_config));
+		config->yuv2rgb_cc_config = NULL;
+	}
+	if (config->rgb2yuv_cc_config) {
+		memset(isp_subdev->params.config.rgb2yuv_cc_config, 0 ,
+		       sizeof(struct ia_css_cc_config));
+		config->rgb2yuv_cc_config = NULL;
+	}
+	if (config->anr_config) {
+		memset(isp_subdev->params.config.anr_config, 0 ,
+		       sizeof(struct ia_css_anr_config));
+		config->anr_config = NULL;
+	}
+	if (config->s3a_config) {
+		memset(isp_subdev->params.config.s3a_config, 0 ,
+		       sizeof(struct ia_css_3a_config));
+		config->s3a_config = NULL;
+	}
+	if (config->macc_table) {
+		memset(isp_subdev->params.config.macc_table, 0 ,
+		       sizeof(struct ia_css_macc_table));
+		config->macc_table = NULL;
+	}
+	if (config->gamma_table) {
+		memset(isp_subdev->params.config.gamma_table, 0 ,
+		       sizeof(struct ia_css_gamma_table));
+		config->gamma_table = NULL;
+	}
+	if (config->ctc_table) {
+		memset(isp_subdev->params.config.ctc_table, 0 ,
+		       sizeof(struct ia_css_ctc_table));
+		config->ctc_table = NULL;
+	}
+	if (config->xnr_table) {
+		memset(isp_subdev->params.config.xnr_table, 0 ,
+		       sizeof(struct ia_css_xnr_table));
+		config->xnr_table = NULL;
+	}
+	if (config->r_gamma_table) {
+		memset(isp_subdev->params.config.r_gamma_table, 0 ,
+		       sizeof(struct ia_css_rgb_gamma_table));
+		config->r_gamma_table = NULL;
+	}
+	if (config->g_gamma_table) {
+		memset(isp_subdev->params.config.g_gamma_table, 0 ,
+		       sizeof(struct ia_css_rgb_gamma_table));
+		config->g_gamma_table = NULL;
+	}
+	if (config->b_gamma_table) {
+		memset(isp_subdev->params.config.b_gamma_table, 0 ,
+		       sizeof(struct ia_css_rgb_gamma_table));
+		config->b_gamma_table = NULL;
+	}
+	if (config->dz_config) {
+		memset(isp_subdev->params.config.dz_config, 0 ,
+		       sizeof(struct ia_css_dz_config));
+		config->dz_config = NULL;
+	}
+	if (config->motion_vector) {
+		memset(isp_subdev->params.config.motion_vector, 0 ,
+		       sizeof(struct ia_css_vector));
+		config->motion_vector = NULL;
+	}
+	if (config->shading_table) {
+		ia_css_shading_table_free(config->shading_table);
+		config->shading_table = NULL;
+	}
+	if (config->morph_table) {
+		ia_css_morph_table_free(config->morph_table);
+		config->morph_table = NULL;
+	}
+	if (config->dvs_coefs) {
+		config->dvs_coefs = NULL;
+	}
+}
+
+static inline
+enum ia_css_pipe_mode __pipe_id_to_pipe_mode(enum ia_css_pipe_id pipe_id)
+{
+	switch (pipe_id) {
+	case IA_CSS_PIPE_ID_PREVIEW:
+		return IA_CSS_PIPE_MODE_PREVIEW;
+	case IA_CSS_PIPE_ID_CAPTURE:
+		return IA_CSS_PIPE_MODE_CAPTURE;
+	case IA_CSS_PIPE_ID_VIDEO:
+		return IA_CSS_PIPE_MODE_VIDEO;
+	case IA_CSS_PIPE_ID_ACC:
+		return IA_CSS_PIPE_MODE_ACC;
+	default:
+		return IA_CSS_PIPE_MODE_NUM;
+	}
+
+}
+static void __apply_additional_pipe_config(struct atomisp_sub_device *isp_subdev)
+{
+	int i = 0;
+	for (i = 0; i< IA_CSS_PIPE_ID_NUM; i++) {
+		isp_subdev->css2_basis.pipe_configs[i].isp_pipe_version = 2;
+
+		switch(i) {
+		  case IA_CSS_PIPE_ID_CAPTURE:
+		       break;
+		  case IA_CSS_PIPE_ID_VIDEO:
+			  //In order to use isp2_dz_min set enable_reduce_pipe
+		      isp_subdev->css2_basis.pipe_extra_configs[i].enable_reduced_pipe = true;
+
+		      //In order to load isp_dz binary set enable_dz
+		      isp_subdev->css2_basis.pipe_configs[i].enable_dz = false;
+
+		      if(isp_subdev->params.video_dis_en){
+		           isp_subdev->css2_basis.pipe_extra_configs[i].enable_dvs_6axis = true;
+		           isp_subdev->css2_basis.pipe_configs[i].dvs_frame_delay = 2;
+		      }
+		       break;
+		  case IA_CSS_PIPE_ID_PREVIEW:
+		  case IA_CSS_PIPE_ID_COPY:
+		  case IA_CSS_PIPE_ID_ACC:
+		       break;
+		  default:
+		      break;
+		  }
+	}
+
+	}
+
+static void __configure_output(struct atomisp_sub_device *isp_subdev,
+			       unsigned int width,
+			       unsigned int height,
+			       enum ia_css_frame_format format,
+			       enum ia_css_pipe_id pipe_id)
+{
+
+	isp_subdev->css2_basis.curr_pipe = pipe_id;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].mode = __pipe_id_to_pipe_mode(pipe_id);
+	isp_subdev->css2_basis.update_pipe[pipe_id] = true;
+
+	isp_subdev->css2_basis.pipe_configs[pipe_id].output_info.res.width =
+	    width;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].output_info.res.height =
+	    height;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].output_info.format =
+	    format;
+	if (width * height > isp_subdev->css2_basis.stream_config.effective_res.width *
+	    isp_subdev->css2_basis.stream_config.effective_res.height) {
+		isp_subdev->css2_basis.stream_config.effective_res.width = width;
+		isp_subdev->css2_basis.stream_config.effective_res.height = height;
+	}
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "configuring pipe[%d] output info w=%d.h=%d.f=%d.\n",
+		 pipe_id, width, height, format);
+}
+static void __configure_pp_input(struct atomisp_sub_device *isp_subdev,
+				 unsigned int width,
+				 unsigned int height,
+				 enum ia_css_pipe_id pipe_id)
+{
+	if (width == 0 && height == 0)
+		return;
+
+	isp_subdev->css2_basis.curr_pipe = pipe_id;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].mode = __pipe_id_to_pipe_mode(pipe_id);
+	isp_subdev->css2_basis.update_pipe[pipe_id] = true;
+
+	if (width <=
+	    isp_subdev->css2_basis.pipe_configs[pipe_id].output_info.res.width ||
+	    height <=
+	    isp_subdev->css2_basis.pipe_configs[pipe_id].output_info.res.height
+	   )
+		return;
+	isp_subdev->css2_basis.pipe_extra_configs[pipe_id].enable_yuv_ds = true;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].bayer_ds_out_res.width = width;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].bayer_ds_out_res.height = height;
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "configuring pipe[%d]capture pp input w=%d.h=%d.\n",
+		 pipe_id, width, height);
+}
+static void __configure_vf_output(struct atomisp_sub_device *isp_subdev,
+				  unsigned int width,
+				  unsigned int height,
+				  enum ia_css_frame_format format,
+				  enum ia_css_pipe_id pipe_id)
+{
+
+	//Setting VF width to zero disable VF interrupts for the particular pipe
+	if(!isp_subdev->video_pipe_vf_enable)
+		width = 0;
+
+	isp_subdev->css2_basis.curr_pipe = pipe_id;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].mode = __pipe_id_to_pipe_mode(pipe_id);
+	isp_subdev->css2_basis.update_pipe[pipe_id] = true;
+
+	isp_subdev->css2_basis.pipe_configs[pipe_id].vf_output_info.res.width = width;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].vf_output_info.res.height = height;
+	isp_subdev->css2_basis.pipe_configs[pipe_id].vf_output_info.format = format;
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "configuring pipe[%d] vf output info w=%d.h=%d.f=%d.\n",
+		 pipe_id, width, height, format);
+}
+
+enum ia_css_err __destroy_pipes(struct atomisp_sub_device *isp_subdev,
+                                       bool force)
+{
+	int i;
+	enum ia_css_err ret = IA_CSS_SUCCESS;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (isp_subdev->css2_basis.stream) {
+		dev_dbg(isp->dev, "destroy css stream first.\n");
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		if (isp_subdev->css2_basis.pipes[i]
+		    		&& (force || isp_subdev->css2_basis.update_pipe[i])) {
+			ret |= ia_css_pipe_destroy(isp_subdev->css2_basis.pipes[i]);
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+					 "destroy pipe[%d]failed.\
+					 cannot recover\n", i);
+			}
+			isp_subdev->css2_basis.pipes[i] = NULL;
+			isp_subdev->css2_basis.update_pipe[i] = false;
+		}
+	}
+	return ret;
+}
+
+static enum ia_css_err __create_pipe(struct atomisp_sub_device *isp_subdev)
+{
+
+	int i, j;
+	enum ia_css_err ret;
+	struct ia_css_pipe_extra_config extra_config;
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s\n", __func__);
+	__apply_additional_pipe_config(isp_subdev);
+	ia_css_pipe_extra_config_defaults(&extra_config);
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		if (isp_subdev->css2_basis.pipe_configs[i].output_info.res.width) {
+			if (!memcmp(&extra_config,
+				    &isp_subdev->css2_basis.pipe_extra_configs[i],
+				    sizeof(extra_config)))
+				ret = ia_css_pipe_create(
+					&isp_subdev->css2_basis.pipe_configs[i],
+					&isp_subdev->css2_basis.pipes[i]);
+			else
+				ret = ia_css_pipe_create_extra(
+					&isp_subdev->css2_basis.pipe_configs[i],
+					&isp_subdev->css2_basis.pipe_extra_configs[i],
+					&isp_subdev->css2_basis.pipes[i]);
+			if (ret) {
+				v4l2_err(&atomisp_dev, "create pipe[%d] error.\n", i);
+				goto pipe_err;
+	}
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "dump pipe[%d] info w=%d, h=%d,f=%d vf_w=%d vf_h=%d vf_f=%d.\n",
+				 i,
+				 isp_subdev->css2_basis.pipe_configs[i].output_info.res.width,
+				 isp_subdev->css2_basis.pipe_configs[i].output_info.res.height,
+				 isp_subdev->css2_basis.pipe_configs[i].output_info.format,
+				 isp_subdev->css2_basis.pipe_configs[i].vf_output_info.res.width,
+				 isp_subdev->css2_basis.pipe_configs[i].vf_output_info.res.height,
+				 isp_subdev->css2_basis.pipe_configs[i].vf_output_info.format);
+		}
+	}
+
+	return IA_CSS_SUCCESS;
+pipe_err:
+	for (j = i; j >= 0; j--)
+		if (isp_subdev->css2_basis.pipes[j]) {
+			ia_css_pipe_destroy(isp_subdev->css2_basis.pipes[j]);
+			isp_subdev->css2_basis.pipes[j] = NULL;
+}
+
+	return ret;
+}
+static void dump_stream_pipe_config(struct atomisp_sub_device *isp_subdev)
+{
+	struct ia_css_pipe_config *p_config;
+	struct ia_css_pipe_extra_config *pe_config;
+	struct ia_css_stream_config *s_config;
+	int i = 0;
+
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		if (isp_subdev->css2_basis.pipes[i]) {
+			p_config = &isp_subdev->css2_basis.pipe_configs[i];
+			pe_config =
+			    &isp_subdev->css2_basis.pipe_extra_configs[i];
+			v4l2_dbg(3, dbg_level, &isp_subdev->subdev,
+				 "dumping pipe[%d] config:\n"
+				 "pipe_config.pipe_id:%d.\n"
+				 "pipe_config.output_info w=%d, h=%d.\n"
+				 "pipe_config.vf_pp_in_res w=%d, h=%d.\n"
+				 "pipe_config.capt_pp_in_res w=%d, h=%d.\n"
+				 "pipe_config.vf_output_info w=%d, h=%d.\n"
+				 "pipe_config.bayer_ds_out_res w=%d, h=%d.\n"
+				 "pipe_config.envelope w=%d, h=%d.\n"
+				 "pipe_config.default_capture_config.capture_mode=%d.\n"
+                 		 "pipe_config.default_capture_config..enable_xnr=%d.\n"
+				 "pipe_config.enable_dz:%d.\n"
+				 "pipe_config.isp_pipe_version:%d.\n"
+				 "dumping pipe[%d] extra config:\n"
+				 "pipe_extra_config.enable_raw_binning:%d.\n"
+				 "pipe_extra_config.enable_yuv_ds:%d.\n"
+				 "pipe_extra_config.enable_high_speed:%d.\n"
+				 "pipe_extra_config.enable_dvs_6axis:%d.\n"
+				 "pipe_extra_config.enable_reduced_pipe:%d.\n"
+				 "pipe_extra_config.disable_vf_pp:%d.\n",
+				 i,
+				 p_config->mode,
+				 p_config->output_info.res.width,
+				 p_config->output_info.res.height,
+				 p_config->vf_pp_in_res.width,
+                 		 p_config->vf_pp_in_res.height,
+                 		 p_config->capt_pp_in_res.width,
+                 		 p_config->capt_pp_in_res.height,
+				 p_config->vf_output_info.res.width,
+				 p_config->vf_output_info.res.height,
+				 p_config->bayer_ds_out_res.width,
+				 p_config->bayer_ds_out_res.height,
+				 p_config->dvs_envelope.width,
+				 p_config->dvs_envelope.height,
+				 p_config->default_capture_config.mode,
+				 p_config->default_capture_config.enable_xnr,
+                 		 p_config->enable_dz,
+                 		 p_config->isp_pipe_version,
+				 i,
+				 pe_config->enable_raw_binning,
+				 pe_config->enable_yuv_ds,
+				 pe_config->enable_high_speed,
+				 pe_config->enable_dvs_6axis,
+				 pe_config->enable_reduced_pipe,
+				 pe_config->disable_vf_pp);
+		}
+	}
+
+	s_config = &isp_subdev->css2_basis.stream_config;
+	v4l2_dbg(3, dbg_level, &isp_subdev->subdev,
+		 "dumping stream config:\n"
+		 "stream_config.mode=%d.\n"
+		 "stream_config.input_res w=%d, h=%d.\n"
+		 "stream_config.effective_res w=%d, h=%d.\n"
+		 "stream_config.format=%d.\n"
+		 "stream_config.bayer_order=%d.\n"
+		 "stream_config.2ppc=%d.\n"
+		 "stream_config.online=%d.\n"
+         	 "stream_config.continuous=%d.\n"
+		 "stream_config.channel_id=%d.\n"
+		 "stream_config.init_num_cont_raw_buf=%d\n"
+		 "stream_config.left_padding=%d\n",
+		 s_config->mode,
+		 s_config->input_res.width, s_config->input_res.height,
+		 s_config->effective_res.width, s_config->effective_res.height,
+		 s_config->format,
+		 s_config->bayer_order,
+		 s_config->two_pixels_per_clock,
+		 s_config->online, s_config->continuous,
+		 s_config->channel_id,
+		 s_config->init_num_cont_raw_buf,
+		 s_config->left_padding);
+}
+
+void atomisp_css_update_isp_params(struct atomisp_sub_device *isp_subdev)
+{
+	ia_css_stream_set_isp_config(
+			isp_subdev->css2_basis.stream,
+			&isp_subdev->params.config);
+	atomisp_ISP_parameters_clean_up(isp_subdev, &isp_subdev->params.config);
+}
+
+enum ia_css_err __destroy_stream(struct atomisp_sub_device *isp_subdev,
+                                        bool force)
+{
+	int i;
+	bool pipe_updated = false;
+
+	if (!isp_subdev->css2_basis.stream)
+		return IA_CSS_SUCCESS;
+
+	if (!force) {
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+			if (isp_subdev->css2_basis.update_pipe[i]) {
+				pipe_updated = true;
+ 				break;
+			}
+	}
+
+	if (!(force || pipe_updated))
+		return IA_CSS_SUCCESS;
+
+	if (isp_subdev->css2_basis.stream_state == CSS2_STREAM_STARTED
+	    && ia_css_stream_stop(isp_subdev->css2_basis.stream) != IA_CSS_SUCCESS) {
+		dev_err(isp_subdev->isp->dev, "stop stream failed.\n");
+		return -EINVAL;
+	}
+	isp_subdev->css2_basis.stream_state = CSS2_STREAM_STOPPED;
+
+	if (ia_css_stream_destroy(isp_subdev->css2_basis.stream) != IA_CSS_SUCCESS) {
+		dev_err(isp_subdev->isp->dev, "destroy stream failed.\n");
+		return -EINVAL;
+	}
+
+	isp_subdev->css2_basis.stream_state = CSS2_STREAM_UNINIT;
+	isp_subdev->css2_basis.stream = NULL;
+    	isp_subdev->stream_prepared = false;
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err __create_stream(struct atomisp_sub_device *isp_subdev)
+{
+	int pipe_index = 0, i;
+	struct ia_css_pipe *multi_pipes[IA_CSS_PIPE_ID_NUM];
+	const struct ia_css_stream_config *s_config =
+	    		&isp_subdev->css2_basis.stream_config;
+	enum ia_css_err ret;
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 ">%s.\n", __func__);
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		if (isp_subdev->css2_basis.pipes[i])
+			multi_pipes[pipe_index++] = isp_subdev->css2_basis.pipes[i];
+	}
+
+	ia_css_input_set_mode(isp_subdev,
+			get_input_mode(isp_subdev->isp->inputs[isp_subdev->input_curr].type, isp_subdev->isp));
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 "<%s.\n", __func__);
+	dump_stream_pipe_config(isp_subdev);
+	ret = ia_css_stream_create(s_config, pipe_index, multi_pipes,
+				    &isp_subdev->css2_basis.stream);
+	isp_subdev->stream_prepared = true;
+	return ret;
+}
+
+void atomisp_destroy_pipes_stream_force(struct atomisp_sub_device *isp_subdev)
+{
+	__destroy_stream(isp_subdev, true);
+	__destroy_pipes(isp_subdev, true);
+}
+
+void
+ia_css_input_set_mode(struct atomisp_sub_device *isp_subdev,
+		      enum ia_css_input_mode mode)
+{
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "ENTER %s with mode set as=%d \n",__func__,mode);
+	isp_subdev->css2_basis.stream_config.mode = mode;
+	if (mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+			ia_css_mipi_frame_specify(ATOMISP_MIPI_BUFFER_SIZE, false);
+	}
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "EXIT %s \n",__func__);
+}
+
+enum ia_css_input_mode get_input_mode(unsigned int input_type, struct atomisp_device *isp)
+{
+	if (input_type != TEST_PATTERN && input_type != FILE_INPUT){
+		if (fastboot){
+ 	               if(isp->firmware_switched == false){
+	                       return multistream_enabled ? IA_CSS_INPUT_MODE_BUFFERED_SENSOR : IA_CSS_INPUT_MODE_SENSOR;
+                       }
+        	}
+		return IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
+	}
+	else if(input_type == FILE_INPUT)
+		return IA_CSS_INPUT_MODE_FIFO;
+	else if(input_type == TEST_PATTERN)
+		return IA_CSS_INPUT_MODE_TPG;
+	return -1;
+}
+
+enum ia_css_err ia_css_update_stream(struct atomisp_sub_device *isp_subdev)
+{
+	enum ia_css_err ret;
+
+	if (__destroy_stream(isp_subdev, true) != IA_CSS_SUCCESS)
+		dev_warn(isp_subdev->isp->dev, "destroy stream failed.\n");
+
+	if (__destroy_pipes(isp_subdev, true) != IA_CSS_SUCCESS)
+		dev_warn(isp_subdev->isp->dev, "destroy pipe failed.\n");
+
+	ret = __create_pipe(isp_subdev);
+	if (ret != IA_CSS_SUCCESS) {
+		dev_err(isp_subdev->isp->dev, "create pipe failed.\n");
+		return ret;
+	}
+
+	ret = __create_stream(isp_subdev);
+	if (ret != IA_CSS_SUCCESS) {
+		dev_warn(isp_subdev->isp->dev, "create stream failed.\n");
+		__destroy_pipes(isp_subdev, true);
+		return ret;
+	}
+
+	return ret;
+}
+
+static enum ia_css_err __get_frame_info(struct atomisp_sub_device *isp_subdev,
+				struct ia_css_frame_info *info,
+				enum frame_info_type type)
+{
+	enum ia_css_err ret;
+	struct ia_css_pipe_info p_info;
+	unsigned int pipe_id = isp_subdev->css2_basis.curr_pipe;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		 ">%s.\n", __func__);
+
+	if (__destroy_stream(isp_subdev, true) != IA_CSS_SUCCESS)
+		dev_warn(isp->dev, "destroy stream failed.\n");
+
+	if (__destroy_pipes(isp_subdev, true) != IA_CSS_SUCCESS)
+		dev_warn(isp->dev, "destroy pipe failed.\n");
+
+	if((ret = __create_pipe(isp_subdev)) != IA_CSS_SUCCESS)
+		goto pipe_err;
+
+	if((ret = __create_stream(isp_subdev)) != IA_CSS_SUCCESS)
+		goto stream_err;
+
+	ret = ia_css_pipe_get_info(
+			isp_subdev->css2_basis.pipes[pipe_id], &p_info);
+	if (ret == IA_CSS_SUCCESS) {
+		switch (type) {
+		case VF_FRAME:
+			*info = p_info.vf_output_info;
+			v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "getting vf frame info.\n");
+			break;
+		case OUTPUT_FRAME:
+			*info = p_info.output_info;
+			v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "getting main frame info.\n");
+			break;
+		case RAW_FRAME:
+			*info = p_info.raw_output_info;
+			v4l2_dbg(3, dbg_level, &atomisp_dev,
+				 "getting raw frame info.\n");
+			break;
+		default:
+			info = NULL;
+			v4l2_err(&atomisp_dev,
+				  "wrong type for getting frame info");
+		}
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "get frame info: w=%d, h=%d.\n",
+			 	info->res.width, info->res.height);
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "<%s.\n", __func__);
+		return IA_CSS_SUCCESS;
+	}
+
+stream_err:
+	__destroy_pipes(isp_subdev, true);
+pipe_err:
+
+	return ret;
+}
+
+enum ia_css_err ia_css_preview_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+{
+	__configure_output(isp_subdev, width, height, format, IA_CSS_PIPE_ID_PREVIEW);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_preview_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_PREVIEW;
+	return __get_frame_info(isp_subdev, info, OUTPUT_FRAME);
+}
+
+enum ia_css_err ia_css_capture_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+{
+	__configure_output(isp_subdev, width, height, format,
+			   IA_CSS_PIPE_ID_CAPTURE);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_capture_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_CAPTURE;
+	return __get_frame_info(isp_subdev, info, OUTPUT_FRAME);
+}
+
+enum ia_css_err ia_css_capture_configure_viewfinder(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+{
+	__configure_vf_output(isp_subdev, width, height, format, IA_CSS_PIPE_ID_CAPTURE);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_capture_get_viewfinder_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_CAPTURE;
+	__get_frame_info(isp_subdev, info, VF_FRAME);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_video_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+{
+	__configure_output(isp_subdev, width, height, format,
+			   IA_CSS_PIPE_ID_VIDEO);
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_video_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_VIDEO;
+	return __get_frame_info(isp_subdev, info, OUTPUT_FRAME);
+}
+
+enum ia_css_err ia_css_video_configure_viewfinder(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format)
+{
+	__configure_vf_output(isp_subdev, width, height, format, IA_CSS_PIPE_ID_VIDEO);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_video_get_viewfinder_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_VIDEO;
+	return __get_frame_info(isp_subdev, info, VF_FRAME);
+}
+
+enum ia_css_err ia_css_preview_configure_pp_input(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height)
+{
+		__configure_pp_input(isp_subdev, width, height, IA_CSS_PIPE_ID_PREVIEW);
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_capture_configure_pp_input(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height)
+{
+	__configure_pp_input(isp_subdev, width, height, IA_CSS_PIPE_ID_CAPTURE);
+	return IA_CSS_SUCCESS;
+}
+void
+ia_css_capture_set_mode(struct atomisp_sub_device *isp_subdev,
+			enum ia_css_capture_mode mode)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_CAPTURE;
+	if (isp_subdev->css2_basis.pipe_configs[IA_CSS_PIPE_ID_CAPTURE].default_capture_config.mode != mode) {
+		isp_subdev->css2_basis.pipe_configs[IA_CSS_PIPE_ID_CAPTURE].default_capture_config.mode = mode;
+		isp_subdev->css2_basis.update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;
+	}
+}
+
+void
+ia_css_capture_enable_online(struct atomisp_sub_device *isp_subdev,
+			     bool enable)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_CAPTURE;
+	if (isp_subdev->css2_basis.stream_config.online != enable) {
+		isp_subdev->css2_basis.stream_config.online = enable;
+		isp_subdev->css2_basis.update_pipe[IA_CSS_PIPE_ID_CAPTURE] =
+		    true;
+	}
+}
+
+void
+ia_css_input_set_two_pixels_per_clock(struct atomisp_sub_device *isp_subdev,
+					   bool enable)
+{
+	int i;
+
+	if (isp_subdev->css2_basis.stream_config.two_pixels_per_clock !=
+	    enable) {
+		isp_subdev->css2_basis.stream_config.two_pixels_per_clock =
+		    enable;
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+			isp_subdev->css2_basis.update_pipe[i] = true;
+	}
+}
+void
+ia_css_enable_dz(struct atomisp_sub_device *isp_subdev, bool enable)
+{
+ int i;
+ for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+ {
+	 isp_subdev->css2_basis.pipe_configs[i].enable_dz = enable;
+ }
+}
+void
+ia_css_input_set_resolution(struct atomisp_sub_device *isp_subdev,struct v4l2_mbus_framefmt *ffmt){
+       int pixel_pad_for_raw = 0;
+
+       if(isp_subdev->css2_basis.stream_config.format == IA_CSS_STREAM_FORMAT_RAW_10)
+               pixel_pad_for_raw = 12;
+       else
+               pixel_pad_for_raw = 0;
+       isp_subdev->css2_basis.stream_config.input_res.width = ffmt->width + pixel_pad_for_raw;
+       isp_subdev->css2_basis.stream_config.input_res.height = ffmt->height + pixel_pad_for_raw;
+
+}
+void
+ia_css_input_set_format(struct atomisp_sub_device *isp_subdev,enum ia_css_stream_format format){
+       isp_subdev->css2_basis.stream_config.format = format;
+}
+void
+ia_css_input_set_binning_factor(struct atomisp_sub_device *isp_subdev, unsigned int binning_factor){
+
+       isp_subdev->css2_basis.stream_config.sensor_binning_factor =  binning_factor;
+}
+void
+ia_css_input_set_bayer_order(struct atomisp_sub_device *isp_subdev, enum ia_css_bayer_order bayer_order){
+
+       isp_subdev->css2_basis.stream_config.bayer_order = bayer_order;
+}
+void
+ia_css_video_set_dis_envelope(struct atomisp_sub_device *isp_subdev,
+                                       unsigned int dvs_w, unsigned int dvs_h)
+{
+       isp_subdev->css2_basis.pipe_configs[IA_CSS_PIPE_ID_VIDEO].dvs_envelope.width = dvs_w;
+       isp_subdev->css2_basis.pipe_configs[IA_CSS_PIPE_ID_VIDEO].dvs_envelope.height  = dvs_h;
+}
+
+void
+ia_css_enable_raw_binning(struct atomisp_sub_device *isp_subdev,
+			     bool enable)
+{
+	int i;
+
+	for(i=0;i<IA_CSS_PIPE_ID_NUM;i++) {
+		if(isp_subdev->css2_basis.pipe_extra_configs[i].enable_raw_binning != enable) {
+			isp_subdev->css2_basis.pipe_extra_configs[i].enable_raw_binning = enable;
+			isp_subdev->css2_basis.update_pipe[i] = true;
+		}
+	}
+}
+
+void ia_css_enable_continuous(struct atomisp_sub_device *isp_subdev,
+				  bool enable)
+{
+	int i;
+
+	if (isp_subdev->css2_basis.stream_config.continuous != enable) {
+		isp_subdev->css2_basis.stream_config.continuous = enable;
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+			isp_subdev->css2_basis.update_pipe[i] = true;
+	}
+}
+
+void ia_css_preview_enable_online(struct atomisp_sub_device *isp_subdev,
+				  bool enable)
+{
+	int i;
+
+	if (isp_subdev->css2_basis.stream_config.online != enable) {
+		isp_subdev->css2_basis.stream_config.online = enable;
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+			isp_subdev->css2_basis.update_pipe[i] = true;
+	}
+}
+
+enum ia_css_err ia_css_capture_get_output_raw_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info)
+{
+	isp_subdev->css2_basis.curr_pipe = IA_CSS_PIPE_ID_CAPTURE;
+	return __get_frame_info(isp_subdev, info, RAW_FRAME);
+}
+
+int atomisp_css_init(struct atomisp_device *isp)
+{
+        int i, retval, ret = 0;
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+        for(i = 0; i <  MAX_LOAD_FIRMWARE_TIMEOUTS; i++)
+        {
+                retval = wait_event_interruptible_timeout(atomisp_wait_queue, isp->firmware_load_complete == true, 250);
+                if(retval>=0 && isp->firmware_load_complete)
+                        break;
+        }
+
+        if(isp->firmware == NULL)
+        {
+                ret = -EINVAL;
+                goto css_init_failed;
+        }
+
+        if (ia_css_init(&css_env,
+                        &isp->css_fw,
+                        (uint32_t)isp->mmu_base_addr,
+                        IA_CSS_IRQ_TYPE_PULSE)) {
+                ret = -EINVAL;
+                goto css_init_failed;
+        }
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+
+css_init_failed:
+        return ret;
+}
+
+void atomisp_css_uninit(struct atomisp_device *isp)
+{
+	struct atomisp_sub_device *isp_subdev;
+	unsigned int i;
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+	for (i = 0; i < isp->num_of_streams; i++) {
+		isp_subdev = &isp->isp_subdev[i];
+		atomisp_ISP_parameters_clean_up(isp_subdev, &isp_subdev->params.config);
+		isp_subdev->params.css_update_params_needed = false;
+	}
+
+	ia_css_uninit();
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+}
+
+enum ia_css_err ia_css_start(struct atomisp_sub_device *isp_subdev, bool in_reset)
+{
+	enum ia_css_err ret;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (in_reset) {
+		if (__destroy_stream(isp_subdev, true) != IA_CSS_SUCCESS)
+			dev_warn(isp->dev, "destroy stream failed.\n");
+
+		if (__destroy_pipes(isp_subdev, true) != IA_CSS_SUCCESS)
+			dev_warn(isp->dev, "destroy pipe failed.\n");
+
+		if ((ret = __create_pipe(isp_subdev)) != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev, "create pipe error.\n");
+			goto pipe_err;
+		}
+		if ((ret = __create_stream(isp_subdev)) != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev, "create stream error.\n");
+			goto stream_err;
+		}
+	}
+
+	/*
+	 * For dual steam case, it is possible that:
+	 * 1: for this stream, it is at the stage that:
+	 * - after set_fmt is called
+	 * - before stream on is called
+	 * 2: for the other stream, the stream off is called which css reset
+	 * has been done.
+	 *
+	 * Thus the stream created in set_fmt get destroyed and need to be
+	 * recreated in the next stream on.
+	 */
+	if (isp_subdev->stream_prepared == false) {
+		if (__create_pipe(isp_subdev)) {
+			dev_err(isp->dev, "create pipe error.\n");
+			return -EINVAL;
+		}
+		if (__create_stream(isp_subdev)) {
+			dev_err(isp->dev, "create stream error.\n");
+			ret = -EINVAL;
+			goto stream_err;
+		}
+	}
+
+	/*
+	 * SP can only be started one time
+	 * if atomisp_subdev_streaming_count() tell there aleady has some subdev
+	 * at streamming, then SP should already be started previously, so
+	 * need to skip start sp procedure
+	 */
+	if (atomisp_subdev_streaming_count(isp_subdev->isp)) {
+		dev_dbg(isp_subdev->isp->dev, "skip start sp.\n");
+	} else {
+		ret = ia_css_start_sp();
+		if (ret != IA_CSS_SUCCESS) {
+			dev_err(isp_subdev->isp->dev, "start sp error.\n");
+			goto start_err;
+		}
+ 	}
+
+	if ((ret = ia_css_stream_start(isp_subdev->css2_basis.stream)) !=
+	    				IA_CSS_SUCCESS) {
+		v4l2_err(&atomisp_dev, "stream start error.\n");
+		goto start_err;
+	}
+
+	isp_subdev->css2_basis.stream_state = CSS2_STREAM_STARTED;
+	return IA_CSS_SUCCESS;
+
+start_err:
+	__destroy_stream(isp_subdev, true);
+stream_err:
+	__destroy_pipes(isp_subdev, true);
+
+	/* css 2.0 API limitation: ia_css_stop_sp() could be only called after
+	 * destroy all pipes
+	 * */
+	if (atomisp_subdev_streaming_count(isp_subdev->isp)){
+			v4l2_dbg(3, dbg_level, &atomisp_dev, "can not stop sp.\n");
+	} else if(ia_css_isp_has_started())
+		if(ia_css_stop_sp() != IA_CSS_SUCCESS)
+			v4l2_warn(&atomisp_dev, "stop sp failed\n");
+pipe_err:
+	return ret;
+}
+
+
+enum ia_css_err ia_css_stop(struct atomisp_sub_device *isp_subdev, bool in_reset)
+{
+	int i = 0;
+	enum ia_css_err ret = IA_CSS_SUCCESS;
+
+
+	/* if is called in atomisp_reset(), force destroy stream */
+	if ((ret = __destroy_stream(isp_subdev, true)) != IA_CSS_SUCCESS) {
+		v4l2_err(&atomisp_dev, "destroy stream failed.\n");
+		goto err;
+	}
+	/* if is called in atomisp_reset(), force destroy all pipes */
+
+	if ((ret = __destroy_pipes(isp_subdev, true)) != IA_CSS_SUCCESS) {
+		v4l2_err(&atomisp_dev, "destroy pipes failed.\n");
+		goto err;
+	}
+
+	/*
+	 * SP can not be stopped if other streams are still running
+	 * if atomisp_subdev_streaming_count() tell there aleady has some subdev
+	 * at streamming, then SP can not be stopped, so
+	 * need to skip start sp procedure
+	 */
+	if (atomisp_subdev_streaming_count(isp_subdev->isp)) {
+		v4l2_info(&atomisp_dev, "skip stop sp.\n");
+	} else if (ia_css_isp_has_started()) {
+		if (ia_css_stop_sp() != IA_CSS_SUCCESS) {
+			v4l2_err(&atomisp_dev, "stop sp failed.\n");
+			goto err;
+		}
+	}
+
+	isp_subdev->css2_basis.stream_state = CSS2_STREAM_STOPPED;
+
+	/* FIXME: Current code would cause streamon, then streamoff failed
+	 * If configs are not cleared, it would create wrong pipe/stream in
+	 * set format. No better solution has found yet.*/
+	if (!in_reset) {
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+			ia_css_pipe_config_defaults(&isp_subdev->css2_basis.pipe_configs[i]);
+			ia_css_pipe_extra_config_defaults(
+						&isp_subdev->css2_basis.pipe_extra_configs[i]);
+		}
+		ia_css_stream_config_defaults(&isp_subdev->css2_basis.stream_config);
+	}
+
+	return IA_CSS_SUCCESS;
+
+err:
+	v4l2_err(&atomisp_dev, "stop css fatal error. cannot recover\n");
+	return ret;
+}
+
+void
+ia_css_disable_vf_pp(struct atomisp_sub_device *isp_subdev, bool disable)
+{
+	int i;
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+		isp_subdev->css2_basis.pipe_extra_configs[i].disable_vf_pp
+    							= !!disable;
+}
+void atomisp_css2_hw_store_8(hrt_address addr, uint8_t data)
+{
+        unsigned long flags;
+
+	MMIO_LOCK
+	PCI_CONFIG_LOCK
+        _hrt_master_port_store_8(addr, data);
+	PCI_CONFIG_UNLOCK
+	MMIO_UNLOCK
+}
+
+void atomisp_css2_hw_store_16(hrt_address addr, uint16_t data)
+{
+        unsigned long flags;
+
+	MMIO_LOCK
+	PCI_CONFIG_LOCK
+        _hrt_master_port_store_16(addr, data);
+	PCI_CONFIG_UNLOCK
+	MMIO_UNLOCK
+}
+
+void atomisp_css2_hw_store_32(hrt_address addr, uint32_t data)
+{
+        unsigned long flags;
+
+	MMIO_LOCK
+	PCI_CONFIG_LOCK
+        _hrt_master_port_store_32(addr, data);
+	PCI_CONFIG_UNLOCK
+	MMIO_UNLOCK
+}
+
+uint8_t atomisp_css2_hw_load_8(hrt_address addr)
+{
+        unsigned long flags;
+        uint8_t ret;
+
+	MMIO_LOCK
+	PCI_CONFIG_LOCK
+        ret = _hrt_master_port_load_8(addr);
+	PCI_CONFIG_UNLOCK
+	MMIO_UNLOCK
+        return ret;
+}
+
+uint16_t atomisp_css2_hw_load_16(hrt_address addr)
+{
+        unsigned long flags;
+        uint16_t ret;
+
+	MMIO_LOCK
+	PCI_CONFIG_LOCK
+        ret = _hrt_master_port_load_16(addr);
+	PCI_CONFIG_UNLOCK
+	MMIO_UNLOCK
+        return ret;
+}
+uint32_t atomisp_css2_hw_load_32(hrt_address addr)
+{
+        unsigned long flags;
+        uint32_t ret;
+
+	MMIO_LOCK
+	PCI_CONFIG_LOCK
+        ret = _hrt_master_port_load_32(addr);
+	PCI_CONFIG_UNLOCK
+	MMIO_UNLOCK
+        return ret;
+}
+
+void atomisp_css2_hw_store(hrt_address addr,
+                                  const void *from, uint32_t n)
+{
+        unsigned long flags;
+        unsigned i;
+        unsigned int _to = (unsigned int)addr;
+        const char *_from = (const char *)from;
+
+	MMIO_LOCK
+	PCI_CONFIG_LOCK
+        for (i = 0; i < n; i++, _to++, _from++)
+                _hrt_master_port_store_8(_to , *_from);
+	PCI_CONFIG_UNLOCK
+	MMIO_UNLOCK
+}
+
+void atomisp_css2_hw_load(hrt_address addr, void *to, uint32_t n)
+{
+        unsigned long flags;
+        unsigned i;
+        char *_to = (char *)to;
+        unsigned int _from = (unsigned int)addr;
+
+	MMIO_LOCK
+	PCI_CONFIG_LOCK
+        for (i = 0; i < n; i++, _to++, _from++)
+                *_to = _hrt_master_port_load_8(_from);
+	PCI_CONFIG_UNLOCK
+	MMIO_UNLOCK
+}
diff --git a/drivers/media/atomisp2/atomisp_compat.h b/drivers/media/atomisp2/atomisp_compat.h
new file mode 100644
index 0000000..7b3fa9f
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_compat.h
@@ -0,0 +1,168 @@
+/*
+ * Support for Clovertrail PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css.h"
+#include "sh_css_sp.h"
+#include "atomisp_internal.h"
+
+#define ia_css_sp_has_booted() ia_css_sp_has_initialized()
+
+struct atomisp_sub_device;
+
+//static inline enum sh_css_err sh_css_allocate_continuous_frames(bool enable)
+//{
+	//return sh_css_err_unsupported_configuration;
+//}
+
+void atomisp_css_uninit(struct atomisp_device *isp);
+
+enum ia_css_err ia_css_preview_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format);
+
+enum ia_css_err ia_css_preview_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+enum ia_css_err ia_css_capture_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format);
+
+enum ia_css_err ia_css_capture_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+enum ia_css_err ia_css_capture_configure_viewfinder(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format);
+
+enum ia_css_err ia_css_capture_get_viewfinder_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+enum ia_css_err ia_css_video_configure_output(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format);
+
+enum ia_css_err ia_css_video_get_output_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+enum ia_css_err ia_css_video_configure_viewfinder(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format);
+
+enum ia_css_err ia_css_video_get_viewfinder_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+enum ia_css_err ia_css_preview_configure_pp_input(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height);
+
+enum ia_css_err ia_css_capture_configure_pp_input(
+	struct atomisp_sub_device *isp_subdev,
+	unsigned int width,
+	unsigned int height);
+
+void
+ia_css_enable_dz(struct atomisp_sub_device *isp_subdev,
+                       bool enable);
+void
+ia_css_capture_set_mode(struct atomisp_sub_device *isp_subdev,
+			enum ia_css_capture_mode mode);
+
+void
+ia_css_input_set_resolution(struct atomisp_sub_device *isp_subdev,
+                       struct v4l2_mbus_framefmt *ffmt);
+void
+ia_css_input_set_format(struct atomisp_sub_device *isp_subdev,
+                       enum ia_css_stream_format format);
+void
+ia_css_input_set_binning_factor(struct atomisp_sub_device *isp_subdev,
+                       unsigned int binning_factor);
+void
+ia_css_input_set_bayer_order(struct atomisp_sub_device *isp_subdev,
+                       enum ia_css_bayer_order bayer_order);
+
+void
+ia_css_capture_enable_online(struct atomisp_sub_device *isp_subdev,
+			     bool enable);
+
+void
+ia_css_enable_raw_binning(struct atomisp_sub_device *isp_subdev,
+			     bool enable);
+void
+ia_css_video_set_dis_envelope(struct atomisp_sub_device *isp_subdev,
+                 unsigned int dvs_w, unsigned int dvs_h);
+
+void
+ia_css_input_set_two_pixels_per_clock(struct atomisp_sub_device *isp_subdev,
+					   bool enable);
+
+void ia_css_preview_enable_online(struct atomisp_sub_device *isp_subdev,
+				  bool enable);
+void ia_css_enable_continuous(struct atomisp_sub_device *isp_subdev,
+				  bool enable);
+enum ia_css_err ia_css_capture_get_output_raw_frame_info(
+	struct atomisp_sub_device *isp_subdev,
+	struct ia_css_frame_info *info);
+
+//void atomisp_sh_css_mmu_set_page_table_base_index(unsigned int base_index);
+int atomisp_css_init(struct atomisp_device *isp);
+enum ia_css_err ia_css_stop(struct atomisp_sub_device *isp_subdev, bool need_reset);
+enum ia_css_err ia_css_start(struct atomisp_sub_device *isp_subdev, bool need_reset);
+void ia_css_disable_vf_pp(struct atomisp_sub_device *isp_subdev, bool disable);
+
+void
+ia_css_input_set_mode(struct atomisp_sub_device *isp_subdev,
+		      enum ia_css_input_mode mode);
+
+enum ia_css_err __destroy_stream(struct atomisp_sub_device *isp_subdev, bool force);
+
+enum ia_css_err __destroy_pipes(struct atomisp_sub_device *isp_subdev, bool force);
+
+enum ia_css_input_mode get_input_mode(unsigned int input_type, struct atomisp_device *isp);
+
+enum ia_css_err ia_css_update_stream(struct atomisp_sub_device *isp_subdev);
+
+void atomisp_destroy_pipes_stream_force(struct atomisp_sub_device *isp_subdev);
+void atomisp_css_update_isp_params(struct atomisp_sub_device *isp_subdev);
+
+void atomisp_css2_hw_store_8(hrt_address addr, uint8_t data);
+void atomisp_css2_hw_store_16(hrt_address addr, uint16_t data);
+void atomisp_css2_hw_store_32(hrt_address addr, uint32_t data);
+uint8_t atomisp_css2_hw_load_8(hrt_address addr);
+uint16_t atomisp_css2_hw_load_16(hrt_address addr);
+uint32_t atomisp_css2_hw_load_32(hrt_address addr);
+void atomisp_css2_hw_store(hrt_address addr, const void *from, uint32_t n);
+void atomisp_css2_hw_load(hrt_address addr, void *to, uint32_t n);
diff --git a/drivers/media/atomisp2/atomisp_csi2.c b/drivers/media/atomisp2/atomisp_csi2.c
new file mode 100644
index 0000000..d176f98
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_csi2.c
@@ -0,0 +1,387 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <media/v4l2-event.h>
+#include <media/v4l2-mediabus.h>
+#include "atomisp_internal.h"
+
+static const unsigned int csi2_input_fmts[] = {
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+};
+
+static const unsigned int csi2_output_fmts[] = {
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+};
+
+
+/* V4L2 subdev operations */
+
+static struct v4l2_mbus_framefmt *
+__csi2_get_format(struct atomisp_mipi_csi2_device *csi2,
+		struct v4l2_subdev_fh *fh,
+		unsigned int pad,
+		enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(fh, pad);
+	else
+		return &csi2->formats[pad];
+}
+
+static enum media_bus_format
+isp_video_uncompressed_code(enum media_bus_format code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+		return MEDIA_BUS_FMT_SBGGR10_1X10;
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+		return MEDIA_BUS_FMT_SGRBG10_1X10;
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+		return MEDIA_BUS_FMT_SRGGB10_1X10;
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+		return MEDIA_BUS_FMT_SGBRG10_1X10;
+	default:
+		return code;
+	}
+}
+
+static void
+csi2_try_format(struct atomisp_mipi_csi2_device *csi2,
+	struct v4l2_subdev_fh *fh,
+	unsigned int pad,
+	struct v4l2_mbus_framefmt *fmt,
+	enum v4l2_subdev_format_whence which)
+{
+	enum media_bus_format pixelcode;
+	struct v4l2_mbus_framefmt *format;
+	unsigned int i;
+
+	switch (pad) {
+	case CSI2_PAD_SINK:
+		/* Clamp the width and height to valid range (1-8191). */
+		for (i = 0; i < ARRAY_SIZE(csi2_input_fmts); i++) {
+			if (fmt->code == csi2_input_fmts[i])
+				break;
+		}
+
+		/* If not found, use SGRBG10 as default */
+		if (i >= ARRAY_SIZE(csi2_input_fmts))
+			fmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+
+		fmt->width = clamp_t(u32, fmt->width, 1, 4608);
+		fmt->height = clamp_t(u32, fmt->height, 1, 8191);
+		break;
+
+	case CSI2_PAD_SOURCE:
+		/* Source format same as sink format, except for DPCM
+		 * compression.
+		 */
+		pixelcode = fmt->code;
+		format = __csi2_get_format(csi2, fh, CSI2_PAD_SINK, which);
+		memcpy(fmt, format, sizeof(*fmt));
+
+		/* allow dpcm decompression */
+		if (isp_video_uncompressed_code(fmt->code) == pixelcode)
+			fmt->code = pixelcode;
+
+		break;
+
+	default:
+		break;
+	}
+
+	/* RGB, non-interlaced */
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+/*
+ * csi2_enum_mbus_code - Handle pixel format enumeration
+ * @sd     : pointer to v4l2 subdev structure
+ * @fh     : V4L2 subdev file handle
+ * @code   : pointer to v4l2_subdev_pad_mbus_code_enum structure
+ * return -EINVAL or zero on success
+*/
+static int csi2_enum_mbus_code(struct v4l2_subdev *sd,
+			struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	if (code->pad == CSI2_PAD_SINK) {
+		if (code->index >= ARRAY_SIZE(csi2_input_fmts))
+			return -EINVAL;
+		code->code = csi2_input_fmts[code->index];
+	} else {
+		format = __csi2_get_format(csi2, fh, CSI2_PAD_SINK,
+			V4L2_SUBDEV_FORMAT_TRY);
+		switch (code->index) {
+		case 0:
+			/* Passthrough sink pad code */
+			code->code = format->code;
+			break;
+		case 1:
+			/* Uncompressed code */
+			code->code = isp_video_uncompressed_code(format->code);
+			break;
+		default:
+			/* Fallthrough if above is false */
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * csi2_get_format - Handle get format by pads subdev method
+ * @sd : pointer to v4l2 subdev structure
+ * @fh : V4L2 subdev file handle
+ * @pad: pad num
+ * @fmt: pointer to v4l2 format structure
+ * return -EINVAL or zero on sucess
+*/
+static int csi2_get_format(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh, struct v4l2_subdev_format *fmt)
+{
+	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __csi2_get_format(csi2, fh, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+/*
+ * csi2_set_format - Handle set format by pads subdev method
+ * @sd : pointer to v4l2 subdev structure
+ * @fh : V4L2 subdev file handle
+ * @pad: pad num
+ * @fmt: pointer to v4l2 format structure
+ * return -EINVAL or zero on success
+*/
+static int csi2_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		    struct v4l2_subdev_format *fmt)
+{
+	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __csi2_get_format(csi2, fh, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	csi2_try_format(csi2, fh, fmt->pad, &fmt->format, fmt->which);
+	*format = fmt->format;
+
+	/* Propagate the format from sink to source */
+	if (fmt->pad == CSI2_PAD_SINK) {
+		format = __csi2_get_format(csi2, fh, CSI2_PAD_SOURCE,
+			fmt->which);
+		*format = fmt->format;
+		csi2_try_format(csi2, fh, CSI2_PAD_SOURCE, format, fmt->which);
+	}
+
+	return 0;
+}
+
+/*
+ * csi2_set_stream - Enable/Disable streaming on the CSI2 module
+ * @sd: ISP CSI2 V4L2 subdevice
+ * @enable: Enable/disable stream (1/0)
+ *
+ * Return 0 on success or a negative error code otherwise.
+*/
+static int csi2_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	 return 0;
+}
+
+/* subdev core operations */
+static const struct v4l2_subdev_core_ops csi2_core_ops = {
+	.queryctrl = v4l2_subdev_queryctrl,
+	.querymenu = v4l2_subdev_querymenu,
+	.g_ctrl = v4l2_subdev_g_ctrl,
+	.s_ctrl = v4l2_subdev_s_ctrl,
+	.g_ext_ctrls = v4l2_subdev_g_ext_ctrls,
+	.try_ext_ctrls = v4l2_subdev_try_ext_ctrls,
+	.s_ext_ctrls = v4l2_subdev_s_ext_ctrls,
+};
+
+/* subdev video operations */
+static const struct v4l2_subdev_video_ops csi2_video_ops = {
+	.s_stream = csi2_set_stream,
+};
+
+/* subdev pad operations */
+static const struct v4l2_subdev_pad_ops csi2_pad_ops = {
+	.enum_mbus_code = csi2_enum_mbus_code,
+	.get_fmt = csi2_get_format,
+	.set_fmt = csi2_set_format,
+};
+
+/* subdev operations */
+static const struct v4l2_subdev_ops csi2_ops = {
+	.core = &csi2_core_ops,
+	.video = &csi2_video_ops,
+	.pad = &csi2_pad_ops,
+};
+
+
+/*
+ * csi2_link_setup - Setup CSI2 connections.
+ * @entity : Pointer to media entity structure
+ * @local  : Pointer to local pad array
+ * @remote : Pointer to remote pad array
+ * @flags  : Link flags
+ * return -EINVAL or zero on success
+*/
+static int csi2_link_setup(struct media_entity *entity,
+	    const struct media_pad *local,
+	    const struct media_pad *remote, u32 flags)
+{
+	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
+	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
+	u32 result = local->index | media_entity_type(remote->entity);
+
+	switch (result) {
+	case CSI2_PAD_SOURCE | MEDIA_ENT_T_DEVNODE:
+		/* not supported yet */
+		return -EINVAL;
+
+	case CSI2_PAD_SOURCE | MEDIA_ENT_T_V4L2_SUBDEV:
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (csi2->output & ~CSI2_OUTPUT_ISP_SUBDEV)
+				return -EBUSY;
+			csi2->output |= CSI2_OUTPUT_ISP_SUBDEV;
+		} else {
+			csi2->output &= ~CSI2_OUTPUT_ISP_SUBDEV;
+		}
+		break;
+
+	default:
+		/* Link from camera to CSI2 is fixed... */
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* media operations */
+static const struct media_entity_operations csi2_media_ops = {
+	.link_setup = csi2_link_setup,
+};
+
+/*
+* ispcsi2_init_entities - Initialize subdev and media entity.
+* @csi2: Pointer to ispcsi2 structure.
+* return -ENOMEM or zero on success
+*/
+static int mipi_csi2_init_entities(struct atomisp_mipi_csi2_device *csi2,
+					int port)
+{
+	struct v4l2_subdev *sd = &csi2->subdev;
+	struct media_pad *pads = csi2->pads;
+	struct media_entity *me = &sd->entity;
+	int ret;
+
+	v4l2_subdev_init(sd, &csi2_ops);
+	snprintf(sd->name, sizeof(sd->name), "ATOM ISP CSI2-port%d", port);
+
+	v4l2_set_subdevdata(sd, csi2);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pads[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	pads[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+
+	me->ops = &csi2_media_ops;
+	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
+	ret = media_entity_init(me, CSI2_PADS_NUM, pads, 0);
+	if (ret < 0)
+		return ret;
+
+	csi2->formats[CSI2_PAD_SINK].code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	csi2->formats[CSI2_PAD_SOURCE].code = MEDIA_BUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+void
+atomisp_mipi_csi2_unregister_entities(struct atomisp_mipi_csi2_device *csi2)
+{
+	media_entity_cleanup(&csi2->subdev.entity);
+	v4l2_device_unregister_subdev(&csi2->subdev);
+}
+
+int atomisp_mipi_csi2_register_entities(struct atomisp_mipi_csi2_device *csi2,
+			struct v4l2_device *vdev)
+{
+	int ret;
+
+	/* Register the subdev and video nodes. */
+	ret = v4l2_device_register_subdev(vdev, &csi2->subdev);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	atomisp_mipi_csi2_unregister_entities(csi2);
+	return ret;
+}
+
+/*
+ * atomisp_mipi_csi2_cleanup - Routine for module driver cleanup
+*/
+void atomisp_mipi_csi2_cleanup(struct atomisp_device *isp)
+{
+}
+
+
+int atomisp_mipi_csi2_init(struct atomisp_device *isp)
+{
+	struct atomisp_mipi_csi2_device *csi2_port;
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
+		csi2_port = &isp->csi2_port[i];
+		csi2_port->isp = isp;
+		ret = mipi_csi2_init_entities(csi2_port, i);
+		if (ret < 0)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	atomisp_mipi_csi2_cleanup(isp);
+	return ret;
+}
+
diff --git a/drivers/media/atomisp2/atomisp_csi2.h b/drivers/media/atomisp2/atomisp_csi2.h
new file mode 100644
index 0000000..42ff5bb
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_csi2.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef __ATOMISP_CSI2_H__
+#define __ATOMISP_CSI2_H__
+
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+
+#define CSI2_PAD_SINK		0
+#define CSI2_PAD_SOURCE		1
+#define CSI2_PADS_NUM		2
+
+#define CSI2_OUTPUT_ISP_SUBDEV	(1 << 0)
+#define CSI2_OUTPUT_MEMORY	(1 << 1)
+
+struct atomisp_device;
+struct v4l2_device;
+
+struct atomisp_mipi_csi2_device {
+	struct v4l2_subdev subdev;
+	struct media_pad pads[CSI2_PADS_NUM];
+	struct v4l2_mbus_framefmt formats[CSI2_PADS_NUM];
+
+	struct v4l2_ctrl_handler ctrls;
+	struct atomisp_device *isp;
+
+	u32 output; /* output direction */
+};
+
+int atomisp_mipi_csi2_init(struct atomisp_device *isp);
+void atomisp_mipi_csi2_cleanup(struct atomisp_device *isp);
+void atomisp_mipi_csi2_unregister_entities(
+					struct atomisp_mipi_csi2_device *csi2);
+int atomisp_mipi_csi2_register_entities(struct atomisp_mipi_csi2_device *csi2,
+			struct v4l2_device *vdev);
+
+#endif /* __ATOMISP_CSI2_H__ */
diff --git a/drivers/media/atomisp2/atomisp_file.c b/drivers/media/atomisp2/atomisp_file.c
new file mode 100644
index 0000000..e1f60e2
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_file.c
@@ -0,0 +1,354 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <media/v4l2-event.h>
+#include <media/v4l2-mediabus.h>
+
+#include <linux/delay.h>
+
+#include <ia_css.h>
+
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_file.h"
+#include "atomisp_internal.h"
+#include "atomisp_ioctl.h"
+
+static void file_work(struct work_struct *work)
+{
+	struct atomisp_file_device *file_dev = container_of(work,
+					struct atomisp_file_device, work_thread);
+	struct atomisp_device *isp = file_dev->isp;
+	struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[0];
+	struct atomisp_video_pipe *out_pipe = &isp_subdev->video_in;
+	unsigned short *buf = NULL;
+	struct v4l2_mbus_framefmt isp_sink_fmt;
+
+	if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED)
+		return;
+
+	dev_dbg(isp->dev, ">%s: ready to start streaming\n", __func__);
+	isp_sink_fmt = *atomisp_subdev_get_ffmt(isp_subdev, NULL,
+						V4L2_SUBDEV_FORMAT_ACTIVE,
+						ATOMISP_SUBDEV_PAD_SINK);
+	while (1) {
+		wait_for_completion(&file_dev->file_inject_start);
+		INIT_COMPLETION(file_dev->file_inject_start);
+
+		if (out_pipe->vb2outq.bufs[file_dev->framecount] == NULL)
+			file_dev->framecount = 0;
+		buf = vb2_plane_vaddr(out_pipe->vb2outq.bufs[file_dev->framecount], 0);
+		file_dev->framecount++;
+
+		if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED || !file_dev->fStreaming)
+			return;
+
+		while (!ia_css_isp_has_started())
+			usleep_range(1000, 1500);
+
+		ia_css_stream_send_input_frame(isp_subdev->css2_basis.stream,
+				       buf, isp_sink_fmt.width, isp_sink_fmt.height);
+	}
+
+	dev_dbg(isp->dev, "<%s: streaming done\n", __func__);
+}
+
+static int file_input_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct atomisp_file_device *file_dev = v4l2_get_subdevdata(sd);
+	struct atomisp_device *isp = file_dev->isp;
+
+	dev_dbg(isp->dev, "%s: enable %d\n", __func__, enable);
+	if (enable) {
+		if (isp->isp_subdev[0].streaming != ATOMISP_DEVICE_STREAMING_ENABLED)
+			return 0;
+
+		if (!file_dev->fWork_queued) {
+			queue_work(file_dev->work_queue, &file_dev->work_thread);
+			file_dev->fWork_queued = true;
+		}
+
+		file_dev->fStreaming = true;
+		complete(&file_dev->file_inject_start);
+	} else {
+		if (!file_dev->fWork_queued)
+			return 0;
+
+		file_dev->fStreaming = false;
+		complete(&file_dev->file_inject_start);
+		cancel_work_sync(&file_dev->work_thread);
+		file_dev->fWork_queued = false;
+	}
+	return 0;
+}
+
+static int file_input_g_parm(struct v4l2_subdev *sd,
+		struct v4l2_streamparm *param)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_s_parm(struct v4l2_subdev *sd,
+		struct v4l2_streamparm *param)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				enum media_bus_format *code)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct atomisp_file_device *file_dev = v4l2_get_subdevdata(sd);
+	struct atomisp_device *isp = file_dev->isp;
+	struct v4l2_mbus_framefmt *isp_sink_fmt;
+
+	isp_sink_fmt = atomisp_subdev_get_ffmt(&isp->isp_subdev[0], NULL,
+					       V4L2_SUBDEV_FORMAT_ACTIVE,
+					       ATOMISP_SUBDEV_PAD_SINK);
+
+	fmt->width = isp_sink_fmt->width;
+	fmt->height = isp_sink_fmt->height;
+	trace_printk("WARNING: in file_input_g_mbus_fmt, overwriting MBUS FMT to FIXED!!!. %dx%d\n", fmt->width, fmt->height);
+	fmt->code = isp_sink_fmt->code; //TODO set right code
+
+	return 0;
+}
+
+static int file_input_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct atomisp_file_device *file_dev = v4l2_get_subdevdata(sd);
+        struct atomisp_device *isp = file_dev->isp;
+
+	file_input_g_mbus_fmt(sd, fmt);
+	isp->isp_subdev[0].css2_basis.stream_config.mode = IA_CSS_INPUT_MODE_FIFO;
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
+static int file_input_g_chip_ident(struct v4l2_subdev *sd,
+			       struct v4l2_dbg_chip_ident *chip)
+{
+	if (!chip)
+		return -EINVAL;
+
+	return 0;
+}
+#endif
+
+static int file_input_log_status(struct v4l2_subdev *sd)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/*to fake*/
+	return -EINVAL;
+}
+
+static int file_input_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	/*to fake*/
+	return -EINVAL;
+}
+
+static int file_input_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_s_power(struct v4l2_subdev *sd, int on)
+{
+	/* to fake */
+	return 0;
+}
+
+static int file_input_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int file_input_enum_frame_ival(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_frame_interval_enum *fie)
+{
+	/*to fake*/
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops file_input_video_ops = {
+	.s_stream = file_input_s_stream,
+	.g_parm = file_input_g_parm,
+	.s_parm = file_input_s_parm,
+	.enum_framesizes = file_input_enum_framesizes,
+	.enum_frameintervals = file_input_enum_frameintervals,
+	.enum_mbus_fmt = file_input_enum_mbus_fmt,
+	.try_mbus_fmt = file_input_g_mbus_fmt,
+	.g_mbus_fmt = file_input_g_mbus_fmt,
+	.s_mbus_fmt = file_input_s_mbus_fmt,
+};
+
+static const struct v4l2_subdev_core_ops file_input_core_ops = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
+	.g_chip_ident = file_input_g_chip_ident,
+#endif
+	.log_status = file_input_log_status,
+	.queryctrl = file_input_queryctrl,
+	.g_ctrl = file_input_g_ctrl,
+	.s_ctrl = file_input_s_ctrl,
+	.s_power = file_input_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops file_input_pad_ops = {
+	.enum_mbus_code = file_input_enum_mbus_code,
+	.enum_frame_size = file_input_enum_frame_size,
+	.enum_frame_interval = file_input_enum_frame_ival,
+};
+
+static const struct v4l2_subdev_ops file_input_ops = {
+	.core = &file_input_core_ops,
+	.video = &file_input_video_ops,
+	.pad = &file_input_pad_ops,
+};
+
+void
+atomisp_file_input_unregister_entities(struct atomisp_file_device *file_dev)
+{
+	media_entity_cleanup(&file_dev->sd.entity);
+	v4l2_device_unregister_subdev(&file_dev->sd);
+}
+
+int atomisp_file_input_register_entities(struct atomisp_file_device *file_dev,
+			struct v4l2_device *vdev)
+{
+	/* Register the subdev and video nodes. */
+	return  v4l2_device_register_subdev(vdev, &file_dev->sd);
+}
+
+void atomisp_file_input_cleanup(struct atomisp_device *isp)
+{
+	struct atomisp_file_device *file_dev = &isp->file_dev;
+
+	if (file_dev->fWork_queued) {
+		file_dev->fStreaming = false;
+		complete(&file_dev->file_inject_start);
+		cancel_work_sync(&file_dev->work_thread);
+		file_dev->fWork_queued = false;
+	}
+
+	if (file_dev->work_queue) {
+		destroy_workqueue(file_dev->work_queue);
+		file_dev->work_queue = NULL;
+	}
+
+	return;
+}
+
+int atomisp_file_input_init(struct atomisp_device *isp)
+{
+	struct atomisp_file_device *file_dev = &isp->file_dev;
+	struct v4l2_subdev *sd = &file_dev->sd;
+	struct media_pad *pads = file_dev->pads;
+	struct media_entity *me = &sd->entity;
+	struct camera_mipi_info *file_input_info = NULL;
+	int ret;
+
+	file_dev->isp = isp;
+	file_dev->work_queue = create_singlethread_workqueue(
+				"ATOMISP file injection work queue");
+	if (!file_dev->work_queue) {
+		dev_warn(isp->dev,
+			"Failed to create file inject work queue\n");
+		return -ENOMEM;
+	}
+	INIT_WORK(&file_dev->work_thread, file_work);
+	init_completion(&file_dev->file_inject_start);
+	file_dev->fWork_queued = false;
+	file_dev->fStreaming = false;
+	file_dev->framecount = 0;
+	v4l2_subdev_init(sd, &file_input_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	strcpy(sd->name, "file_input_subdev");
+	v4l2_set_subdevdata(sd, file_dev);
+
+	file_input_info = kzalloc(sizeof(*file_input_info), GFP_KERNEL);
+	if (!file_input_info) {
+		v4l2_err(&atomisp_dev,
+			    "Failed to allocate memory for file input\n");
+		return -ENOMEM;
+	}
+
+	file_input_info->port = ATOMISP_CAMERA_PORT_PRIMARY;
+	/* the default input format is IA_CSS_STREAM_FORMAT_YUV422_8
+	and no bayer order */
+	v4l2_set_subdev_hostdata(sd, (void *)file_input_info);
+
+	pads[0].flags = MEDIA_PAD_FL_SINK;
+	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
+
+	ret = media_entity_init(me, 1, pads, 0);
+	if (ret < 0)
+		goto fail;
+	return 0;
+fail:
+	kfree(file_input_info);
+	atomisp_file_input_cleanup(isp);
+	return ret;
+}
diff --git a/drivers/media/atomisp2/atomisp_file.h b/drivers/media/atomisp2/atomisp_file.h
new file mode 100644
index 0000000..21afc8f
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_file.h
@@ -0,0 +1,51 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ATOMISP_FILE_H__
+#define __ATOMISP_FILE_H__
+
+#include <media/media-entity.h>
+#include <media/v4l2-subdev.h>
+
+struct atomisp_device;
+
+struct atomisp_file_device {
+	struct v4l2_subdev sd;
+	struct atomisp_device *isp;
+	struct media_pad pads[1];
+
+	struct workqueue_struct *work_queue;
+	struct work_struct work_thread;
+	bool fWork_queued;
+	bool fStreaming;
+	 struct completion file_inject_start;
+	int framecount;
+};
+
+void atomisp_file_input_cleanup(struct atomisp_device *isp);
+int atomisp_file_input_init(struct atomisp_device *isp);
+void atomisp_file_input_unregister_entities(
+				struct atomisp_file_device *file_dev);
+int atomisp_file_input_register_entities(struct atomisp_file_device *file_dev,
+			struct v4l2_device *vdev);
+#endif /* __ATOMISP_FILE_H__ */
diff --git a/drivers/media/atomisp2/atomisp_fops.c b/drivers/media/atomisp2/atomisp_fops.c
new file mode 100644
index 0000000..43a90f8
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_fops.c
@@ -0,0 +1,1013 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_compat.h"
+#include "atomisp_fops.h"
+#include "atomisp_internal.h"
+#include "atomisp_ioctl.h"
+#include "atomisp_subdev.h"
+#include "atomisp-regs.h"
+
+#include "hrt/hive_isp_css_mm_hrt.h"
+#include "hrt/hive_isp_css_custom_host_hrt.h"
+
+#include "ia_css_debug.h"
+#include "host/mmu_local.h"
+#include "device_access/device_access.h"
+#include "memory_access/memory_access.h"
+
+#include "atomisp_acc.h"
+
+#define ISP_LEFT_PAD			128	/* equal to 2*NWAY */
+#define CSS_DTRACE_VERBOSITY_LEVEL	5	/* Controls trace verbosity */
+
+/*
+ * input image data, and current frame resolution for test
+ */
+#define	ISP_PARAM_MMAP_OFFSET	0xfffff000
+
+#define MAGIC_CHECK(is, should)	\
+	if (unlikely((is) != (should))) { \
+		printk(KERN_ERR "magic mismatch: %x (expected %x)\n", \
+			is, should); \
+		BUG(); \
+	}
+
+
+
+int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			     struct atomisp_video_pipe *pipe,
+			     enum ia_css_buffer_type css_buf_type,
+			     enum ia_css_pipe_id css_pipe_id, bool streamoff)
+{
+	struct atomisp_vb2 *vb2;
+	unsigned long irqflags;
+	int err, pipe_index;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "ENTER q_video_buffers_to_css, pipe=%p, pipe_type=%d, activeq list empty=%s, buffers_in_css=%d\n", pipe, pipe->pipe_type, (list_empty(&pipe->activeq))?"true":"false", pipe->buffers_in_css);
+
+	while (pipe->buffers_in_css < ATOMISP_CSS_Q_DEPTH) {
+		struct ia_css_buffer css_buf;
+		memset(&css_buf, 0, sizeof(struct ia_css_buffer));
+		spin_lock_irqsave(&pipe->irq_lock, irqflags);
+        if (list_empty(&pipe->activeq) || (!pipe->users)) {
+	        if(list_empty(&pipe->activeq))
+		        v4l2_dbg(4, dbg_level, &atomisp_dev, "atomisp_q_video_buffers_to_css: DMA activeq empty, exiting function\n");
+		    else
+			    v4l2_dbg(4, dbg_level, &atomisp_dev, "atomisp_q_video_buffers_to_css: pipe not in use, exiting function\n");
+		spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
+		return -EINVAL;
+		}
+		vb2 = list_entry(pipe->activeq.next,
+			struct atomisp_vb2, list);
+		list_del_init(&vb2->list);
+		spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
+		css_buf.type = css_buf_type;
+		css_buf.data.frame = vb2->cssframe;
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "q_video_buffers_to_css: DMA delete from activeq vb2 vaddr=%X, fd=%d, index=%d\n", vb2->cssframe->data, vb2->vb.v4l2_buf.m.fd, vb2->vb.v4l2_buf.index);
+		pipe_index = (unsigned int)(css_pipe_id);
+		err = ia_css_pipe_enqueue_buffer(isp_subdev->css2_basis.pipes[pipe_index],
+						 &css_buf);
+		if (err) {
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "ERROR with ia_css_pipe_enqueue_buffer");
+			spin_lock_irqsave(&pipe->irq_lock, irqflags);
+			list_add_tail(&vb2->list, &pipe->activeq);
+			spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
+			dev_err(isp->dev, "%s, css q fails: %d\n",
+					__func__, err);
+			return -EINVAL;
+		}
+
+		/*
+		 * CSS2.0 Issue: after stream off, need to queue 1 buffer to CSS
+		 * to recover SP.
+		 * So if it is in stream off state, only need to queue 1 buffer
+		 */
+
+		if (streamoff)
+			return 0;
+
+		pipe->buffers_in_css++;
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "Buffers in css incremented to %d\n", pipe->buffers_in_css);
+		vb2 = NULL;
+	}
+	return 0;
+}
+
+int atomisp_q_s3a_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			   enum ia_css_pipe_id css_pipe_id, bool streamoff)
+{
+	struct atomisp_s3a_buf *s3a_buf;
+	int pipe_index = 0;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (list_empty(&isp_subdev->s3a_stats)) {
+		WARN(1, "%s: No s3a buffers available!\n", __func__);
+		return -EINVAL;
+	}
+
+	while (isp_subdev->s3a_bufs_in_css[css_pipe_id] < ATOMISP_CSS_Q_DEPTH) {
+		struct ia_css_buffer buffer;
+		memset(&buffer, 0, sizeof(struct ia_css_buffer));
+		s3a_buf = list_entry(isp_subdev->s3a_stats.next,
+				struct atomisp_s3a_buf, list);
+		list_move_tail(&s3a_buf->list, &isp_subdev->s3a_stats);
+
+		buffer.type = IA_CSS_BUFFER_TYPE_3A_STATISTICS;
+		buffer.data.stats_3a = s3a_buf->s3a_stat;
+		pipe_index = (unsigned int)css_pipe_id;
+		if (ia_css_pipe_enqueue_buffer(
+					isp_subdev->css2_basis.pipes[pipe_index],
+					&buffer)) {
+			dev_err(isp->dev, "failed to q s3a stat buffer\n");
+			return -EINVAL;
+		}
+
+		/*
+		 * CSS2.0 Issue: after stream off, need to queue 1 buffer to CSS
+		 * to recover SP.
+		 * So if it is in stream off state, only need to queue 1 buffer
+		 */
+
+		if (streamoff)
+			return 0;
+
+		isp_subdev->s3a_bufs_in_css[css_pipe_id]++;
+	}
+	return 0;
+}
+
+int atomisp_q_dis_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			   enum ia_css_pipe_id css_pipe_id, bool streamoff)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct atomisp_dvs_buf *dvs_buf;
+	int pipe_index = 0;
+
+	if (list_empty(&isp_subdev->dvs_stats)) {
+		WARN(1, "%s: No dis buffers available!\n", __func__);
+		return -EINVAL;
+	}
+
+	while (isp_subdev->dis_bufs_in_css < ATOMISP_CSS_Q_DEPTH) {
+		struct ia_css_buffer buffer = {0};
+		dvs_buf = list_entry(isp_subdev->dvs_stats.next,
+				struct atomisp_dvs_buf, list);
+		list_move_tail(&dvs_buf->list, &isp_subdev->dvs_stats);
+
+		buffer.type = IA_CSS_BUFFER_TYPE_DIS_STATISTICS;
+		buffer.data.stats_dvs = dvs_buf->dvs_stat;
+		pipe_index = (unsigned int )(css_pipe_id);
+		if (ia_css_pipe_enqueue_buffer(isp_subdev->css2_basis.pipes[pipe_index],
+					&buffer)) {
+			dev_err(isp->dev, "failed to q dvs stat buffer\n");
+			return -EINVAL;
+		}
+		/*
+		 * CSS2.0 Issue: after stream off, need to queue 1 buffer to CSS
+		 * to recover SP.
+		 * So if it is in stream off state, only need to queue 1 buffer
+		 */
+		if (streamoff)
+			return 0;
+
+		isp_subdev->dis_bufs_in_css++;
+		dvs_buf = NULL;
+	}
+	return 0;
+}
+
+/* queue all available buffers to css */
+int atomisp_qbuffers_to_css(struct atomisp_sub_device *isp_subdev, bool streamoff)
+{
+	enum ia_css_buffer_type buf_type;
+	enum ia_css_pipe_id css_capture_pipe_id = IA_CSS_PIPE_ID_NUM;
+	enum ia_css_pipe_id css_preview_pipe_id = IA_CSS_PIPE_ID_NUM;
+	struct atomisp_video_pipe *capture_pipe = NULL;
+	struct atomisp_video_pipe *vf_pipe = NULL;
+	struct atomisp_video_pipe *preview_pipe = NULL;
+
+	if (!isp_subdev->enable_vfpp->val) {
+		preview_pipe = &isp_subdev->video_out_capture;
+		css_preview_pipe_id = IA_CSS_PIPE_ID_VIDEO;
+	} else if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+		if(isp_subdev->video_pipe_vf_enable)
+		     vf_pipe =  &isp_subdev->video_out_vf;
+		capture_pipe = &isp_subdev->video_out_capture;
+		preview_pipe = &isp_subdev->video_out_preview;
+		css_capture_pipe_id = IA_CSS_PIPE_ID_VIDEO;
+		css_preview_pipe_id = IA_CSS_PIPE_ID_VIDEO;
+	} else if (isp_subdev->params.continuous_vf) {
+		capture_pipe = &isp_subdev->video_out_capture;
+		vf_pipe = &isp_subdev->video_out_vf;
+		preview_pipe = &isp_subdev->video_out_preview;
+		css_capture_pipe_id = IA_CSS_PIPE_ID_CAPTURE;
+		css_preview_pipe_id = IA_CSS_PIPE_ID_PREVIEW;
+	} else if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_PREVIEW) {
+		preview_pipe = &isp_subdev->video_out_preview;
+		css_preview_pipe_id = IA_CSS_PIPE_ID_PREVIEW;
+	} else {
+		/* ATOMISP_RUN_MODE_STILL_CAPTURE */
+		capture_pipe = &isp_subdev->video_out_capture;
+		if (!atomisp_is_mbuscode_raw(isp_subdev->
+			    fmt[isp_subdev->capture_pad].fmt.code))
+			vf_pipe = &isp_subdev->video_out_vf;
+		else
+			vf_pipe = NULL; // Making vf_pipe = NULL since video_mode initialize it & for next capture_mode run it cause kernel panic
+		css_capture_pipe_id = IA_CSS_PIPE_ID_CAPTURE;
+	}
+
+	if (capture_pipe) {
+		buf_type = atomisp_get_css_buf_type(isp_subdev, capture_pipe);
+		atomisp_q_video_buffers_to_css(isp_subdev, capture_pipe, buf_type,
+					 css_capture_pipe_id, streamoff);
+	}
+
+	if (vf_pipe) {
+		buf_type = atomisp_get_css_buf_type(isp_subdev, vf_pipe);
+		atomisp_q_video_buffers_to_css(isp_subdev, vf_pipe, buf_type,
+					 css_capture_pipe_id, streamoff);
+	}
+
+	if (preview_pipe) {
+		buf_type = atomisp_get_css_buf_type(isp_subdev, preview_pipe);
+		atomisp_q_video_buffers_to_css(isp_subdev, preview_pipe, buf_type,
+					 css_preview_pipe_id, streamoff);
+	}
+
+	//Currently allowing only video mode to q stats buff.
+	//TODO: Enable stat bufs queuing if capture/preview mode supports dis & s3a
+	if(isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO){
+	if (isp_subdev->params.curr_grid_info.s3a_grid.enable) {
+		if (css_capture_pipe_id < IA_CSS_PIPE_ID_NUM)
+			atomisp_q_s3a_buffers_to_css(isp_subdev, css_capture_pipe_id, streamoff);
+		if (css_preview_pipe_id < IA_CSS_PIPE_ID_NUM && css_preview_pipe_id < IA_CSS_PIPE_ID_NUM)
+			atomisp_q_s3a_buffers_to_css(isp_subdev, css_preview_pipe_id, streamoff);
+	}
+
+	if (isp_subdev->params.curr_grid_info.dvs_grid.enable)
+		atomisp_q_dis_buffers_to_css(isp_subdev, css_capture_pipe_id, streamoff);
+	}
+	return 0;
+}
+
+static int atomisp_vb2_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,
+	unsigned int *nbuffers, unsigned int *nplanes,
+	unsigned int sizes[], void *alloc_ctxs[]) {
+	struct video_device *vdev = vb2_get_drv_priv(vq);
+  	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	unsigned long size;
+
+	if (fmt)
+		size = fmt->fmt.pix.sizeimage;
+	else {
+		size = pipe->pix.sizeimage;
+	}
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "atomisp_vb2_queue_setup: size=%lu\n", size);
+	trace_printk("atomisp_vb2_queue_setup: size=%lu\n", size);
+
+  if (size == 0)
+    return -EINVAL;
+
+  if (0 == *nbuffers) {
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "WARNING in atomisp_vb2_queue_setup, nbuffers == 0. Setting to 3\n");
+    *nbuffers = 3;
+	}
+
+  *nplanes = 1;
+  sizes[0] = size;
+
+	isp->raw_dmamask = DMA_BIT_MASK(36); /* 36 is ISP IUNIT MMU limit */
+	vdev->dev.dma_mask = &isp->raw_dmamask;
+	vdev->dev.coherent_dma_mask = isp->raw_dmamask;
+
+	alloc_ctxs[0] = vb2_dma_contig_init_ctx(&vdev->dev);
+	if (!alloc_ctxs[0]) {
+		v4l2_err(&atomisp_dev, "Error in atomisp_vb2_queue_setup allocating alloc_ctx\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* This gets called from vb2_qbuf if already streaming, and from vb2_streamon*/
+static void atomisp_vb2_buf_queue(struct vb2_buffer *vb) {
+	struct vb2_queue *q = vb->vb2_queue;
+	struct video_device *vdev = vb2_get_drv_priv(q);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_vb2 *buf = container_of(vb, struct atomisp_vb2, vb);
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA atomisp_vb2_buf_queue, adding buf %d to activeq\n", vb->v4l2_buf.index);
+
+	list_add_tail(&buf->list, &pipe->activeq);
+
+}
+static int atomisp_vb2_buf_prepare(struct vb2_buffer *vb) {
+  struct video_device *vdev = vb2_get_drv_priv(vb->vb2_queue);
+  struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	unsigned long size;
+
+	size = pipe->pix.sizeimage;
+
+	vb2_set_plane_payload(vb, 0, size);
+	//TODO handle more planes
+
+	return 0;
+}
+
+static void atomisp_vb2_unlock(struct vb2_queue *vq) {
+	struct video_device *vdev = vb2_get_drv_priv(vq);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	mutex_unlock(&isp->vb2mutex);
+}
+
+static void atomisp_vb2_lock(struct vb2_queue *vq) {
+	struct video_device *vdev = vb2_get_drv_priv(vq);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	mutex_lock(&isp->vb2mutex);
+}
+
+static int atomisp_vb2_start_streaming(struct vb2_queue *vq, unsigned int count) {
+/*
+	called once to enter 'streaming' state; the driver may
+  receive buffers with @buf_queue callback before
+  @start_streaming is called; the driver gets the number
+  of already queued buffers in count parameter; driver
+  can return an error if hardware fails or not enough
+  buffers has been queued, in such case all buffers that
+  have been already given by the @buf_queue callback are
+  invalidated.
+*/
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "ENTER atomisp_vb2_start_streaming, queued buffer count=%d\n", count);
+	return 0;
+}
+
+static struct vb2_ops vb2_qops = {
+  .queue_setup    = atomisp_vb2_queue_setup, //required
+	.buf_prepare    = atomisp_vb2_buf_prepare,
+  .buf_queue      = atomisp_vb2_buf_queue, //required
+  .start_streaming = atomisp_vb2_start_streaming, //Called after streaming enabled in streamon
+  //.stop_streaming = atomisp_vb2_stop_streaming,
+  .wait_prepare   = atomisp_vb2_unlock,
+  .wait_finish    = atomisp_vb2_lock,
+};
+
+static int atomisp_vb2_setup(struct video_device *vdev) {
+	int rc;
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct vb2_queue *q, *outq;
+	q = &pipe->vb2q;
+	memset(q, 0, sizeof(struct vb2_queue));
+  	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  	q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+  	q->drv_priv = vdev;
+	q->buf_struct_size = sizeof(struct atomisp_vb2);
+ 	q->ops = &vb2_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+
+  /* We currently use the monotonic clock for both input and output buffers
+   * (for details, see atomisp_cmd.c:atomisp_buf_done).
+   */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,8,0)
+	q->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+#endif
+
+  rc = vb2_queue_init(q);
+  if (rc < 0)
+    return rc;
+	vdev->queue = q;
+	INIT_LIST_HEAD(&pipe->activeq);
+
+	/* Just for file injection */
+	outq = &pipe->vb2outq;
+	memset(outq, 0, sizeof(struct vb2_queue));
+	outq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	outq->io_modes = VB2_MMAP;
+	outq->drv_priv = vdev;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,8,0)
+        outq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+#endif
+	outq->buf_struct_size = sizeof(struct atomisp_vb2);
+	outq->ops = &vb2_qops;
+	outq->mem_ops = &vb2_dma_contig_memops;
+	rc = vb2_queue_init(outq);
+	if (rc < 0)
+		return rc;
+	INIT_LIST_HEAD(&pipe->activeq_out);
+
+	return 0;
+}
+
+int atomisp_dev_init_struct(struct atomisp_device *isp)
+{
+	int i = 0;
+	if (isp == NULL)
+		return -EINVAL;
+
+	isp->sw_contex.file_input = 0;
+	isp->need_gfx_throttle = true;
+	isp->isp_fatal_error = false;
+
+	for(i=0;i<ATOM_ISP_MAX_INPUTS;i++)
+		isp->inputs[i].used_by = -1;
+
+	/*
+	 * For Merrifield, frequency is scalable.
+	 * After boot-up, the default frequency is 200MHz.
+	 * For Medfield/Clovertrail, all running at 320MHz
+	 */
+	if (IS_MRFLD)
+		isp->sw_contex.running_freq = ISP_FREQ_200MHZ;
+	else
+		isp->sw_contex.running_freq = ISP_FREQ_320MHZ;
+
+	return 0;
+}
+
+int atomisp_subdev_init_struct(struct atomisp_sub_device *isp_subdev)
+{
+	int i = 0;
+
+	v4l2_ctrl_s_ctrl(isp_subdev->run_mode,
+			 ATOMISP_RUN_MODE_STILL_CAPTURE);
+	isp_subdev->params.color_effect = V4L2_COLORFX_NONE;
+	isp_subdev->params.bad_pixel_en = 1;
+	isp_subdev->params.gdc_cac_en = 0;
+	isp_subdev->params.video_dis_en = 0;
+	isp_subdev->params.sc_en = 0;
+	isp_subdev->params.fpn_en = 0;
+	isp_subdev->params.xnr_en = 0;
+	isp_subdev->params.false_color = 0;
+	isp_subdev->params.online_process = 1;
+	isp_subdev->params.yuv_ds_en = 0;
+	isp_subdev->params.offline_parm.num_captures = 1;
+	isp_subdev->params.offline_parm.skip_frames = 0;
+	isp_subdev->params.offline_parm.offset = 0;
+	isp_subdev->params.continuous_vf = false;
+	isp_subdev->delayed_init = ATOMISP_DELAYED_INIT_NOT_QUEUED;
+
+	isp_subdev->css2_basis.stream = NULL;
+	for (i = 0; i < IA_CSS_PIPE_MODE_NUM; i++) {
+		isp_subdev->css2_basis.pipes[i] = NULL;
+		ia_css_pipe_config_defaults(&isp_subdev->css2_basis.pipe_configs[i]);
+		ia_css_pipe_extra_config_defaults(
+				&isp_subdev->css2_basis.pipe_extra_configs[i]);
+	}
+	ia_css_stream_config_defaults(&isp_subdev->css2_basis.stream_config);
+	isp_subdev->css2_basis.curr_pipe = 0;
+	isp_subdev->video_pipe_vf_enable = false;
+	isp_subdev->stream_prepared = false;
+	/* Add for channel */
+	if (isp_subdev->isp->inputs[0].camera)
+		isp_subdev->input_curr = 0;
+
+	init_completion(&isp_subdev->buf_done);
+
+	return 0;
+}
+
+static void *my_kernel_malloc(size_t bytes, bool zero_mem)
+{
+	void *ptr = atomisp_kernel_malloc(bytes);
+
+	if (ptr && zero_mem)
+		memset(ptr, 0, bytes);
+
+	return ptr;
+}
+
+/*
+ * Return the number of concurrent running streams.
+ */
+int atomisp_subdev_streaming_count(struct atomisp_device *isp)
+{
+	int i, sum;
+
+	for (i = 0, sum = 0; i < isp->num_of_streams; i++)
+		sum += isp->isp_subdev[i].streaming ==
+		    ATOMISP_DEVICE_STREAMING_ENABLED;
+
+	return sum;
+}
+
+/* SOF IRQ enable only in single stream mode */
+void atomisp_control_irq_sof(struct atomisp_device *isp)
+{
+	if (atomisp_subdev_streaming_count(isp) == 1)
+		ia_css_irq_enable(IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF, true);
+	else
+		ia_css_irq_enable(IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF, false);
+}
+
+/*
+ * file operation functions
+ */
+unsigned int atomisp_subdev_users(struct atomisp_sub_device *isp_subdev)
+{
+
+	int no_of_users = isp_subdev->video_out_preview.users +
+	       isp_subdev->video_out_vf.users +
+	       isp_subdev->video_out_capture.users +
+	       isp_subdev->video_in.users;
+	return no_of_users;
+}
+
+unsigned int atomisp_dev_users(struct atomisp_device *isp)
+{
+	unsigned int i, sum = 0;
+
+	for (i = 0; i < isp->num_of_streams; i++)
+		sum += atomisp_subdev_users(&isp->isp_subdev[i]);
+
+	return sum;
+}
+
+static int atomisp_css2_dbg_print(const char *fmt, va_list args)
+{
+	if (dbg_level > 5)
+		vprintk(fmt, args);
+	return 0;
+}
+
+static int atomisp_css2_err_print(const char *fmt, va_list args)
+{
+	vprintk(fmt, args);
+	return 0;
+}
+
+struct ia_css_env css_env = {
+                .cpu_mem_env.alloc = my_kernel_malloc,
+                .cpu_mem_env.free = atomisp_kernel_free,
+                .css_mem_env.alloc = atomisp_css2_mm_alloc,
+                .css_mem_env.free = atomisp_css2_mm_free,
+                .css_mem_env.load = atomisp_css2_mm_load,
+                .css_mem_env.store = atomisp_css2_mm_store,
+                .css_mem_env.set = atomisp_css2_mm_set,
+                .css_mem_env.mmap = atomisp_css2_mm_mmap,
+
+                .hw_access_env.store_8 = atomisp_css2_hw_store_8,
+                .hw_access_env.store_16 = atomisp_css2_hw_store_16,
+                .hw_access_env.store_32 = atomisp_css2_hw_store_32,
+
+                .hw_access_env.load_8 = atomisp_css2_hw_load_8,
+                .hw_access_env.load_16 = atomisp_css2_hw_load_16,
+                .hw_access_env.load_32 = atomisp_css2_hw_load_32,
+
+                .hw_access_env.load = atomisp_css2_hw_load,
+                .hw_access_env.store = atomisp_css2_hw_store,
+
+                .print_env.debug_print = atomisp_css2_dbg_print,
+                .print_env.error_print = atomisp_css2_err_print,
+};
+
+static int atomisp_open(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	int ret = -EINVAL;
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev, ">%s [%d]\n",
+				__func__, pipe->pipe_type);
+
+	//following conditions gets executed if only one sub_dev is registered
+	if(isp->detected_snr_cnt==1)
+			if(isp_subdev!=&isp->isp_subdev[0])
+				return 0;
+if (fastboot){
+
+	if(atomisp_subdev_streaming_count(isp)>=1 && isp->firmware_switched == false){
+        	return ret;
+        }
+}
+
+	mutex_lock(&isp->mutex);
+
+	if (!isp->input_cnt) {
+		v4l2_err(&atomisp_dev, "no camera attached\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	if (pipe->users)
+		goto done;
+
+	atomisp_vb2_setup(vdev);
+
+	if (atomisp_subdev_users(isp_subdev)) {
+		goto done;
+	}
+
+	atomisp_subdev_init_struct(isp_subdev);
+
+	if(atomisp_dev_users(isp))
+		goto done;
+
+	hrt_isp_css_mm_init();
+	isp->mmu_base_addr = hrt_isp_get_mmu_base_address();
+	if (isp->mmu_base_addr < 0) {
+		hrt_isp_css_mm_clear();
+		goto error;
+	}
+
+	/* runtime power management, turn on ISP */
+	ret = pm_runtime_get_sync(vdev->v4l2_dev->dev);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev,
+				"Failed to power on device\n");
+		goto error;
+	}
+
+	ret = atomisp_css_init(isp);
+	if(ret < 0)
+		goto css_init_failed;
+	/*uncomment the following to lines to enable offline preview*/
+	/*sh_css_enable_continuous(true);*/
+	/*sh_css_preview_enable_online(false);*/
+	atomisp_dev_init_struct(isp);
+
+done:
+	pipe->users++;
+	mutex_unlock(&isp->mutex);
+	dev_warn(isp->dev, "atomisp_open: successfully opened video%d\n", pipe->pipe_type);
+	return 0;
+
+css_init_failed:
+	dev_err(isp->dev, "css init failed --- bad firmware?\n");
+error:
+	pm_runtime_put(vdev->v4l2_dev->dev);
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+
+static int atomisp_release(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	struct v4l2_mbus_framefmt isp_sink_fmt;
+	struct v4l2_requestbuffers req;
+	int ret = 0;
+	if (isp == NULL)
+		return -EBADF;
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s [%d]\n", __func__, pipe->pipe_type);
+
+	req.count = 0;
+	req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	req.memory = vdev->queue->memory;
+	mutex_lock(&isp->streamoff_mutex);
+	mutex_lock(&isp->mutex);
+	pipe->users--;
+
+	if (pipe->users)
+		goto done;
+
+	/*When release is called before streaming begins, the allocated frames need to be freed*/
+	atomisp_free_css_frames(&pipe->vb2q);
+
+	if (pipe->vb2q.streaming && __atomisp_streamoff(file, NULL, V4L2_BUF_TYPE_VIDEO_CAPTURE))
+	{
+		dev_err(isp->dev,
+			"atomisp_streamoff failed on release, driver bug");
+		goto done;
+	}
+
+	vb2_fop_release(file);
+	vb2_queue_release(&pipe->vb2outq);
+
+	/*
+	 * A little trick here:
+	 * file injection input resolution is recorded in the sink pad,
+	 * therefore can not be cleared when releaseing one device node.
+	 * The sink pad setting can only be cleared when all device nodes
+	 * get released.
+	 */
+	if (!isp->sw_contex.file_input) {
+		memset(&isp_sink_fmt, 0, sizeof(isp_sink_fmt));
+		atomisp_subdev_set_ffmt(isp_subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SINK, &isp_sink_fmt);
+	}
+
+	if (atomisp_subdev_users(isp_subdev))
+	{
+		goto done;
+	}
+
+	/* clear the sink pad for file input */
+	if (isp->sw_contex.file_input) {
+		memset(&isp_sink_fmt, 0, sizeof(isp_sink_fmt));
+		atomisp_subdev_set_ffmt(isp_subdev, NULL,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				ATOMISP_SUBDEV_PAD_SINK, &isp_sink_fmt);
+	}
+
+	atomisp_free_3a_dvs_buffers(isp_subdev);
+	atomisp_free_internal_buffers(isp_subdev);
+
+	/*uninit the camera subdev*/
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+			       core, init, 0);
+	if (ret == -1 || ret == -EINVAL)
+		v4l2_err(&atomisp_dev, "sensor firmware failed\n");
+
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       core, s_power, 0);
+	if (ret)
+		v4l2_warn(&atomisp_dev, "Failed to power-off sensor\n");
+
+	if(atomisp_dev_users(isp))
+	{
+		goto done;
+	}
+
+
+	del_timer_sync(&isp->wdt);
+	atomisp_acc_release(isp);
+	atomisp_free_all_shading_tables(isp);
+
+	atomisp_destroy_pipes_stream_force(isp_subdev);
+	atomisp_css_uninit(isp);
+
+
+	if (pm_runtime_put_sync(vdev->v4l2_dev->dev) < 0)
+		v4l2_dbg(3, dbg_level, &atomisp_dev, "Failed to power off device\n");
+done:
+	mutex_unlock(&isp->mutex);
+	mutex_unlock(&isp->streamoff_mutex);
+	return 0;
+}
+
+/*
+ * Memory help functions for image frame and private parameters
+ */
+static int do_isp_mm_remap(struct vm_area_struct *vma,
+		ia_css_ptr isp_virt, u32 host_virt, u32 pgnr)
+{
+	u32 pfn;
+
+	while (pgnr) {
+		pfn = hmm_virt_to_phys(isp_virt) >> PAGE_SHIFT;
+		if (remap_pfn_range(vma, host_virt, pfn,
+				    PAGE_SIZE, PAGE_SHARED)) {
+			v4l2_err(&atomisp_dev,
+				    "remap_pfn_range err.\n");
+			return -EAGAIN;
+		}
+
+		isp_virt += PAGE_SIZE;
+		host_virt += PAGE_SIZE;
+		pgnr--;
+	}
+
+	return 0;
+}
+
+static int frame_mmap(const struct ia_css_frame *frame,
+	struct vm_area_struct *vma)
+{
+	ia_css_ptr isp_virt;
+	u32 host_virt;
+	u32 pgnr;
+
+	if (!frame) {
+		v4l2_err(&atomisp_dev,
+			    "%s: NULL frame pointer.\n", __func__);
+		return -EINVAL;
+	}
+
+	host_virt = vma->vm_start;
+	isp_virt = frame->data;
+	atomisp_get_frame_pgnr(frame, &pgnr);
+
+	if (do_isp_mm_remap(vma, isp_virt, host_virt, pgnr))
+		return -EAGAIN;
+
+	return 0;
+}
+
+static int atomisp_vb2_mmap_mapper(struct vb2_queue *q,
+	struct vm_area_struct *vma)
+{
+	u32 offset = vma->vm_pgoff << PAGE_SHIFT;
+	int ret = -EINVAL, i;
+	struct vb2_buffer *vb2;
+	struct atomisp_vb2 *avb2;
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+
+	for (i = 0; i < VIDEO_MAX_FRAME; i++) {
+		vb2 = q->bufs[i];
+		if (vb2 && vb2->v4l2_buf.memory == V4L2_MEMORY_MMAP
+		     && vb2->v4l2_planes[0].m.mem_offset == offset)
+		{
+			avb2 = container_of(vb2, struct atomisp_vb2, vb);
+			ret = frame_mmap(avb2->cssframe, vma);
+			vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
+			break;
+		}
+	}
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+	return ret;
+}
+
+/* The input frame contains left and right padding that need to be removed.
+ * There is always ISP_LEFT_PAD padding on the left side.
+ * There is also padding on the right (padded_width - width).
+ */
+static int
+remove_pad_from_frame(struct ia_css_frame *in_frame, __u32 width, __u32 height)
+{
+	unsigned int i;
+	unsigned short *buffer;
+	int ret = 0;
+	ia_css_ptr load = in_frame->data;
+	ia_css_ptr store = load;
+
+	buffer = kmalloc(width*sizeof(load), GFP_KERNEL);
+	if (!buffer) {
+		v4l2_err(&atomisp_dev, "out of memory.\n");
+		return -ENOMEM;
+	}
+
+	load += ISP_LEFT_PAD;
+	for (i = 0; i < height; i++) {
+		ret = hrt_isp_css_mm_load(load, buffer, width*sizeof(load));
+		if (ret < 0)
+			goto remove_pad_error;
+
+		ret = hrt_isp_css_mm_store(store, buffer, width*sizeof(store));
+		if (ret < 0)
+			goto remove_pad_error;
+
+		load  += in_frame->info.padded_width;
+		store += width;
+	}
+
+remove_pad_error:
+	kfree(buffer);
+	return ret;
+}
+
+static int atomisp_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	struct ia_css_frame *raw_virt_addr;
+	u32 start = vma->vm_start;
+	u32 end = vma->vm_end;
+	u32 size = end - start;
+	u32 origin_size, new_size;
+	int ret;
+
+	if (!(vma->vm_flags & (VM_WRITE | VM_READ)))
+		return -EACCES;
+
+	if (!(vma->vm_flags & VM_SHARED))
+		return -EINVAL;
+
+	mutex_lock(&isp->mutex);
+	new_size = pipe->pix.width * pipe->pix.height * 2;
+
+	/* mmap for ISP offline raw data */
+	if ((pipe->pipe_type == ATOMISP_PIPE_CAPTURE) &&
+	    (vma->vm_pgoff == (ISP_PARAM_MMAP_OFFSET >> PAGE_SHIFT))) {
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "vma->vm_pgoff == (ISP_PARAM_MMAP_OFFSET >> PAGE_SHIFT)\n");
+		if (isp_subdev->params.online_process != 0) {
+			ret = -EINVAL;
+			goto error;
+		}
+		raw_virt_addr = isp_subdev->raw_output_frame;
+		if (raw_virt_addr == NULL) {
+			v4l2_err(&atomisp_dev,
+				 "Failed to request RAW frame\n");
+			ret = -EINVAL;
+			goto error;
+		}
+
+		ret = remove_pad_from_frame(raw_virt_addr,
+				      pipe->pix.width,
+				      pipe->pix.height);
+		if (ret < 0) {
+			v4l2_err(&atomisp_dev, "remove pad failed.\n");
+			goto error;
+		}
+		origin_size = raw_virt_addr->data_bytes;
+		raw_virt_addr->data_bytes = new_size;
+
+		if (size != PAGE_ALIGN(new_size)) {
+			v4l2_err(&atomisp_dev,
+				 "incorrect size for mmap ISP"
+				 " Raw Frame\n");
+			ret = -EINVAL;
+			goto error;
+		}
+
+		if (frame_mmap(raw_virt_addr, vma)) {
+			v4l2_err(&atomisp_dev,
+				 "frame_mmap failed.\n");
+			raw_virt_addr->data_bytes = origin_size;
+			ret = -EAGAIN;
+			goto error;
+		}
+		raw_virt_addr->data_bytes = origin_size;
+		vma->vm_flags |= (VM_DONTEXPAND | VM_DONTDUMP);
+		mutex_unlock(&isp->mutex);
+		return 0;
+	}
+
+	/*
+	 * mmap for normal frames
+	 */
+	if (size != pipe->pix.sizeimage) {
+		v4l2_err(&atomisp_dev,
+			    "incorrect size for mmap ISP frames\n");
+		ret = -EINVAL;
+		goto error;
+	}
+	mutex_unlock(&isp->mutex);
+
+  return atomisp_vb2_mmap_mapper(&pipe->vb2q, vma);
+
+error:
+	mutex_unlock(&isp->mutex);
+
+	return ret;
+}
+
+int atomisp_file_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	return vb2_mmap(&pipe->vb2outq, vma);
+}
+
+static unsigned int
+atomisp_poll(struct file *file, struct poll_table_struct *pt)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "inside atomisp_poll before mutex lock\n");
+	mutex_lock(&isp->mutex);
+	if (pipe->vb2q.streaming != 1) {
+		mutex_unlock(&isp->mutex);
+		v4l2_dbg(4, dbg_level, &atomisp_dev,  KERN_ERR "pipe is not streaming. unlocking mutex\n");
+		return POLLERR;
+	}
+	mutex_unlock(&isp->mutex);
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "device is streaming so unlock mutex\n");
+	return vb2_fop_poll(file, pt);
+}
+
+const struct v4l2_file_operations atomisp_fops = {
+	.owner = THIS_MODULE,
+	.open = atomisp_open,
+	.release = atomisp_release,
+	.mmap = atomisp_mmap,
+	.unlocked_ioctl = video_ioctl2,
+	.poll = atomisp_poll,
+};
+
+const struct v4l2_file_operations atomisp_file_fops = {
+	.owner = THIS_MODULE,
+	.open = atomisp_open,
+	.release = atomisp_release,
+	.mmap = atomisp_file_mmap,
+	.ioctl = video_ioctl2,
+	.poll = atomisp_poll,
+};
+
diff --git a/drivers/media/atomisp2/atomisp_fops.h b/drivers/media/atomisp2/atomisp_fops.h
new file mode 100644
index 0000000..08fe86f
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_fops.h
@@ -0,0 +1,65 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__ATOMISP_FOPS_H__
+#define	__ATOMISP_FOPS_H__
+
+#include "sh_css_legacy.h"
+
+#define MAX_LOAD_FIRMWARE_TIMEOUTS 20
+static DECLARE_WAIT_QUEUE_HEAD(atomisp_wait_queue);
+static DECLARE_WAIT_QUEUE_HEAD(atomisp_switch_wait_queue);
+
+extern struct ia_css_env css_env;
+
+int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			     struct atomisp_video_pipe *pipe,
+			     enum ia_css_buffer_type css_buf_type,
+			     enum ia_css_pipe_id css_pipe_id, bool streamoff);
+
+int atomisp_q_s3a_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			   enum ia_css_pipe_id css_pipe_id, bool streamoff);
+
+int atomisp_q_dis_buffers_to_css(struct atomisp_sub_device *isp_subdev,
+			   enum ia_css_pipe_id css_pipe_id, bool streamoff);
+
+int atomisp_dev_init_struct(struct atomisp_device *isp);
+int atomisp_subdev_init_struct(struct atomisp_sub_device *isp_subdev);
+
+int atomisp_subdev_streaming_count(struct atomisp_device *isp);
+void atomisp_control_irq_sof(struct atomisp_device * isp);
+
+unsigned int atomisp_subdev_users(struct atomisp_sub_device *isp_subdev);
+unsigned int atomisp_dev_users(struct atomisp_device *isp);
+
+/*
+ * Memory help functions for image frame and private parameters
+ */
+
+int atomisp_file_mmap(struct file *file, struct vm_area_struct *vma);
+
+int atomisp_qbuffers_to_css(struct atomisp_sub_device *isp_subdev, bool streamoff);
+
+extern const struct v4l2_file_operations atomisp_fops;
+
+#endif /* __ATOMISP_FOPS_H__ */
diff --git a/drivers/media/atomisp2/atomisp_helper.h b/drivers/media/atomisp2/atomisp_helper.h
new file mode 100644
index 0000000..4482c9d
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_helper.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef _atomisp_helper_h_
+#define _atomisp_helper_h_
+#include "atomisp_v4l2.h"
+
+static inline void __iomem *atomisp_get_io_virt_addr(unsigned int address)
+{
+	void __iomem *ret = atomisp_io_base + (address & 0x003FFFFF);
+	return ret;
+}
+#endif
+
diff --git a/drivers/media/atomisp2/atomisp_internal.h b/drivers/media/atomisp2/atomisp_internal.h
new file mode 100644
index 0000000..0a514ed
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_internal.h
@@ -0,0 +1,312 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef __ATOMISP_INTERNAL_H__
+#define __ATOMISP_INTERNAL_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/firmware.h>
+#include <linux/kernel.h>
+#include <linux/pm_qos.h>
+#include <linux/idr.h>
+#include <linux/slab.h>
+
+#include <media/media-device.h>
+#include <media/v4l2-subdev.h>
+
+#include "ia_css_types.h"
+#include "sh_css_legacy.h"
+
+#include "atomisp_csi2.h"
+#include "atomisp_file.h"
+#include "atomisp_subdev.h"
+#include "atomisp_tpg.h"
+
+#include "gp_device.h"
+#include "irq.h"
+
+#define MULTI_STREAM_NUM	3
+#define EXP_ID_WRAPAROUND       250
+
+#define ATOMISP_MAJOR		0
+#define ATOMISP_MINOR		5
+#define ATOMISP_PATCHLEVEL	1
+
+#define DRIVER_VERSION_STR	__stringify(ATOMISP_MAJOR) \
+	"." __stringify(ATOMISP_MINOR) "." __stringify(ATOMISP_PATCHLEVEL)
+#define DRIVER_VERSION		KERNEL_VERSION(ATOMISP_MAJOR, \
+	ATOMISP_MINOR, ATOMISP_PATCHLEVEL)
+
+#define ATOM_ISP_STEP_WIDTH	4
+#define ATOM_ISP_STEP_HEIGHT	4
+
+#define ATOM_ISP_MIN_WIDTH	4
+#define ATOM_ISP_MIN_HEIGHT	4
+#define ATOM_ISP_MAX_WIDTH	4352
+#define ATOM_ISP_MAX_HEIGHT	3264
+
+/* sub-QCIF resolution */
+#define ATOM_RESOLUTION_SUBQCIF_WIDTH	128
+#define ATOM_RESOLUTION_SUBQCIF_HEIGHT	96
+
+#define ATOM_ISP_MAX_WIDTH_TMP	1280
+#define ATOM_ISP_MAX_HEIGHT_TMP	720
+
+#define ATOM_ISP_I2C_BUS_1	4
+#define ATOM_ISP_I2C_BUS_2	5
+
+#define ATOM_ISP_POWER_DOWN	0
+#define ATOM_ISP_POWER_UP	1
+
+#define ATOM_ISP_MAX_INPUTS	4
+
+#define ATOMISP_SC_TYPE_SIZE	2
+
+#define ATOMISP_ISP_TIMEOUT_DURATION		(2 * HZ) /* second */
+#define ATOMISP_ISP_FILE_TIMEOUT_DURATION	(60 * HZ)
+#define ATOMISP_ISP_MAX_TIMEOUT_COUNT	2
+
+#define ATOMISP_CSS2_PIPE_MAX	2
+#define ATOMISP_CSS_Q_DEPTH	3
+#define ATOMISP_CSS_EVENTS_MAX  16
+#define ATOMISP_CONT_RAW_FRAMES 10
+
+#define ATOMISP_DELAYED_INIT_NOT_QUEUED	0
+#define ATOMISP_DELAYED_INIT_QUEUED	1
+#define ATOMISP_DELAYED_INIT_WORK_DONE	2
+#define ATOMISP_DELAYED_INIT_DONE	2
+
+#define ATOMISP_MIPI_BUFFER_SIZE	0x60000 // Intermediate MIPI Frame buffer size*32 bytes ~ 12MB
+
+/*
+ * Define how fast CPU should be able to serve ISP interrupts.
+ * The bigger the value, the higher risk that the ISP is not
+ * triggered sufficiently fast for it to process image during
+ * vertical blanking time, increasing risk of dropped frames.
+ * 1000 us is a reasonable value considering that the processing
+ * time is typically ~2000 us.
+ */
+#define ATOMISP_MAX_ISR_LATENCY	1000
+
+
+
+struct atomisp_css_event {
+	enum ia_css_pipe_id pipe;
+	struct ia_css_event event;
+};
+
+struct atomisp_input_subdev {
+	unsigned int type;
+	enum atomisp_camera_port port;
+	int num_lanes;
+	struct v4l2_subdev *camera;
+	struct v4l2_subdev *motor;
+	struct ia_css_morph_table *morph_table;
+	struct ia_css_shading_table *shading_table;
+	struct v4l2_frmsizeenum frame_size;
+
+	/*
+	 * To show this resource is used by
+	 * which stream, in ISP multiple stream mode
+	 */
+	int used_by;
+};
+
+struct atomisp_freq_scaling_rule {
+	unsigned int width;
+	unsigned int height;
+	unsigned short fps;
+	unsigned int isp_freq;
+	unsigned int run_mode;
+};
+
+enum atomisp_dfs_mode {
+	ATOMISP_DFS_MODE_AUTO = 0,
+	ATOMISP_DFS_MODE_LOW,
+	ATOMISP_DFS_MODE_MAX,
+};
+
+struct atomisp_regs {
+	/* PCI config space info */
+	u16 pcicmdsts;
+	u32 ispmmadr;
+	u32 msicap;
+	u32 msi_addr;
+	u16 msi_data;
+	u8 intr;
+	u32 interrupt_control;
+	u32 pmcs;
+	u32 cg_dis;
+	u32 i_control;
+
+	/* I-Unit PHY related info */
+	u32 csi_rcomp_config;
+	u32 csi_afe_dly;
+	u32 csi_control;
+
+	/* New for MRFLD */
+	u32 csi_afe_rcomp_config;
+	u32 csi_afe_hs_control;
+	u32 csi_deadline_control;
+	u32 csi_access_viol;
+};
+
+struct atomisp_sw_contex {
+	bool bypass;
+	bool file_input;
+	int  invalid_frame;
+	int  invalid_vf_frame;
+	int  invalid_s3a;
+	int  invalid_dis;
+
+	int power_state;
+	int running_freq;
+};
+
+struct atomisp_acc_fw {
+	struct ia_css_fw_info *fw;
+	unsigned int handle;
+	unsigned int flags;
+	unsigned int type;
+	struct {
+		size_t length;
+		unsigned long css_ptr;
+	} args[N_IA_CSS_ISP_MEMORIES];
+	struct list_head list;
+};
+
+struct atomisp_map {
+	ia_css_ptr ptr;
+	size_t length;
+	struct list_head list;
+	/* FIXME: should keep book which maps are currently used
+	 * by binaries and not allow releasing those
+	 * which are in use. Implement by reference counting.
+	 */
+};
+
+#define ATOMISP_DEVICE_STREAMING_DISABLED	0
+#define ATOMISP_DEVICE_STREAMING_ENABLED	1
+#define ATOMISP_DEVICE_STREAMING_STOPPING	2
+#define ATOMISP_DEVICE_STREAMING_STARTING       3
+
+
+/*
+ * ci device struct
+ */
+struct atomisp_device {
+	struct pci_dev *pdev;
+	struct device *dev;
+	struct v4l2_device v4l2_dev;
+	struct media_device media_dev;
+	struct atomisp_platform_data *pdata;
+	struct pci_dev *pci_root;
+	const struct firmware *firmware;
+	const struct firmware *aux_firmware;
+
+	bool firmware_load_complete;
+
+	struct pm_qos_request pm_qos;
+	s32 max_isr_latency;
+
+	struct {
+		struct list_head fw;
+		struct list_head memory_maps;
+		struct ia_css_pipe *pipeline;
+		bool extension_mode;
+		struct ida ida;
+		struct completion acc_done;
+	} acc;
+
+	struct ia_css_fw css_fw;
+
+	/* ISP modules */
+	struct atomisp_sub_device *isp_subdev;
+	/*
+	 * MRFLD has 3 CSI ports, while MFLD has only 2.
+	 */
+	struct atomisp_mipi_csi2_device csi2_port[ATOMISP_CAMERA_NR_PORTS];
+	struct atomisp_tpg_device tpg;
+	struct atomisp_file_device file_dev;
+
+	/* Purpose of mutex is to protect and serialize use of isp data
+	 * structures and css API calls. */
+	struct mutex mutex;
+	struct mutex vb2mutex;
+	/*
+	 * Serialise streamoff: mutex is dropped during streamoff to
+	 * cancel the watchdog queue. MUST be acquired BEFORE
+	 * "mutex".
+	 */
+	struct mutex streamoff_mutex;
+
+	struct atomisp_input_subdev inputs[ATOM_ISP_MAX_INPUTS];
+	struct v4l2_subdev *flash;
+	struct v4l2_subdev *motor;
+
+	struct atomisp_regs saved_regs;
+	struct atomisp_sw_contex sw_contex;
+
+	/* isp timeout status flag */
+	bool isp_timeout;
+	bool isp_fatal_error;
+	struct workqueue_struct *wdt_work_queue;
+	struct work_struct wdt_work;
+	struct timer_list wdt;
+	atomic_t wdt_count;
+	unsigned int wdt_duration;	/* in jiffies */
+	enum atomisp_frame_status fr_status;
+
+	spinlock_t lock; /* Just for streaming below */
+
+	bool need_gfx_throttle;
+
+	int num_of_streams;
+	int input_cnt;
+	u64 raw_dmamask;
+
+	/*
+	 * Counts number of successful registered sub_devs
+	 */
+	int detected_snr_cnt;
+	int mmu_base_addr;
+
+	//fastboot related flags
+	bool switch_fw_on_streamoff ;
+	bool firmware_switched;
+};
+
+
+#define v4l2_dev_to_atomisp_device(dev) \
+	container_of(dev, struct atomisp_device, v4l2_dev)
+
+extern struct v4l2_device atomisp_dev;
+
+extern void *atomisp_kernel_malloc(size_t bytes);
+
+extern void atomisp_kernel_free(void *ptr);
+
+#define MRFLD_FW_PATH_SMALL   "iaisp_2400_css.bin.small"
+#define MRFLD_FW_PATH_BIG   "iaisp_2400_css.bin.big"
+#define MRFLD_FW_PATH   MRFLD_FW_PATH_BIG
+
+#endif /* __ATOMISP_INTERNAL_H__ */
diff --git a/drivers/media/atomisp2/atomisp_ioctl.c b/drivers/media/atomisp2/atomisp_ioctl.c
new file mode 100644
index 0000000..c949a4a
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_ioctl.c
@@ -0,0 +1,2486 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/delay.h>
+
+//#include <asm/intel-mid.h>
+
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+#include <uapi/linux/v4l2-subdev.h>
+
+#include "atomisp_acc.h"
+#include "atomisp_compat.h"
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_fops.h"
+#include "atomisp_internal.h"
+#include "atomisp_ioctl.h"
+#include "atomisp-regs.h"
+#include "atomisp_v4l2.h"
+
+#include "sh_css_hrt.h"
+#include "ia_css_debug.h"
+#include "gp_device.h"
+#include "device_access.h"
+#include "irq.h"
+
+#include "hrt/hive_isp_css_mm_hrt.h"
+
+#define IOCTL_ENTER v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s.\n", __func__);
+#define IOCTL_EXIT v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+
+/* for v4l2_capability */
+static const char *DRIVER = "atomisp";	/* max size 15 */
+static const char *CARD = "ATOM ISP";	/* max size 31 */
+static const char *BUS_INFO = "PCI-3";	/* max size 31 */
+static const u32 VERSION = DRIVER_VERSION;
+
+/*
+ * FIXME: ISP should not know beforehand all CIDs supported by sensor.
+ * Instead, it needs to propagate to sensor unkonwn CIDs.
+ */
+static struct v4l2_queryctrl ci_v4l2_controls[] = {
+	{
+		.id = V4L2_CID_AUTO_WHITE_BALANCE,
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.name = "Automatic White Balance",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_RED_BALANCE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Red Balance",
+		.minimum = 0x00,
+		.maximum = 0xff,
+		.step = 1,
+		.default_value = 0x00,
+	},
+	{
+		.id = V4L2_CID_BLUE_BALANCE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Blue Balance",
+		.minimum = 0x00,
+		.maximum = 0xff,
+		.step = 1,
+		.default_value = 0x00,
+	},
+	{
+		.id = V4L2_CID_GAMMA,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Gamma",
+		.minimum = 0x00,
+		.maximum = 0xff,
+		.step = 1,
+		.default_value = 0x00,
+	},
+	{
+		.id = V4L2_CID_HFLIP,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Image h-flip",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_VFLIP,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Image v-flip",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_POWER_LINE_FREQUENCY,
+		.type = V4L2_CTRL_TYPE_MENU,
+		.name = "Light frequency filter",
+		.minimum = 1,
+		.maximum = 2,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_CID_COLORFX,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Image Color Effect",
+		.minimum = 0,
+		.maximum = 9,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Bad Pixel Correction",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "GDC/CAC",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_VIDEO_STABLIZATION,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Video Stablization",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_FIXED_PATTERN_NR,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Fixed Pattern Noise Reduction",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "False Color Correction",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_REQUEST_FLASH,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Request flash frames",
+		.minimum = 0,
+		.maximum = 10,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_CID_ATOMISP_LOW_LIGHT,
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.name = "Low light mode",
+		.minimum = 0,
+		.maximum = 1,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_CID_BIN_FACTOR_HORZ,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Horizontal binning factor",
+		.minimum = 0,
+		.maximum = 10,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_BIN_FACTOR_VERT,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Vertical binning factor",
+		.minimum = 0,
+		.maximum = 10,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_2A_STATUS,
+		.type = V4L2_CTRL_TYPE_BITMASK,
+		.name = "AE and AWB status",
+		.minimum = 0,
+		.maximum = V4L2_2A_STATUS_AE_READY | V4L2_2A_STATUS_AWB_READY,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_EXPOSURE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "exposure",
+		.minimum = -4,
+		.maximum = 4,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_SCENE_MODE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "scene mode",
+		.minimum = 0,
+		.maximum = 13,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_ISO_SENSITIVITY,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "iso",
+		.minimum = -4,
+		.maximum = 4,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "white balance",
+		.minimum = 0,
+		.maximum = 9,
+		.step = 1,
+		.default_value = 0,
+	},
+	{
+		.id = V4L2_CID_EXPOSURE_METERING,
+		.type = V4L2_CTRL_TYPE_MENU,
+		.name = "metering",
+		.minimum = 0,
+		.maximum = 2,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_CID_3A_LOCK,
+		.type = V4L2_CTRL_TYPE_BITMASK,
+		.name = "3a lock",
+		.minimum = 0,
+		.maximum = V4L2_LOCK_EXPOSURE | V4L2_LOCK_WHITE_BALANCE
+			 | V4L2_LOCK_FOCUS,
+		.step = 1,
+		.default_value = 0,
+	},
+};
+static const u32 ctrls_num = ARRAY_SIZE(ci_v4l2_controls);
+
+static unsigned int atomisp_get_pipe_index(struct atomisp_sub_device *isp_subdev,
+				    enum atomisp_pipe_type pipe_type)
+{
+	switch (pipe_type) {
+	case ATOMISP_PIPE_CAPTURE:
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO
+					|| !isp_subdev->enable_vfpp->val)
+			return (unsigned int) IA_CSS_PIPE_ID_VIDEO;
+		else
+			return (unsigned int) IA_CSS_PIPE_ID_CAPTURE;
+	case ATOMISP_PIPE_VIEWFINDER:
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
+			return (unsigned int) IA_CSS_PIPE_ID_VIDEO;
+		else if (!atomisp_is_mbuscode_raw(
+				 isp_subdev->
+				 fmt[isp_subdev->capture_pad].fmt.code))
+			return (unsigned int) IA_CSS_PIPE_ID_CAPTURE;
+	case ATOMISP_PIPE_PREVIEW:
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
+			return (unsigned int) IA_CSS_PIPE_ID_VIDEO;
+		else
+			return (unsigned int) IA_CSS_PIPE_ID_PREVIEW;
+	case ATOMISP_PIPE_FILEINPUT:
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int __get_css_frame_info(struct atomisp_sub_device *isp_subdev,
+				enum atomisp_pipe_type pipe_type,
+				struct ia_css_frame_info *frame_info)
+{
+	enum ia_css_err ret;
+	struct ia_css_pipe_info info;
+	int pipe_index = atomisp_get_pipe_index(isp_subdev, pipe_type);
+
+	if (pipe_index >= IA_CSS_PIPE_ID_NUM)
+		return -EINVAL;
+
+	ret = ia_css_pipe_get_info(isp_subdev->css2_basis.pipes[pipe_index],
+					   &info);
+	if (ret != IA_CSS_SUCCESS)
+		return -EINVAL;
+
+	switch (pipe_type) {
+	case ATOMISP_PIPE_CAPTURE:
+		*frame_info = info.output_info;
+		break;
+	case ATOMISP_PIPE_VIEWFINDER:
+		*frame_info = info.vf_output_info;
+		break;
+	case ATOMISP_PIPE_PREVIEW:
+		if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
+			*frame_info = info.vf_output_info;
+		else
+			*frame_info = info.output_info;
+		break;
+	default:
+		frame_info = NULL;
+		break;
+	}
+	return frame_info ? 0 : -EINVAL;
+}
+
+/*
+ * v4l2 ioctls
+ * return ISP capabilities
+ *
+ * FIXME: capabilities should be different for video0/video2/video3
+ */
+static int atomisp_querycap(struct file *file, void *fh,
+			    struct v4l2_capability *cap)
+{
+	int ret = 0;
+	IOCTL_ENTER
+	memset(cap, 0, sizeof(struct v4l2_capability));
+
+	WARN_ON(sizeof(DRIVER) > sizeof(cap->driver) ||
+		sizeof(CARD) > sizeof(cap->card) ||
+		sizeof(BUS_INFO) > sizeof(cap->bus_info));
+
+	strncpy(cap->driver, DRIVER, sizeof(cap->driver) - 1);
+	strncpy(cap->card, CARD, sizeof(cap->card) - 1);
+	strncpy(cap->bus_info, BUS_INFO, sizeof(cap->card) - 1);
+
+	cap->version = VERSION;
+
+	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE |
+	    V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT;
+	IOCTL_EXIT
+
+	return ret;
+}
+
+/*
+ * return sensor chip identification
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
+static int atomisp_g_chip_ident(struct file *file, void *fh,
+	struct v4l2_dbg_chip_ident *chip)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	int ret = 0;
+
+	IOCTL_ENTER
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+			       core, g_chip_ident, chip);
+
+	if (ret)
+		v4l2_err(&atomisp_dev,
+			    "failed to g_chip_ident for sensor\n");
+	IOCTL_EXIT
+	return ret;
+}
+#endif
+
+/*
+ * enum input are used to check primary/secondary camera
+ */
+static int atomisp_enum_input(struct file *file, void *fh,
+	struct v4l2_input *input)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+
+	int index = input->index;
+
+	IOCTL_ENTER
+	if (index >= isp->input_cnt)
+		return -EINVAL;
+
+	if (!isp->inputs[index].camera)
+		return -EINVAL;
+
+	memset(input, 0, sizeof(struct v4l2_input));
+	strncpy(input->name, isp->inputs[index].camera->name,
+		sizeof(input->name) - 1);
+
+	/*
+	 * HACK: append actuator's name to sensor's
+	 * As currently userspace can't talk directly to subdev nodes, this
+	 * ioctl is the only way to enum inputs + possible external actuators
+	 * for 3A tuning purpose.
+	 */
+	if (isp->inputs[index].motor &&
+	    strlen(isp->inputs[index].motor->name) > 0) {
+		const int cur_len = strnlen(input->name, 32);
+		const int max_size = sizeof(input->name) - cur_len - 1;
+
+		if (max_size > 0) {
+			input->name[cur_len] = '+';
+			strncpy(&input->name[cur_len + 1],
+				isp->inputs[index].motor->name, max_size - 1);
+		}
+	}
+
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+	input->index = index;
+	input->reserved[0] = isp->inputs[index].type;
+	input->reserved[1] = isp->inputs[index].port;
+	IOCTL_EXIT
+
+	return 0;
+}
+
+static unsigned int atomisp_streaming_count(struct atomisp_sub_device *isp_subdev)
+{
+	//TODO DMA
+	return isp_subdev->video_out_preview.vb2q.streaming
+		+ isp_subdev->video_out_capture.vb2q.streaming
+		+ isp_subdev->video_in.vb2q.streaming;
+}
+
+/*
+ * get input are used to get current primary/secondary camera
+ */
+static int atomisp_g_input(struct file *file, void *fh, unsigned int *input)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	IOCTL_ENTER
+	mutex_lock(&isp->mutex);
+	*input = isp_subdev->input_curr;
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+
+	return 0;
+}
+
+
+/*
+ * set input are used to set current primary/secondary camera
+ */
+static int atomisp_s_input(struct file *file, void *fh, unsigned int port)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	struct v4l2_subdev *camera = NULL;
+	int ret;
+	int i, input = 0;
+	int mipi_port = (int)port;
+
+	IOCTL_ENTER
+	mutex_lock(&isp->mutex);
+	if (mipi_port >= ATOM_ISP_MAX_INPUTS) {
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			 "input_cnt: %d\n",isp->input_cnt);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	if(mipi_port < 0) input = 0; /* always use the first default one */
+	else
+	{
+	  /* convernt to input index from a physical mipi port */
+	  for(i = 0; i < ATOM_ISP_MAX_INPUTS; i++) {
+	    if(isp->inputs[i].port == mipi_port) {
+	      input = i;
+	      break;
+	    }
+	  }
+	  if( i == ATOM_ISP_MAX_INPUTS) {
+		v4l2_err(&atomisp_dev,
+			 "%s, no camera on mipi port=%d\n",__func__, mipi_port);
+		ret = -EINVAL;
+		goto error;
+	  }
+	}
+	trace_printk("Input selected: index=%d mipi-port=%d num_lanes=%d\n",
+	       input, isp->inputs[input].port, isp->inputs[input].num_lanes);
+
+	/*
+	 * Checked whether the request camera:
+	 * 1: already in use
+	 * 2: if in use, whether it is by other streams
+	 */
+	if (isp->inputs[input].used_by > -1 &&
+	    isp->inputs[input].used_by != isp_subdev->index) {
+		v4l2_err(&atomisp_dev,
+			 "%s, camera is already used by:%d\n", __func__,
+			 isp->inputs[input].used_by);
+		ret = -EBUSY;
+		goto error;
+	}
+
+	camera = isp->inputs[input].camera;
+	if (!camera) {
+		v4l2_err(&atomisp_dev,
+			 "%s, no camera\n",__func__);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	if (atomisp_streaming_count(isp_subdev)) {
+		v4l2_err(&atomisp_dev,
+			 "ISP is still streaming, stop first\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	/* power off the current sensor, as it is not used this time */
+	if (isp->inputs[isp_subdev->input_curr].used_by == isp_subdev->index &&
+		isp_subdev->input_curr != input) {
+		ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       core, s_power, 0);
+		if (ret)
+			v4l2_warn(&atomisp_dev,
+				    "Failed to power-off previous sensor\n");
+	}
+
+	/* powe on the new sensor */
+	if (!isp->sw_contex.file_input) {
+		ret = v4l2_subdev_call(isp->inputs[input].camera,
+				       core, s_power, 1);
+		if (ret) {
+			v4l2_err(&atomisp_dev,
+				    "Failed to power-on new sensor\n");
+			ret = -EINVAL;
+			goto error;
+		}
+
+	if (!isp->sw_contex.file_input && isp->inputs[input].motor)
+			ret = v4l2_subdev_call(isp->inputs[input].motor, core,
+					       init, 1);
+	}
+
+	isp_subdev->input_curr = input;
+	/* marked this camera is used by stream */
+	isp->inputs[input].used_by = isp_subdev->index;
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+
+	return 0;
+
+error:
+	mutex_unlock(&isp->mutex);
+
+	return ret;
+}
+
+static int atomisp_g_fmt_cap(struct file *file, void *fh,
+	struct v4l2_format *f)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+
+	int ret;
+
+	IOCTL_ENTER
+	mutex_lock(&isp->mutex);
+	ret = atomisp_get_fmt(vdev, f);
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+	return ret;
+}
+
+static int atomisp_g_fmt_file(struct file *file, void *fh,
+		struct v4l2_format *f)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+
+	IOCTL_ENTER
+	mutex_lock(&isp->mutex);
+	f->fmt.pix = pipe->pix;
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+	return 0;
+}
+
+/* This function looks up the closest available resolution. */
+static int atomisp_try_fmt_cap(struct file *file, void *fh,
+	struct v4l2_format *f)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	int ret;
+
+	IOCTL_ENTER
+	mutex_lock(&isp->mutex);
+	ret = atomisp_try_fmt(vdev, f, NULL);
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+	return ret;
+}
+
+static int atomisp_s_fmt_cap(struct file *file, void *fh,
+	struct v4l2_format *input_format)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	int ret;
+	IOCTL_ENTER
+	mutex_lock(&isp->mutex);
+	ret = atomisp_set_fmt(vdev, input_format);
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+	return ret;
+}
+
+static int atomisp_s_fmt_file(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	int ret;
+
+	IOCTL_ENTER
+	mutex_lock(&isp->mutex);
+	ret = atomisp_set_fmt_file(vdev, f);
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+	return ret;
+}
+
+/*
+ * is_resolution_supported - Check whether resolution is supported
+ * @width: check resolution width
+ * @height: check resolution height
+ *
+ * Return 1 on supported or 0 otherwise.
+*/
+static int is_resolution_supported(u32 width, u32 height)
+{
+	if ((width > ATOM_ISP_MIN_WIDTH) && (width <= ATOM_ISP_MAX_WIDTH) &&
+	    (height > ATOM_ISP_MIN_HEIGHT) && (height <= ATOM_ISP_MAX_HEIGHT)) {
+		if (!(width % ATOM_ISP_STEP_WIDTH) &&
+		    !(height % ATOM_ISP_STEP_HEIGHT))
+			return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * This ioctl allows applications to enumerate all frame intervals that the
+ * device supports for the given pixel format and frame size.
+ *
+ * framerate =  1 / frameintervals
+ */
+static int atomisp_enum_frameintervals(struct file *file, void *fh,
+	struct v4l2_frmivalenum *arg)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	int ret;
+
+	IOCTL_ENTER
+	if (arg->index != 0)
+		return -EINVAL;
+
+	if (!atomisp_get_format_bridge(arg->pixel_format))
+		return -EINVAL;
+
+	if (!is_resolution_supported(arg->width, arg->height))
+		return -EINVAL;
+
+	mutex_lock(&isp->mutex);
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+		video, enum_frameintervals, arg);
+
+	if (ret) {
+		/* set the FPS to default 15*/
+		arg->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+		arg->discrete.numerator = 1;
+		arg->discrete.denominator = 15;
+	}
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+
+	return 0;
+}
+
+void atomisp_free_css_frames(struct vb2_queue *q)
+{
+	struct atomisp_vb2 *avb2;
+	int i;
+	for (i = 0; i < q->num_buffers; i++) {
+		avb2 = container_of(q->bufs[i], struct atomisp_vb2, vb);
+		ia_css_frame_free(avb2->cssframe);
+		avb2->cssframe = NULL;
+	}
+}
+
+int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_s3a_buf *s3a_buf = NULL;
+	struct atomisp_dvs_buf *dvs_buf = NULL;
+	/* 2 css pipes consuming 3a buffers */
+	int count = ATOMISP_CSS_Q_DEPTH * 2;
+
+	trace_printk("ENTER atomisp_alloc_css_stat_bufs\n");
+
+	if (!list_empty(&isp_subdev->s3a_stats) && !list_empty(&isp_subdev->dvs_stats))
+		return 0;
+
+	while (count--) {
+		if (isp_subdev->params.curr_grid_info.s3a_grid.enable) {
+			v4l2_dbg(5, dbg_level, &atomisp_dev,
+				 "allocating %d 3a buffers\n", count);
+			s3a_buf = kzalloc(sizeof(struct atomisp_s3a_buf), GFP_KERNEL);
+			if (!s3a_buf) {
+				v4l2_err(&atomisp_dev, "s3a stat buf alloc failed\n");
+				goto s3a_error;
+			}
+
+			s3a_buf->s3a_stat =
+			    ia_css_isp_3a_statistics_allocate(&isp_subdev->params.curr_grid_info.s3a_grid);
+			if (!s3a_buf->s3a_stat) {
+				v4l2_err(&atomisp_dev,
+					 "3a stat buf allocation failed\n");
+				kfree(s3a_buf);
+				goto s3a_error;
+			}
+			list_add_tail(&s3a_buf->list, &isp_subdev->s3a_stats);
+		}
+
+		if (isp_subdev->params.curr_grid_info.dvs_grid.enable) {
+			v4l2_dbg(2, dbg_level, &atomisp_dev,
+				 "allocating %d dvs buffers\n", count);
+			dvs_buf = kzalloc(sizeof(struct atomisp_dvs_buf), GFP_KERNEL);
+			if (!dvs_buf) {
+				v4l2_err(&atomisp_dev, "dis stat buf alloc failed\n");
+				goto dvs_error;
+			}
+
+			dvs_buf->dvs_stat =
+			    ia_css_isp_dvs_statistics_allocate(&isp_subdev->params.curr_grid_info.dvs_grid);
+			if (!dvs_buf->dvs_stat) {
+				v4l2_err(&atomisp_dev,
+					 "dvs stat buf allocation failed\n");
+				kfree(dvs_buf);
+				goto dvs_error;
+			}
+			list_add_tail(&dvs_buf->list, &isp_subdev->dvs_stats);
+		}
+
+	}
+
+	trace_printk("EXIT atomisp_alloc_css_stat_bufs\n");
+	return 0;
+dvs_error:
+	v4l2_err(&atomisp_dev,
+		    "failed to allocate statistics buffers\n");
+
+	while (!list_empty(&isp_subdev->dvs_stats)) {
+		dvs_buf = list_entry(isp_subdev->dvs_stats.next,
+				     struct atomisp_dvs_buf, list);
+		ia_css_isp_dvs_statistics_free(dvs_buf->dvs_stat);
+		list_del(&dvs_buf->list);
+		kfree(dvs_buf);
+	}
+s3a_error:
+	while (!list_empty(&isp_subdev->s3a_stats)) {
+		s3a_buf = list_entry(isp_subdev->s3a_stats.next,
+					   struct atomisp_s3a_buf, list);
+		ia_css_isp_3a_statistics_free(s3a_buf->s3a_stat);
+		list_del(&s3a_buf->list);
+		kfree(s3a_buf);
+	}
+	trace_printk("ERROR in atomisp_alloc_css_stat_bufs\n");
+	return -ENOMEM;
+}
+
+/*
+ * Initiate Memory Mapping or User Pointer I/O
+ */
+int __atomisp_reqbufs(struct file *file, void *fh,
+	struct v4l2_requestbuffers *req)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	struct ia_css_frame_info frame_info;
+	struct ia_css_frame *frame;
+	struct atomisp_vb2 *avb2;
+	int ret = 0, i = 0;
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "Enter __atomisp_reqbufs, count=%d, req->mem=%d, req->type=%d\n",
+		req->count, req->memory, req->type);
+	ia_css_update_stream(isp_subdev);
+
+	ret =  vb2_ioctl_reqbufs(file, fh, req);
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "Return value from vb2_ioctl_reqbufs=%d\n", ret);
+	if (req->count == 0) {
+		return 0; //TODO DMA is this check needed?
+	}
+	if (ret)
+		return ret;
+	//Currently allowing only video mode to allocate stats buff.
+	//TODO: Enable stat bufs allocation if capture/preview mode supports dis & s3a
+	if(isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
+	atomisp_alloc_css_stat_bufs(isp_subdev);
+
+	/*
+	 * for user pointer type, buffers are not really allcated here,
+	 * buffers are setup in QBUF operation through v4l2_buffer structure
+	 */
+	if (req->memory == V4L2_MEMORY_USERPTR || req->memory == V4L2_MEMORY_DMABUF)
+		return 0;
+
+	ret = __get_css_frame_info(isp_subdev, pipe->pipe_type, &frame_info);
+	if (ret)
+		return -EINVAL;
+
+	/*
+	 * Allocate the real frame here for selected node using our
+	 * memory management function
+	 */
+	for (i = 0; i < req->count; i++) {
+		if (ia_css_frame_allocate_from_info(&frame, &frame_info)) {
+			v4l2_err(&atomisp_dev, "ERROR allocating css frame, buf=%d\n", i);
+			goto error;
+		}
+		avb2 = container_of(pipe->vb2q.bufs[i], struct atomisp_vb2, vb);
+		avb2->cssframe = frame;
+	}
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "Exiting successfully from __atomisp_reqbufs\n");
+	return ret;
+
+error:
+	while (i--) {
+		avb2 = container_of(pipe->vb2q.bufs[i], struct atomisp_vb2, vb);
+		ia_css_frame_free(avb2->cssframe);
+		avb2->cssframe = NULL;
+	}
+
+	if (isp_subdev->vf_frame)
+		ia_css_frame_free(isp_subdev->vf_frame);
+
+	return -ENOMEM;
+}
+
+int atomisp_reqbufs(struct file *file, void *fh,
+	struct v4l2_requestbuffers *req)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	int ret;
+
+	IOCTL_ENTER
+	mutex_lock(&isp->mutex);
+	ret = __atomisp_reqbufs(file, fh, req);
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+
+	return ret;
+}
+
+static int atomisp_reqbufs_file(struct file *file, void *fh,
+		struct v4l2_requestbuffers *req)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	int ret;
+
+	IOCTL_ENTER
+	if (req->count == 0) {
+		atomisp_free_css_frames(&pipe->vb2outq);
+	}
+	ret = vb2_reqbufs(&pipe->vb2outq, req);
+	IOCTL_EXIT
+	return ret;
+}
+
+
+/* application query the status of a buffer */
+static int atomisp_querybuf(struct file *file, void *fh,
+	struct v4l2_buffer *buf)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	int ret;
+
+	IOCTL_ENTER
+	ret = vb2_querybuf(&pipe->vb2q, buf);
+	IOCTL_EXIT
+	return ret;
+}
+
+static int atomisp_querybuf_file(struct file *file, void *fh,
+				struct v4l2_buffer *buf)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	int ret;
+
+	IOCTL_ENTER
+	ret = vb2_querybuf(&pipe->vb2outq, buf);
+	IOCTL_EXIT
+	return ret;
+}
+
+/*
+ * Applications call the VIDIOC_QBUF ioctl to enqueue an empty (capturing) or
+ * filled (output) buffer in the drivers incoming queue.
+ */
+static int atomisp_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	unsigned long userptr = 0;
+	struct vb2_queue *q = vdev->queue;
+	struct vb2_buffer *vb2 = q->bufs[buf->index];
+	struct atomisp_vb2 *avb2 = container_of(vb2, struct atomisp_vb2, vb);
+	struct ia_css_frame_info frame_info;
+	struct ia_css_frame *handle = NULL;
+	u32 length;
+	u32 pgnr;
+	int ret = 0;
+
+	IOCTL_ENTER
+	mutex_lock(&isp->mutex);
+	if (isp->isp_fatal_error) {
+		ret = -EIO;
+		goto error;
+	}
+
+	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STOPPING) {
+		v4l2_err(&atomisp_dev, "ISP ERROR\n");
+		ret = -EIO;
+		goto error;
+	}
+
+	if (!buf || buf->index >= VIDEO_MAX_FRAME ||
+		!pipe->vb2q.bufs[buf->index]) {
+		v4l2_err(&atomisp_dev,
+			    "Invalid index for qbuf.\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "atomisp_qbuf fd=%d, VB2_BUF_STATE=%d\n", buf->m.fd, vdev->queue->bufs[buf->index]->state);
+	ret = vb2_ioctl_qbuf(file, fh, buf); //This will call atomisp_vb2_buf_queue
+	if (ret) {
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "ERROR with vb2_ioctl_qbuf\n");
+	   	goto error;
+	}
+
+	if (buf->memory == V4L2_MEMORY_DMABUF) {
+		struct vb2_dc_buf *dc_buf;
+		struct hrt_userbuffer_attr attributes;
+		length = vb2_plane_size(vb2, 0);
+		pgnr = (length + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+		attributes.pgnr = pgnr;
+		attributes.type = HRT_KERNEL_PTR;
+		dc_buf = (struct vb2_dc_buf*) vb2->planes[0].mem_priv;
+		attributes.priv = (void*) dc_buf->dma_sgt;
+
+		if (__get_css_frame_info(isp_subdev, pipe->pipe_type,
+             &frame_info)) {
+      			ret = -EIO;
+      			goto error;
+    		}
+
+		ret = ia_css_frame_map(&handle, &frame_info, NULL,
+               0, &attributes);
+
+    		if (ret != IA_CSS_SUCCESS) {
+      			dev_err(isp->dev, "Failed ia_css_frame_dma \n");
+      			ret = -ENOMEM;
+      			goto error;
+    		}
+
+		if (avb2->cssframe) {
+			v4l2_dbg(4, dbg_level, &atomisp_dev, "WARNING cssframe already exists or was not initialized to NULL\n");
+			ia_css_frame_free(avb2->cssframe);
+			avb2->cssframe = NULL;
+		}
+		avb2->cssframe = handle;
+
+		//Note in vb2 do not need to set V4L2_BUF_FLAG
+		v4l2_dbg(4, dbg_level, &atomisp_dev, "DMA after vb2_ioctl_qbuf V4L2_BUF_FLAG=0X%X, buf fd=%d, index=%d, vaddr=%X\n", buf->flags, buf->m.fd,avb2->vb.v4l2_buf.index, avb2->cssframe->data);
+
+		goto cssqbuf;
+	}
+	/*
+	 * For userptr type frame, we convert user space address to physic
+	 * address and reprograme out page table properly
+	 */
+	else if (buf->memory == V4L2_MEMORY_USERPTR) {
+		struct hrt_userbuffer_attr attributes;
+		userptr = buf->m.userptr;
+		length = vb2_plane_size(vb2, 0);
+
+		if (__get_css_frame_info(isp_subdev, pipe->pipe_type,
+				   &frame_info)) {
+			ret = -EIO;
+			goto error;
+		}
+
+		pgnr = (length + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+		attributes.pgnr = pgnr;
+#ifdef CONFIG_ION
+		attributes.type = buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_ION
+					? HRT_USR_ION : HRT_USR_PTR;
+#else
+		attributes.type = HRT_USR_PTR;
+#endif
+		ret = ia_css_frame_map(&handle, &frame_info, (void *)userptr,
+				       0, &attributes);
+		if (ret != IA_CSS_SUCCESS) {
+			dev_err(isp->dev, "Failed to map user buffer\n");
+			ret = -ENOMEM;
+			goto error;
+		}
+
+		if (avb2->cssframe) {
+			ia_css_frame_free(avb2->cssframe);
+			avb2->cssframe = NULL;
+		}
+
+		avb2->cssframe = handle;
+	} else if (buf->memory == V4L2_MEMORY_MMAP) {
+	}
+
+cssqbuf:
+
+	/* TODO: do this better, not best way to queue to css */
+	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED){
+		atomisp_qbuffers_to_css(isp_subdev, false);
+
+		if (!timer_pending(&isp->wdt) &&
+		    atomisp_buffers_queued(isp_subdev))
+			mod_timer(&isp->wdt, jiffies + isp->wdt_duration);
+	}
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+	return ret;
+
+error:
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+
+static int atomisp_qbuf_file(struct file *file, void *fh,
+					struct v4l2_buffer *buf)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+
+	IOCTL_ENTER
+	if (buf->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+    		v4l2_err(&atomisp_dev, "Unsupported buffer type\n");
+    		return -EINVAL;
+  	}
+
+	IOCTL_EXIT
+	return vb2_qbuf(&pipe->vb2outq, buf);
+}
+
+/*
+ * Applications call the VIDIOC_DQBUF ioctl to dequeue a filled (capturing) or
+ * displayed (output buffer)from the driver's outgoing queue
+ */
+static int atomisp_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	int ret = 0;
+
+	IOCTL_ENTER
+	ret = vb2_ioctl_dqbuf(file, fh, buf);
+	IOCTL_EXIT
+	return ret;
+}
+
+static int atomisp_get_dc_buf(struct vb2_dc_buf *dc_buf,struct atomisp_device *isp, int pgnr)
+{
+	unsigned int ret = 0;
+	struct sg_table *sgt;
+
+	if(!dc_buf){
+		dev_err(isp->dev,"%s: vb2 buffer is NULL\n",__func__);
+		return -EINVAL;
+	}
+
+	sgt = kmalloc(sizeof(*sgt),GFP_KERNEL);
+	if(!sgt){
+		dev_err(isp->dev,"%s: failed to alloc sg table\n",__func__);
+		return -ENOMEM;
+	}
+
+	sgt->orig_nents = pgnr;
+
+	ret = sg_alloc_table(sgt,sgt->orig_nents,GFP_KERNEL);
+	if(ret!=0){
+		dev_err(isp->dev,"%s: failed to initialize sg_table\n",__func__);
+		return -ENOMEM;
+	}
+
+	dc_buf->sgt_base = sgt;
+
+	return 0;
+}
+
+static int atomisp_expbuf(struct file *file, void *priv, struct v4l2_exportbuffer *eb)
+{
+		struct video_device *vdev = video_devdata(file);
+		struct atomisp_device *isp = video_get_drvdata(vdev);
+		struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+		struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+		struct vb2_queue *q = vdev->queue;
+		struct vb2_buffer *vb2 = q->bufs[eb->index];
+		struct vb2_plane *vb_plane;
+		struct vb2_dc_buf *dc_buf;
+		struct hrt_userbuffer_attr attributes;
+		struct atomisp_vb2 *avb2 = container_of(vb2, struct atomisp_vb2, vb);
+		struct ia_css_frame_info frame_info;
+		struct ia_css_frame *handle = NULL;
+		u32 length;
+		u32 pgnr;
+		int ret = 0;
+
+		IOCTL_ENTER
+		length = vb2_plane_size(vb2,0);
+		pgnr = (length+(PAGE_SIZE -1)) >> PAGE_SHIFT;
+		attributes.pgnr = pgnr;
+		attributes.type = HRT_USR_PTR;
+		vb_plane = &vb2->planes[eb->plane];
+
+		if(!vb_plane->mem_priv){
+				dev_err(isp->dev, "%s: private member error for a plane\n",__func__);
+				ret = -EINVAL;
+				return ret;
+			}
+		dc_buf = (struct vb2_dc_buf*)vb_plane->mem_priv;
+
+		ret = atomisp_get_dc_buf(dc_buf,isp,pgnr);
+		if(ret != IA_CSS_SUCCESS)
+				dev_err(isp->dev,"Failed to create dc buffer\n");
+
+		attributes.priv = (void*)dc_buf->sgt_base;
+
+
+		ret = vb2_ioctl_expbuf(file,priv,eb);
+		if(ret != IA_CSS_SUCCESS)
+				dev_err(isp->dev,"Failed to export dma_buf\n");
+
+
+		if (__get_css_frame_info(isp_subdev, pipe->pipe_type,&frame_info)) {
+		      			ret = -EIO;
+		      			return ret;
+		    		}
+
+				ret = ia_css_frame_map(&handle, &frame_info, NULL,0, &attributes);
+
+		    		if (ret != IA_CSS_SUCCESS) {
+		      			dev_err(isp->dev, "Failed ia_css_frame_dma \n");
+		      			ret = -ENOMEM;
+		      			return ret;
+		    		}
+
+				if (avb2->cssframe) {
+					v4l2_dbg(4, dbg_level, &atomisp_dev, "WARNING cssframe already exists or was not initialized to NULL\n");
+					ia_css_frame_free(avb2->cssframe);
+					avb2->cssframe = NULL;
+				}
+				avb2->cssframe = handle;
+
+		IOCTL_EXIT
+		return ret;
+}
+
+
+
+
+enum ia_css_pipe_id atomisp_get_css_pipe_id(struct atomisp_sub_device *isp_subdev)
+{
+	if (isp_subdev->params.continuous_vf &&
+	    isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO)
+		return IA_CSS_PIPE_ID_PREVIEW;
+
+	if (!isp_subdev->enable_vfpp->val)
+		return IA_CSS_PIPE_ID_CAPTURE;
+
+	switch (isp_subdev->run_mode->val) {
+	case ATOMISP_RUN_MODE_PREVIEW:
+		return IA_CSS_PIPE_ID_PREVIEW;
+	case ATOMISP_RUN_MODE_VIDEO:
+		return IA_CSS_PIPE_ID_VIDEO;
+	case ATOMISP_RUN_MODE_STILL_CAPTURE:
+		/* fall through */
+	default:
+		return IA_CSS_PIPE_ID_CAPTURE;
+	}
+}
+
+int atomisp_get_css_buf_type(struct atomisp_sub_device *isp_subdev,
+			 struct atomisp_video_pipe *pipe)
+{
+	if (pipe->pipe_type == ATOMISP_PIPE_CAPTURE ||
+	    (pipe->pipe_type == ATOMISP_PIPE_PREVIEW &&
+	     isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO))
+		return IA_CSS_BUFFER_TYPE_OUTPUT_FRAME;
+	else
+		return IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME;
+}
+
+static unsigned int atomisp_sensor_start_stream(struct atomisp_sub_device *isp_subdev)
+{
+	if (!isp_subdev->enable_vfpp->val)
+		return 1;
+
+	if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||
+	    (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_STILL_CAPTURE &&
+	     !atomisp_is_mbuscode_raw(
+		     isp_subdev->fmt[
+			     isp_subdev->capture_pad].fmt.code) &&
+	     !isp_subdev->params.continuous_vf))
+		return 2;
+	else
+		return 1;
+}
+
+
+/*
+ * This ioctl start the capture during streaming I/O.
+ */
+static int atomisp_streamon(struct file *file, void *fh,
+	enum v4l2_buf_type type)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	enum ia_css_pipe_id css_pipe_id;
+	unsigned int sensor_start_stream;
+	int ret = 0;
+#ifdef PUNIT_CAMERA_BUSY
+	u32 msg_ret;
+#endif
+
+	IOCTL_ENTER
+	if (type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_dbg(isp->dev, "unsupported v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&isp->mutex);
+
+	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STOPPING) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	if (vb2_is_streaming(&pipe->vb2q)) {
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA WARNING: pipe->vb2q.streaming. Need to verify\n");
+		goto out;
+	}
+
+	/*
+	 * The number of streaming video nodes is based on which
+	 * binary is going to be run.
+	 */
+	sensor_start_stream = atomisp_sensor_start_stream(isp_subdev);
+
+	trace_printk("DMA About to call vb2_ioctl_streamon\n");
+	ret = vb2_ioctl_streamon(file, fh, type);
+	trace_printk("Return from streamon: %d\n", ret);
+	if (ret)
+		goto out;
+
+	if (atomisp_streaming_count(isp_subdev) > sensor_start_stream) {
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA atomisp_streaming_count(isp) > sensor_start_stream\n");
+		/* trigger still capture */
+		if (isp_subdev->params.continuous_vf &&
+		    pipe->pipe_type == ATOMISP_PIPE_CAPTURE &&
+		    isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {
+			if (isp_subdev->delayed_init != ATOMISP_DELAYED_INIT_DONE){
+				flush_work(&isp_subdev->delayed_init_work);
+				mutex_unlock(&isp->mutex);
+				if (wait_for_completion_interruptible(
+						&isp_subdev->init_done) != 0)
+					return -ERESTARTSYS;
+				mutex_lock(&isp->mutex);
+			}
+			ret = ia_css_stream_capture(
+					isp_subdev->css2_basis.stream,
+					isp_subdev->params.offline_parm.num_captures,
+					isp_subdev->params.offline_parm.skip_frames,
+					isp_subdev->params.offline_parm.offset);
+			if (ret)
+				return -EINVAL;
+		}
+		atomisp_qbuffers_to_css(isp_subdev, false);
+		goto out;
+	}
+
+	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED) {
+		atomisp_qbuffers_to_css(isp_subdev, false);
+		goto start_sensor;
+	}
+
+#ifdef PUNIT_CAMERA_BUSY
+	if (!IS_MRFLD && isp->need_gfx_throttle) {
+		/*
+		 * As per h/w architect and ECO 697611 we need to throttle the
+		 * GFX performance (freq) while camera is up to prevent peak
+		 * current issues. this is done by setting the camera busy bit.
+		 */
+		msg_ret = intel_mid_msgbus_read32(PUNIT_PORT, MFLD_OR1);
+		msg_ret |= 0x100;
+		intel_mid_msgbus_write32(PUNIT_PORT, MFLD_OR1, msg_ret);
+	}
+#endif
+
+	css_pipe_id = atomisp_get_css_pipe_id(isp_subdev);
+
+	ret = atomisp_acc_load_extensions(isp);
+	if (ret < 0) {
+		dev_err(isp->dev, "acc extension failed to load\n");
+		goto out;
+	}
+
+	v4l2_dbg(4, dbg_level, &atomisp_dev, "About to call ia_css_start in atomisp_streamon\n");
+	ret = ia_css_start(isp_subdev, false);
+	if (ret != IA_CSS_SUCCESS) {
+		dev_err(isp->dev, "ia_css_start fails: %d\n", ret);
+		ret = -EINVAL;
+		v4l2_dbg(2, dbg_level, &atomisp_dev, "<%s [%d] LINE:%d.\n",
+			 __func__, pipe->pipe_type, __LINE__);
+		goto out;
+	}
+
+	if (isp_subdev->params.continuous_vf &&
+	    isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO) {
+		INIT_COMPLETION(isp_subdev->init_done);
+		isp_subdev->delayed_init = ATOMISP_DELAYED_INIT_QUEUED;
+		queue_work(isp_subdev->delayed_init_workq,
+			   &isp_subdev->delayed_init_work);
+	}
+
+	/* Make sure that update_isp_params is called at least once.*/
+	isp_subdev->params.css_update_params_needed = true;
+	isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_ENABLED;
+	atomic_set(&isp_subdev->sof_count, -1);
+	atomic_set(&isp_subdev->sequence, -1);
+	atomic_set(&isp_subdev->sequence_temp, -1);
+	atomic_set(&isp->wdt_count, 0);
+	if (isp->sw_contex.file_input)
+		isp->wdt_duration = ATOMISP_ISP_FILE_TIMEOUT_DURATION;
+	else
+		isp->wdt_duration = ATOMISP_ISP_TIMEOUT_DURATION;
+	isp->fr_status = ATOMISP_FRAME_STATUS_OK;
+	isp->sw_contex.invalid_frame = false;
+	isp_subdev->params.dvs_proj_data_valid = false;
+
+	v4l2_dbg(6, dbg_level, &atomisp_dev, "DMA wdt_duration=%u, About to call atomisp_qbuffers_to_css\n", isp->wdt_duration);
+	atomisp_qbuffers_to_css(isp_subdev, false);
+
+	/* Only start sensor when the last streaming instance started */
+	/* File injection fails this check  */
+#if 0
+	if (atomisp_streaming_count(isp) < sensor_start_stream) {
+
+		v4l2_dbg(2, dbg_level, &atomisp_dev, "<%s [%d] LINE:%d.\n",
+			 __func__, pipe->pipe_type, __LINE__);
+		goto out;
+	}
+#endif
+
+start_sensor:
+	if (isp->flash) {
+		ret += v4l2_subdev_call(isp->flash, core, s_power, 1);
+		isp_subdev->params.num_flash_frames = 0;
+		isp_subdev->params.flash_state = ATOMISP_FLASH_IDLE;
+		atomisp_setup_flash(isp_subdev);
+	}
+
+	if (!isp->sw_contex.file_input) {
+		atomisp_control_irq_sof(isp);
+		atomisp_set_term_en_count(isp);
+
+		if (IS_MRFLD &&
+			atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_AUTO) < 0)
+			dev_dbg(isp->dev, "dfs failed!\n");
+		} else {
+			if (IS_MRFLD &&
+				atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_MAX) < 0)
+				dev_dbg(isp->dev, "dfs failed!\n");
+		}
+
+	/* stream on the sensor */
+		ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       video, s_stream, 1);
+		if (ret) {
+			atomisp_reset(isp);
+			ret = -EINVAL;
+		}
+
+out:
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+	return ret;
+}
+
+int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	struct atomisp_vb2 *vb2 = NULL;
+	int ret = 0;
+	unsigned long flags;
+	bool first_streamoff = false;
+#ifdef PUNIT_CAMERA_BUSY
+	u32 msg_ret;
+#endif
+
+	v4l2_dbg(2, dbg_level, &atomisp_dev, ">%s [%d]\n",
+				__func__, pipe->pipe_type);
+	BUG_ON(!mutex_is_locked(&isp->mutex));
+	BUG_ON(!mutex_is_locked(&isp->streamoff_mutex));
+
+	if (type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_dbg(isp->dev, "unsupported v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * do only streamoff for capture & vf pipes in
+	 * case of continuous capture
+	 */
+	if (isp_subdev->run_mode->val != ATOMISP_RUN_MODE_VIDEO &&
+	    isp_subdev->params.continuous_vf &&
+	    pipe->pipe_type != ATOMISP_PIPE_PREVIEW) {
+
+		v4l2_dbg(6, dbg_level, &atomisp_dev, "VB2 streamoff for continuous_vf not supported\n");
+		return -EINVAL;
+	}
+	if (isp_subdev->run_mode->val == ATOMISP_RUN_MODE_VIDEO){
+	   if(pipe->pipe_type == ATOMISP_PIPE_VIEWFINDER){
+		  if(pipe->buffers_in_css !=0){
+			  v4l2_dbg(4, dbg_level, &atomisp_dev, "%s freeing up buffers in CSS\n",__func__);
+			  atomisp_css_flush(isp);
+
+		  }
+		  atomisp_free_css_frames(&pipe->vb2q);
+		  if (pipe->vb2q.streaming) return vb2_ioctl_streamoff(file, fh,  type);
+
+	    }
+	}
+
+
+	atomisp_clear_frame_counters(isp_subdev);
+	spin_lock_irqsave(&isp->lock, flags);
+	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED
+	    || isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STARTING) {
+		isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_STOPPING;
+		first_streamoff = true;
+	}
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	if (first_streamoff) {
+		mutex_unlock(&isp->mutex);
+		/* not disable watch dog if other streams still running */
+		if (!atomisp_subdev_streaming_count(isp_subdev->isp)) {
+			del_timer_sync(&isp->wdt);
+			cancel_work_sync(&isp->wdt_work);
+		}
+
+		/*
+		 * must stop sending pixels into GP_FIFO before stop
+		 * the pipeline.
+		 */
+		if (isp->sw_contex.file_input)
+			v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+					video, s_stream, 0);
+
+		mutex_lock(&isp->mutex);
+		atomisp_acc_unload_extensions(isp);
+	}
+
+	spin_lock_irqsave(&isp->lock, flags);
+	if (atomisp_streaming_count(isp_subdev) <= 1)
+		isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_DISABLED;
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	if (!first_streamoff) {
+		if(pipe->vb2q.streaming)
+		{
+			ret = vb2_ioctl_streamoff(file, fh,  type);
+			if (ret)
+				return ret;
+		}
+		goto stopsensor;
+	}
+
+	if (!isp->sw_contex.file_input)
+		atomisp_control_irq_sof(isp);
+
+	if (isp_subdev->delayed_init == ATOMISP_DELAYED_INIT_QUEUED) {
+		cancel_work_sync(&isp_subdev->delayed_init_work);
+		isp_subdev->delayed_init = ATOMISP_DELAYED_INIT_NOT_QUEUED;
+	}
+
+	/*Set the width, height etc. in atomisp_video_pipe to 0*/
+	memset(&pipe->pix, 0, sizeof(struct v4l2_pix_format));
+
+	ret = ia_css_stop(isp_subdev, false);
+
+	if (ret) {
+		v4l2_err(&atomisp_dev, "stop css failed, ret=%d.\n", ret);
+		return ret;
+	}
+
+	//TODO DMA wake up interruptible pipes
+	if(pipe->vb2q.streaming)
+    		ret = vb2_ioctl_streamoff(file, fh,  type);
+
+    	atomisp_clear_css_buffer_counters(isp_subdev);
+
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(&pipe->irq_lock, flags);
+
+	while (!list_empty(&pipe->activeq)) {
+		vb2 = list_first_entry(&pipe->activeq, struct atomisp_vb2, list);
+		if (!vb2)
+			break;
+		list_del(&vb2->list);
+	}
+	spin_unlock_irqrestore(&pipe->irq_lock, flags);
+
+stopsensor:
+	if (!isp->sw_contex.file_input)
+		ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       video, s_stream, 0);
+
+	if (isp->flash) {
+		ret += v4l2_subdev_call(isp->flash, core, s_power, 0);
+		isp_subdev->params.num_flash_frames = 0;
+		isp_subdev->params.flash_state = ATOMISP_FLASH_IDLE;
+	}
+
+	atomisp_free_css_frames(&pipe->vb2q);
+	/* if other streams are running, we should not power off isp */
+	if (atomisp_subdev_streaming_count(isp))
+		return 0;
+
+#ifdef PUNIT_CAMERA_BUSY
+	if (!IS_MRFLD && isp->need_gfx_throttle) {
+		/* Free camera_busy bit */
+		msg_ret = intel_mid_msgbus_read32(PUNIT_PORT, MFLD_OR1);
+		msg_ret &= ~0x100;
+		intel_mid_msgbus_write32(PUNIT_PORT, MFLD_OR1, msg_ret);
+	}
+#endif
+
+	if (IS_MRFLD && atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW))
+		v4l2_warn(&atomisp_dev, "DFS failed.\n");
+	/*
+	 * ISP work around, need to reset isp
+	 * Is it correct time to reset ISP when first node does streamoff?
+	 */
+	if (isp->sw_contex.power_state == ATOM_ISP_POWER_UP) {
+		unsigned int i;
+		if (isp->isp_timeout)
+			dev_err(isp->dev, "%s: Resetting with WA activated",
+				__func__);
+		/*
+		 * It is possible that the other asd stream is in the stage
+		 * that v4l2_setfmt is just get called on it, which will
+		 * create css stream on that stream. But at this point, there
+		 * is no way to destroy the css stream created on that stream.
+		 *
+		 * So force stream destroy here.
+		 */
+		for (i = 0; i < isp->num_of_streams; i++) {
+			if (isp->isp_subdev[i].stream_prepared)
+				atomisp_destroy_pipes_stream_force(&isp->
+						isp_subdev[i]);
+		}
+		atomisp_reset(isp);
+		isp->isp_timeout = false;
+	}
+
+	v4l2_dbg(2, dbg_level, &atomisp_dev, "<%s [%d]\n",
+		 __func__, pipe->pipe_type);
+	return ret;
+}
+
+static int atomisp_streamoff(struct file *file, void *fh,
+			     enum v4l2_buf_type type)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	int rval;
+
+	IOCTL_ENTER
+	mutex_lock(&isp->streamoff_mutex);
+	mutex_lock(&isp->mutex);
+	rval = __atomisp_streamoff(file, fh, type);
+	mutex_unlock(&isp->mutex);
+	mutex_unlock(&isp->streamoff_mutex);
+	IOCTL_EXIT
+
+	return rval;
+}
+
+/*
+ * To get the current value of a control.
+ * applications initialize the id field of a struct v4l2_control and
+ * call this ioctl with a pointer to this structure
+ */
+static int atomisp_g_ctrl(struct file *file, void *fh,
+	struct v4l2_control *control)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < ctrls_num; i++) {
+		if (ci_v4l2_controls[i].id == control->id) {
+			ret = 0;
+			break;
+		}
+	}
+
+	if (ret)
+		return ret;
+
+	mutex_lock(&isp->mutex);
+
+	switch (control->id) {
+	case V4L2_CID_IRIS_ABSOLUTE:
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+	case V4L2_CID_FNUMBER_ABSOLUTE:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_2A_STATUS:
+	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_SCENE_MODE:
+	case V4L2_CID_ISO_SENSITIVITY:
+	case V4L2_CID_EXPOSURE_METERING:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_3A_LOCK:
+		mutex_unlock(&isp->mutex);
+		return v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       core, g_ctrl, control);
+	case V4L2_CID_COLORFX:
+		ret = atomisp_color_effect(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION:
+		ret = atomisp_bad_pixel(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC:
+		ret = atomisp_gdc_cac(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_VIDEO_STABLIZATION:
+		ret = atomisp_video_stable(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_FIXED_PATTERN_NR:
+		ret = atomisp_fixed_pattern(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION:
+		ret = atomisp_false_color(isp_subdev, 0, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_LOW_LIGHT:
+		ret = atomisp_low_light(isp_subdev, 0, &control->value);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+
+/*
+ * To change the value of a control.
+ * applications initialize the id and value fields of a struct v4l2_control
+ * and call this ioctl.
+ */
+static int atomisp_s_ctrl(struct file *file, void *fh,
+			  struct v4l2_control *control)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < ctrls_num; i++) {
+		if (ci_v4l2_controls[i].id == control->id) {
+			ret = 0;
+			break;
+		}
+	}
+
+	if (ret)
+		return ret;
+
+	mutex_lock(&isp->mutex);
+	switch (control->id) {
+	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_SCENE_MODE:
+	case V4L2_CID_ISO_SENSITIVITY:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+	case V4L2_CID_EXPOSURE_METERING:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_3A_LOCK:
+		mutex_unlock(&isp->mutex);
+		return v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+				       core, s_ctrl, control);
+	case V4L2_CID_COLORFX:
+		ret = atomisp_color_effect(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION:
+		ret = atomisp_bad_pixel(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC:
+		ret = atomisp_gdc_cac(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_VIDEO_STABLIZATION:
+		ret = atomisp_video_stable(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_FIXED_PATTERN_NR:
+		ret = atomisp_fixed_pattern(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION:
+		ret = atomisp_false_color(isp_subdev, 1, &control->value);
+		break;
+	case V4L2_CID_REQUEST_FLASH:
+		ret = atomisp_flash_enable(isp_subdev, control->value);
+		break;
+	case V4L2_CID_ATOMISP_LOW_LIGHT:
+		ret = atomisp_low_light(isp_subdev, 1, &control->value);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	mutex_unlock(&isp->mutex);
+	return ret;
+}
+/*
+ * To query the attributes of a control.
+ * applications set the id field of a struct v4l2_queryctrl and call the
+ * this ioctl with a pointer to this structure. The driver fills
+ * the rest of the structure.
+ */
+static int atomisp_queryctl(struct file *file, void *fh,
+			    struct v4l2_queryctrl *qc)
+{
+	int i, ret = -EINVAL;
+
+	IOCTL_ENTER
+	if (qc->id & V4L2_CTRL_FLAG_NEXT_CTRL)
+		return ret;
+
+	for (i = 0; i < ctrls_num; i++) {
+		if (ci_v4l2_controls[i].id == qc->id) {
+			memcpy(qc, &ci_v4l2_controls[i],
+			       sizeof(struct v4l2_queryctrl));
+			qc->reserved[0] = 0;
+			ret = 0;
+			break;
+		}
+	}
+	if (ret != 0)
+		qc->flags = V4L2_CTRL_FLAG_DISABLED;
+
+	IOCTL_EXIT
+	return ret;
+}
+
+static int atomisp_camera_g_ext_ctrls(struct file *file, void *fh,
+	struct v4l2_ext_controls *c)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	struct v4l2_control ctrl;
+	int i;
+	int ret = 0;
+
+	for (i = 0; i < c->count; i++) {
+		ctrl.id = c->controls[i].id;
+		ctrl.value = c->controls[i].value;
+		switch (ctrl.id) {
+		case V4L2_CID_EXPOSURE_ABSOLUTE:
+		case V4L2_CID_IRIS_ABSOLUTE:
+		case V4L2_CID_FNUMBER_ABSOLUTE:
+		case V4L2_CID_BIN_FACTOR_HORZ:
+		case V4L2_CID_BIN_FACTOR_VERT:
+		case V4L2_CID_3A_LOCK:
+			/*
+			 * Exposure related control will be handled by sensor
+			 * driver
+			 */
+			ret = v4l2_subdev_call(isp->inputs
+					       [isp_subdev->input_curr].camera,
+					       core, g_ctrl, &ctrl);
+			break;
+		case V4L2_CID_FOCUS_ABSOLUTE:
+		case V4L2_CID_FOCUS_RELATIVE:
+		case V4L2_CID_FOCUS_STATUS:
+		case V4L2_CID_FOCUS_AUTO:
+			if (isp->inputs[isp_subdev->input_curr].motor)
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].motor,
+					core, g_ctrl, &ctrl);
+			else
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].camera,
+					core, g_ctrl, &ctrl);
+			break;
+		case V4L2_CID_FLASH_STATUS:
+		case V4L2_CID_FLASH_INTENSITY:
+		case V4L2_CID_FLASH_TORCH_INTENSITY:
+		case V4L2_CID_FLASH_INDICATOR_INTENSITY:
+		case V4L2_CID_FLASH_TIMEOUT:
+		case V4L2_CID_FLASH_STROBE:
+		case V4L2_CID_FLASH_MODE:
+			if (isp->flash)
+				ret = v4l2_subdev_call(
+					isp->flash, core, g_ctrl, &ctrl);
+			break;
+		case V4L2_CID_ZOOM_ABSOLUTE:
+			mutex_lock(&isp->mutex);
+			ret = atomisp_digital_zoom(isp_subdev, 0, &ctrl.value);
+			mutex_unlock(&isp->mutex);
+			break;
+		case V4L2_CID_G_SKIP_FRAMES:
+			ret = v4l2_subdev_call(
+				isp->inputs[isp_subdev->input_curr].camera,
+				sensor, g_skip_frames, (u32 *)&ctrl.value);
+			break;
+		default:
+			ret = -EINVAL;
+		}
+
+		if (ret) {
+			c->error_idx = i;
+			break;
+		}
+		c->controls[i].value = ctrl.value;
+	}
+	return ret;
+}
+
+/* This ioctl allows the application to get multiple controls by class */
+static int atomisp_g_ext_ctrls(struct file *file, void *fh,
+	struct v4l2_ext_controls *c)
+{
+	struct v4l2_control ctrl;
+	int i, ret = 0;
+
+	IOCTL_ENTER
+	/* input_lock is not need for the Camera releated IOCTLs
+	 * The input_lock downgrade the FPS of 3A*/
+	ret = atomisp_camera_g_ext_ctrls(file, fh, c);
+	if (ret != -EINVAL)
+		return ret;
+
+	for (i = 0; i < c->count; i++) {
+		ctrl.id = c->controls[i].id;
+		ctrl.value = c->controls[i].value;
+		ret = atomisp_g_ctrl(file, fh, &ctrl);
+		c->controls[i].value = ctrl.value;
+		if (ret) {
+			c->error_idx = i;
+			break;
+		}
+	}
+	IOCTL_EXIT
+	return ret;
+}
+
+static int atomisp_camera_s_ext_ctrls(struct file *file, void *fh,
+	struct v4l2_ext_controls *c)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	struct v4l2_control ctrl;
+	int i;
+	int ret = 0;
+
+	for (i = 0; i < c->count; i++) {
+		struct v4l2_ctrl *ctr;
+
+		ctrl.id = c->controls[i].id;
+		ctrl.value = c->controls[i].value;
+		switch (ctrl.id) {
+		case V4L2_CID_EXPOSURE_ABSOLUTE:
+		case V4L2_CID_IRIS_ABSOLUTE:
+		case V4L2_CID_FNUMBER_ABSOLUTE:
+		case V4L2_CID_VCM_TIMEING:
+		case V4L2_CID_VCM_SLEW:
+		case V4L2_CID_TEST_PATTERN:
+		case V4L2_CID_3A_LOCK:
+			ret = v4l2_subdev_call(
+				isp->inputs[isp_subdev->input_curr].camera,
+				core, s_ctrl, &ctrl);
+			break;
+		case V4L2_CID_FOCUS_ABSOLUTE:
+		case V4L2_CID_FOCUS_RELATIVE:
+		case V4L2_CID_FOCUS_STATUS:
+		case V4L2_CID_FOCUS_AUTO:
+			if (isp->inputs[isp_subdev->input_curr].motor)
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].motor,
+					core, s_ctrl, &ctrl);
+			else
+				ret = v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].camera,
+					core, s_ctrl, &ctrl);
+			break;
+		case V4L2_CID_FLASH_STATUS:
+		case V4L2_CID_FLASH_INTENSITY:
+		case V4L2_CID_FLASH_TORCH_INTENSITY:
+		case V4L2_CID_FLASH_INDICATOR_INTENSITY:
+		case V4L2_CID_FLASH_TIMEOUT:
+		case V4L2_CID_FLASH_STROBE:
+		case V4L2_CID_FLASH_MODE:
+			mutex_lock(&isp->mutex);
+			if (isp->flash) {
+				ret = v4l2_subdev_call(isp->flash,
+					core, s_ctrl, &ctrl);
+				/* When flash mode is changed we need to reset
+				 * flash state */
+				if (ctrl.id == V4L2_CID_FLASH_MODE) {
+					isp_subdev->params.flash_state = ATOMISP_FLASH_IDLE;
+					isp_subdev->params.num_flash_frames = 0;
+				}
+			}
+			mutex_unlock(&isp->mutex);
+			break;
+		case V4L2_CID_ZOOM_ABSOLUTE:
+			mutex_lock(&isp->mutex);
+			ret = atomisp_digital_zoom(isp_subdev, 1, &ctrl.value);
+			mutex_unlock(&isp->mutex);
+			break;
+		default:
+			ctr = v4l2_ctrl_find(&isp_subdev->ctrl_handler,
+					     ctrl.id);
+			if (ctr)
+				ret = v4l2_ctrl_s_ctrl(ctr, ctrl.value);
+			else
+				ret = -EINVAL;
+		}
+
+		if (ret) {
+			c->error_idx = i;
+			break;
+		}
+		c->controls[i].value = ctrl.value;
+	}
+	return ret;
+}
+
+/* This ioctl allows the application to set multiple controls by class */
+static int atomisp_s_ext_ctrls(struct file *file, void *fh,
+	struct v4l2_ext_controls *c)
+{
+	struct v4l2_control ctrl;
+	int i, ret = 0;
+
+	IOCTL_ENTER
+	/* input_lock is not need for the Camera releated IOCTLs
+	 * The input_lock downgrade the FPS of 3A*/
+	ret = atomisp_camera_s_ext_ctrls(file, fh, c);
+	if (ret != -EINVAL)
+		return ret;
+
+	for (i = 0; i < c->count; i++) {
+		ctrl.id = c->controls[i].id;
+		ctrl.value = c->controls[i].value;
+		ret = atomisp_s_ctrl(file, fh, &ctrl);
+		c->controls[i].value = ctrl.value;
+		if (ret) {
+			c->error_idx = i;
+			break;
+		}
+	}
+	IOCTL_EXIT
+	return ret;
+}
+
+/*
+ * vidioc_g/s_param are used to switch isp running mode
+ */
+static int atomisp_g_parm(struct file *file, void *fh,
+	struct v4l2_streamparm *parm)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	IOCTL_ENTER
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		v4l2_err(&atomisp_dev,
+			    "unsupport v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&isp->mutex);
+	parm->parm.capture.capturemode = isp_subdev->run_mode->val;
+	mutex_unlock(&isp->mutex);
+	IOCTL_EXIT
+
+	return 0;
+}
+
+static int atomisp_s_parm(struct file *file, void *fh,
+	struct v4l2_streamparm *parm)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+	struct v4l2_subdev_frame_interval fi;
+	int mode;
+	int rval;
+
+	IOCTL_ENTER
+
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		v4l2_err(&atomisp_dev,
+			    "unsupport v4l2 buf type\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&isp->mutex);
+
+	switch (parm->parm.capture.capturemode) {
+	case CI_MODE_NONE:
+		trace_printk("CI_MODE_NONE\n");
+		memset(&fi, 0, sizeof(fi));
+		fi.interval = parm->parm.capture.timeperframe;
+
+		rval = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+					video, s_frame_interval, &fi);
+		if (!rval)
+			parm->parm.capture.timeperframe = fi.interval;
+		goto out;
+	case CI_MODE_VIDEO:
+		trace_printk("CI_MODE_VIDEO\n");
+		mode = ATOMISP_RUN_MODE_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		trace_printk("CI_MODE_STILL_CAPTURE\n");
+		mode = ATOMISP_RUN_MODE_STILL_CAPTURE;
+		break;
+	case CI_MODE_CONTINUOUS:
+		trace_printk("CI_MODE_CONTINOUS\n");
+		mode = ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE;
+		break;
+	case CI_MODE_PREVIEW:
+		trace_printk("CI_MODE_PREVIEW\n");
+		mode = ATOMISP_RUN_MODE_PREVIEW;
+		break;
+	default:
+		rval = -EINVAL;
+		goto out;
+	}
+
+	rval = v4l2_ctrl_s_ctrl(isp_subdev->run_mode, mode);
+
+out:
+	mutex_unlock(&isp->mutex);
+
+	IOCTL_EXIT
+	return rval == -ENOIOCTLCMD ? 0 : rval;
+}
+
+static int atomisp_s_parm_file(struct file *file, void *fh,
+				struct v4l2_streamparm *parm)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_sub_device *isp_subdev =
+	    atomisp_to_sub_device(atomisp_to_video_pipe(vdev));
+
+	IOCTL_ENTER
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		v4l2_err(&atomisp_dev,
+			    "unsupport v4l2 buf type for output\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * only isp_subdev[0] support file injection function.
+	 *
+	 * This is to simplify the driver design, since there would be no
+	 * context passed to atomisp_file.c to state which subdev is using the
+	 * file injection.
+	 *
+	 * Just hardcode in atomisp_file.c that isp_subdev[0] is always used.
+	 *
+	 * also, we should not have the obscure UCs that for example, one
+	 * stream is in sensor mode, while the other is in file injection.
+	 */
+	if (isp_subdev->index != 0)
+		return 0;
+
+	mutex_lock(&isp->mutex);
+	isp->sw_contex.file_input = 1;
+	mutex_unlock(&isp->mutex);
+
+	IOCTL_EXIT
+	return 0;
+}
+
+/* set default atomisp ioctl value */
+static long atomisp_vidioc_default(struct file *file, void *fh,
+	bool valid_prio, int cmd, void *arg)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atomisp_device *isp = video_get_drvdata(vdev);
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *isp_subdev = atomisp_to_sub_device(pipe);
+	int err;
+	struct v4l2_subdev_format *fmt;
+
+	v4l2_dbg(5, dbg_level, &atomisp_dev, ">%s. 0x%x\n", __func__, cmd);
+	mutex_lock(&isp->mutex);
+	switch (cmd) {
+	case VIDIOC_SUBDEV_G_FMT:
+		fmt = (struct v4l2_subdev_format *)arg;
+
+		if (fmt->which != V4L2_SUBDEV_FORMAT_TRY &&
+                    fmt->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+                        return -EINVAL;
+
+                if (fmt->pad >= isp_subdev->subdev.entity.num_pads)
+                        return -EINVAL;
+
+		fmt->format = *atomisp_subdev_get_ffmt(isp_subdev, fh, fmt->which, fmt->pad);
+		err = 0;
+		break;
+	case VIDIOC_SUBDEV_S_FMT:
+		fmt = (struct v4l2_subdev_format *)arg;
+		if (fmt->which != V4L2_SUBDEV_FORMAT_TRY &&
+                    fmt->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+                        return -EINVAL;
+
+                if (fmt->pad >= isp_subdev->subdev.entity.num_pads)
+                        return -EINVAL;
+
+		err = atomisp_subdev_set_ffmt(isp_subdev, fh, fmt->which, fmt->pad,
+                                       &fmt->format);
+		break;
+	case ATOMISP_FW_LOAD:
+		v4l2_dbg(1, dbg_level, &atomisp_dev, "Entering ATOMISP_FW_LOAD ioctl\n");
+		err = atomisp_fw(isp, 0, arg);
+		v4l2_dbg(1, dbg_level, &atomisp_dev, "Exiting ATOMISP_FW_LOAD ioctl call\n");
+		break;
+	case ATOMISP_IOC_G_XNR:
+		err = atomisp_xnr(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_XNR:
+		err = atomisp_xnr(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_NR:
+		err = atomisp_nr(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_NR:
+		err = atomisp_nr(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_TNR:
+		err = atomisp_tnr(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_TNR:
+		err = atomisp_tnr(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_HISTOGRAM:
+		err = atomisp_histogram(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_HISTOGRAM:
+		err = atomisp_histogram(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_BLACK_LEVEL_COMP:
+		err = atomisp_black_level(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_BLACK_LEVEL_COMP:
+		err = atomisp_black_level(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_EE:
+		err = atomisp_ee(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_EE:
+		err = atomisp_ee(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_DIS_STAT:
+		err = atomisp_get_dis_stat(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_S_DIS_COEFS:
+		err = atomisp_set_dis_coefs(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_S_DIS_VECTOR:
+		err = atomisp_set_dis_vector(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_PARM:
+		err = atomisp_param(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_PARM:
+		err = atomisp_param(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_3A_STAT:
+		err = atomisp_3a_stat(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_GAMMA:
+		err = atomisp_gamma(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_GAMMA:
+		err = atomisp_gamma(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_GDC_TAB:
+		err = atomisp_gdc_cac_table(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_GDC_TAB:
+		err = atomisp_gdc_cac_table(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_MACC:
+		err = atomisp_macc_table(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_MACC:
+		err = atomisp_macc_table(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_BAD_PIXEL_DETECTION:
+		err = atomisp_bad_pixel_param(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_BAD_PIXEL_DETECTION:
+		err = atomisp_bad_pixel_param(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_FALSE_COLOR_CORRECTION:
+		err = atomisp_false_color_param(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_FALSE_COLOR_CORRECTION:
+		err = atomisp_false_color_param(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_CTC:
+		err = atomisp_ctc(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_CTC:
+		err = atomisp_ctc(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_WHITE_BALANCE:
+		err = atomisp_white_balance_param(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_WHITE_BALANCE:
+		err = atomisp_white_balance_param(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_G_3A_CONFIG:
+		err = atomisp_3a_config_param(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_3A_CONFIG:
+		err = atomisp_3a_config_param(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_FPN_TABLE:
+		err = atomisp_fixed_pattern_table(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_ISP_MAKERNOTE:
+		err = atomisp_exif_makernote(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_G_SENSOR_MODE_DATA:
+		err = atomisp_get_sensor_mode_data(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA:
+		mutex_unlock(&isp->mutex);
+		if (isp->inputs[isp_subdev->input_curr].motor)
+			return v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].motor,
+					core, ioctl, cmd, arg);
+		else
+			return v4l2_subdev_call(
+					isp->inputs[isp_subdev->input_curr].camera,
+					core, ioctl, cmd, arg);
+
+	case ATOMISP_IOC_S_EXPOSURE:
+	case ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP:
+	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
+		mutex_unlock(&isp->mutex);
+		return v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera,
+					core, ioctl, cmd, arg);
+
+	case ATOMISP_IOC_ACC_LOAD:
+		err = atomisp_acc_load(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_LOAD_TO_PIPE:
+		err = atomisp_acc_load_to_pipe(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_UNLOAD:
+		err = atomisp_acc_unload(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_START:
+		err = atomisp_acc_start(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_WAIT:
+		err = atomisp_acc_wait(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_MAP:
+		err = atomisp_acc_map(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_UNMAP:
+		err = atomisp_acc_unmap(isp, arg);
+		break;
+
+	case ATOMISP_IOC_ACC_S_MAPPED_ARG:
+		err = atomisp_acc_s_mapped_arg(isp, arg);
+		break;
+
+	case ATOMISP_IOC_CAMERA_BRIDGE:
+		err = -EINVAL;
+		break;
+
+	case ATOMISP_IOC_S_ISP_SHD_TAB:
+		err = atomisp_set_shading_table(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_G_ISP_GAMMA_CORRECTION:
+		err = atomisp_gamma_correction(isp_subdev, 0, arg);
+		break;
+
+	case ATOMISP_IOC_S_ISP_GAMMA_CORRECTION:
+		err = atomisp_gamma_correction(isp_subdev, 1, arg);
+		break;
+
+	case ATOMISP_IOC_S_PARAMETERS:
+		err = atomisp_set_parameters(isp_subdev, arg);
+		break;
+
+	case ATOMISP_IOC_S_CONT_CAPTURE_CONFIG:
+		err = atomisp_offline_capture_configure(isp_subdev, arg);
+		break;
+
+	default:
+		mutex_unlock(&isp->mutex);
+		return -EINVAL;
+	}
+	mutex_unlock(&isp->mutex);
+	v4l2_dbg(5, dbg_level, &atomisp_dev, "<%s.\n", __func__);
+	return err;
+}
+
+const struct v4l2_ioctl_ops atomisp_ioctl_ops = {
+	.vidioc_querycap = atomisp_querycap,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
+	.vidioc_g_chip_ident = atomisp_g_chip_ident,
+#endif
+	.vidioc_enum_input = atomisp_enum_input,
+	.vidioc_g_input = atomisp_g_input,
+	.vidioc_s_input = atomisp_s_input,
+	.vidioc_queryctrl = atomisp_queryctl,
+	.vidioc_s_ctrl = atomisp_s_ctrl,
+	.vidioc_g_ctrl = atomisp_g_ctrl,
+	.vidioc_s_ext_ctrls = atomisp_s_ext_ctrls,
+	.vidioc_g_ext_ctrls = atomisp_g_ext_ctrls,
+	.vidioc_enum_fmt_vid_cap = atomisp_enum_fmt_cap,
+	.vidioc_try_fmt_vid_cap = atomisp_try_fmt_cap,
+	.vidioc_g_fmt_vid_cap = atomisp_g_fmt_cap,
+	.vidioc_s_fmt_vid_cap = atomisp_s_fmt_cap,
+	//.vidioc_s_fmt_type_private = atomisp_s_fmt_cap,
+	.vidioc_reqbufs = atomisp_reqbufs,
+	.vidioc_querybuf = atomisp_querybuf,
+	.vidioc_qbuf = atomisp_qbuf,
+	.vidioc_dqbuf = atomisp_dqbuf,
+	.vidioc_expbuf = atomisp_expbuf,
+	.vidioc_streamon = atomisp_streamon,
+	.vidioc_streamoff = atomisp_streamoff,
+	.vidioc_default = atomisp_vidioc_default,
+	.vidioc_enum_frameintervals = atomisp_enum_frameintervals,
+	.vidioc_s_parm = atomisp_s_parm,
+	.vidioc_g_parm = atomisp_g_parm,
+};
+
+const struct v4l2_ioctl_ops atomisp_file_ioctl_ops = {
+	.vidioc_querycap = atomisp_querycap,
+	.vidioc_g_fmt_vid_out = atomisp_g_fmt_file,
+	.vidioc_s_fmt_vid_out = atomisp_s_fmt_file,
+	.vidioc_s_parm = atomisp_s_parm_file,
+	.vidioc_reqbufs = atomisp_reqbufs_file,
+	.vidioc_querybuf = atomisp_querybuf_file,
+	.vidioc_qbuf = atomisp_qbuf_file,
+	/* .vidioc_streamon = atomisp_streamon_out, */
+};
diff --git a/drivers/media/atomisp2/atomisp_ioctl.h b/drivers/media/atomisp2/atomisp_ioctl.h
new file mode 100644
index 0000000..afa4fb1
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_ioctl.h
@@ -0,0 +1,71 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__ATOMISP_IOCTL_H__
+#define	__ATOMISP_IOCTL_H__
+
+#include <ia_css.h>
+
+struct atomisp_device;
+struct atomisp_video_pipe;
+
+/* Taken from videobuf2-dma-contig.c to extract dma_sgt
+ * to pass to CSS */
+/*struct vb2_dc_buf {
+  struct device     *dev;
+  void        *vaddr;
+  unsigned long     size;
+  dma_addr_t      dma_addr;
+  enum dma_data_direction   dma_dir;
+  struct sg_table     *dma_sgt;
+};*/
+
+extern const struct atomisp_format_bridge atomisp_output_fmts[];
+
+const struct atomisp_format_bridge *atomisp_get_format_bridge(
+	unsigned int pixelformat);
+const struct atomisp_format_bridge *atomisp_get_format_bridge_from_mbus(
+	enum media_bus_format mbus_code);
+
+int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *isp_subdev);
+
+int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type);
+int __atomisp_reqbufs(struct file *file, void *fh,
+		struct v4l2_requestbuffers *req);
+
+int atomisp_reqbufs(struct file *file, void *fh,
+			struct v4l2_requestbuffers *req);
+
+enum ia_css_pipe_id atomisp_get_css_pipe_id(struct atomisp_sub_device *isp_subdev);
+
+int atomisp_get_css_buf_type(struct atomisp_sub_device *isp_subdev,
+			 struct atomisp_video_pipe *pipe);
+
+void atomisp_free_css_frames(struct vb2_queue *q);
+extern const struct v4l2_file_operations atomisp_file_fops;
+
+extern const struct v4l2_ioctl_ops atomisp_ioctl_ops;
+
+extern const struct v4l2_ioctl_ops atomisp_file_ioctl_ops;
+
+#endif /* __ATOMISP_IOCTL_H__ */
diff --git a/drivers/media/atomisp2/atomisp_subdev.c b/drivers/media/atomisp2/atomisp_subdev.c
new file mode 100644
index 0000000..dd2a84d
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_subdev.c
@@ -0,0 +1,1042 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifdef ENABLE_DEV_DEBUG
+#define DEBUG
+#endif
+
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-event.h>
+#include <media/v4l2-mediabus.h>
+#include "atomisp_cmd.h"
+#include "atomisp_compat.h"
+#include "atomisp_common.h"
+#include "atomisp_internal.h"
+
+static const unsigned int isp_subdev_input_fmts[] = {
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+};
+
+static const unsigned int isp_subdev_preview_output_fmts[] = {
+	/* yuv420, nv12, yv12, nv21, rgb565 */
+	MEDIA_BUS_FMT_UYVY8_1X16,
+	MEDIA_BUS_FMT_YUYV8_1X16,
+	V4L2_PIX_FMT_YUV420,
+	V4L2_PIX_FMT_YVU420,
+	V4L2_PIX_FMT_NV12,
+	V4L2_PIX_FMT_RGB565,
+	V4L2_PIX_FMT_RGB24,
+	V4L2_PIX_FMT_NV21,
+};
+
+static const unsigned int isp_subdev_vf_output_fmts[] = {
+	/* yuv420, nv12, yv12, nv21, rgb565 */
+	MEDIA_BUS_FMT_UYVY8_1X16,
+	MEDIA_BUS_FMT_YUYV8_1X16,
+	V4L2_PIX_FMT_YUV420,
+	V4L2_PIX_FMT_YVU420,
+	V4L2_PIX_FMT_NV12,
+	V4L2_PIX_FMT_RGB565,
+	V4L2_PIX_FMT_RGB24,
+	V4L2_PIX_FMT_NV21,
+};
+
+static const unsigned int isp_subdev_capture_output_fmts[] = {
+	/* yuv420, nv12, yv12, nv21, rgb565, nv11, yuv422, nv16, yv16, yuy2 */
+	/* rgb565, rgb888 */
+	MEDIA_BUS_FMT_UYVY8_1X16,
+	MEDIA_BUS_FMT_YUYV8_1X16,
+	V4L2_PIX_FMT_YUV420,
+	V4L2_PIX_FMT_YVU420,
+	V4L2_PIX_FMT_YUV422P,
+	V4L2_PIX_FMT_YUV444,
+	V4L2_PIX_FMT_NV12,
+	V4L2_PIX_FMT_NV21,
+	V4L2_PIX_FMT_NV16,
+	V4L2_PIX_FMT_NV61,
+	V4L2_PIX_FMT_YUYV,
+	V4L2_PIX_FMT_UYVY,
+	V4L2_PIX_FMT_RGB565,
+	V4L2_PIX_FMT_RGB24,
+	V4L2_PIX_FMT_RGB32
+};
+
+const struct atomisp_in_fmt_conv atomisp_in_fmt_conv[] = {
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, IA_CSS_STREAM_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_BGGR },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, IA_CSS_STREAM_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_GBRG },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, IA_CSS_STREAM_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_GRBG },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, IA_CSS_STREAM_FORMAT_RAW_8, IA_CSS_BAYER_ORDER_RGGB },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, IA_CSS_STREAM_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_BGGR },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, IA_CSS_STREAM_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_GBRG },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, IA_CSS_STREAM_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_GRBG },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, IA_CSS_STREAM_FORMAT_RAW_10, IA_CSS_BAYER_ORDER_RGGB },
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, IA_CSS_STREAM_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_BGGR },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, IA_CSS_STREAM_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_GBRG },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, IA_CSS_STREAM_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_GRBG },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, IA_CSS_STREAM_FORMAT_RAW_12, IA_CSS_BAYER_ORDER_RGGB },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, IA_CSS_STREAM_FORMAT_YUV422_8, 0 },
+	{ 0x8003, IA_CSS_STREAM_FORMAT_YUV422_8, 0 },
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, IA_CSS_STREAM_FORMAT_RGB_565, 0 },
+	{ 0x800b, IA_CSS_STREAM_FORMAT_RGB_888, 0 },
+};
+
+const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv(
+	enum media_bus_format code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(atomisp_in_fmt_conv); i++)
+		if (code == atomisp_in_fmt_conv[i].code)
+			return &atomisp_in_fmt_conv[i];
+
+	return NULL;
+}
+
+/*
+ * V4L2 subdev operations
+ */
+
+/*
+ * isp_subdev_ioctl - CCDC module private ioctl's
+ * @sd: ISP V4L2 subdevice
+ * @cmd: ioctl command
+ * @arg: ioctl argument
+ *
+ * Return 0 on success or a negative error code otherwise.
+ */
+static long isp_subdev_ioctl(struct v4l2_subdev *sd,
+	unsigned int cmd, void *arg)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+/*
+ * isp_subdev_set_power - Power on/off the CCDC module
+ * @sd: ISP V4L2 subdevice
+ * @on: power on/off
+ *
+ * Return 0 on success or a negative error code otherwise.
+ */
+static int isp_subdev_set_power(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+static int isp_subdev_subscribe_event(struct v4l2_subdev *sd,
+	struct v4l2_fh *fh,
+	struct v4l2_event_subscription *sub)
+{
+	if (sub->type != V4L2_EVENT_FRAME_SYNC &&
+	    sub->type != V4L2_EVENT_ATOMISP_3A_STATS_READY)
+		return -EINVAL;
+
+	return v4l2_event_subscribe(fh, sub, 16, NULL);
+}
+
+static int isp_subdev_unsubscribe_event(struct v4l2_subdev *sd,
+	struct v4l2_fh *fh,
+	struct v4l2_event_subscription *sub)
+{
+	return v4l2_event_unsubscribe(fh, sub);
+}
+
+/*
+ * isp_subdev_enum_mbus_code - Handle pixel format enumeration
+ * @sd: pointer to v4l2 subdev structure
+ * @fh : V4L2 subdev file handle
+ * @code: pointer to v4l2_subdev_pad_mbus_code_enum structure
+ * return -EINVAL or zero on success
+ */
+static int isp_subdev_enum_mbus_code(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_mbus_code_enum *code)
+{
+	switch (code->pad) {
+	case ATOMISP_SUBDEV_PAD_SINK:
+		if (code->index >= ARRAY_SIZE(isp_subdev_input_fmts))
+			return -EINVAL;
+
+		code->code = isp_subdev_input_fmts[code->index];
+		break;
+
+	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
+		/* format conversion inside isp subdev */
+		if (code->index >= ARRAY_SIZE(isp_subdev_preview_output_fmts))
+			return -EINVAL;
+
+		code->code = isp_subdev_preview_output_fmts[code->index];
+		break;
+	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
+		/* format conversion inside isp subdev */
+		if (code->index >= ARRAY_SIZE(isp_subdev_vf_output_fmts))
+			return -EINVAL;
+
+		code->code = isp_subdev_vf_output_fmts[code->index];
+		break;
+	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
+		/* format conversion inside isp subdev */
+		if (code->index >= ARRAY_SIZE(isp_subdev_capture_output_fmts))
+			return -EINVAL;
+
+		code->code = isp_subdev_capture_output_fmts[code->index];
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int isp_subdev_validate_rect(uint32_t pad,
+				    uint32_t target)
+{
+	switch (pad) {
+	case ATOMISP_SUBDEV_PAD_SINK:
+		switch (target) {
+		case V4L2_SEL_TGT_CROP:
+			return 0;
+		}
+		break;
+	default:
+		switch (target) {
+		case V4L2_SEL_TGT_COMPOSE:
+			return 0;
+		}
+		break;
+	}
+
+	return -EINVAL;
+}
+
+struct v4l2_rect *atomisp_subdev_get_rect(struct atomisp_sub_device *isp_sd,
+					  struct v4l2_subdev_fh *fh,
+					  uint32_t which, uint32_t pad,
+					  uint32_t target)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY) {
+		switch (target) {
+		case V4L2_SEL_TGT_CROP:
+			return v4l2_subdev_get_try_crop(fh, pad);
+		case V4L2_SEL_TGT_COMPOSE:
+			return v4l2_subdev_get_try_compose(fh, pad);
+		}
+	}
+
+	switch (target) {
+	case V4L2_SEL_TGT_CROP:
+		return &isp_sd->fmt[pad].crop;
+	case V4L2_SEL_TGT_COMPOSE:
+		return &isp_sd->fmt[pad].compose;
+	}
+	return NULL;
+}
+
+struct v4l2_mbus_framefmt
+*atomisp_subdev_get_ffmt(struct atomisp_sub_device *isp_sd, struct v4l2_subdev_fh *fh,
+			 uint32_t which, uint32_t pad)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(fh, pad);
+
+	return &isp_sd->fmt[pad].fmt;
+}
+
+static void isp_get_fmt_rect(struct atomisp_sub_device *isp_sd, struct v4l2_subdev_fh *fh,
+			     uint32_t which, struct v4l2_mbus_framefmt **ffmt,
+			     struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
+			     struct v4l2_rect *comp[ATOMISP_SUBDEV_PADS_NUM])
+{
+	unsigned int i;
+
+	for (i = 0; i < ATOMISP_SUBDEV_PADS_NUM; i++) {
+		ffmt[i] = atomisp_subdev_get_ffmt(isp_sd, fh, which, i);
+		crop[i] = atomisp_subdev_get_rect(isp_sd, fh, which, i,
+						  V4L2_SEL_TGT_CROP);
+		comp[i] = atomisp_subdev_get_rect(isp_sd, fh, which, i,
+						  V4L2_SEL_TGT_COMPOSE);
+	}
+}
+
+static void isp_subdev_propagate(struct atomisp_sub_device *isp_sd,
+				 struct v4l2_subdev_fh *fh,
+				 uint32_t which, uint32_t pad, uint32_t target,
+				 uint32_t flags)
+{
+	struct v4l2_mbus_framefmt *ffmt[ATOMISP_SUBDEV_PADS_NUM];
+	struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
+		*comp[ATOMISP_SUBDEV_PADS_NUM];
+	struct v4l2_rect r;
+
+	if (flags & V4L2_SEL_FLAG_KEEP_CONFIG)
+		return;
+
+	isp_get_fmt_rect(isp_sd, fh, which, ffmt, crop, comp);
+
+	memset(&r, 0, sizeof(r));
+
+	switch (pad) {
+	case ATOMISP_SUBDEV_PAD_SINK:
+		/* Only crop target supported on sink pad. */
+		r.width = ffmt[pad]->width;
+		r.height = ffmt[pad]->height;
+
+		atomisp_subdev_set_selection(
+			isp_sd, fh, which, pad, target, flags, &r);
+		break;
+	}
+}
+
+static int isp_subdev_get_selection(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_fh *fh,
+				    struct v4l2_subdev_selection *sel)
+{
+	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
+	int rval = isp_subdev_validate_rect(sel->pad, sel->target);
+	if (rval)
+		return rval;
+
+	sel->r = *atomisp_subdev_get_rect(isp_sd, fh, sel->which, sel->pad,
+					  sel->target);
+	return 0;
+}
+
+static char *atomisp_pad_str[] = { "ATOMISP_SUBDEV_PAD_SINK",
+				   "ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE",
+				   "ATOMISP_SUBDEV_PAD_SOURCE_VF",
+				   "ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW" };
+
+int atomisp_subdev_set_selection(struct atomisp_sub_device *isp_sd,
+				 struct v4l2_subdev_fh *fh, uint32_t which,
+				 uint32_t pad, uint32_t target, uint32_t flags,
+				 struct v4l2_rect *r)
+{
+	struct atomisp_device *isp = isp_sd->isp;
+	struct v4l2_mbus_framefmt *ffmt[ATOMISP_SUBDEV_PADS_NUM];
+	struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
+		*comp[ATOMISP_SUBDEV_PADS_NUM];
+	unsigned int i;
+
+	int rval = isp_subdev_validate_rect(pad, target);
+	if (rval)
+		return rval;
+
+	isp_get_fmt_rect(isp_sd, fh, which, ffmt, crop, comp);
+
+	dev_dbg(isp->dev,
+		"sel: pad %s tgt %s l %d t %d w %d h %d which %s f 0x%8.8x\n",
+		atomisp_pad_str[pad], target == V4L2_SEL_TGT_CROP
+		? "V4L2_SEL_TGT_CROP" : "V4L2_SEL_TGT_COMPOSE",
+		r->left, r->top, r->width, r->height,
+		which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY"
+		: "V4L2_SUBDEV_FORMAT_ACTIVE", flags);
+
+	r->width = rounddown(r->width, ATOM_ISP_STEP_WIDTH);
+	r->height = rounddown(r->height, ATOM_ISP_STEP_HEIGHT);
+
+	switch (pad) {
+	case ATOMISP_SUBDEV_PAD_SINK: {
+		/* Only crop target supported on sink pad. */
+		unsigned int dvs_w, dvs_h;
+
+		crop[pad]->width = ffmt[pad]->width;
+		crop[pad]->height = ffmt[pad]->height;
+
+		if (!isp->sw_contex.bypass && crop[pad]->width
+		    && crop[pad]->height)
+			crop[pad]->width -= pad_w, crop[pad]->height -= pad_h;
+
+		/* if subdev type is SOC camera,we do not need to set DVS */
+		if (isp->inputs[isp_sd->input_curr].type == SOC_CAMERA)
+			isp_sd->params.video_dis_en = 0;
+
+		if (isp_sd->params.video_dis_en &&
+		    isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+			/* This resolution contains 20 % of DVS slack
+			 * (of the desired captured image before
+			 * scaling, or 1 / 6 of what we get from the
+			 * sensor) in both width and height. Remove
+			 * it. */
+			crop[pad]->width = roundup(crop[pad]->width * 5 / 6,
+						   ATOM_ISP_STEP_WIDTH);
+			crop[pad]->height = roundup(crop[pad]->height * 5 / 6,
+						    ATOM_ISP_STEP_HEIGHT);
+		}
+
+		crop[pad]->width = min(crop[pad]->width, r->width);
+		crop[pad]->height = min(crop[pad]->height, r->height);
+
+		if (!(flags & V4L2_SEL_FLAG_KEEP_CONFIG)) {
+			for (i = ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE;
+			     i <= ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW; i++) {
+				struct v4l2_rect tmp = *crop[pad];
+
+				atomisp_subdev_set_selection(
+					isp_sd, fh, which, i, V4L2_SEL_TGT_COMPOSE,
+					flags, &tmp);
+			}
+		}
+
+		if (which == V4L2_SUBDEV_FORMAT_TRY)
+			break;
+
+		if (isp_sd->params.video_dis_en &&
+		    isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+			dvs_w = rounddown(crop[pad]->width / 5,
+					  ATOM_ISP_STEP_WIDTH);
+			dvs_h = rounddown(crop[pad]->height / 5,
+					  ATOM_ISP_STEP_HEIGHT);
+		}
+		 else if (!isp_sd->params.video_dis_en &&  isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
+		  /*
+		   * For CSS2.0, digital zoom needs to set dvs envelope to 12
+		   * when dvs is disabled.
+		   */
+		   dvs_w = dvs_h = 12;
+		}else {
+			dvs_w = dvs_h = 0;
+		}
+		ia_css_video_set_dis_envelope(isp_sd,dvs_w,dvs_h);
+
+
+		isp_sd->css2_basis.stream_config.effective_res.width = crop[pad]->width;
+		isp_sd->css2_basis.stream_config.effective_res.height = crop[pad]->height;
+
+		break;
+	}
+	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE: {
+		/* Only compose target is supported on source pads. */
+
+		if (crop[ATOMISP_SUBDEV_PAD_SINK]->width == r->width
+		    && crop[ATOMISP_SUBDEV_PAD_SINK]->height == r->height)
+			isp_sd->params.yuv_ds_en = false;
+		else
+			isp_sd->params.yuv_ds_en = true;
+
+		comp[pad]->width = r->width;
+		comp[pad]->height = r->height;
+
+		break;
+	}
+	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
+	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
+		comp[pad]->width = r->width;
+		comp[pad]->height = r->height;
+		break;
+	}
+
+	/* Set format dimensions on non-sink pads as well. */
+	if (pad != ATOMISP_SUBDEV_PAD_SINK) {
+		ffmt[pad]->width = comp[pad]->width;
+		ffmt[pad]->height = comp[pad]->height;
+	}
+
+	*r = *atomisp_subdev_get_rect(isp_sd, fh, which, pad, target);
+
+	dev_dbg(isp->dev, "sel actual: l %d t %d w %d h %d\n",
+		r->left, r->top, r->width, r->height);
+
+	return 0;
+}
+
+static int isp_subdev_set_selection(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_fh *fh,
+				    struct v4l2_subdev_selection *sel)
+{
+	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
+
+	return atomisp_subdev_set_selection(isp_sd, fh, sel->which, sel->pad,
+					    sel->target, sel->flags, &sel->r);
+}
+
+static int atomisp_get_sensor_bin_factor(struct atomisp_sub_device *isp_subdev)
+{
+	struct v4l2_control ctrl;
+	int hbin, vbin;
+	int ret;
+	struct atomisp_device *isp = isp_subdev->isp;
+
+	if (isp->inputs[isp_subdev->input_curr].type == FILE_INPUT ||
+	isp->inputs[isp_subdev->input_curr].type == TEST_PATTERN)
+		return 0;
+
+	memset(&ctrl, 0, sizeof(ctrl));
+
+	ctrl.id = V4L2_CID_BIN_FACTOR_HORZ;
+	ret = v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera, core,
+			       g_ctrl, &ctrl);
+	hbin = ctrl.value;
+	ctrl.id = V4L2_CID_BIN_FACTOR_VERT;
+	ret |= v4l2_subdev_call(isp->inputs[isp_subdev->input_curr].camera, core,
+				g_ctrl, &ctrl);
+	vbin = ctrl.value;
+
+	/*
+	 * ISP needs to know binning factor from sensor.
+	 * In case horizontal and vertical sensor's binning factors
+	 * are different or sensor does not support binning factor CID,
+	 * ISP will apply default 0 value.
+	 */
+	if (ret || hbin != vbin)
+		hbin = 0;
+
+	return hbin;
+}
+
+int atomisp_subdev_set_ffmt(struct atomisp_sub_device *isp_sd, struct v4l2_subdev_fh *fh,
+			    uint32_t which, uint32_t pad,
+			    struct v4l2_mbus_framefmt *ffmt)
+{
+	struct atomisp_device *isp = isp_sd->isp;
+	struct v4l2_mbus_framefmt *__ffmt =
+		atomisp_subdev_get_ffmt(isp_sd, fh, which, pad);
+
+	dev_dbg(isp->dev, "ffmt: pad %s w %d h %d code 0x%8.8x which %s\n",
+		atomisp_pad_str[pad], ffmt->width, ffmt->height, ffmt->code,
+		which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY"
+		: "V4L2_SUBDEV_FORMAT_ACTIVE");
+
+	/* Set bypass mode. One must only set raw or non-raw formats
+	 * on the source pads. */
+	if (pad != ATOMISP_SUBDEV_PAD_SINK
+	    && which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		struct v4l2_mbus_framefmt *f =
+			atomisp_subdev_get_ffmt(isp_sd, fh, which,
+						ATOMISP_SUBDEV_PAD_SINK);
+
+		isp->sw_contex.bypass = !atomisp_is_mbuscode_raw(f->code)
+			|| atomisp_is_mbuscode_raw(ffmt->code);
+	}
+
+	switch (pad) {
+	case ATOMISP_SUBDEV_PAD_SINK: {
+		struct atomisp_in_fmt_conv *fc =
+			atomisp_find_in_fmt_conv(ffmt->code);
+
+		if (!fc) {
+			ffmt->code = atomisp_in_fmt_conv[0].code;
+			fc = atomisp_find_in_fmt_conv(ffmt->code);
+			BUG_ON(!fc);
+		}
+
+		*__ffmt = *ffmt;
+
+		isp_subdev_propagate(isp_sd, fh, which, pad,
+				     V4L2_SEL_TGT_CROP, 0);
+		if (which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+				if(isp_sd->css2_basis.stream_config.format != fc->in_sh_fmt)
+					ia_css_input_set_format(isp_sd,fc->in_sh_fmt);
+
+					ia_css_input_set_resolution(isp_sd,ffmt);
+					ia_css_input_set_binning_factor(isp_sd,atomisp_get_sensor_bin_factor(isp_sd));
+					ia_css_input_set_bayer_order(isp_sd,fc->bayer_order);
+
+					if(atomisp_try_mipi_frame_buffer_size(isp_sd, ffmt->width,
+							ffmt->height, atomisp_get_format_bridge_from_mbus(ffmt->code)->pixelformat)){
+						v4l2_err(&atomisp_dev, "ERROR: Input frame buffer size is larger than the allocated intermediate MIPI buffers:[%x0x]\n",ATOMISP_MIPI_BUFFER_SIZE);
+						return -EINVAL;
+					}
+				v4l2_subdev_call(isp->inputs[isp_sd->input_curr].camera,video, s_mbus_fmt, __ffmt);
+
+			}
+		break;
+	}
+	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
+	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
+	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
+		__ffmt->code = ffmt->code;
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * isp_subdev_get_format - Retrieve the video format on a pad
+ * @sd : ISP V4L2 subdevice
+ * @fh : V4L2 subdev file handle
+ * @pad: Pad number
+ * @fmt: Format
+ *
+ * Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
+ * to the format type.
+ */
+static int isp_subdev_get_format(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh, struct v4l2_subdev_format *fmt)
+{
+
+	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
+	fmt->format = *atomisp_subdev_get_ffmt(isp_sd, fh, fmt->which, fmt->pad);
+
+	return 0;
+}
+
+/*
+ * isp_subdev_set_format - Set the video format on a pad
+ * @sd : ISP subdev V4L2 subdevice
+ * @fh : V4L2 subdev file handle
+ * @pad: Pad number
+ * @fmt: Format
+ *
+ * Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
+ * to the format type.
+ */
+static int isp_subdev_set_format(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh, struct v4l2_subdev_format *fmt)
+{
+	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
+	return atomisp_subdev_set_ffmt(isp_sd, fh, fmt->which, fmt->pad,
+				       &fmt->format);
+}
+
+/* V4L2 subdev core operations */
+static const struct v4l2_subdev_core_ops isp_subdev_v4l2_core_ops = {
+	 .ioctl = isp_subdev_ioctl,
+	 .s_power = isp_subdev_set_power,
+	 .subscribe_event = isp_subdev_subscribe_event,
+	 .unsubscribe_event = isp_subdev_unsubscribe_event,
+};
+
+/* V4L2 subdev pad operations */
+static const struct v4l2_subdev_pad_ops isp_subdev_v4l2_pad_ops = {
+	 .enum_mbus_code = isp_subdev_enum_mbus_code,
+	 .get_fmt = isp_subdev_get_format,
+	 .set_fmt = isp_subdev_set_format,
+	 .get_selection = isp_subdev_get_selection,
+	 .set_selection = isp_subdev_set_selection,
+};
+
+/* V4L2 subdev operations */
+static const struct v4l2_subdev_ops isp_subdev_v4l2_ops = {
+	 .core = &isp_subdev_v4l2_core_ops,
+	 .pad = &isp_subdev_v4l2_pad_ops,
+};
+
+static void isp_subdev_init_params(struct atomisp_sub_device *isp_subdev)
+{
+	/* parameters initialization */
+	INIT_LIST_HEAD(&isp_subdev->s3a_stats);
+	INIT_LIST_HEAD(&isp_subdev->dvs_stats);
+}
+
+/*
+* isp_subdev_link_setup - Setup isp subdev connections
+* @entity: ispsubdev media entity
+* @local: Pad at the local end of the link
+* @remote: Pad at the remote end of the link
+* @flags: Link flags
+*
+* return -EINVAL or zero on success
+*/
+static int isp_subdev_link_setup(struct media_entity *entity,
+	const struct media_pad *local,
+	const struct media_pad *remote, u32 flags)
+{
+	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
+	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
+	struct atomisp_device *isp = isp_sd->isp;
+	unsigned int i;
+
+	switch (local->index | media_entity_type(remote->entity)) {
+	case ATOMISP_SUBDEV_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:
+		/* Read from the sensor CSI2-ports. */
+		if (!(flags & MEDIA_LNK_FL_ENABLED)) {
+			isp_sd->input = ATOMISP_SUBDEV_INPUT_NONE;
+			break;
+		}
+
+		if (isp_sd->input != ATOMISP_SUBDEV_INPUT_NONE)
+			return -EBUSY;
+
+		for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
+			if (remote->entity != &isp->csi2_port[i].subdev.entity)
+				continue;
+
+			isp_sd->input = ATOMISP_SUBDEV_INPUT_CSI2_PORT1 + i;
+			return 0;
+		}
+
+		return -EINVAL;
+
+	case ATOMISP_SUBDEV_PAD_SINK | MEDIA_ENT_T_DEVNODE:
+		/* read from memory */
+		if (flags & MEDIA_LNK_FL_ENABLED) {
+			if (isp_sd->input >= ATOMISP_SUBDEV_INPUT_CSI2_PORT1 &&
+				isp_sd->input < (ATOMISP_SUBDEV_INPUT_CSI2_PORT1
+						+ ATOMISP_CAMERA_NR_PORTS))
+				return -EBUSY;
+			isp_sd->input = ATOMISP_SUBDEV_INPUT_MEMORY;
+		} else {
+			if (isp_sd->input == ATOMISP_SUBDEV_INPUT_MEMORY)
+				isp_sd->input = ATOMISP_SUBDEV_INPUT_NONE;
+		}
+		break;
+
+	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW | MEDIA_ENT_T_DEVNODE:
+		/* always write to memory */
+		break;
+
+	case ATOMISP_SUBDEV_PAD_SOURCE_VF | MEDIA_ENT_T_DEVNODE:
+		/* always write to memory */
+		break;
+
+	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE | MEDIA_ENT_T_DEVNODE:
+		/* always write to memory */
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* media operations */
+static const struct media_entity_operations isp_subdev_media_ops = {
+	 .link_setup = isp_subdev_link_setup,
+/*	 .set_power = v4l2_subdev_set_power,	*/
+};
+
+static int __atomisp_update_run_mode(struct atomisp_sub_device *isp_subdev)
+{
+	struct atomisp_device *isp = isp_subdev->isp;
+	struct v4l2_ctrl *ctrl = isp_subdev->run_mode;
+	struct v4l2_ctrl *c;
+	struct v4l2_streamparm p;
+	int modes[] = { CI_MODE_NONE,
+			CI_MODE_VIDEO,
+			CI_MODE_STILL_CAPTURE,
+			CI_MODE_CONTINUOUS,
+			CI_MODE_PREVIEW };
+	s32 mode;
+
+	if (ctrl->val != ATOMISP_RUN_MODE_VIDEO &&
+	    isp_subdev->params.continuous_vf)
+		mode = ATOMISP_RUN_MODE_PREVIEW;
+	else
+		mode = ctrl->val;
+
+	c = v4l2_ctrl_find(
+		isp->inputs[isp_subdev->input_curr].camera->ctrl_handler,
+		V4L2_CID_RUN_MODE);
+
+	if (c)
+		return v4l2_ctrl_s_ctrl(c, mode);
+
+	/* Fall back to obsolete s_parm */
+	memset(&p, 0, sizeof(p));
+
+	p.parm.capture.capturemode = modes[mode];
+
+	return v4l2_subdev_call(
+		isp->inputs[isp_subdev->input_curr].camera, video, s_parm, &p);
+}
+
+int atomisp_update_run_mode(struct atomisp_sub_device *isp_subdev)
+{
+	int rval;
+
+	mutex_lock(isp_subdev->ctrl_handler.lock);
+	rval = __atomisp_update_run_mode(isp_subdev);
+	mutex_unlock(isp_subdev->ctrl_handler.lock);
+
+	return rval;
+}
+
+static int s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct atomisp_sub_device *isp_subdev = container_of(
+                ctrl->handler, struct atomisp_sub_device, ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_RUN_MODE:
+		return __atomisp_update_run_mode(isp_subdev);
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ctrl_ops = {
+	.s_ctrl = &s_ctrl,
+};
+
+static const struct v4l2_ctrl_config ctrl_fmt_auto = {
+	.ops = &ctrl_ops,
+	.id = V4L2_CID_FMT_AUTO,
+	.name = "Automatic format guessing",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const char * const ctrl_run_mode_menu[] = {
+	NULL,
+	"Video",
+	"Still capture",
+	"Continuous capture",
+	"Preview",
+};
+
+static const struct v4l2_ctrl_config ctrl_run_mode = {
+	.ops = &ctrl_ops,
+	.id = V4L2_CID_RUN_MODE,
+	.name = "Atomisp run mode",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 1,
+	.def = 1,
+	.max = 4,
+	.qmenu = ctrl_run_mode_menu,
+};
+
+static const struct v4l2_ctrl_config ctrl_enable_vfpp = {
+	.id = V4L2_CID_ENABLE_VFPP,
+	.name = "Atomisp vf postprocess",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.def = 1,
+	.max = 1,
+	.step = 1
+};
+
+/*
+ * isp_subdev_init_entities - Initialize V4L2 subdev and media entity
+ * @isp_subdev: ISP CCDC module
+ *
+ * Return 0 on success and a negative error code on failure.
+ */
+static int isp_subdev_init_entities(struct atomisp_sub_device *isp_subdev)
+{
+	struct v4l2_subdev *sd = &isp_subdev->subdev;
+	struct media_pad *pads = isp_subdev->pads;
+	struct media_entity *me = &sd->entity;
+	int ret;
+
+	isp_subdev->input = ATOMISP_SUBDEV_INPUT_NONE;
+
+	v4l2_subdev_init(sd, &isp_subdev_v4l2_ops);
+	strlcpy(sd->name, "ATOM ISP SUBDEV", sizeof(sd->name));
+	v4l2_set_subdevdata(sd, isp_subdev);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pads[ATOMISP_SUBDEV_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	pads[ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW].flags = MEDIA_PAD_FL_SOURCE;
+	pads[ATOMISP_SUBDEV_PAD_SOURCE_VF].flags = MEDIA_PAD_FL_SOURCE;
+	pads[ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE].flags = MEDIA_PAD_FL_SOURCE;
+
+	isp_subdev->fmt[ATOMISP_SUBDEV_PAD_SINK].fmt.code =
+		MEDIA_BUS_FMT_SBGGR10_1X10;
+	isp_subdev->fmt[ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW].fmt.code =
+		MEDIA_BUS_FMT_SBGGR10_1X10;
+	isp_subdev->fmt[ATOMISP_SUBDEV_PAD_SOURCE_VF].fmt.code =
+		MEDIA_BUS_FMT_SBGGR10_1X10;
+	isp_subdev->fmt[ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE].fmt.code =
+		MEDIA_BUS_FMT_SBGGR10_1X10;
+
+	me->ops = &isp_subdev_media_ops;
+	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
+	ret = media_entity_init(me, ATOMISP_SUBDEV_PADS_NUM, pads, 0);
+	if (ret < 0)
+		return ret;
+
+	isp_subdev->video_in.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	isp_subdev->video_in.isp = isp_subdev->isp;
+	isp_subdev->video_in.isp_subdev = isp_subdev;
+	isp_subdev->video_in.pipe_type = ATOMISP_PIPE_FILEINPUT;
+	spin_lock_init(&isp_subdev->video_in.irq_lock);
+
+	isp_subdev->video_out_preview.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	isp_subdev->video_out_preview.isp = isp_subdev->isp;
+	isp_subdev->video_out_preview.pipe_type = ATOMISP_PIPE_PREVIEW;
+	isp_subdev->video_out_preview.isp_subdev = isp_subdev;
+	spin_lock_init(&isp_subdev->video_out_preview.irq_lock);
+
+	isp_subdev->video_out_vf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	isp_subdev->video_out_vf.isp = isp_subdev->isp;
+	isp_subdev->video_out_vf.isp_subdev = isp_subdev;
+	isp_subdev->video_out_vf.pipe_type = ATOMISP_PIPE_VIEWFINDER;
+	spin_lock_init(&isp_subdev->video_out_vf.irq_lock);
+
+	isp_subdev->video_out_capture.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	isp_subdev->video_out_capture.isp = isp_subdev->isp;
+	isp_subdev->video_out_capture.isp_subdev = isp_subdev;
+	isp_subdev->video_out_capture.pipe_type = ATOMISP_PIPE_CAPTURE;
+	spin_lock_init(&isp_subdev->video_out_capture.irq_lock);
+
+	ret = atomisp_video_init(&isp_subdev->video_in, "MEMORY");
+	if (ret < 0)
+		return ret;
+
+	ret = atomisp_video_init(&isp_subdev->video_out_capture, "CAPTURE");
+	if (ret < 0)
+		return ret;
+
+	ret = atomisp_video_init(&isp_subdev->video_out_vf, "VIEWFINDER");
+	if (ret < 0)
+		return ret;
+
+	ret = atomisp_video_init(&isp_subdev->video_out_preview, "PREVIEW");
+	if (ret < 0)
+		return ret;
+
+	/* Connect the isp subdev to the video node. */
+	ret = media_entity_create_link(&isp_subdev->video_in.vdev.entity,
+		0, &isp_subdev->subdev.entity, ATOMISP_SUBDEV_PAD_SINK, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = media_entity_create_link(&isp_subdev->subdev.entity,
+		ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW,
+		&isp_subdev->video_out_preview.vdev.entity, 0, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = media_entity_create_link(&isp_subdev->subdev.entity,
+		ATOMISP_SUBDEV_PAD_SOURCE_VF,
+		&isp_subdev->video_out_vf.vdev.entity, 0, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = media_entity_create_link(&isp_subdev->subdev.entity,
+		ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE,
+		&isp_subdev->video_out_capture.vdev.entity, 0, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = v4l2_ctrl_handler_init(&isp_subdev->ctrl_handler, 1);
+	if (ret)
+		return ret;
+
+	isp_subdev->fmt_auto = v4l2_ctrl_new_custom(&isp_subdev->ctrl_handler,
+						    &ctrl_fmt_auto, NULL);
+	isp_subdev->run_mode = v4l2_ctrl_new_custom(&isp_subdev->ctrl_handler,
+						    &ctrl_run_mode, NULL);
+	isp_subdev->enable_vfpp =
+				v4l2_ctrl_new_custom(&isp_subdev->ctrl_handler,
+						     &ctrl_enable_vfpp, NULL);
+
+	/* Make controls visible on subdev as well. */
+	isp_subdev->subdev.ctrl_handler = &isp_subdev->ctrl_handler;
+
+	return isp_subdev->ctrl_handler.error;
+}
+
+void atomisp_subdev_unregister_entities(struct atomisp_sub_device *isp_subdev)
+{
+	v4l2_ctrl_handler_free(&isp_subdev->ctrl_handler);
+
+	media_entity_cleanup(&isp_subdev->subdev.entity);
+
+	v4l2_device_unregister_subdev(&isp_subdev->subdev);
+	atomisp_video_unregister(&isp_subdev->video_in);
+	atomisp_video_unregister(&isp_subdev->video_out_preview);
+	atomisp_video_unregister(&isp_subdev->video_out_vf);
+	atomisp_video_unregister(&isp_subdev->video_out_capture);
+}
+
+int atomisp_subdev_register_entities(struct atomisp_sub_device *isp_subdev,
+	struct v4l2_device *vdev)
+{
+	int ret;
+
+	/* Register the subdev and video node. */
+	ret = v4l2_device_register_subdev(vdev, &isp_subdev->subdev);
+	if (ret < 0)
+		goto error;
+
+	ret = atomisp_video_register(&isp_subdev->video_out_capture, vdev);
+	if (ret < 0)
+		goto error;
+
+	ret = atomisp_video_register(&isp_subdev->video_out_vf, vdev);
+	if (ret < 0)
+		goto error;
+
+	ret = atomisp_video_register(&isp_subdev->video_out_preview, vdev);
+	if (ret < 0)
+		goto error;
+
+	ret = atomisp_video_register(&isp_subdev->video_in, vdev);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	atomisp_subdev_unregister_entities(isp_subdev);
+	return ret;
+}
+
+
+/*
+ * atomisp_subdev_init - ISP Subdevice  initialization.
+ * @dev: Device pointer specific to the ATOM ISP.
+ *
+ * TODO: Get the initialisation values from platform data.
+ *
+ * Return 0 on success or a negative error code otherwise.
+ */
+int atomisp_subdev_init(struct atomisp_device *isp)
+{
+	struct atomisp_sub_device *isp_subdev;
+	int ret = 0, i;
+	/*
+	 * CSS2.0 supports multiple streams
+	 */
+	isp->num_of_streams = IS_MRFLD ? MULTI_STREAM_NUM : 1;
+	isp->isp_subdev = kzalloc(sizeof(struct atomisp_sub_device) *
+				  isp->num_of_streams, GFP_KERNEL);
+	if(!isp->isp_subdev)
+	{
+		return -ENOMEM;
+	}
+
+	for(i =0; i< isp->num_of_streams; i++){
+		isp_subdev = &isp->isp_subdev[i];
+		spin_lock_init(&isp_subdev->lock);
+		isp_subdev->isp = isp;
+		isp_subdev->index = i;
+		isp_subdev_init_params(isp_subdev);
+		ret = isp_subdev_init_entities(isp_subdev);
+		if (ret < 0)
+		 	break;
+	}
+
+	return ret;
+}
+
+void atomisp_subdev_cleanup(struct atomisp_sub_device *isp_subdev)
+{
+	kfree(isp_subdev);
+}
+
diff --git a/drivers/media/atomisp2/atomisp_subdev.h b/drivers/media/atomisp2/atomisp_subdev.h
new file mode 100644
index 0000000..c6a73a3
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_subdev.h
@@ -0,0 +1,312 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef __ATOMISP_SUBDEV_H__
+#define __ATOMISP_SUBDEV_H__
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-core.h>
+
+#include "atomisp_common.h"
+#include "atomisp_v4l2.h"
+#include "ia_css.h"
+
+enum atomisp_subdev_input_entity {
+	ATOMISP_SUBDEV_INPUT_NONE,
+	ATOMISP_SUBDEV_INPUT_MEMORY,
+	ATOMISP_SUBDEV_INPUT_CSI2,
+	/*
+	 * The following enum for CSI2 port must go together in one row.
+	 * Otherwise it breaks the code logic.
+	 */
+	ATOMISP_SUBDEV_INPUT_CSI2_PORT1,
+	ATOMISP_SUBDEV_INPUT_CSI2_PORT2,
+	ATOMISP_SUBDEV_INPUT_CSI2_PORT3,
+};
+
+#define ATOMISP_SUBDEV_PAD_SINK			0
+/* capture output for still and video frames */
+#define ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE	1
+/* viewfinder output for downscaled capture output */
+#define ATOMISP_SUBDEV_PAD_SOURCE_VF		2
+/* preview output for display */
+#define ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW	3
+#define ATOMISP_SUBDEV_PADS_NUM			4
+
+enum atomisp_pipe_type {
+	ATOMISP_PIPE_CAPTURE,
+	ATOMISP_PIPE_VIEWFINDER,
+	ATOMISP_PIPE_PREVIEW,
+	ATOMISP_PIPE_FILEINPUT
+};
+
+struct atomisp_in_fmt_conv {
+	enum media_bus_format code;
+	enum ia_css_stream_format in_sh_fmt;
+	enum ia_css_bayer_order bayer_order;
+};
+
+struct atomisp_3a_dis_stat_buf {
+	struct ia_css_isp_3a_statistics s3a_data;
+	struct ia_css_isp_dvs_statistics dvs_stat;
+	struct list_head list;
+};
+
+struct atomisp_s3a_buf {
+	struct ia_css_isp_3a_statistics *s3a_stat;
+	struct list_head list;
+};
+
+struct atomisp_dvs_buf {
+	struct ia_css_isp_dvs_statistics *dvs_stat;
+	struct list_head list;
+};
+
+struct atomisp_sub_device;
+
+struct atomisp_video_pipe {
+	struct video_device vdev;
+	enum v4l2_buf_type type;
+	struct media_pad pad;
+	struct vb2_queue vb2q;
+	struct vb2_queue vb2outq; /* Just for file injection */
+	struct list_head activeq;
+	struct list_head activeq_out;
+	unsigned int buffers_in_css;
+
+	/* irq_lock is used to protect video buffer state change operations and
+	 * also to make activeq, activeq_out, capq and outq list
+	 * operations atomic. */
+	spinlock_t irq_lock;
+	unsigned int users;
+	enum atomisp_pipe_type pipe_type;
+
+	struct atomisp_device *isp;
+	struct v4l2_pix_format pix;
+	uint32_t sh_fmt;
+	struct atomisp_sub_device *isp_subdev;
+	int field_sequence;
+	int previous_frame_exp_id;
+};
+
+struct atomisp_pad_format {
+	struct v4l2_mbus_framefmt fmt;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+};
+
+/* Internal states for flash process */
+enum atomisp_flash_state {
+        ATOMISP_FLASH_IDLE,
+        ATOMISP_FLASH_REQUESTED,
+        ATOMISP_FLASH_ONGOING,
+        ATOMISP_FLASH_DONE
+};
+
+enum atomisp_css2_stream_state {
+        CSS2_STREAM_UNINIT,
+        CSS2_STREAM_CREATED,
+        CSS2_STREAM_STARTED,
+        CSS2_STREAM_STOPPED,
+};
+
+struct atomisp_css_params {
+	int online_process;
+	int yuv_ds_en;
+	unsigned int color_effect;
+	bool gdc_cac_en;
+	bool macc_en;
+	bool bad_pixel_en;
+	bool video_dis_en;
+	bool sc_en;
+	bool fpn_en;
+	bool xnr_en;
+	bool low_light;
+	bool continuous_vf;
+	int false_color;
+	unsigned int histogram_elenum;
+	struct ia_css_isp_config config;
+
+	/* current configurations */
+	struct ia_css_dp_config   dp_config;
+	struct ia_css_wb_config   wb_config;
+	struct ia_css_cc_config   cc_config;
+	struct ia_css_nr_config   nr_config;
+	struct ia_css_ee_config   ee_config;
+	struct ia_css_ob_config   ob_config;
+	struct ia_css_de_config   de_config;
+	struct ia_css_ce_config   ce_config;
+	struct ia_css_gc_config   gc_config;
+	struct ia_css_tnr_config  tnr_config;
+	struct ia_css_3a_config   s3a_config;
+	struct ia_css_macc_config   macc_config;
+	struct ia_css_anr_config  anr_config;
+	struct ia_css_dz_config   dz_config;  /**< Digital Zoom */
+	struct ia_css_capture_config   capture_config;
+	struct ia_css_gamma_table gamma_table;
+	struct ia_css_ctc_table   ctc_table;
+	struct ia_css_macc_table  macc_table;
+	struct ia_css_xnr_table   xnr_table;
+	struct ia_css_dvs_coefficients dvs_coefs;
+	struct ia_css_vector  motion_vector;
+	/*
+	 * overlay removed from css 1.5
+	 * struct ia_css_overlay	*vf_overlay;
+	 */
+
+	/* Current grid info */
+	struct ia_css_grid_info curr_grid_info;
+
+	/* Intermediate buffers used to communicate data between
+	   CSS and user space. These are needed to perform the
+	   copy_to_user. */
+	struct ia_css_3a_statistics *s3a_user_stat;
+	int s3a_output_bytes;
+	bool s3a_buf_data_valid;
+
+	struct ia_css_dvs_coefficients *dvs_coeff;
+	struct ia_css_dvs_statistics *dvs_stat;
+	bool dvs_proj_data_valid;
+	int  dvs_hor_coef_bytes;
+	int  dvs_ver_coef_bytes;
+	int  dvs_ver_proj_bytes;
+	int  dvs_hor_proj_bytes;
+
+	/* Flash */
+	int num_flash_frames;
+	enum atomisp_flash_state flash_state;
+	enum atomisp_frame_status last_frame_status;
+	/* continuous capture */
+	struct atomisp_cont_capture_conf offline_parm;
+	/* Flag to check if driver needs to update params to css */
+	bool css_update_params_needed;
+};
+
+struct atomisp_css2_basis {
+	struct ia_css_stream *stream;
+	struct ia_css_stream_config stream_config;
+	struct ia_css_pipe *pipes[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_pipe *multi_pipes[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_pipe_config pipe_configs[IA_CSS_PIPE_ID_NUM];
+	struct ia_css_pipe_extra_config pipe_extra_configs[IA_CSS_PIPE_ID_NUM];
+	bool update_pipe[IA_CSS_PIPE_ID_NUM];
+	unsigned int curr_pipe;
+	enum atomisp_css2_stream_state stream_state;
+};
+
+struct atomisp_sub_device {
+	struct v4l2_subdev subdev;
+	struct media_pad pads[ATOMISP_SUBDEV_PADS_NUM];
+	struct atomisp_pad_format fmt[ATOMISP_SUBDEV_PADS_NUM];
+	uint16_t capture_pad; /* main capture pad; defines much of isp config */
+
+	struct atomisp_css_params params;
+
+	enum atomisp_subdev_input_entity input;
+	unsigned int output;
+	struct atomisp_video_pipe video_in;
+	struct atomisp_video_pipe video_out_capture; /* capture output */
+	struct atomisp_video_pipe video_out_vf;      /* viewfinder output */
+	struct atomisp_video_pipe video_out_preview; /* preview output */
+	/* struct isp_subdev_params params; */
+	spinlock_t lock;
+	struct atomisp_device *isp;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *fmt_auto;
+	struct v4l2_ctrl *run_mode;
+	struct v4l2_ctrl *enable_vfpp;
+
+	struct atomisp_css2_basis css2_basis;
+
+	struct list_head s3a_stats;
+	struct list_head dvs_stats;
+        unsigned int s3a_bufs_in_css[IA_CSS_PIPE_ID_NUM];
+        unsigned int dis_bufs_in_css;
+
+
+	struct ia_css_frame *vf_frame; /* TODO: needed? */
+	struct ia_css_frame *raw_output_frame;
+	enum atomisp_frame_status frame_status[VIDEO_MAX_FRAME];
+
+	int input_curr;
+
+	unsigned int streaming; /* Hold both mutex and lock to change this */
+	bool stream_prepared; /* whether css stream is created */
+
+	bool video_pipe_vf_enable; // flag is set when video pipe generates vf frame
+
+	/*
+	 * subdev index;
+	 * recored in resource(atomisp_input_subdev) to show which sub device
+	 * is using this resource
+	 */
+	int index;
+
+	/*
+	 * this is to notify all the buffers are dequeued from CSS.
+	 *
+	 * css2.0 bug: all the buffers needs to be dequeued after stream off
+	 */
+	struct completion buf_done;
+
+	 /* delayed memory allocation for css */
+        struct completion init_done;
+        struct workqueue_struct *delayed_init_workq;
+        unsigned int delayed_init;
+        struct work_struct delayed_init_work;
+
+        atomic_t sof_count;
+        atomic_t sequence;      /* Sequence value that is assigned to buffer. */
+        atomic_t sequence_temp;
+};
+
+extern const struct atomisp_in_fmt_conv atomisp_in_fmt_conv[];
+
+const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv(
+	enum media_bus_format code);
+
+/* Get pointer to appropriate format */
+struct v4l2_mbus_framefmt
+*atomisp_subdev_get_ffmt(struct atomisp_sub_device *isp_sd, struct v4l2_subdev_fh *fh,
+			 uint32_t which, uint32_t pad);
+struct v4l2_rect *atomisp_subdev_get_rect(struct atomisp_sub_device *isp_sd,
+					  struct v4l2_subdev_fh *fh,
+					  uint32_t which, uint32_t pad,
+					  uint32_t target);
+int atomisp_subdev_set_selection(struct atomisp_sub_device *sd,
+				 struct v4l2_subdev_fh *fh, uint32_t which,
+				 uint32_t pad, uint32_t target, uint32_t flags,
+				 struct v4l2_rect *r);
+/* Actually set the format */
+int atomisp_subdev_set_ffmt(struct atomisp_sub_device *sd, struct v4l2_subdev_fh *fh,
+			    uint32_t which, uint32_t pad,
+			    struct v4l2_mbus_framefmt *ffmt);
+
+int atomisp_update_run_mode(struct atomisp_sub_device *isp_subdev);
+
+void atomisp_subdev_unregister_entities(struct atomisp_sub_device *isp_subdev);
+int atomisp_subdev_register_entities(struct atomisp_sub_device *isp_subdev,
+	struct v4l2_device *vdev);
+int atomisp_subdev_init(struct atomisp_device *isp);
+void atomisp_subdev_cleanup(struct atomisp_sub_device *isp_subdev);
+
+#endif /* __ATOMISP_SUBDEV_H__ */
diff --git a/drivers/media/atomisp2/atomisp_tables.h b/drivers/media/atomisp2/atomisp_tables.h
new file mode 100644
index 0000000..f9bf76a
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_tables.h
@@ -0,0 +1,327 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef	__ATOMISP_TABLES_H__
+#define	__ATOMISP_TABLES_H__
+
+#include "sh_css_params.h"
+
+/*Sepia image effect table*/
+static struct ia_css_cc_config sepia_cc_config = {
+	.fraction_bits  = 8,
+	.matrix	 = {141, 18, 68, -40, -5, -19, 35, 4, 16},
+};
+
+/*Negative image effect table*/
+static struct ia_css_cc_config nega_cc_config = {
+	.fraction_bits  = 8,
+	.matrix	 = {255, 29, 120, 0, 374, 342, 0, 672, -301},
+};
+
+/*Mono image effect table*/
+static struct ia_css_cc_config mono_cc_config = {
+	.fraction_bits  = 8,
+	.matrix	 = {255, 29, 120, 0, 0, 0, 0, 0, 0},
+};
+
+/*Skin whiten image effect table*/
+static struct ia_css_macc_table skin_low_macc_table = {
+	.data = {
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	7168, 0, 2048, 8192,
+	5120, -1024, 2048, 8192,
+	8192, 2048, -1024, 5120,
+	8192, 2048, 0, 7168,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192
+	}
+};
+
+static struct ia_css_macc_table skin_medium_macc_table = {
+	.data = {
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	5120, 0, 6144, 8192,
+	3072, -1024, 2048, 6144,
+	6144, 2048, -1024, 3072,
+	8192, 6144, 0, 5120,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192
+	}
+};
+
+static struct ia_css_macc_table skin_high_macc_table = {
+	.data = {
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	4096, 0, 8192, 8192,
+	0, -2048, 4096, 6144,
+	6144, 4096, -2048, 0,
+	8192, 8192, 0, 4096,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192
+	}
+};
+
+/*Blue enhencement image effect table*/
+static struct ia_css_macc_table blue_macc_table = {
+	.data = {
+	9728, -3072, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	9728, 0, -3072, 8192,
+	12800, 1536, -3072, 8192,
+	11264, 0, 0, 11264,
+	9728, -3072, 0, 11264
+	}
+};
+
+/*Green enhencement image effect table*/
+static struct ia_css_macc_table green_macc_table = {
+	.data = {
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	10240, 4096, 0, 8192,
+	10240, 4096, 0, 12288,
+	12288, 0, 0, 12288,
+	14336, -2048, 4096, 8192,
+	10240, 0, 4096, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192,
+	8192, 0, 0, 8192
+	}
+};
+
+/* this table is from CSS1.5 default_ctc_table(20121003) */
+static struct ia_css_ctc_table vivid_ctc_table = {
+	.data.vamem_2 = {
+	0,  384,  837,  957, 1011, 1062, 1083, 1080,
+	1078, 1077, 1053, 1039, 1012,  992,  969,  951,
+	929,  906,  886,  866,  845,  823,  809,  790,
+	772,  758,  741,  726,  711,  701,  688,  675,
+	666,  656,  648,  639,  633,  626,  618,  612,
+	603,  594,  582,  572,  557,  545,  529,  516,
+	504,  491,  480,  467,  459,  447,  438,  429,
+	419,  412,  404,  397,  389,  382,  376,  368,
+	363,  357,  351,  345,  340,  336,  330,  326,
+	321,  318,  312,  308,  304,  300,  297,  294,
+	291,  286,  284,  281,  278,  275,  271,  268,
+	261,  257,  251,  245,  240,  235,  232,  225,
+	223,  218,  213,  209,  206,  204,  199,  197,
+	193,  189,  186,  185,  183,  179,  177,  175,
+	172,  170,  169,  167,  164,  164,  162,  160,
+	158,  157,  156,  154,  154,  152,  151,  150,
+	149,  148,  146,  147,  146,  144,  143,  143,
+	142,  141,  140,  141,  139,  138,  138,  138,
+	137,  136,  136,  135,  134,  134,  134,  133,
+	132,  132,  131,  130,  131,  130,  129,  128,
+	129,  127,  127,  127,  127,  125,  125,  125,
+	123,  123,  122,  120,  118,  115,  114,  111,
+	110,  108,  106,  105,  103,  102,  100,   99,
+	97,   97,   96,   95,   94,   93,   93,   91,
+	91,   91,   90,   90,   89,   89,   88,   88,
+	89,   88,   88,   87,   87,   87,   87,   86,
+	87,   87,   86,   87,   86,   86,   84,   84,
+	82,   80,   78,   76,   74,   72,   70,   68,
+	67,   65,   62,   60,   58,   56,   55,   54,
+	53,   51,   49,   49,   47,   45,   45,   45,
+	41,   40,   39,   39,   34,   33,   34,   32,
+	25,   23,   24,   20,   13,    9,   12,    0,
+	0
+	}
+};
+#if 0
+/*Color enhancement image effect table*/
+static struct ia_css_ctc_table vivid_ctc_table = {
+	.data = {
+	876, 872, 869, 865, 861, 858, 854, 850,
+	847, 843, 839, 835, 832, 828, 824, 821,
+	817, 813, 810, 806, 802, 799, 795, 791,
+	788, 784, 780, 777, 773, 769, 766, 762,
+	758, 754, 751, 747, 743, 740, 736, 732,
+	729, 725, 721, 718, 714, 710, 707, 703,
+	699, 696, 692, 688, 685, 681, 677, 673,
+	670, 666, 662, 659, 655, 651, 648, 644,
+	640, 637, 633, 629, 626, 622, 618, 615,
+	611, 607, 604, 600, 596, 592, 589, 585,
+	581, 578, 574, 570, 567, 563, 559, 556,
+	552, 548, 545, 541, 539, 537, 536, 534,
+	533, 531, 530, 528, 527, 525, 524, 522,
+	521, 519, 518, 516, 515, 514, 512, 511,
+	509, 508, 506, 505, 503, 502, 500, 499,
+	497, 496, 494, 493, 491, 490, 488, 487,
+	485, 484, 482, 481, 479, 478, 476, 475,
+	473, 472, 470, 469, 467, 466, 464, 463,
+	461, 460, 458, 457, 455, 454, 452, 451,
+	449, 448, 446, 445, 443, 442, 440, 439,
+	437, 436, 434, 433, 431, 430, 428, 427,
+	425, 424, 422, 421, 419, 418, 417, 415,
+	414, 412, 411, 409, 408, 406, 405, 403,
+	402, 400, 399, 397, 396, 394, 393, 392,
+	392, 391, 391, 390, 389, 389, 388, 388,
+	387, 387, 386, 385, 385, 384, 384, 383,
+	383, 382, 381, 381, 380, 380, 379, 379,
+	378, 377, 377, 376, 376, 375, 375, 374,
+	374, 373, 372, 372, 371, 371, 370, 370,
+	369, 368, 368, 367, 367, 366, 366, 365,
+	364, 364, 363, 363, 362, 362, 361, 360,
+	360, 359, 359, 358, 358, 357, 356, 356,
+	355, 355, 354, 354, 353, 352, 352, 351,
+	351, 350, 350, 349, 348, 348, 347, 347,
+	346, 346, 345, 344, 344, 343, 343, 342,
+	342, 341, 340, 340, 339, 339, 338, 338,
+	337, 336, 336, 335, 335, 334, 334, 333,
+	333, 332, 331, 331, 330, 330, 329, 329,
+	328, 327, 327, 326, 326, 325, 325, 324,
+	323, 323, 322, 322, 321, 321, 320, 319,
+	319, 318, 318, 317, 317, 316, 315, 315,
+	314, 314, 313, 313, 312, 311, 311, 310,
+	310, 309, 309, 308, 307, 307, 306, 306,
+	305, 305, 304, 303, 303, 302, 302, 301,
+	301, 300, 299, 299, 298, 298, 297, 297,
+	296, 296, 295, 294, 294, 293, 293, 292,
+	292, 291, 290, 290, 289, 289, 288, 288,
+	287, 286, 286, 285, 285, 284, 284, 283,
+	282, 282, 281, 281, 280, 280, 279, 278,
+	278, 277, 277, 276, 276, 275, 274, 274,
+	273, 273, 272, 272, 271, 270, 270, 269,
+	269, 268, 268, 267, 266, 266, 265, 265,
+	264, 264, 263, 262, 262, 261, 261, 260,
+	260, 259, 259, 258, 257, 257, 256, 256,
+	255, 255, 254, 253, 253, 252, 252, 251,
+	251, 250, 249, 249, 248, 248, 247, 247,
+	246, 245, 245, 244, 244, 243, 243, 242,
+	241, 241, 240, 240, 239, 239, 238, 237,
+	237, 236, 236, 235, 235, 234, 233, 233,
+	232, 232, 231, 231, 230, 229, 229, 228,
+	228, 227, 227, 226, 225, 225, 224, 224,
+	223, 223, 222, 221, 221, 220, 220, 219,
+	219, 218, 218, 217, 216, 216, 215, 215,
+	214, 214, 213, 212, 212, 211, 211, 210,
+	210, 209, 208, 208, 207, 207, 206, 206,
+	205, 204, 204, 203, 203, 202, 202, 201,
+	200, 200, 199, 199, 198, 198, 197, 196,
+	196, 195, 195, 194, 194, 193, 192, 192,
+	191, 191, 190, 190, 189, 188, 188, 187,
+	187, 186, 186, 185, 184, 184, 183, 183,
+	182, 182, 181, 181, 180, 179, 179, 178,
+	178, 177, 177, 176, 175, 175, 174, 174,
+	173, 173, 172, 171, 171, 170, 170, 169,
+	169, 168, 167, 167, 166, 166, 165, 165,
+	164, 163, 163, 163, 162, 162, 161, 161,
+	161, 160, 160, 159, 159, 159, 158, 158,
+	158, 157, 157, 156, 156, 156, 155, 155,
+	155, 154, 154, 153, 153, 153, 152, 152,
+	152, 151, 151, 150, 150, 150, 149, 149,
+	149, 148, 148, 147, 147, 147, 146, 146,
+	145, 145, 145, 144, 144, 144, 143, 143,
+	142, 142, 142, 141, 141, 141, 140, 140,
+	139, 139, 139, 138, 138, 138, 137, 137,
+	136, 136, 136, 135, 135, 134, 134, 134,
+	133, 133, 133, 132, 132, 131, 131, 131,
+	130, 130, 130, 129, 129, 128, 128, 128,
+	127, 127, 127, 126, 126, 125, 125, 125,
+	124, 124, 123, 123, 123, 122, 122, 122,
+	121, 121, 120, 120, 120, 119, 119, 119,
+	118, 118, 117, 117, 117, 116, 116, 116,
+	115, 115, 114, 114, 114, 113, 113, 112,
+	112, 112, 111, 111, 111, 110, 110, 109,
+	109, 109, 108, 108, 108, 107, 107, 106,
+	106, 106, 105, 105, 105, 104, 104, 103,
+	103, 103, 102, 102, 101, 101, 101, 100,
+	100, 100, 99, 99, 98, 98, 98, 97,
+	97, 97, 96, 96, 95, 95, 95, 94,
+	94, 94, 93, 93, 92, 92, 92, 91,
+	91, 91, 90, 90, 89, 89, 89, 88,
+	88, 87, 87, 87, 86, 86, 86, 85,
+	85, 84, 84, 84, 83, 83, 83, 82,
+	82, 81, 81, 81, 80, 80, 80, 79,
+	79, 78, 78, 78, 77, 77, 76, 76,
+	76, 75, 75, 75, 74, 74, 73, 73,
+	73, 72, 72, 72, 71, 71, 70, 70,
+	70, 69, 69, 69, 68, 68, 67, 67,
+	67, 66, 66, 65, 65, 65, 64, 64,
+	64, 63, 63, 61, 61, 61, 61, 61,
+	61, 60, 60, 58, 58, 58, 58, 58,
+	58, 57, 57, 56, 56, 56, 55, 55,
+	54, 54, 54, 53, 53, 53, 51, 51,
+	51, 51, 51, 50, 50, 50, 48, 48,
+	48, 48, 48, 47, 47, 47, 45, 45,
+	45, 45, 45, 44, 44, 42, 42, 42,
+	42, 42, 42, 41, 41, 40, 40, 40,
+	39, 39, 39, 38, 38, 37, 37, 37,
+	35, 35, 35, 35, 35, 34, 34, 34,
+	32, 32, 32, 32, 32, 31, 31, 31,
+	29, 29, 29, 29, 29, 28, 28, 28,
+	26, 26, 25, 25, 25, 25, 25, 25,
+	24, 24, 22, 22, 22, 22, 22, 22,
+	21, 21, 19, 19, 19, 19, 19, 18,
+	18, 18, 16, 16, 16, 16, 16, 15,
+	15, 15, 13, 13, 13, 12, 12, 12,
+	12, 12, 10, 10, 10, 9, 9, 9,
+	9, 9, 8, 8, 6, 6, 6, 6,
+	6, 6, 5, 5, 3, 3, 3, 3,
+	3, 3, 2, 2, 0, 0, 0, 0,
+	}
+};
+#endif
+#endif
diff --git a/drivers/media/atomisp2/atomisp_tpg.c b/drivers/media/atomisp2/atomisp_tpg.c
new file mode 100644
index 0000000..8a389f8
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_tpg.c
@@ -0,0 +1,251 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <media/v4l2-event.h>
+#include <media/v4l2-mediabus.h>
+#include "atomisp_internal.h"
+#include "atomisp_tpg.h"
+
+static int tpg_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int tpg_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				enum media_bus_format *code)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_try_mbus_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_framefmt *fmt)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	/*to fake*/
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
+static int tpg_g_chip_ident(struct v4l2_subdev *sd,
+			       struct v4l2_dbg_chip_ident *chip)
+{
+	if (!chip)
+		return -EINVAL;
+	return 0;
+}
+#endif
+
+static int tpg_log_status(struct v4l2_subdev *sd)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	/*to fake*/
+	return -EINVAL;
+}
+
+static int tpg_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	/*to fake*/
+	return -EINVAL;
+}
+
+static int tpg_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_s_power(struct v4l2_subdev *sd, int on)
+{
+	/*
+	int x_delta = -2;
+	int y_delta = 3;
+	unsigned int x_mask  = (1 << 4) - 1;
+	unsigned int y_mask  = (1 << 4) - 1;
+	unsigned int xy_mask = (1 << 8) - 1;
+
+	sh_css_input_set_bayer_order(sh_css_bayer_order_grbg);
+	sh_css_input_set_format(SH_CSS_INPUT_FORMAT_RAW_10);
+	sh_css_input_configure_port(MIPI_PORT0_ID, 2, 0xffff4);
+	sh_css_tpg_configure(x_mask, x_delta, y_mask, y_delta, xy_mask);
+	sh_css_input_set_mode(SH_CSS_INPUT_MODE_TPG);
+	*/
+
+	return 0;
+}
+
+static int tpg_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	/*to fake*/
+	return 0;
+}
+
+static int tpg_enum_frame_ival(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_frame_interval_enum *fie)
+{
+	/*to fake*/
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops tpg_video_ops = {
+	.s_stream = tpg_s_stream,
+	.g_parm = tpg_g_parm,
+	.s_parm = tpg_s_parm,
+	.enum_framesizes = tpg_enum_framesizes,
+	.enum_frameintervals = tpg_enum_frameintervals,
+	.enum_mbus_fmt = tpg_enum_mbus_fmt,
+	.try_mbus_fmt = tpg_try_mbus_fmt,
+	.g_mbus_fmt = tpg_g_mbus_fmt,
+	.s_mbus_fmt = tpg_s_mbus_fmt,
+};
+
+static const struct v4l2_subdev_core_ops tpg_core_ops = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0)
+	.g_chip_ident = tpg_g_chip_ident,
+#endif
+	.log_status = tpg_log_status,
+	.queryctrl = tpg_queryctrl,
+	.g_ctrl = tpg_g_ctrl,
+	.s_ctrl = tpg_s_ctrl,
+	.s_power = tpg_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops tpg_pad_ops = {
+	.enum_mbus_code = tpg_enum_mbus_code,
+	.enum_frame_size = tpg_enum_frame_size,
+	.enum_frame_interval = tpg_enum_frame_ival,
+};
+
+static const struct v4l2_subdev_ops tpg_ops = {
+	.core = &tpg_core_ops,
+	.video = &tpg_video_ops,
+	.pad = &tpg_pad_ops,
+};
+
+void atomisp_tpg_unregister_entities(struct atomisp_tpg_device *tpg)
+{
+	media_entity_cleanup(&tpg->sd.entity);
+	v4l2_device_unregister_subdev(&tpg->sd);
+}
+
+int atomisp_tpg_register_entities(struct atomisp_tpg_device *tpg,
+			struct v4l2_device *vdev)
+{
+	int ret;
+	/* Register the subdev and video nodes. */
+	ret = v4l2_device_register_subdev(vdev, &tpg->sd);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	atomisp_tpg_unregister_entities(tpg);
+	return ret;
+}
+
+void atomisp_tpg_cleanup(struct atomisp_device *isp)
+{
+
+}
+
+int atomisp_tpg_init(struct atomisp_device *isp)
+{
+	struct atomisp_tpg_device *tpg = &isp->tpg;
+	struct v4l2_subdev *sd = &tpg->sd;
+	struct media_pad *pads = tpg->pads;
+	struct media_entity *me = &sd->entity;
+	int ret;
+
+	tpg->isp = isp;
+	v4l2_subdev_init(sd, &tpg_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	strcpy(sd->name, "tpg_subdev");
+	v4l2_set_subdevdata(sd, tpg);
+
+	pads[0].flags = MEDIA_PAD_FL_SINK;
+	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
+
+	ret = media_entity_init(me, 1, pads, 0);
+	if (ret < 0)
+		goto fail;
+	return 0;
+fail:
+	atomisp_tpg_cleanup(isp);
+	return ret;
+}
diff --git a/drivers/media/atomisp2/atomisp_tpg.h b/drivers/media/atomisp2/atomisp_tpg.h
new file mode 100644
index 0000000..64ab60f
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_tpg.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ATOMISP_TPG_H__
+#define __ATOMISP_TPG_H__
+
+#include <media/media-entity.h>
+#include <media/v4l2-subdev.h>
+
+struct atomisp_tpg_device {
+	struct v4l2_subdev sd;
+	struct atomisp_device *isp;
+	struct media_pad pads[1];
+};
+
+void atomisp_tpg_cleanup(struct atomisp_device *isp);
+int atomisp_tpg_init(struct atomisp_device *isp);
+void atomisp_tpg_unregister_entities(struct atomisp_tpg_device *tpg);
+int atomisp_tpg_register_entities(struct atomisp_tpg_device *tpg,
+			struct v4l2_device *vdev);
+
+#endif /* __ATOMISP_TPG_H__ */
diff --git a/drivers/media/atomisp2/atomisp_v4l2.c b/drivers/media/atomisp2/atomisp_v4l2.c
new file mode 100644
index 0000000..0f462b8
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_v4l2.c
@@ -0,0 +1,1313 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/atomisp_platform.h>
+
+#include "atomisp_cmd.h"
+#include "atomisp_common.h"
+#include "atomisp_fops.h"
+#include "atomisp_file.h"
+#include "atomisp_ioctl.h"
+#include "atomisp_acc.h"
+#include "atomisp-regs.h"
+#include "hmm/hmm.h"
+
+#include "device_access.h"
+#include "memory_access.h"
+
+#include "hrt/hive_isp_css_mm_hrt.h"
+
+/*
+ *  *Fastboot flag
+ */
+bool fastboot = 0;
+
+/*
+ *  *Multistreaming - Buffered Sensor Mode flag
+ */
+bool multistream_enabled = 1;
+
+
+/* set reserved memory pool size in page */
+static unsigned int repool_pgnr;
+module_param(repool_pgnr, uint, 0644);
+MODULE_PARM_DESC(repool_pgnr,
+		"Set the reserved memory pool size in page (default:0)");
+
+bool dypool_enable;
+module_param(dypool_enable, bool, 0644);
+MODULE_PARM_DESC(dypool_enable,
+		"dynamic memory pool enable/disable (default:disable)");
+
+/* cross componnet debug message flag */
+int dbg_level = 2;
+module_param(dbg_level, int, 0644);
+MODULE_PARM_DESC(dbg_level, "debug message on/off (default:off)");
+
+int mipicsi_flag;
+module_param(mipicsi_flag, int, 0644);
+MODULE_PARM_DESC(mipicsi_flag, "mipi csi compression predictor algorithm");
+
+/*set to 16x16 since this is the amount of lines and pixels the sensor
+exports extra. If these are kept at the 10x8 that they were on, in yuv
+downscaling modes incorrect resolutions where requested to the sensor
+driver with strange outcomes as a result. The proper way tot do this
+would be to have a list of tables the specify the sensor res, mipi rec,
+output res, and isp output res. however since we do not have this yet,
+the chosen solution is the next best thing. */
+int pad_w = 16;
+module_param(pad_w, int, 0644);
+MODULE_PARM_DESC(pad_w, "extra data for ISP processing");
+
+int pad_h = 16;
+module_param(pad_h, int, 0644);
+MODULE_PARM_DESC(pad_h, "extra data for ISP processing");
+
+struct v4l2_device atomisp_dev = {
+	.name = "atomisp",
+};
+
+void __iomem *atomisp_io_base;
+
+int atomisp_pci_vendor; /* pci vendor id */
+int atomisp_pci_device; /* pci device id */
+
+int atomisp_video_init(struct atomisp_video_pipe *video, const char *name)
+{
+	int ret;
+	const char *direction;
+
+	switch (video->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		direction = "output";
+		video->pad.flags = MEDIA_PAD_FL_SINK;
+		video->vdev.fops = &atomisp_fops;
+		video->vdev.ioctl_ops = &atomisp_ioctl_ops;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		direction = "input";
+		video->pad.flags = MEDIA_PAD_FL_SOURCE;
+		video->vdev.fops = &atomisp_file_fops;
+		video->vdev.ioctl_ops = &atomisp_file_ioctl_ops;
+		video->vdev.vfl_dir = VFL_DIR_TX;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = media_entity_init(&video->vdev.entity, 1, &video->pad, 0);
+	if (ret < 0)
+		return ret;
+
+	/* Initialize the video device. */
+	snprintf(video->vdev.name, sizeof(video->vdev.name),
+		 "ATOMISP ISP %s %s", name, direction);
+	video->vdev.release = video_device_release_empty;
+	video_set_drvdata(&video->vdev, video->isp);
+
+	return 0;
+}
+
+int atomisp_video_register(struct atomisp_video_pipe *video,
+	struct v4l2_device *vdev)
+{
+	int ret;
+
+	video->vdev.v4l2_dev = vdev;
+
+	ret = video_register_device(&video->vdev, VFL_TYPE_GRABBER, -1);
+	if (ret < 0)
+		v4l2_err(&atomisp_dev,
+			"%s: could not register video device (%d)\n",
+			__func__, ret);
+
+	return ret;
+}
+
+void atomisp_video_unregister(struct atomisp_video_pipe *video)
+{
+	if (video_is_registered(&video->vdev)) {
+		media_entity_cleanup(&video->vdev.entity);
+		video_unregister_device(&video->vdev);
+	}
+}
+
+static int atomisp_save_iunit_reg(struct atomisp_device *isp)
+{
+	struct pci_dev *dev = isp->pdev;
+
+	dev_dbg(isp->dev, "%s\n", __func__);
+
+	pci_read_config_word(dev, PCI_COMMAND, &isp->saved_regs.pcicmdsts);
+	/* isp->saved_regs.ispmmadr is set from the atomisp_pci_probe() */
+	pci_read_config_dword(dev, PCI_MSI_CAPID, &isp->saved_regs.msicap);
+	pci_read_config_dword(dev, PCI_MSI_ADDR, &isp->saved_regs.msi_addr);
+	pci_read_config_word(dev, PCI_MSI_DATA,  &isp->saved_regs.msi_data);
+	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &isp->saved_regs.intr);
+	pci_read_config_dword(dev, PCI_INTERRUPT_CTRL,
+			      &isp->saved_regs.interrupt_control);
+
+	if (IS_MRFLD) {
+		pci_read_config_dword(dev, MRFLD_PCI_PMCS,
+				      &isp->saved_regs.pmcs);
+		/* Ensure read/write combining is enabled. */
+		pci_read_config_dword(dev, PCI_I_CONTROL,
+				&isp->saved_regs.i_control);
+		isp->saved_regs.i_control |=
+				MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING |
+				MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_ACCESS_CTRL_VIOL,
+				      &isp->saved_regs.csi_access_viol);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_RCOMP_CONTROL,
+				      &isp->saved_regs.csi_rcomp_config);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
+				      &isp->saved_regs.csi_afe_dly);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_CONTROL,
+				      &isp->saved_regs.csi_control);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_RCOMP_CONTROL,
+				      &isp->saved_regs.csi_afe_rcomp_config);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_HS_CONTROL,
+				      &isp->saved_regs.csi_afe_hs_control);
+		pci_read_config_dword(dev, MRFLD_PCI_CSI_DEADLINE_CONTROL,
+				      &isp->saved_regs.csi_deadline_control);
+	} else {
+		pci_read_config_dword(dev, MFLD_PCI_PMCS,
+				      &isp->saved_regs.pmcs);
+
+		/* Ensure clock gating for ISPCLK, PERF and NOA monitoring. */
+		pci_read_config_dword(dev, MFLD_PCI_CG_DIS,
+				      &isp->saved_regs.cg_dis);
+		isp->saved_regs.cg_dis &= ~(MFLD_PCI_CG_DIS_DISABLED_ISPCLK |
+				MFLD_PCI_CG_DIS_DISABLED_PERF_MON |
+				MFLD_PCI_CG_DIS_DISABLED_NOA_MON);
+
+		/* Ensure read/write combining is enabled. */
+		pci_read_config_dword(dev, PCI_I_CONTROL,
+				&isp->saved_regs.i_control);
+		isp->saved_regs.i_control |=
+				MFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING |
+				MFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;
+
+		isp->saved_regs.csi_rcomp_config = intel_mid_msgbus_read32(
+				MFLD_IUNITPHY_PORT, MFLD_CSI_RCOMP);
+		isp->saved_regs.csi_afe_dly = intel_mid_msgbus_read32(
+				MFLD_IUNITPHY_PORT, MFLD_CSI_AFE);
+
+		/* Ensure mipi1 and mipi4 configurations are enabled */
+		isp->saved_regs.csi_control = intel_mid_msgbus_read32(
+				MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL);
+		isp->saved_regs.csi_control &= ~(MFLD_CSI_CONTROL_DIS_MIPI4_IF |
+				MFLD_CSI_CONTROL_DIS_MIPI1_IF);
+		isp->saved_regs.csi_control |= MFLD_CSI_CONTROL_EN_MIPI4_LANE |
+				MFLD_CSI_CONTROL_EN_MIPI1_LANE;
+	}
+
+	return 0;
+}
+
+extern void atomisp_css2_hw_store_32(hrt_address addr, uint32_t data);
+static int atomisp_restore_iunit_reg(struct atomisp_device *isp)
+{
+	struct pci_dev *dev = isp->pdev;
+
+	dev_dbg(isp->dev, "%s\n", __func__);
+
+	pci_write_config_word(dev, PCI_COMMAND, isp->saved_regs.pcicmdsts);
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0,
+			       isp->saved_regs.ispmmadr);
+	pci_write_config_dword(dev, PCI_MSI_CAPID, isp->saved_regs.msicap);
+	pci_write_config_dword(dev, PCI_MSI_ADDR, isp->saved_regs.msi_addr);
+	pci_write_config_word(dev, PCI_MSI_DATA, isp->saved_regs.msi_data);
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, isp->saved_regs.intr);
+	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL,
+			       isp->saved_regs.interrupt_control);
+	pci_write_config_dword(dev, PCI_I_CONTROL,
+					isp->saved_regs.i_control);
+
+	if (IS_MRFLD) {
+		pci_write_config_dword(dev, MRFLD_PCI_PMCS,
+						isp->saved_regs.pmcs);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_ACCESS_CTRL_VIOL,
+				      isp->saved_regs.csi_access_viol);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_RCOMP_CONTROL,
+				      isp->saved_regs.csi_rcomp_config);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
+				      isp->saved_regs.csi_afe_dly);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_CONTROL,
+				      isp->saved_regs.csi_control);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_RCOMP_CONTROL,
+				      isp->saved_regs.csi_afe_rcomp_config);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_HS_CONTROL,
+				      isp->saved_regs.csi_afe_hs_control);
+		pci_write_config_dword(dev, MRFLD_PCI_CSI_DEADLINE_CONTROL,
+				      isp->saved_regs.csi_deadline_control);
+
+		atomisp_css2_hw_store_32(MRFLD_CSI_RECEIVER_SELECTION_REG, 1);
+
+	} else {
+		pci_write_config_dword(dev, MFLD_PCI_PMCS,
+				       isp->saved_regs.pmcs);
+		pci_write_config_dword(dev, MFLD_PCI_CG_DIS,
+						isp->saved_regs.cg_dis);
+		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_RCOMP,
+				    isp->saved_regs.csi_rcomp_config);
+		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_AFE,
+				    isp->saved_regs.csi_afe_dly);
+		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL,
+				    isp->saved_regs.csi_control);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int atomisp_mrfld_pre_power_down(struct atomisp_device *isp)
+{
+	struct pci_dev *dev = isp->pdev;
+	u32 irq;
+	unsigned long timeout;
+
+	if (isp->sw_contex.power_state == ATOM_ISP_POWER_DOWN)
+		return 0;
+
+	/*
+	 * MRFLD HAS requirement: cannot power off i-unit if
+	 * ISP has IRQ not serviced.
+	 * So, here we need to check if there is any pending
+	 * IRQ, if so, waiting for it to be served
+	 */
+	timeout = jiffies + msecs_to_jiffies(500);
+	while (1) {
+		pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
+		if (!(irq & (1 << INTR_IIR)))
+			break;
+		if (time_after(jiffies, timeout)) {
+			v4l2_err(&atomisp_dev,
+				"%s: IRQ raised!!!\n", __func__);
+			return -EAGAIN;
+		}
+		usleep_range(1000, 1500);
+	};
+
+	/*
+	* MRFLD WORKAROUND:
+	* before powering off IUNIT, clear the pending interrupts
+	* and disable the interrupt. driver should avoid writing 0
+	* to IIR. It could block subsequent interrupt messages.
+	* HW sighting:4568410.
+	*/
+	pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
+	irq = (irq & ~(1 << INTR_IER)) | (1 << INTR_IIR);
+	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, irq);
+	atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW);
+
+	return 0;
+}
+
+/* Workaround for pmu_nc_set_power_state not ready in MRFLD */
+static int atomisp_mrfld_power_down(struct atomisp_device *isp)
+{
+	unsigned long timeout;
+	u32 reg_value;
+
+	/* writing 0x3 to ISPSSPM0 bit[1:0] to power off the IUNIT */
+	reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
+	reg_value &= ~MRFLD_ISPSSPM0_ISPSSC_MASK;
+	reg_value |= MRFLD_ISPSSPM0_IUNIT_POWER_OFF;
+	intel_mid_msgbus_write32(PUNIT_PORT, MRFLD_ISPSSPM0, reg_value);
+
+	/*
+	 * There should be no iunit access while power-down is
+	 * in progress HW sighting: 4567865
+	 * FIXME: msecs_to_jiffies(50)- experienced value
+	 */
+	timeout = jiffies + msecs_to_jiffies(50);
+	while (1) {
+		reg_value = intel_mid_msgbus_read32(PUNIT_PORT,
+							MRFLD_ISPSSPM0);
+		v4l2_dbg(1, dbg_level, &atomisp_dev,
+				"power-off in progress, ISPSSPM0: 0x%x\n",
+				reg_value);
+		/* wait until ISPSSPM0 bit[25:24] shows 0x3 */
+		if ((reg_value >> MRFLD_ISPSSPM0_ISPSSS_OFFSET) ==
+			MRFLD_ISPSSPM0_IUNIT_POWER_OFF)
+			return 0;
+
+		if (time_after(jiffies, timeout)) {
+			v4l2_err(&atomisp_dev,
+				"power-off iunit timeout.\n");
+			return -EBUSY;
+		}
+		/* FIXME: experienced value for delay */
+		usleep_range(100, 150);
+	};
+}
+
+
+/* Workaround for pmu_nc_set_power_state not ready in MRFLD */
+static int atomisp_mrfld_power_up(struct atomisp_device *isp)
+{
+	unsigned long timeout;
+	u32 reg_value;
+
+	/* writing 0x0 to ISPSSPM0 bit[1:0] to power off the IUNIT */
+	reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
+	reg_value &= ~MRFLD_ISPSSPM0_ISPSSC_MASK;
+	intel_mid_msgbus_write32(PUNIT_PORT, MRFLD_ISPSSPM0, reg_value);
+	reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
+
+	/* FIXME: experienced value for delay */
+	timeout = jiffies + msecs_to_jiffies(50);
+	while (1) {
+		reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
+		v4l2_dbg(1, dbg_level, &atomisp_dev,
+				"power-on in progress, ISPSSPM0: 0x%x\n",
+				reg_value);
+		/* wait until ISPSSPM0 bit[25:24] shows 0x0 */
+		if ((reg_value >> MRFLD_ISPSSPM0_ISPSSS_OFFSET) ==
+			MRFLD_ISPSSPM0_IUNIT_POWER_ON)
+			return 0;
+
+		if (time_after(jiffies, timeout)) {
+			v4l2_err(&atomisp_dev,
+				"power-on iunit timeout.\n");
+			return -EBUSY;
+		}
+		/* FIXME: experienced value for delay */
+		usleep_range(100, 150);
+	};
+}
+
+static int atomisp_runtime_suspend(struct device *dev)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)
+		dev_get_drvdata(dev);
+	int ret;
+
+	if (IS_MRFLD) {
+		ret = atomisp_mrfld_pre_power_down(isp);
+		if (ret)
+			return ret;
+	}
+
+	/*Turn off the ISP d-phy*/
+	ret = atomisp_ospm_dphy_down(isp);
+	if (!ret) {
+		pm_qos_update_request(&isp->pm_qos, PM_QOS_DEFAULT_VALUE);
+	if (IS_MRFLD)
+			ret = atomisp_mrfld_power_down(isp);
+	}
+
+	return ret;
+}
+
+static int atomisp_runtime_resume(struct device *dev)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)
+		dev_get_drvdata(dev);
+	int ret;
+
+	if (IS_MRFLD) {
+		ret = atomisp_mrfld_power_up(isp);
+		if (ret)
+			return ret;
+	}
+
+	pm_qos_update_request(&isp->pm_qos, isp->max_isr_latency);
+	if (isp->sw_contex.power_state == ATOM_ISP_POWER_DOWN) {
+		/*Turn on ISP d-phy */
+		ret = atomisp_ospm_dphy_up(isp);
+		if (ret) {
+			v4l2_err(&atomisp_dev,
+				    "Failed to power up ISP!.\n");
+			return -EINVAL;
+		}
+	}
+
+	/*restore register values for iUnit and iUnitPHY registers*/
+	if (isp->saved_regs.pcicmdsts)
+		atomisp_restore_iunit_reg(isp);
+
+	if (IS_MRFLD)
+		atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW);
+
+	return 0;
+}
+
+static int atomisp_suspend(struct device *dev)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)
+		dev_get_drvdata(dev);
+	unsigned long flags;
+	int ret, i;
+
+	/*
+	 * FIXME: Suspend is not supported by sensors. Abort if any video
+	 * node was opened.
+	 */
+	if (atomisp_dev_users(isp))
+		return -EBUSY;
+
+	spin_lock_irqsave(&isp->lock, flags);
+	for(i=0;i<isp->num_of_streams;i++)
+	{
+		if (isp->isp_subdev[i].streaming != ATOMISP_DEVICE_STREAMING_DISABLED) {
+			spin_unlock_irqrestore(&isp->lock, flags);
+			v4l2_err(&atomisp_dev,
+				    "atomisp cannot suspend at this time.\n");
+			return -EINVAL;
+		}
+	}
+	spin_unlock_irqrestore(&isp->lock, flags);
+
+	/* Prepare for MRFLD IUNIT power down */
+	if (IS_MRFLD) {
+		ret = atomisp_mrfld_pre_power_down(isp);
+		if (ret)
+			return ret;
+	}
+
+	/*Turn off the ISP d-phy */
+	ret = atomisp_ospm_dphy_down(isp);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "fail to power off ISP\n");
+	} else {
+		pm_qos_update_request(&isp->pm_qos, PM_QOS_DEFAULT_VALUE);
+	if (IS_MRFLD)
+			ret = atomisp_mrfld_power_down(isp);
+	}
+
+	return ret;
+}
+
+static int atomisp_resume(struct device *dev)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)
+		dev_get_drvdata(dev);
+	int ret;
+
+	if (IS_MRFLD) {
+		ret = atomisp_mrfld_power_up(isp);
+		if (ret)
+			return ret;
+	}
+
+	pm_qos_update_request(&isp->pm_qos, isp->max_isr_latency);
+
+	/*Turn on ISP d-phy */
+	ret = atomisp_ospm_dphy_up(isp);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "Failed to power up ISP!.\n");
+		return -EINVAL;
+	}
+
+	/*restore register values for iUnit and iUnitPHY registers*/
+	if (isp->saved_regs.pcicmdsts)
+		atomisp_restore_iunit_reg(isp);
+
+	if (IS_MRFLD)
+		atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW);
+
+	return 0;
+}
+#endif
+
+static int mrfld_csi_lane_config(struct atomisp_device *isp)
+{
+	static const u8 mipi_lanes[MRFLD_PORT_CONFIG_NUM][MRFLD_PORT_NUM] = {
+		{4, 1, 0},
+		{3, 1, 0},
+		{2, 1, 0},
+		{1, 1, 0},
+		{2, 1, 2},
+		{3, 1, 1},
+		{2, 1, 1},
+		{1, 1, 1}
+	};
+
+	unsigned int i, j;
+	u8 sensor_lanes[MRFLD_PORT_NUM] = {0};
+	u32 data;
+
+	for (i = 0; i < isp->input_cnt; i++) {
+
+		if (isp->inputs[i].type != RAW_CAMERA &&
+			isp->inputs[i].type != SOC_CAMERA)
+			continue;
+
+		switch (isp->inputs[i].port) {
+		case ATOMISP_CAMERA_PORT_PRIMARY:
+			sensor_lanes[0] = isp->inputs[i].num_lanes;
+			v4l2_dbg(4, dbg_level, &atomisp_dev,
+			       "CSI_CONTROL ATOMISP_CAMERA_PORT_PRIMARY port = %d num lanse=%d\n",
+			  isp->inputs[i].port, isp->inputs[i].num_lanes);
+
+			break;
+		case ATOMISP_CAMERA_PORT_SECONDARY:
+			sensor_lanes[1] = isp->inputs[i].num_lanes;
+			v4l2_dbg(4, dbg_level, &atomisp_dev,
+			       "CSI_CONTROL ATOMISP_CAMERA_PORT_SECONDARY port = %d num lanse=%d\n",
+			  isp->inputs[i].port, isp->inputs[i].num_lanes);
+
+			break;
+		case ATOMISP_CAMERA_PORT_THIRD:
+			sensor_lanes[2] = isp->inputs[i].num_lanes;
+			v4l2_dbg(4, dbg_level, &atomisp_dev,
+			       "CSI_CONTROL ATOMISP_CAMERA_PORT_THIRD port = %d num lanse=%d\n",
+			  isp->inputs[i].port, isp->inputs[i].num_lanes);
+
+			break;
+		default:
+			v4l2_err(&atomisp_dev,
+				"%s: invalid port: %d for the %dth sensor\n",
+				__func__, isp->inputs[i].port, i);
+			break;
+		}
+	}
+
+	for (i = 0; i < MRFLD_PORT_CONFIG_NUM; i++) {
+		for (j = 0; j < MRFLD_PORT_NUM; j++)
+			if (sensor_lanes[j]
+				&& sensor_lanes[j] != mipi_lanes[i][j])
+				break;
+
+		if (j == MRFLD_PORT_NUM)
+			break;	/* matched setting is found */
+	}
+
+	if (i == MRFLD_PORT_CONFIG_NUM) {
+		v4l2_err(&atomisp_dev,
+			"%s: could not find the CSI port setting for %d-%d-%d\n",
+			__func__, sensor_lanes[0],
+			sensor_lanes[1], sensor_lanes[2]);
+		return -EINVAL;
+	}
+
+	pci_read_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, &data);
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+				"%s: original CSI_CONTROL is 0x%x\n",
+				__func__, data);
+	data &= ~MRFLD_PORT_CONFIG_MASK;
+	data |= (i << MRFLD_PORT_CONFIGCODE_SHIFT)
+		| (mipi_lanes[i][2] ? 0 : (1 << MRFLD_PORT3_ENABLE_SHIFT))
+		| (((1 << mipi_lanes[i][0]) - 1) << MRFLD_PORT1_LANES_SHIFT)
+		| (((1 << mipi_lanes[i][1]) - 1) << MRFLD_PORT2_LANES_SHIFT)
+		| (((1 << mipi_lanes[i][2]) - 1) << MRFLD_PORT3_LANES_SHIFT);
+
+	pci_write_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, data);
+
+	pci_read_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, &data);
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev,
+		"%s: the portconfig is %d-%d-%d, CSI_CONTROL is 0x%x\n",
+		__func__, mipi_lanes[i][0], mipi_lanes[i][1],
+		mipi_lanes[i][2], data);
+
+	return 0;
+}
+
+static int atomisp_subdev_probe(struct atomisp_device *isp)
+{
+	const struct atomisp_platform_data *pdata;
+	struct intel_v4l2_subdev_table *subdevs;
+	int raw_index = -1;
+
+	pdata = __intel_get_v4l2_subdev_table();
+	if (pdata == NULL) {
+		dev_err(isp->dev, "no platform data available\n");
+		return 0;
+	}
+
+	for (subdevs = pdata->subdevs; subdevs->type; ++subdevs) {
+		struct v4l2_subdev *subdev;
+		struct i2c_board_info *board_info =
+			&subdevs->v4l2_subdev.board_info;
+		struct i2c_adapter *adapter =
+			i2c_get_adapter(subdevs->v4l2_subdev.i2c_adapter_id);
+
+		if (adapter == NULL) {
+			dev_err(isp->dev,
+				"Failed to find i2c adapter for subdev %s\n",
+				board_info->type);
+			break;
+		}
+
+		subdev = v4l2_i2c_new_subdev_board(&isp->v4l2_dev, adapter,
+				board_info, NULL);
+
+		if (subdev == NULL) {
+			dev_warn(isp->dev, "Subdev %s detection fail\n",
+				 board_info->type);
+			continue;
+		}
+
+		dev_info(isp->dev, "Subdev %s successfully register\n",
+			 board_info->type);
+		isp->detected_snr_cnt++;
+
+		switch (subdevs->type) {
+		case RAW_CAMERA:
+			raw_index = isp->input_cnt;
+			dev_dbg(isp->dev, "raw_index: %d\n", raw_index);
+		case SOC_CAMERA:
+			dev_dbg(isp->dev, "SOC_INDEX: %d\n", isp->input_cnt);
+			if (isp->input_cnt >= ATOM_ISP_MAX_INPUTS) {
+				dev_warn(isp->dev,
+					 "too many atomisp inputs, ignored\n");
+				break;
+			}
+
+			isp->inputs[isp->input_cnt].type = subdevs->type;
+			isp->inputs[isp->input_cnt].port = subdevs->port;
+			isp->inputs[isp->input_cnt].num_lanes = subdevs->num_lanes;
+			isp->inputs[isp->input_cnt].camera = subdev;
+			isp->inputs[isp->input_cnt].shading_table = NULL;
+			isp->inputs[isp->input_cnt].morph_table = NULL;
+			/*
+			 * initialize the subdev frame size, then next we can
+			 * judge whether frame_size store effective value via
+			 * pixel_format.
+			 */
+			isp->inputs[isp->input_cnt].frame_size.pixel_format = 0;
+			isp->input_cnt++;
+			break;
+		case CAMERA_MOTOR:
+			isp->motor = subdev;
+			break;
+		case LED_FLASH:
+		case XENON_FLASH:
+			isp->flash = subdev;
+			break;
+		default:
+			dev_dbg(isp->dev, "unknown subdev probed\n");
+			break;
+		}
+
+	}
+
+	/*
+	 * HACK: Currently VCM belongs to primary sensor only, but correct
+	 * approach must be to acquire from platform code which sensor
+	 * owns it.
+	 */
+	if (isp->motor && raw_index >= 0)
+		isp->inputs[raw_index].motor = isp->motor;
+
+	/* Proceed even if no modules detected. For COS mode and no modules. */
+	if (!isp->inputs[0].camera)
+	{
+		//setting detected_snr_cnt to 1 for file injection
+		isp->detected_snr_cnt = 1;
+		dev_warn(isp->dev, "no camera attached or fail to detect\n");
+
+	}
+	if (IS_MRFLD)
+		return mrfld_csi_lane_config(isp);
+
+	return 0;
+}
+
+static void atomisp_unregister_entities(struct atomisp_device *isp)
+{
+	unsigned int i;
+	for(i =0;i< isp->detected_snr_cnt; i++)
+		atomisp_subdev_unregister_entities(&isp->isp_subdev[i]);
+	atomisp_tpg_unregister_entities(&isp->tpg);
+	atomisp_file_input_unregister_entities(&isp->file_dev);
+	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++)
+		atomisp_mipi_csi2_unregister_entities(&isp->csi2_port[i]);
+
+	v4l2_device_unregister(&isp->v4l2_dev);
+	media_device_unregister(&isp->media_dev);
+}
+
+static int atomisp_register_entities(struct atomisp_device *isp)
+{
+	int ret = 0;
+	unsigned int i;
+	struct v4l2_subdev *subdev = NULL;
+	struct media_entity *input = NULL;
+	unsigned int flags;
+	unsigned int pad;
+
+	isp->media_dev.dev = isp->dev;
+
+	strlcpy(isp->media_dev.model, "Intel Atom ISP",
+		sizeof(isp->media_dev.model));
+	if (IS_MRFLD)
+		isp->media_dev.hw_revision = ATOMISP_CSS_VERSION_20;
+	else
+		isp->media_dev.hw_revision = ATOMISP_CSS_VERSION_15;
+
+	ret = media_device_register(&isp->media_dev);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "%s: Media device registration "
+			 "failed (%d)\n", __func__, ret);
+		return ret;
+	}
+
+	isp->v4l2_dev.mdev = &isp->media_dev;
+	ret = v4l2_device_register(isp->dev, &isp->v4l2_dev);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev,
+			"%s: V4L2 device registration failed (%d)\n",
+			__func__, ret);
+		goto v4l2_device_failed;
+	}
+
+	ret = atomisp_subdev_probe(isp);
+	if (ret < 0)
+		goto csi_and_subdev_probe_failed;
+
+	/* Register internal entities */
+	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
+		ret = atomisp_mipi_csi2_register_entities(&isp->csi2_port[i],
+								&isp->v4l2_dev);
+		if (ret == 0)
+			continue;
+
+		/* error case */
+		v4l2_err(&atomisp_dev,
+			"failed to register the CSI port: %d\n", i);
+		/* deregister all registered CSI ports */
+		while (i--)
+			atomisp_mipi_csi2_unregister_entities(
+							&isp->csi2_port[i]);
+
+		goto csi_and_subdev_probe_failed;
+	}
+
+	ret =
+	atomisp_file_input_register_entities(&isp->file_dev, &isp->v4l2_dev);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev,
+			"atomisp_file_input_register_entities failed\n");
+		goto file_input_register_failed;
+	}
+
+	ret = atomisp_tpg_register_entities(&isp->tpg, &isp->v4l2_dev);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "atomisp_tpg_register_entities failed\n");
+		goto tpg_register_failed;
+	}
+
+	for(i=0;i<isp->detected_snr_cnt;i++)
+	{
+		ret =
+		atomisp_subdev_register_entities(&isp->isp_subdev[i], &isp->v4l2_dev);
+		if (ret < 0) {
+			v4l2_err(&atomisp_dev,
+				"atomisp_subdev_register_entities failed\n");
+			goto subdev_register_failed;
+		}
+	}
+
+	for (i = 0; i < isp->num_of_streams; i++) {
+                struct atomisp_sub_device *isp_subdev = &isp->isp_subdev[i];
+
+                init_completion(&isp_subdev->init_done);
+
+                isp_subdev->delayed_init_workq =
+                        alloc_workqueue(isp->v4l2_dev.name, WQ_CPU_INTENSIVE,
+                                        1);
+                if (isp_subdev->delayed_init_workq == NULL) {
+                        dev_err(isp->dev,
+                                        "Failed to initialize delayed init workq\n");
+                        ret = -ENOMEM;
+
+                        for (; i > 0; i--)
+                                destroy_workqueue(isp->isp_subdev[i - 1].
+                                                delayed_init_workq);
+                        goto wq_alloc_failed;
+                }
+                INIT_WORK(&isp_subdev->delayed_init_work, atomisp_delayed_init_work);
+        }
+
+	for (i = 0; i < isp->input_cnt; i++) {
+		if (isp->inputs[i].port >= ATOMISP_CAMERA_NR_PORTS) {
+			v4l2_err(&atomisp_dev,
+					"isp->inputs port %d not supported\n",
+					isp->inputs[i].port);
+			ret = -EINVAL;
+			goto link_failed;
+		}
+
+		subdev = isp->inputs[i].camera;
+		input = &isp->csi2_port[isp->inputs[i].port].subdev.entity;
+		pad = CSI2_PAD_SINK;
+		flags = 0;
+
+		ret = media_entity_create_link(&subdev->entity, 0,
+			input, pad, flags);
+		if (ret < 0) {
+			v4l2_err(&atomisp_dev,
+				"snr to mipi csi link failed\n");
+			goto link_failed;
+		}
+	}
+
+	v4l2_dbg(1, dbg_level, &atomisp_dev,
+		"FILE_INPUT enable, camera_cnt: %d\n", isp->input_cnt);
+	isp->inputs[isp->input_cnt].type = FILE_INPUT;
+	isp->inputs[isp->input_cnt].port = -1;
+	isp->inputs[isp->input_cnt].shading_table = NULL;
+	isp->inputs[isp->input_cnt].morph_table = NULL;
+	isp->inputs[isp->input_cnt++].camera = &isp->file_dev.sd;
+
+	if (isp->input_cnt < ATOM_ISP_MAX_INPUTS) {
+		v4l2_dbg(1, dbg_level, &atomisp_dev,
+			"TPG detected, camera_cnt: %d\n", isp->input_cnt);
+		isp->inputs[isp->input_cnt].type = TEST_PATTERN;
+		isp->inputs[isp->input_cnt].port = -1;
+		isp->inputs[isp->input_cnt].shading_table = NULL;
+		isp->inputs[isp->input_cnt].morph_table = NULL;
+		isp->inputs[isp->input_cnt++].camera = &isp->tpg.sd;
+	} else {
+		v4l2_warn(&atomisp_dev,
+			"too many atomisp inputs, TPG ignored.\n");
+	}
+
+	ret = v4l2_device_register_subdev_nodes(&isp->v4l2_dev);
+	if (ret < 0)
+		goto link_failed;
+
+	return ret;
+
+link_failed:
+	for (i = 0; i < isp->num_of_streams; i++)
+		destroy_workqueue(isp->isp_subdev[i].
+			delayed_init_workq);
+wq_alloc_failed:
+	for(i=0;i<isp->num_of_streams;i++)
+		atomisp_subdev_unregister_entities(&isp->isp_subdev[i]);
+subdev_register_failed:
+	while(i--)
+		atomisp_subdev_unregister_entities(&isp->isp_subdev[i]);
+tpg_register_failed:
+	atomisp_tpg_unregister_entities(&isp->tpg);
+file_input_register_failed:
+	atomisp_file_input_unregister_entities(&isp->file_dev);
+csi_and_subdev_probe_failed:
+	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++)
+		atomisp_mipi_csi2_unregister_entities(&isp->csi2_port[i]);
+v4l2_device_failed:
+	v4l2_device_unregister(&isp->v4l2_dev);
+	media_device_unregister(&isp->media_dev);
+	return ret;
+}
+
+static int atomisp_initialize_modules(struct atomisp_device *isp)
+{
+	int ret;
+	unsigned int i, j;
+
+	ret = atomisp_mipi_csi2_init(isp);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "mipi csi2 initialization failed\n");
+		goto error_mipi_csi2;
+	}
+
+	ret = atomisp_file_input_init(isp);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev,
+			"file input device initialization failed\n");
+		goto error_file_input;
+	}
+
+	ret = atomisp_tpg_init(isp);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "tpg initialization failed\n");
+		goto error_tpg;
+	}
+
+	ret = atomisp_subdev_init(isp);
+	if (ret < 0) {
+		v4l2_err(&atomisp_dev, "ISP subdev initialization failed\n");
+		goto error_isp_subdev;
+	}
+
+	/* connect submoduels */
+	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
+		for(j=0;j<isp->num_of_streams;j++){
+			ret = media_entity_create_link(
+				&isp->csi2_port[i].subdev.entity,
+				CSI2_PAD_SOURCE,
+				&isp->isp_subdev[j].subdev.entity,
+				ATOMISP_SUBDEV_PAD_SINK,
+				0);
+			if (ret < 0)
+				goto error_link;
+		}
+	}
+	return 0;
+
+error_link:
+error_isp_subdev:
+	atomisp_subdev_cleanup(isp->isp_subdev);
+error_tpg:
+	atomisp_tpg_cleanup(isp);
+error_file_input:
+	atomisp_file_input_cleanup(isp);
+error_mipi_csi2:
+	atomisp_mipi_csi2_cleanup(isp);
+	return ret;
+}
+
+int firmware_load_helper(const struct firmware **firmware, struct atomisp_device *isp)
+{
+	struct device *dev = isp->dev;
+	const struct firmware *fw;
+	int rc, retval = 0;
+        char *fw_path = NULL;
+        if (fastboot){
+	        fw_path = isp->firmware? MRFLD_FW_PATH_BIG:  MRFLD_FW_PATH_SMALL;
+        }
+        else{
+                fw_path = MRFLD_FW_PATH;
+        }
+
+        rc = request_firmware(&fw, fw_path, dev);
+        if (rc) {
+                if (rc == -ENOENT)
+                        v4l2_err(&atomisp_dev, "atomisp: Error ISP firmware %s not found.\n",
+                                    fw_path);
+                else
+                        v4l2_err(&atomisp_dev, "atomisp: Error %d while requesting"
+                                    " firmware %s\n", rc, fw_path);
+                *firmware = NULL;
+                retval = -1;
+        } else if (fw == NULL || fw->data == NULL) {
+                v4l2_err(&atomisp_dev, "atomisp: ISP firmware data is NULL.\n");
+                *firmware = NULL;
+        } else {
+                v4l2_dbg(2, dbg_level, &atomisp_dev, "atomisp: ISP firmware %s successfully loaded\n", fw_path);
+                *firmware = fw;
+        }
+
+	return retval;
+}
+
+int load_ISP_firmware(void *void_isp)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)void_isp;
+	int retval = 0;
+        retval = firmware_load_helper(&(isp->firmware), isp);
+        isp->firmware_load_complete = true;
+        if(isp->firmware != NULL)
+        {
+ 	       //Fixing the issue where insmod failed because firmware data is accessed before we even check whether firmware load completed or not
+               isp->css_fw.data = (void *)isp->firmware->data;
+               isp->css_fw.bytes = isp->firmware->size;
+        }
+        wake_up_interruptible(&atomisp_wait_queue);
+	return retval;
+}
+
+#define ATOM_ISP_PCI_BAR	0
+
+static int atomisp_pci_probe(struct pci_dev *dev,
+				       const struct pci_device_id *id)
+{
+	struct atomisp_device *isp;
+	unsigned int start;
+	void __iomem *base;
+	int err, i;
+
+	err = byt_plat_clk_init();
+	if(err)
+	{
+		dev_err(&dev->dev, "atomisp: PMC clock initialization failed\n");
+		return err;
+	}
+
+	for( i = 0; i < MAX_CLK_COUNT; i++)
+	{
+		byt_plat_set_clock_freq(i, CLK_FREQ_TYPE_PLL);
+		byt_plat_configure_clock(i, CLK_CONFG_FORCE_ON);
+	}
+
+	if (!dev) {
+		dev_err(&dev->dev, "atomisp: error device ptr\n");
+		return -EINVAL;
+	}
+
+	atomisp_pci_vendor = id->vendor;
+	atomisp_pci_device = id->device;
+
+	err = pcim_enable_device(dev);
+	if (err) {
+		dev_err(&dev->dev, "Failed to enable CI ISP device (%d)\n",
+			err);
+		return err;
+	}
+
+	start = pci_resource_start(dev, ATOM_ISP_PCI_BAR);
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "start: 0x%x\n", start);
+
+	err = pcim_iomap_regions(dev, 1 << ATOM_ISP_PCI_BAR, pci_name(dev));
+	if (err) {
+		dev_err(&dev->dev, "Failed to I/O memory remapping (%d)\n",
+			err);
+		return err;
+	}
+
+	base = pcim_iomap_table(dev)[ATOM_ISP_PCI_BAR];
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "base: %p\n", base);
+
+	atomisp_io_base = base;
+
+	v4l2_dbg(3, dbg_level, &atomisp_dev, "atomisp_io_base: %p\n",
+			atomisp_io_base);
+
+	isp = devm_kzalloc(&dev->dev, sizeof(struct atomisp_device), GFP_KERNEL);
+	if (!isp) {
+		dev_err(&dev->dev, "Failed to alloc CI ISP structure\n");
+		return -ENOMEM;
+	}
+	isp->pdev = dev;
+	isp->dev = &dev->dev;
+        /*
+         * Set fastboot flag according to command line arguments
+         */
+        if (fastboot) {
+		v4l2_dbg(2, dbg_level, &atomisp_dev, "Fastboot enabled : Explicit ioctl call needed to switch to big firmware for multistreaming\n");
+        }
+        else {
+	        v4l2_dbg(2, dbg_level, &atomisp_dev, "Fastboot disabled : Multistreaming from the beginning. No need to call switch ioctl.\n");
+        }
+        /*
+         *Set input sensor mode whcich is to be used at the beginning.
+         *Will have no effect if fastboot is disabled.
+         */
+        if (multistream_enabled) {
+	        v4l2_dbg(2, dbg_level, &atomisp_dev, "Multistreaming enabled : Buffered sensor mode  set from the beginning\n");
+        }
+        else if (fastboot){
+	        v4l2_dbg(2, dbg_level, &atomisp_dev, "Multistreaming disabled : Multistreaming will be available when switch to big firmware is complete\n");
+                multistream_enabled = 0;
+        }
+        else {
+	        v4l2_dbg(2, dbg_level, &atomisp_dev, "Multistreaming is enabled from the beginning because fastboot is disabled\n");
+        }
+
+        if (fastboot){
+	        isp->firmware_switched = false;
+        }
+
+	isp->sw_contex.power_state = ATOM_ISP_POWER_UP;
+	isp->pci_root = pci_get_bus_and_slot(0, 0);
+	if (!isp->pci_root) {
+		dev_err(&dev->dev, "Unable to find PCI host\n");
+		return -ENODEV;
+	}
+	isp->saved_regs.ispmmadr = start;
+
+	mutex_init(&isp->mutex);
+	mutex_init(&isp->streamoff_mutex);
+	mutex_init(&isp->vb2mutex);
+	spin_lock_init(&isp->lock);
+
+	isp->max_isr_latency = ATOMISP_MAX_ISR_LATENCY;
+
+	/* Load isp firmware from user space */
+	isp->firmware = NULL;
+	isp->firmware_load_complete = false;
+        isp->aux_firmware = NULL;
+        isp->switch_fw_on_streamoff = false;
+
+	kthread_run(&load_ISP_firmware, (void *)isp, "load_isp_firmware");
+	isp->wdt_work_queue = alloc_workqueue(isp->v4l2_dev.name, 0, 1);
+	if (isp->wdt_work_queue == NULL) {
+		dev_err(&dev->dev, "Failed to initialize wdt work queue\n");
+		err = -ENOMEM;
+		goto wdt_work_queue_fail;
+	}
+	INIT_WORK(&isp->wdt_work, atomisp_wdt_work);
+
+	pci_set_master(dev);
+	pci_set_drvdata(dev, isp);
+
+	err = pci_enable_msi(dev);
+	if (err) {
+		dev_err(&dev->dev, "Failed to enable msi (%d)\n", err);
+		goto enable_msi_fail;
+	}
+
+	err = devm_request_threaded_irq(&dev->dev, dev->irq,
+					atomisp_isr, atomisp_isr_thread,
+					IRQF_SHARED, "isp_irq", isp);
+	if (err) {
+		dev_err(&dev->dev, "Failed to request irq (%d)\n", err);
+		goto enable_msi_fail;
+	}
+
+	setup_timer(&isp->wdt, atomisp_wdt, (unsigned long)isp);
+
+	atomisp_msi_irq_init(isp, dev);
+
+	pm_qos_add_request(&isp->pm_qos, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_DEFAULT_VALUE);
+
+	if (IS_MRFLD) {
+		u32 reg32;
+		atomisp_css2_hw_store_32(MRFLD_CSI_RECEIVER_SELECTION_REG, 1);
+		pci_read_config_dword(dev, PCI_I_CONTROL, &reg32);
+		reg32 |= MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING
+			| MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;
+		pci_write_config_dword(dev, PCI_I_CONTROL, reg32);
+	}
+
+	err = atomisp_initialize_modules(isp);
+	if (err < 0) {
+		dev_err(&dev->dev, "atomisp_initialize_modules (%d)\n", err);
+		goto enable_msi_fail;
+	}
+
+	err = atomisp_register_entities(isp);
+	if (err < 0) {
+		dev_err(&dev->dev, "atomisp_register_entities failed (%d)\n",
+			err);
+		goto enable_msi_fail;
+	}
+	atomisp_acc_init(isp);
+
+	/* save the iunit context only once after all the values are init'ed. */
+	atomisp_save_iunit_reg(isp);
+
+	/* init the msgbus */
+	intel_mid_msgbus_init();
+
+	err = hmm_pool_register(repool_pgnr, HMM_POOL_TYPE_RESERVED);
+	if (err)
+		v4l2_dbg(3, dbg_level, &atomisp_dev,"Failed to register reserved memory pool.\n");
+
+	pm_runtime_put_noidle(&dev->dev);
+	pm_runtime_allow(&dev->dev);
+	return 0;
+
+enable_msi_fail:
+	destroy_workqueue(isp->wdt_work_queue);
+wdt_work_queue_fail:
+	release_firmware(isp->firmware);
+	pci_dev_put(isp->pci_root);
+	return err;
+}
+
+static void __exit atomisp_pci_remove(struct pci_dev *dev)
+{
+	struct atomisp_device *isp = (struct atomisp_device *)
+		pci_get_drvdata(dev);
+
+	atomisp_acc_cleanup(isp);
+	ia_css_unload_firmware(true);
+	hrt_isp_css_mm_clear();
+
+	pm_runtime_forbid(&dev->dev);
+	pm_runtime_get_noresume(&dev->dev);
+	pm_qos_remove_request(&isp->pm_qos);
+
+	atomisp_msi_irq_uninit(isp, dev);
+	pci_dev_put(isp->pci_root);
+
+	atomisp_unregister_entities(isp);
+
+	destroy_workqueue(isp->wdt_work_queue);
+	atomisp_file_input_cleanup(isp);
+
+	release_firmware(isp->firmware);
+	hmm_pool_unregister(HMM_POOL_TYPE_RESERVED);
+}
+
+static DEFINE_PCI_DEVICE_TABLE(atomisp_pci_tbl) = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0148)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0149)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014A)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014B)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014C)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014D)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014E)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014F)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08D0)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1178)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0F38)},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, atomisp_pci_tbl);
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops atomisp_pm_ops = {
+	.runtime_suspend = atomisp_runtime_suspend,
+	.runtime_resume = atomisp_runtime_resume,
+	.suspend = atomisp_suspend,
+	.resume = atomisp_resume,
+};
+
+#define DEV_PM_OPS (&atomisp_pm_ops)
+#else
+#define DEV_PM_OPS NULL
+#endif
+
+static struct pci_driver atomisp_pci_driver = {
+	.driver = {
+		.pm = DEV_PM_OPS,
+	},
+	.name = "atomisp",
+	.id_table = atomisp_pci_tbl,
+	.probe = atomisp_pci_probe,
+	.remove = atomisp_pci_remove,
+};
+
+static int __init atomisp_init(void)
+{
+	return pci_register_driver(&atomisp_pci_driver);
+}
+
+static void __exit atomisp_exit(void)
+{
+	pci_unregister_driver(&atomisp_pci_driver);
+}
+
+module_init(atomisp_init);
+module_exit(atomisp_exit);
+
+module_param(fastboot, bool , S_IRUSR | S_IRGRP | S_IROTH);
+MODULE_PARM_DESC(fastboot, "Fasboot enable/disable flag");
+
+module_param(multistream_enabled, bool , S_IRUSR | S_IRGRP | S_IROTH);
+MODULE_PARM_DESC(multistream_enabled , "Buffered Sensor Mode enable/disable flag");
+
+
+MODULE_AUTHOR("John Wu <john.wu@intel.com>");
+MODULE_AUTHOR("Sarat Chandra Poluri <sarat.chandra.poluri@intel.com>");
+MODULE_AUTHOR("Kushal Bandi <kushal.bandi@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel ATOM Platform ISP Driver");
diff --git a/drivers/media/atomisp2/atomisp_v4l2.h b/drivers/media/atomisp2/atomisp_v4l2.h
new file mode 100644
index 0000000..d9f126a
--- /dev/null
+++ b/drivers/media/atomisp2/atomisp_v4l2.h
@@ -0,0 +1,43 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ATOMISP_V4L2_H__
+#define __ATOMISP_V4L2_H__
+
+#include "atomisp_internal.h"
+
+struct atomisp_video_pipe;
+struct v4l2_device;
+
+extern void __iomem *atomisp_io_base;
+
+int firmware_load_helper(const struct firmware **firmware, struct atomisp_device *isp);
+int load_ISP_firmware(void *void_isp);
+
+
+int atomisp_video_init(struct atomisp_video_pipe *video, const char *name);
+void atomisp_video_unregister(struct atomisp_video_pipe *video);
+int atomisp_video_register(struct atomisp_video_pipe *video,
+	struct v4l2_device *vdev);
+
+#endif /* __ATOMISP_V4L2_H__ */
diff --git a/drivers/media/atomisp2/css2400/base/circbuf/interface/ia_css_circbuf.h b/drivers/media/atomisp2/css2400/base/circbuf/interface/ia_css_circbuf.h
new file mode 100644
index 0000000..57a1a32
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/base/circbuf/interface/ia_css_circbuf.h
@@ -0,0 +1,354 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_CIRCBUF_H
+#define _IA_CSS_CIRCBUF_H
+
+#include <assert_support.h>
+#include <type_support.h>
+#include <math_support.h>
+#include <storage_class.h>
+#include <platform_support.h>
+#include <sp.h>
+#include "ia_css_circbuf_comm.h"
+#include "ia_css_circbuf_desc.h"
+
+/****************************************************************
+ *
+ * Data structures.
+ *
+ ****************************************************************/
+/**
+ * @brief Data structure for the circular buffer.
+ */
+typedef struct ia_css_circbuf_s ia_css_circbuf_t;
+struct ia_css_circbuf_s {
+	ia_css_circbuf_desc_t *desc;    /* Pointer to the descriptor of the circbuf */
+	ia_css_circbuf_elem_t *elems;	/* an array of elements    */
+};
+
+/**
+ * @brief Create the circular buffer.
+ *
+ * @param cb	The pointer to the circular buffer.
+ * @param elems	An array of elements.
+ * @param desc	The descriptor set to the size using ia_css_circbuf_desc_init().
+ */
+STORAGE_CLASS_EXTERN void ia_css_circbuf_create(
+	ia_css_circbuf_t *cb,
+	ia_css_circbuf_elem_t *elems,
+	ia_css_circbuf_desc_t *desc);
+
+/**
+ * @brief Destroy the circular buffer.
+ *
+ * @param cb The pointer to the circular buffer.
+ */
+STORAGE_CLASS_EXTERN void ia_css_circbuf_destroy(
+		ia_css_circbuf_t *cb);
+
+/**
+ * @brief Pop a value out of the circular buffer.
+ * Get a value at the head of the circular buffer.
+ * The user should call "ia_css_circbuf_is_empty()"
+ * to avoid accessing to an empty buffer.
+ *
+ * @param cb	The pointer to the circular buffer.
+ *
+ * @return the pop-out value.
+ */
+STORAGE_CLASS_EXTERN uint32_t ia_css_circbuf_pop(
+		ia_css_circbuf_t *cb);
+
+/**
+ * @brief Extract a value out of the circular buffer.
+ * Get a value at an arbitrary poistion in the circular
+ * buffer. The user should call "ia_css_circbuf_is_empty()"
+ * to avoid accessing to an empty buffer.
+ *
+ * @param cb	 The pointer to the circular buffer.
+ * @param offset The offset from "start" to the target position.
+ *
+ * @return the extracted value.
+ */
+STORAGE_CLASS_EXTERN uint32_t ia_css_circbuf_extract(
+	ia_css_circbuf_t *cb,
+	int offset);
+
+/****************************************************************
+ *
+ * Inline functions.
+ *
+ ****************************************************************/
+/**
+ * @brief Set the "val" field in the element.
+ *
+ * @param elem The pointer to the element.
+ * @param val  The value to be set.
+ */
+STORAGE_CLASS_INLINE void ia_css_circbuf_elem_set_val(
+	ia_css_circbuf_elem_t *elem,
+	uint32_t val)
+{
+	OP___assert(elem != NULL);
+
+	elem->val = val;
+}
+
+/**
+ * @brief Initialize the element.
+ *
+ * @param elem The pointer to the element.
+ */
+STORAGE_CLASS_INLINE void ia_css_circbuf_elem_init(
+		ia_css_circbuf_elem_t *elem)
+{
+	OP___assert(elem != NULL);
+	ia_css_circbuf_elem_set_val(elem, 0);
+}
+
+/**
+ * @brief Copy an element.
+ *
+ * @param src  The element as the copy source.
+ * @param dest The element as the copy destination.
+ */
+STORAGE_CLASS_INLINE void ia_css_circbuf_elem_cpy(
+	ia_css_circbuf_elem_t *src,
+	ia_css_circbuf_elem_t *dest)
+{
+	OP___assert(src != NULL);
+	OP___assert(dest != NULL);
+
+	ia_css_circbuf_elem_set_val(dest, src->val);
+}
+
+/**
+ * @brief Get position in the circular buffer.
+ *
+ * @param cb		The pointer to the circular buffer.
+ * @param base		The base position.
+ * @param offset	The offset.
+ *
+ * @return the position at offset.
+ */
+STORAGE_CLASS_INLINE uint8_t ia_css_circbuf_get_pos_at_offset(
+	ia_css_circbuf_t *cb,
+	uint32_t base,
+	int offset)
+{
+	uint8_t dest;
+
+	OP___assert(cb != NULL);
+	OP___assert(cb->desc != NULL);
+	OP___assert(cb->desc->size > 0);
+
+	/* step 1: adjudst the offset  */
+	while (offset < 0) {
+		offset += cb->desc->size;
+	}
+
+	/* step 2: shift and round by the upper limit */
+	dest = OP_std_modadd(base, offset, cb->desc->size);
+
+	return dest;
+}
+
+/**
+ * @brief Get the offset between two positions in the circular buffer.
+ * Get the offset from the source position to the terminal position,
+ * along the direction in which the new elements come in.
+ *
+ * @param cb		The pointer to the circular buffer.
+ * @param src_pos	The source position.
+ * @param dest_pos	The terminal position.
+ *
+ * @return the offset.
+ */
+STORAGE_CLASS_INLINE int ia_css_circbuf_get_offset(
+	ia_css_circbuf_t *cb,
+	uint32_t src_pos,
+	uint32_t dest_pos)
+{
+	int offset;
+
+	OP___assert(cb != NULL);
+	OP___assert(cb->desc != NULL);
+
+	offset = (int)(dest_pos - src_pos);
+	offset += (offset < 0) ? cb->desc->size : 0;
+
+	return offset;
+}
+
+/**
+ * @brief Get the maximum number of elements.
+ *
+ * @param cb The pointer to the circular buffer.
+ *
+ * @return the maximum number of elements.
+ *
+ * TODO: Test this API.
+ */
+STORAGE_CLASS_INLINE uint32_t ia_css_circbuf_get_size(
+		ia_css_circbuf_t *cb)
+{
+	OP___assert(cb != NULL);
+	OP___assert(cb->desc != NULL);
+
+	return cb->desc->size;
+}
+
+/**
+ * @brief Get the number of available elements.
+ *
+ * @param cb The pointer to the circular buffer.
+ *
+ * @return the number of available elements.
+ */
+STORAGE_CLASS_INLINE uint32_t ia_css_circbuf_get_num_elems(
+		ia_css_circbuf_t *cb)
+{
+	int num;
+
+	OP___assert(cb != NULL);
+	OP___assert(cb->desc != NULL);
+
+	num = ia_css_circbuf_get_offset(cb, cb->desc->start, cb->desc->end);
+
+	return (uint32_t)num;
+}
+
+/**
+ * @brief Test if the circular buffer is empty.
+ *
+ * @param cb	The pointer to the circular buffer.
+ *
+ * @return
+ *	- true when it is empty.
+ *	- false when it is not empty.
+ */
+STORAGE_CLASS_INLINE bool ia_css_circbuf_is_empty(
+		ia_css_circbuf_t *cb)
+{
+	OP___assert(cb != NULL);
+	OP___assert(cb->desc != NULL);
+
+	return ia_css_circbuf_desc_is_empty(cb->desc);
+}
+
+/**
+ * @brief Test if the circular buffer is full.
+ *
+ * @param cb	The pointer to the circular buffer.
+ *
+ * @return
+ *	- true when it is full.
+ *	- false when it is not full.
+ */
+STORAGE_CLASS_INLINE bool ia_css_circbuf_is_full(ia_css_circbuf_t *cb)
+{
+	OP___assert(cb != NULL);
+	OP___assert(cb->desc != NULL);
+
+	return ia_css_circbuf_desc_is_full(cb->desc);
+}
+
+/**
+ * @brief Write a new element into the circular buffer.
+ * Write a new element WITHOUT checking whether the
+ * circular buffer is full or not. So it also overwrites
+ * the oldest element when the buffer is full.
+ *
+ * @param cb	The pointer to the circular buffer.
+ * @param elem	The new element.
+ */
+STORAGE_CLASS_INLINE void ia_css_circbuf_write(
+	ia_css_circbuf_t *cb,
+	ia_css_circbuf_elem_t elem)
+{
+	OP___assert(cb != NULL);
+	OP___assert(cb->desc != NULL);
+
+	if (ia_css_circbuf_is_full(cb)) {
+		/* Cannot continue as the queue is full*/
+		OP_std_break();
+	}
+
+	ia_css_circbuf_elem_cpy(&elem, &cb->elems[cb->desc->end]);
+
+	cb->desc->end = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->end, 1);
+}
+
+/**
+ * @brief Push a value in the circular buffer.
+ * Put a new value at the tail of the circular buffer.
+ * The user should call "ia_css_circbuf_is_full()"
+ * to avoid accessing to a full buffer.
+ *
+ * @param cb	The pointer to the circular buffer.
+ * @param val	The value to be pushed in.
+ */
+STORAGE_CLASS_INLINE void ia_css_circbuf_push(
+	ia_css_circbuf_t *cb,
+	uint32_t val)
+{
+	ia_css_circbuf_elem_t elem;
+
+	OP___assert(cb != NULL);
+
+	/* set up an element */
+	ia_css_circbuf_elem_init(&elem);
+	ia_css_circbuf_elem_set_val(&elem, val);
+
+	/* write the element into the buffer */
+	ia_css_circbuf_write(cb, elem);
+}
+
+/**
+ * @brief Get the number of free elements.
+ *
+ * @param cb The pointer to the circular buffer.
+ *
+ * @return: The number of free elements.
+ */
+STORAGE_CLASS_INLINE uint32_t ia_css_circbuf_get_free_elems(
+		ia_css_circbuf_t *cb)
+{
+	OP___assert(cb != NULL);
+	OP___assert(cb->desc != NULL);
+
+	return ia_css_circbuf_desc_get_free_elems(cb->desc);
+}
+
+/**
+ * @brief Peek an element in Circular Buffer.
+ *
+ * @param cb	 The pointer to the circular buffer.
+ * @param offset Offset to the element.
+ *
+ * @return the elements value.
+ */
+STORAGE_CLASS_EXTERN uint32_t ia_css_circbuf_peek(
+	ia_css_circbuf_t *cb,
+	int offset);
+
+#endif /*_IA_CSS_CIRCBUF_H */
diff --git a/drivers/media/atomisp2/css2400/base/circbuf/interface/ia_css_circbuf_comm.h b/drivers/media/atomisp2/css2400/base/circbuf/interface/ia_css_circbuf_comm.h
new file mode 100644
index 0000000..aa75b0f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/base/circbuf/interface/ia_css_circbuf_comm.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_CIRCBUF_COMM_H
+#define _IA_CSS_CIRCBUF_COMM_H
+
+#include <type_support.h>  /* uint8_t, uint32_t */
+
+/****************************************************************
+ *
+ * Portable Data structures
+ *
+ ****************************************************************/
+/**
+ * @brief Data structure for the circular descriptor.
+ */
+typedef struct ia_css_circbuf_desc_s ia_css_circbuf_desc_t;
+struct ia_css_circbuf_desc_s {
+	uint8_t size;	/* the maximum number of elements*/
+	uint8_t step;   /* number of bytes per element */
+	uint8_t start;	/* index of the oldest element */
+	uint8_t end;	/* index at which to write the new element */
+};
+#define SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT				\
+	(4 * sizeof(uint8_t))
+
+/**
+ * @brief Data structure for the circular buffer element.
+ */
+typedef struct ia_css_circbuf_elem_s ia_css_circbuf_elem_t;
+struct ia_css_circbuf_elem_s {
+	uint32_t val;	/* the value stored in the element */
+};
+#define SIZE_OF_IA_CSS_CIRCBUF_ELEM_S_STRUCT				\
+	(sizeof(uint32_t))
+
+#endif /*_IA_CSS_CIRCBUF_COMM_H*/
diff --git a/drivers/media/atomisp2/css2400/base/circbuf/interface/ia_css_circbuf_desc.h b/drivers/media/atomisp2/css2400/base/circbuf/interface/ia_css_circbuf_desc.h
new file mode 100644
index 0000000..d29526f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/base/circbuf/interface/ia_css_circbuf_desc.h
@@ -0,0 +1,177 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_CIRCBUF_DESC_H_
+#define _IA_CSS_CIRCBUF_DESC_H_
+
+#include <type_support.h>
+#include <math_support.h>
+#include <storage_class.h>
+#include <platform_support.h>
+#include <sp.h>
+#include "ia_css_circbuf_comm.h"
+/****************************************************************
+ *
+ * Inline functions.
+ *
+ ****************************************************************/
+/**
+ * @brief Test if the circular buffer is empty.
+ *
+ * @param cb_desc The pointer to the circular buffer descriptor.
+ *
+ * @return
+ *	- true when it is empty.
+ *	- false when it is not empty.
+ */
+STORAGE_CLASS_INLINE bool ia_css_circbuf_desc_is_empty(
+		ia_css_circbuf_desc_t *cb_desc)
+{
+	OP___assert(cb_desc != NULL);
+	return (cb_desc->end == cb_desc->start);
+}
+
+/**
+ * @brief Test if the circular buffer descriptor is full.
+ *
+ * @param cb_desc	The pointer to the circular buffer
+ *			descriptor.
+ *
+ * @return
+ *	- true when it is full.
+ *	- false when it is not full.
+ */
+STORAGE_CLASS_INLINE bool ia_css_circbuf_desc_is_full(
+		ia_css_circbuf_desc_t *cb_desc)
+{
+	OP___assert(cb_desc != NULL);
+	return (OP_std_modadd(cb_desc->end, 1, cb_desc->size) == cb_desc->start);
+}
+
+/**
+ * @brief Initialize the circular buffer descriptor
+ *
+ * @param cb_desc	The pointer circular buffer descriptor
+ * @param size 		The size of the circular buffer
+ */
+STORAGE_CLASS_INLINE void ia_css_circbuf_desc_init(
+	ia_css_circbuf_desc_t *cb_desc,
+	int8_t size)
+{
+	OP___assert(cb_desc != NULL);
+	cb_desc->size = size;
+}
+
+/**
+ * @brief Get a position in the circular buffer descriptor.
+ *
+ * @param cb     The pointer to the circular buffer descriptor.
+ * @param base   The base position.
+ * @param offset The offset.
+ *
+ * @return the position in the circular buffer descriptor.
+ */
+STORAGE_CLASS_INLINE uint8_t ia_css_circbuf_desc_get_pos_at_offset(
+	ia_css_circbuf_desc_t *cb_desc,
+	uint32_t base,
+	int offset)
+{
+	uint8_t dest;
+	OP___assert(cb_desc != NULL);
+	OP___assert(cb_desc->size > 0);
+
+	/* step 1: adjust the offset  */
+	while (offset < 0) {
+		offset += cb_desc->size;
+	}
+
+	/* step 2: shift and round by the upper limit */
+	dest = OP_std_modadd(base, offset, cb_desc->size);
+
+	return dest;
+}
+
+/**
+ * @brief Get the offset between two positions in the circular buffer
+ * descriptor.
+ * Get the offset from the source position to the terminal position,
+ * along the direction in which the new elements come in.
+ *
+ * @param cb_desc	The pointer to the circular buffer descriptor.
+ * @param src_pos	The source position.
+ * @param dest_pos	The terminal position.
+ *
+ * @return the offset.
+ */
+STORAGE_CLASS_INLINE int ia_css_circbuf_desc_get_offset(
+	ia_css_circbuf_desc_t *cb_desc,
+	uint32_t src_pos,
+	uint32_t dest_pos)
+{
+	int offset;
+	OP___assert(cb_desc != NULL);
+
+	offset = (int)(dest_pos - src_pos);
+	offset += (offset < 0) ? cb_desc->size : 0;
+
+	return offset;
+}
+
+/**
+ * @brief Get the number of available elements.
+ *
+ * @param cb_desc The pointer to the circular buffer.
+ *
+ * @return The number of available elements.
+ */
+STORAGE_CLASS_INLINE uint32_t ia_css_circbuf_desc_get_num_elems(
+		ia_css_circbuf_desc_t *cb_desc)
+{
+	int num;
+	OP___assert(cb_desc != NULL);
+
+	num = ia_css_circbuf_desc_get_offset(cb_desc,
+				cb_desc->start,
+				cb_desc->end);
+
+	return (uint32_t)num;
+}
+
+/**
+ * @brief Get the number of free elements.
+ *
+ * @param cb_desc The pointer to the circular buffer descriptor.
+ *
+ * @return: The number of free elements.
+ */
+STORAGE_CLASS_INLINE uint32_t ia_css_circbuf_desc_get_free_elems(
+		ia_css_circbuf_desc_t *cb_desc)
+{
+	uint32_t num;
+	OP___assert(cb_desc != NULL);
+
+	num = ia_css_circbuf_desc_get_offset(cb_desc,
+				cb_desc->start,
+				cb_desc->end);
+
+	return (cb_desc->size - num);
+}
+#endif /*_IA_CSS_CIRCBUF_DESC_H_ */
diff --git a/drivers/media/atomisp2/css2400/base/circbuf/src/circbuf.c b/drivers/media/atomisp2/css2400/base/circbuf/src/circbuf.c
new file mode 100644
index 0000000..29ea657
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/base/circbuf/src/circbuf.c
@@ -0,0 +1,267 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_circbuf.h"
+
+#include <assert_support.h>
+
+#ifdef __SP
+#include <hive_isp_css_sp_api_modified.h>
+#endif
+
+/**********************************************************************
+ *
+ * Forward declarations.
+ *
+ **********************************************************************/
+/**
+ * @brief Read the oldest element from the circular buffer.
+ * Read the oldest element WITHOUT checking whehter the
+ * circular buffer is empty or not. The oldest element is
+ * also removed out from the circular buffer.
+ *
+ * @param cb The pointer to the circular buffer.
+ *
+ * @return the oldest element.
+ */
+static inline ia_css_circbuf_elem_t
+ia_css_circbuf_read(ia_css_circbuf_t *cb);
+
+/**
+ * @brief Shift a chunk of elements in the circular buffer.
+ * A chunk of elements (i.e. the ones from the "start" position
+ * to the "chunk_src" position) are shifted in the circular buffer,
+ * along the direction of new elements coming.
+ *
+ * @param cb	     The pointer to the circular buffer.
+ * @param chunk_src  The position at which the first element in the chunk is.
+ * @param chunk_dest The position to which the first element in the chunk would be shift.
+ */
+static inline void ia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,
+						   uint32_t chunk_src,
+						   uint32_t chunk_dest);
+
+/**
+ * @brief Get the "val" field in the element.
+ *
+ * @param elem The pointer to the element.
+ *
+ * @return the "val" field.
+ */
+static inline uint32_t
+ia_css_circbuf_elem_get_val(ia_css_circbuf_elem_t *elem);
+
+/**********************************************************************
+ *
+ * Non-inline functions.
+ *
+ **********************************************************************/
+/**
+ * @brief Create the circular buffer.
+ * Refer to "ia_css_circbuf.h" for details.
+ */
+void
+ia_css_circbuf_create(ia_css_circbuf_t *cb,
+			   ia_css_circbuf_elem_t *elems,
+			   ia_css_circbuf_desc_t *desc)
+{
+	uint32_t i;
+
+	OP___assert(desc);
+
+	cb->desc = desc;
+	/* Initialize to defaults */
+	cb->desc->start = 0;
+	cb->desc->end = 0;
+	cb->desc->step = 0;
+
+	for (i = 0; i < cb->desc->size; i++)
+		ia_css_circbuf_elem_init(&elems[i]);
+
+	cb->elems = elems;
+}
+
+/**
+ * @brief Destroy the circular buffer.
+ * Refer to "ia_css_circbuf.h" for details.
+ */
+void ia_css_circbuf_destroy(ia_css_circbuf_t *cb)
+{
+	cb->desc = NULL;
+
+	cb->elems = NULL;
+}
+
+/**
+ * @brief Pop a value out of the circular buffer.
+ * Refer to "ia_css_circbuf.h" for details.
+ */
+uint32_t ia_css_circbuf_pop(ia_css_circbuf_t *cb)
+{
+	uint32_t ret;
+	ia_css_circbuf_elem_t elem;
+
+	if (ia_css_circbuf_is_empty(cb))
+#ifdef __SP
+		OP_std_break();
+#else
+		assert(0);
+#endif
+	/* read an element from the buffer */
+	elem = ia_css_circbuf_read(cb);
+	ret = ia_css_circbuf_elem_get_val(&elem);
+	return ret;
+}
+
+/**
+ * @brief Extract a value out of the circular buffer.
+ * Refer to "ia_css_circbuf.h" for details.
+ */
+uint32_t ia_css_circbuf_extract(ia_css_circbuf_t *cb, int offset)
+{
+	int max_offset;
+	uint32_t val;
+	uint32_t pos;
+	uint32_t src_pos;
+	uint32_t dest_pos;
+
+	/* get the maximum offest */
+	max_offset = ia_css_circbuf_get_offset(cb, cb->desc->start, cb->desc->end);
+	max_offset--;
+
+	/*
+	 * Step 1: When the target element is at the "start" position.
+	 */
+	if (offset == 0) {
+		val = ia_css_circbuf_pop(cb);
+		return val;
+	}
+
+	/*
+	 * Step 2: When the target element is out of the range.
+	 */
+	if (offset > max_offset) {
+		val = 0;
+		return val;
+	}
+
+	/*
+	 * Step 3: When the target element is between the "start" and
+	 * "end" position.
+	 */
+	/* get the position of the target element */
+	pos = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->start, offset);
+
+	/* get the value from the target element */
+	val = ia_css_circbuf_elem_get_val(&cb->elems[pos]);
+
+	/* shift the elements */
+	src_pos = ia_css_circbuf_get_pos_at_offset(cb, pos, -1);
+	dest_pos = pos;
+	ia_css_circbuf_shift_chunk(cb, src_pos, dest_pos);
+
+	return val;
+}
+
+/**
+ * @brief Peek an element from the circular buffer.
+ * Refer to "ia_css_circbuf.h" for details.
+ */
+uint32_t ia_css_circbuf_peek(ia_css_circbuf_t *cb, int offset)
+{
+	int pos;
+
+	pos = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->end, offset);
+
+	/* get the value at the position */
+	return cb->elems[pos].val;
+}
+
+
+/****************************************************************
+ *
+ * Inline functions.
+ *
+ ****************************************************************/
+/**
+ * @brief Get the "val" field in the element.
+ * Refer to "Forward declarations" for details.
+ */
+static inline uint32_t
+ia_css_circbuf_elem_get_val(ia_css_circbuf_elem_t *elem)
+{
+	return elem->val;
+}
+
+/**
+ * @brief Read the oldest element from the circular buffer.
+ * Refer to "Forward declarations" for details.
+ */
+static inline ia_css_circbuf_elem_t
+ia_css_circbuf_read(ia_css_circbuf_t *cb)
+{
+	ia_css_circbuf_elem_t elem;
+
+	/* get the element from the target position */
+	elem = cb->elems[cb->desc->start];
+
+	/* clear the target position */
+	ia_css_circbuf_elem_init(&cb->elems[cb->desc->start]);
+
+	/* adjust the "start" position */
+	cb->desc->start = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->start, 1);
+	return elem;
+}
+
+/**
+ * @brief Shift a chunk of elements in the circular buffer.
+ * Refer to "Forward declarations" for details.
+ */
+static inline void
+ia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,
+				uint32_t chunk_src, uint32_t chunk_dest)
+{
+	int chunk_offset;
+	int chunk_sz;
+	int i;
+
+	/* get the chunk offset and size */
+	chunk_offset = ia_css_circbuf_get_offset(cb,
+						      chunk_src, chunk_dest);
+	chunk_sz = ia_css_circbuf_get_offset(cb, cb->desc->start, chunk_src) + 1;
+
+	/* shift each element to its terminal position */
+	for (i = 0; i < chunk_sz; i++) {
+
+		/* copy the element from the source to the destination */
+		ia_css_circbuf_elem_cpy(&cb->elems[chunk_src],
+					     &cb->elems[chunk_dest]);
+
+		/* adjust the source/terminal positions */
+		chunk_src = ia_css_circbuf_get_pos_at_offset(cb, chunk_src, -1);
+		chunk_dest = ia_css_circbuf_get_pos_at_offset(cb, chunk_dest, -1);
+
+	}
+
+	/* adjust the index "start" */
+	cb->desc->start = ia_css_circbuf_get_pos_at_offset(cb, cb->desc->start, chunk_offset);
+}
+
diff --git a/drivers/media/atomisp2/css2400/base/refcount/interface/ia_css_refcount.h b/drivers/media/atomisp2/css2400/base/refcount/interface/ia_css_refcount.h
new file mode 100644
index 0000000..4790446
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/base/refcount/interface/ia_css_refcount.h
@@ -0,0 +1,81 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_REFCOUNT_H_
+#define _IA_CSS_REFCOUNT_H_
+
+#include <type_support.h>
+#include <system_types.h>
+#include <ia_css_err.h>
+
+typedef void (*clear_func)(hrt_vaddress ptr);
+
+/*! \brief Function for initializing refcount list
+ *
+ * \param[in]	size		Size of the refcount list.
+ * \return				ia_css_err
+ */
+extern enum ia_css_err ia_css_refcount_init(uint32_t size);
+
+/*! \brief Function for de-initializing refcount list
+ *
+ * \return				None
+ */
+extern void ia_css_refcount_uninit(void);
+
+/*! \brief Function for increasing reference by 1.
+ *
+ * \param[in]	id		ID of the object.
+ * \param[in]	ptr		Data of the object (ptr).
+ * \return				hrt_vaddress (saved address)
+ */
+extern hrt_vaddress ia_css_refcount_increment(int32_t id, hrt_vaddress ptr);
+
+/*! \brief Function for decrease reference by 1.
+ *
+ * \param[in]	id		ID of the object.
+ * \param[in]	ptr		Data of the object (ptr).
+ *
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool ia_css_refcount_decrement(int32_t id, hrt_vaddress ptr);
+
+/*! \brief Function to check if reference count is 1.
+ *
+ * \param[in]	ptr		Data of the object (ptr).
+ *
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool ia_css_refcount_is_single(hrt_vaddress ptr);
+
+/*! \brief Function to clear reference list objects.
+ *
+ * \param[in]	id			ID of the object.
+ * \param[in] clear_func	function to be run to free reference objects.
+ *
+ *  return				None
+ */
+extern void ia_css_refcount_clear(int32_t id,
+				  clear_func clear_func_ptr);
+
+#endif /* _IA_CSS_REFCOUNT_H_ */
diff --git a/drivers/media/atomisp2/css2400/base/refcount/src/refcount.c b/drivers/media/atomisp2/css2400/base/refcount/src/refcount.c
new file mode 100644
index 0000000..93cba70
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/base/refcount/src/refcount.c
@@ -0,0 +1,234 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_refcount.h"
+#include "memory_access/memory_access.h"
+#include "sh_css_defs.h"
+
+#include "platform_support.h"
+
+#include "assert_support.h"
+
+#include "ia_css_debug.h"
+
+/* TODO: enable for other memory aswell
+	 now only for hrt_vaddress */
+struct ia_css_refcount_entry {
+	uint32_t count;
+	hrt_vaddress data;
+	int32_t id;
+};
+
+struct ia_css_refcount_list {
+	uint32_t size;
+	struct ia_css_refcount_entry *items;
+};
+
+static struct ia_css_refcount_list myrefcount;
+
+static struct ia_css_refcount_entry *refcount_find_entry(hrt_vaddress ptr,
+							 bool firstfree)
+{
+	uint32_t i;
+
+	assert(ptr != 0);
+	assert(myrefcount.items != NULL);
+
+	for (i = 0; i < myrefcount.size; i++) {
+
+		if ((&myrefcount.items[i])->data == 0) {
+			if (firstfree) {
+				/* for new entry */
+				return &myrefcount.items[i];
+			}
+		}
+		if ((&myrefcount.items[i])->data == ptr) {
+			/* found entry */
+			return &myrefcount.items[i];
+		}
+	}
+	return NULL;
+}
+
+enum ia_css_err ia_css_refcount_init(uint32_t size)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(size != 0);
+	assert(myrefcount.items == NULL);
+
+	myrefcount.items =
+	    sh_css_malloc(sizeof(struct ia_css_refcount_entry) * size);
+	if (!myrefcount.items)
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	if (err == IA_CSS_SUCCESS) {
+		memset(myrefcount.items, 0,
+		       sizeof(struct ia_css_refcount_entry) * size);
+		myrefcount.size = size;
+	}
+	return err;
+}
+
+void ia_css_refcount_uninit(void)
+{
+	struct ia_css_refcount_entry *entry;
+	uint32_t i;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_refcount_uninit() entry\n");
+	for (i = 0; i < myrefcount.size; i++) {
+		entry = &myrefcount.items[i];
+		if (entry->data != mmgr_NULL) {
+			/*	ia_css_debug_dtrace(IA_CSS_DBG_TRACE,
+				"ia_css_refcount_uninit: freeing (%x)\n",
+				entry->data);*/
+			mmgr_free(entry->data);
+			entry->data = mmgr_NULL;
+			entry->count = 0;
+			entry->id = 0;
+		}
+	}
+	sh_css_free(myrefcount.items);
+	myrefcount.items = NULL;
+	myrefcount.size = 0;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_refcount_uninit() leave\n");
+}
+
+hrt_vaddress ia_css_refcount_increment(int32_t id, hrt_vaddress ptr)
+{
+	struct ia_css_refcount_entry *entry;
+
+	if (ptr == mmgr_NULL)
+		return ptr;
+
+	entry = refcount_find_entry(ptr, false);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_refcount_increment(%x) 0x%x\n", id, ptr);
+
+	if (!entry) {
+		entry = refcount_find_entry(ptr, true);
+		assert(entry != NULL);
+		if (entry == NULL)
+			return mmgr_NULL;
+		entry->id = id;
+	}
+
+	assert(entry->id == id);
+
+	if (entry->data == ptr)
+		entry->count += 1;
+	else if (entry->data == mmgr_NULL) {
+		entry->data = ptr;
+		entry->count = 1;
+	} else
+		return mmgr_NULL;
+
+	return ptr;
+}
+
+bool ia_css_refcount_decrement(int32_t id, hrt_vaddress ptr)
+{
+	struct ia_css_refcount_entry *entry;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_refcount_decrement(%x) 0x%x\n", id, ptr);
+
+	if (ptr == mmgr_NULL)
+		return false;
+
+	entry = refcount_find_entry(ptr, false);
+
+	if (entry) {
+		assert(entry->id == id);
+		if (entry->count > 0) {
+			entry->count -= 1;
+			if (entry->count == 0) {
+				/* ia_css_debug_dtrace(IA_CSS_DBEUG_TRACE,
+				   "ia_css_refcount_decrement: freeing\n");*/
+				mmgr_free(ptr);
+				entry->data = mmgr_NULL;
+				entry->id = 0;
+			}
+			return true;
+		}
+	}
+
+	/* SHOULD NOT HAPPEN: ptr not managed by refcount, or not
+	   valid anymore */
+
+	assert(false);
+
+	return false;
+}
+
+bool ia_css_refcount_is_single(hrt_vaddress ptr)
+{
+	struct ia_css_refcount_entry *entry;
+
+	if (ptr == mmgr_NULL)
+		return false;
+
+	entry = refcount_find_entry(ptr, false);
+
+	if (entry)
+		return (entry->count == 1);
+
+	return true;
+}
+
+void ia_css_refcount_clear(int32_t id, clear_func clear_func_ptr)
+{
+	struct ia_css_refcount_entry *entry;
+	uint32_t i;
+	uint32_t count = 0;
+
+	assert(clear_func_ptr != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_refcount_clear(%x)\n",
+			    id);
+
+	for (i = 0; i < myrefcount.size; i++) {
+		entry = &myrefcount.items[i];
+		if ((entry->data != mmgr_NULL) && (entry->id == id)) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+					    "ia_css_refcount_clear:"
+					    " %x: 0x%x\n", id, entry->data);
+			if (clear_func_ptr) {
+				/* clear using provided function */
+				clear_func_ptr(entry->data);
+			} else {
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+						    "ia_css_refcount_clear: "
+						    "using mmgr_free: "
+						    "no clear_func\n");
+				mmgr_free(entry->data);
+			}
+			assert(entry->count == 0);
+			entry->data = mmgr_NULL;
+			entry->count = 0;
+			entry->id = 0;
+			count++;
+		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_refcount_clear(%x): cleared %d\n", id,
+			    count);
+}
diff --git a/drivers/media/atomisp2/css2400/camera/pipe/interface/ia_css_pipe_binarydesc.h b/drivers/media/atomisp2/css2400/camera/pipe/interface/ia_css_pipe_binarydesc.h
new file mode 100644
index 0000000..bb13c01
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/camera/pipe/interface/ia_css_pipe_binarydesc.h
@@ -0,0 +1,256 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_PIPE_BINARYDESC_H__
+#define __IA_CSS_PIPE_BINARYDESC_H__
+
+#include "ia_css_pipe.h"
+
+/** @brief Get a binary descriptor for copy.
+ *
+ * @param[in] pipe
+ * @param[out] copy_desc
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @param[in/out] vf_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_copy_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *copy_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info);
+
+/** @brief Get a binary descriptor for vfpp.
+ *
+ * @param[in] pipe
+ * @param[out] vfpp_descr
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_vfpp_binarydesc(
+		struct ia_css_pipe const * const pipe,
+		struct ia_css_binary_descr *vf_pp_descr,
+		struct ia_css_frame_info *in_info,
+		struct ia_css_frame_info *out_info);
+
+/** @brief Get a binary descriptor for preview stage.
+ *
+ * @param[in] pipe
+ * @param[out] preview_descr
+ * @param[in/out] in_info
+ * @param[in/out] bds_out_info
+ * @param[in/out] out_info
+ * @param[in/out] vf_info
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+ */
+extern enum ia_css_err ia_css_pipe_get_preview_binarydesc(
+	struct ia_css_pipe * const pipe,
+	struct ia_css_binary_descr *preview_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *bds_out_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info);
+
+/** @brief Get a binary descriptor for video stage.
+ *
+ * @param[in/out] pipe
+ * @param[out] video_descr
+ * @param[in/out] in_info
+ * @param[in/out] bds_out_info
+ * @param[in/out] vf_info
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+ */
+extern enum ia_css_err ia_css_pipe_get_video_binarydesc(
+	struct ia_css_pipe * const pipe,
+	struct ia_css_binary_descr *video_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *bds_out_info,
+	struct ia_css_frame_info *vf_info,
+	int stream_config_left_padding);
+
+/** @brief Get a binary descriptor for yuv scaler stage.
+ *
+ * @param[in/out] pipe
+ * @param[out] yuv_scaler_descr
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @param[in/out] internal_out_info
+ * @param[in/out] vf_info
+ * @return    None
+ *
+ */
+void ia_css_pipe_get_yuvscaler_binarydesc(
+	struct ia_css_pipe * const pipe,
+	struct ia_css_binary_descr *yuv_scaler_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *internal_out_info,
+	struct ia_css_frame_info *vf_info);
+
+/** @brief Get a binary descriptor for capture pp stage.
+ *
+ * @param[in/out] pipe
+ * @param[out] capture_pp_descr
+ * @param[in/out] in_info
+ * @param[in/out] vf_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_capturepp_binarydesc(
+	struct ia_css_pipe * const pipe,
+	struct ia_css_binary_descr *capture_pp_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *vf_info);
+
+/** @brief Get a binary descriptor for primary capture.
+ *
+ * @param[in] pipe
+ * @param[out] prim_descr
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @param[in/out] vf_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_primary_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *prim_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info);
+
+/** @brief Get a binary descriptor for pre gdc stage.
+ *
+ * @param[in] pipe
+ * @param[out] pre_gdc_descr
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_pre_gdc_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *gdc_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info);
+
+/** @brief Get a binary descriptor for gdc stage.
+ *
+ * @param[in] pipe
+ * @param[out] gdc_descr
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_gdc_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *gdc_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info);
+
+/** @brief Get a binary descriptor for post gdc.
+ *
+ * @param[in] pipe
+ * @param[out] post_gdc_descr
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @param[in/out] vf_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_post_gdc_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *post_gdc_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info);
+
+/** @brief Get a binary descriptor for de.
+ *
+ * @param[in] pipe
+ * @param[out] pre_de_descr
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_pre_de_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *pre_de_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info);
+
+/** @brief Get a binary descriptor for pre anr stage.
+ *
+ * @param[in] pipe
+ * @param[out] pre_anr_descr
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_pre_anr_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *pre_anr_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info);
+
+/** @brief Get a binary descriptor for ANR stage.
+ *
+ * @param[in] pipe
+ * @param[out] anr_descr
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_anr_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *anr_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info);
+
+/** @brief Get a binary descriptor for post anr stage.
+ *
+ * @param[in] pipe
+ * @param[out] post_anr_descr
+ * @param[in/out] in_info
+ * @param[in/out] out_info
+ * @param[in/out] vf_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_post_anr_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *post_anr_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info);
+
+#endif /* __IA_CSS_PIPE_BINARYDESC_H__ */
diff --git a/drivers/media/atomisp2/css2400/camera/pipe/interface/ia_css_pipe_stagedesc.h b/drivers/media/atomisp2/css2400/camera/pipe/interface/ia_css_pipe_stagedesc.h
new file mode 100644
index 0000000..dfe8d32
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/camera/pipe/interface/ia_css_pipe_stagedesc.h
@@ -0,0 +1,60 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_PIPE_STAGEDESC_H__
+#define __IA_CSS_PIPE_STAGEDESC_H__
+
+#include <ia_css_acc_types.h> /* ia_css_fw_info */
+#include <ia_css_frame_public.h>
+#include <ia_css_binary.h>
+#include "ia_css_pipeline.h"
+#include "ia_css_pipeline_common.h"
+
+extern void ia_css_pipe_get_generic_stage_desc(
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_binary *binary,
+	struct ia_css_frame *out_frame[],
+	struct ia_css_frame *in_frame,
+	struct ia_css_frame *cc_frame,
+	struct ia_css_frame *vf_frame);
+
+extern void ia_css_pipe_get_firmwares_stage_desc(
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_binary *binary,
+	struct ia_css_frame *out_frame[],
+	struct ia_css_frame *in_frame,
+	struct ia_css_frame *vf_frame,
+	const struct ia_css_fw_info *fw,
+	unsigned int mode);
+
+extern void ia_css_pipe_get_acc_stage_desc(
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_binary *binary,
+	struct ia_css_fw_info *fw);
+
+extern void ia_css_pipe_get_sp_func_stage_desc(
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_frame *out_frame,
+	enum ia_css_pipeline_stage_sp_func sp_func,
+	unsigned max_input_width);
+
+#endif /*__IA_CSS_PIPE_STAGEDESC__H__ */
+
diff --git a/drivers/media/atomisp2/css2400/camera/pipe/interface/ia_css_pipe_util.h b/drivers/media/atomisp2/css2400/camera/pipe/interface/ia_css_pipe_util.h
new file mode 100644
index 0000000..3019d07
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/camera/pipe/interface/ia_css_pipe_util.h
@@ -0,0 +1,45 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_PIPE_UTIL_H__
+#define __IA_CSS_PIPE_UTIL_H__
+
+#include "ia_css_pipe.h"
+
+/** @brief Get Input format bits per pixel based on stream configuration of this
+ * pipe.
+ *
+ * @param[in] pipe
+ * @return   bits per pixel for the underlying stream
+ *
+ */
+extern unsigned int ia_css_pipe_util_pipe_input_format_bpp(
+	const struct ia_css_pipe * const pipe);
+
+extern void ia_css_pipe_util_create_output_frames(
+	struct ia_css_frame *frames[]);
+
+extern void ia_css_pipe_util_set_output_frames(
+	struct ia_css_frame *frames[],
+	unsigned int idx,
+	struct ia_css_frame *frame);
+
+#endif /* __IA_CSS_PIPE_UTIL_H__ */
diff --git a/drivers/media/atomisp2/css2400/camera/pipe/src/pipe_binarydesc.c b/drivers/media/atomisp2/css2400/camera/pipe/src/pipe_binarydesc.c
new file mode 100644
index 0000000..f95190a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/camera/pipe/src/pipe_binarydesc.c
@@ -0,0 +1,779 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_pipe_binarydesc.h"
+#include "ia_css_frame_format.h"
+#include "ia_css_pipe_util.h"
+#include "ia_css_util.h"
+#include "ia_css_debug.h"
+#include "sh_css_params.h"
+#include <assert_support.h>
+/* HRT_GDC_N */
+#include "gdc_device.h"
+
+static void pipe_binarydesc_get_offline(
+	struct ia_css_pipe const * const pipe,
+	const int mode,
+	struct ia_css_binary_descr *descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info[],
+	struct ia_css_frame_info *vf_info);
+
+/* This module provides a binary descriptions to used to find a binary. Since,
+ * every stage is associated with a binary, it implicity helps stage
+ * description. Apart from providing a binary description, this module also
+ * populates the frame info's when required.*/
+
+void ia_css_pipe_get_copy_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *copy_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
+{
+	unsigned int i;
+	/* out_info can be NULL */
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_copy_binarydesc() enter:\n");
+
+	*in_info = *out_info;
+
+	copy_descr->mode = IA_CSS_BINARY_MODE_COPY;
+	copy_descr->online = true;
+	copy_descr->continuous = false;
+	copy_descr->two_ppc = (pipe->stream->config.pixels_per_clock == 2);
+	copy_descr->enable_yuv_ds = false;
+	copy_descr->enable_high_speed = false;
+	copy_descr->enable_dvs_6axis = false;
+	copy_descr->enable_reduced_pipe = false;
+	copy_descr->enable_dz = false;
+	copy_descr->enable_xnr = false;
+	copy_descr->enable_fractional_ds = false;
+	copy_descr->dvs_env.width = 0;
+	copy_descr->dvs_env.height = 0;
+	copy_descr->stream_format = pipe->stream->config.format;
+	copy_descr->in_info = in_info;
+	copy_descr->bds_out_info = NULL;
+	copy_descr->out_info[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		copy_descr->out_info[i] = NULL;
+	}
+	copy_descr->vf_info = vf_info;
+	copy_descr->isp_pipe_version = 1;
+	copy_descr->required_bds_factor = SH_CSS_BDS_FACTOR_1_00;
+	copy_descr->stream_config_left_padding = -1;
+}
+
+/* Generic descriptor for offline binaries. Internal function. */
+static void pipe_binarydesc_get_offline(
+	struct ia_css_pipe const * const pipe,
+	const int mode,
+	struct ia_css_binary_descr *descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info[],
+	struct ia_css_frame_info *vf_info)
+{
+	unsigned int i;
+	/* in_info, out_info, vf_info can be NULL */
+	assert(pipe != NULL);
+	assert(descr != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "pipe_binarydesc_get_offline() enter:\n");
+
+	descr->mode = mode;
+	descr->online = false;
+	descr->continuous = pipe->stream->config.continuous;
+	descr->two_ppc = false;
+	descr->enable_yuv_ds = false;
+	descr->enable_high_speed = false;
+	descr->enable_dvs_6axis = false;
+	descr->enable_reduced_pipe = false;
+	descr->enable_dz = true;
+	descr->enable_xnr = false;
+	descr->enable_fractional_ds = false;
+	descr->dvs_env.width = 0;
+	descr->dvs_env.height = 0;
+	descr->stream_format = pipe->stream->config.format;
+	descr->in_info = in_info;
+	descr->bds_out_info = NULL;
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		descr->out_info[i] = out_info[i];
+	}
+	descr->vf_info = vf_info;
+	descr->isp_pipe_version = pipe->config.isp_pipe_version;
+	descr->required_bds_factor = SH_CSS_BDS_FACTOR_1_00;
+	descr->stream_config_left_padding = -1;
+}
+
+void ia_css_pipe_get_vfpp_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *vf_pp_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	unsigned int i;
+	/* out_info can be NULL ??? */
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_vfpp_binarydesc() enter:\n");
+
+	in_info->raw_bit_depth = 0;
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_VF_PP,
+			       vf_pp_descr, in_info, out_infos, NULL);
+	vf_pp_descr->enable_fractional_ds = true;
+}
+
+static struct sh_css_bds_factor bds_factors_list[] = {
+	{1, 1, SH_CSS_BDS_FACTOR_1_00},
+	{5, 4, SH_CSS_BDS_FACTOR_1_25},
+	{3, 2, SH_CSS_BDS_FACTOR_1_50},
+	{2, 1, SH_CSS_BDS_FACTOR_2_00},
+	{9, 4, SH_CSS_BDS_FACTOR_2_25},
+	{5, 2, SH_CSS_BDS_FACTOR_2_50},
+	{3, 1, SH_CSS_BDS_FACTOR_3_00},
+	{4, 1, SH_CSS_BDS_FACTOR_4_00},
+	{9, 2, SH_CSS_BDS_FACTOR_4_50},
+	{5, 1, SH_CSS_BDS_FACTOR_5_00},
+	{6, 1, SH_CSS_BDS_FACTOR_6_00},
+	{8, 1, SH_CSS_BDS_FACTOR_8_00}
+};
+
+static enum ia_css_err binarydesc_calculate_bds_factor(
+	struct ia_css_resolution input_res,
+	struct ia_css_resolution output_res,
+	unsigned int *bds_factor)
+{
+	unsigned int i;
+	unsigned int bds_list_size = sizeof(bds_factors_list) /
+	    sizeof(struct sh_css_bds_factor);
+	unsigned int in_w = input_res.width,
+	    in_h = input_res.height,
+	    out_w = output_res.width, out_h = output_res.height;
+
+	unsigned int max_bds_factor = 8;
+	unsigned int max_rounding_margin = 2;
+	/* delta in pixels to account for rounding margin in the calculation */
+	unsigned int delta = max_bds_factor * max_rounding_margin;
+
+	/* Assert if the resolutions are not set */
+	assert(in_w != 0 && in_h != 0);
+	assert(out_w != 0 && out_h != 0);
+
+	/* Loop over all bds factors until a match is found */
+	for (i = 0; i < bds_list_size; i++) {
+		unsigned num = bds_factors_list[i].numerator;
+		unsigned den = bds_factors_list[i].denominator;
+
+		/* See width-wise and height-wise if this bds_factor
+		 * satisfies the condition */
+		bool cond = (out_w * num / den + delta > in_w) &&
+		    (out_w * num / den <= in_w) &&
+		    (out_h * num / den + delta > in_h) &&
+		    (out_h * num / den <= in_h);
+
+		if (cond) {
+			*bds_factor = bds_factors_list[i].bds_factor;
+			return IA_CSS_SUCCESS;
+		}
+	}
+
+	/* Throw an error since a suitable bds_factor cannot be found */
+	return IA_CSS_ERR_INVALID_ARGUMENTS;
+}
+
+enum ia_css_err ia_css_pipe_get_preview_binarydesc(
+	struct ia_css_pipe * const pipe,
+	struct ia_css_binary_descr *preview_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *bds_out_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
+{
+	enum ia_css_err err;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	int mode = IA_CSS_BINARY_MODE_PREVIEW;
+	unsigned int i;
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	assert(vf_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_preview_binarydesc() enter:\n");
+
+	in_info->res = pipe->stream->info.effective_info;
+	in_info->padded_width = in_info->res.width;
+	in_info->raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	if (ia_css_util_is_input_format_yuv(pipe->stream->config.format))
+		mode = IA_CSS_BINARY_MODE_COPY;
+	else
+		in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe, mode,
+			       preview_descr, in_info, out_infos, vf_info);
+	if (pipe->stream->config.online) {
+		preview_descr->online = pipe->stream->config.online;
+		preview_descr->two_ppc =
+		    (pipe->stream->config.pixels_per_clock == 2);
+	}
+	preview_descr->stream_format = pipe->stream->config.format;
+
+	/* TODO: Remove this when bds_out_info is available! */
+	*bds_out_info = *in_info;
+
+	if (pipe->extra_config.enable_raw_binning) {
+		if (pipe->config.bayer_ds_out_res.width != 0 &&
+		    pipe->config.bayer_ds_out_res.height != 0) {
+			bds_out_info->res.width =
+			    pipe->config.bayer_ds_out_res.width;
+			bds_out_info->res.height =
+			    pipe->config.bayer_ds_out_res.height;
+			bds_out_info->padded_width =
+			    pipe->config.bayer_ds_out_res.width;
+			err =
+			    binarydesc_calculate_bds_factor(in_info->res,
+				    bds_out_info->res,
+				    &preview_descr->required_bds_factor);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		} else {
+			bds_out_info->res.width = in_info->res.width / 2;
+			bds_out_info->res.height = in_info->res.height / 2;
+			bds_out_info->padded_width = in_info->padded_width / 2;
+			preview_descr->required_bds_factor =
+			    SH_CSS_BDS_FACTOR_2_00;
+		}
+	} else {
+		/* TODO: Remove this when bds_out_info->is available! */
+		bds_out_info->res.width = in_info->res.width;
+		bds_out_info->res.height = in_info->res.height;
+		bds_out_info->padded_width = in_info->padded_width;
+		preview_descr->required_bds_factor = SH_CSS_BDS_FACTOR_1_00;
+	}
+	pipe->required_bds_factor = preview_descr->required_bds_factor;
+
+	/* bayer ds and fractional ds cannot be enabled at the same time,
+	so we disable bds_out_info when fractional ds is used */
+	if (!pipe->extra_config.enable_fractional_ds)
+		preview_descr->bds_out_info = bds_out_info;
+	else
+		preview_descr->bds_out_info = NULL;
+	/*
+	   ----Preview binary-----
+	   --in-->|--out->|vf_veceven|--|--->vf
+	   -----------------------
+	   * Preview binary normally doesn't have a vf_port but
+	   * instead it has an output port. However, the output is
+	   * generated by vf_veceven module in which we might have
+	   * a downscaling (by 1x, 2x, or 4x). Because the resolution
+	   * might change, we need two different info, namely out_info
+	   * & vf_info. In fill_binary_info we use out&vf info to
+	   * calculate vf decimation factor.
+	 */
+	*out_info = *vf_info;
+
+	/* In case of preview_ds binary, we can do any fractional amount
+	 * of downscale, so there is no DS needed in vf_veceven. Therefore,
+	 * out and vf infos will be the same. Otherwise, we set out resolution
+	 * equal to in resolution. */
+	if (!pipe->extra_config.enable_fractional_ds) {
+		/* TODO: Change this when bds_out_info is available! */
+		out_info->res.width = bds_out_info->res.width;
+		out_info->res.height = bds_out_info->res.height;
+		out_info->padded_width = bds_out_info->padded_width;
+	}
+	preview_descr->enable_fractional_ds =
+	    pipe->extra_config.enable_fractional_ds;
+
+	preview_descr->isp_pipe_version = pipe->config.isp_pipe_version;
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_pipe_get_video_binarydesc(
+	struct ia_css_pipe * const pipe,
+	struct ia_css_binary_descr *video_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *bds_out_info,
+	struct ia_css_frame_info *vf_info,
+	int stream_config_left_padding)
+{
+	int mode = IA_CSS_BINARY_MODE_VIDEO;
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool stream_dz_config = false;
+
+	/* vf_info can be NULL */
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	/* assert(vf_info != NULL); */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_video_binarydesc() enter:\n");
+
+	if (ia_css_util_is_input_format_yuv(pipe->stream->config.format))
+		mode = IA_CSS_BINARY_MODE_COPY;
+	in_info->res = pipe->stream->info.effective_info;
+	in_info->padded_width = in_info->res.width;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	out_infos[0] = &pipe->output_info[0];
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe, mode,
+	       video_descr, in_info, out_infos, vf_info);
+	if (pipe->stream->config.online) {
+		video_descr->online = pipe->stream->config.online;
+		video_descr->two_ppc =
+		    (pipe->stream->config.pixels_per_clock == 2);
+	}
+
+	if (mode == IA_CSS_BINARY_MODE_VIDEO) {
+		stream_dz_config =
+		    ((pipe->stream->isp_params_configs->dz_config.dx !=
+		      HRT_GDC_N)
+		     || (pipe->stream->isp_params_configs->dz_config.dy !=
+			 HRT_GDC_N));
+
+		video_descr->enable_dz = pipe->config.enable_dz
+		    || stream_dz_config;
+		video_descr->dvs_env = pipe->config.dvs_envelope;
+		video_descr->enable_yuv_ds = pipe->extra_config.enable_yuv_ds;
+		video_descr->enable_high_speed =
+		    pipe->extra_config.enable_high_speed;
+		video_descr->enable_dvs_6axis =
+		    pipe->extra_config.enable_dvs_6axis;
+		video_descr->enable_reduced_pipe =
+		    pipe->extra_config.enable_reduced_pipe;
+		video_descr->isp_pipe_version = pipe->config.isp_pipe_version;
+		video_descr->enable_fractional_ds =
+		    pipe->extra_config.enable_fractional_ds;
+
+#if defined(IS_ISP_2500_SYSTEM)
+/*
+ ignoring enable_raw_binning, as it is obsolete and setting it gives problems finding the binary
+*/
+		if (pipe->config.bayer_ds_out_res.width != 0 &&
+			pipe->config.bayer_ds_out_res.height != 0) {
+			bds_out_info->res.width = pipe->config.bayer_ds_out_res.width;
+			bds_out_info->res.height = pipe->config.bayer_ds_out_res.height;
+			bds_out_info->padded_width = pipe->config.bayer_ds_out_res.width;
+/* the set of supported scaling factors seems to small for skylake
+			err = calculate_bds_factor(in_info->res, bds_out_info->res,
+					&video_descr.required_bds_factor);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+*/
+		}
+#else
+		if (pipe->extra_config.enable_raw_binning) {
+			if (pipe->config.bayer_ds_out_res.width != 0 &&
+			    pipe->config.bayer_ds_out_res.height != 0) {
+				bds_out_info->res.width =
+				    pipe->config.bayer_ds_out_res.width;
+				bds_out_info->res.height =
+				    pipe->config.bayer_ds_out_res.height;
+				bds_out_info->padded_width =
+				    pipe->config.bayer_ds_out_res.width;
+				err =
+				binarydesc_calculate_bds_factor(
+					in_info->res, bds_out_info->res,
+					&video_descr->required_bds_factor);
+				if (err != IA_CSS_SUCCESS)
+					return err;
+			} else {
+				bds_out_info->res.width =
+				    in_info->res.width / 2;
+				bds_out_info->res.height =
+				    in_info->res.height / 2;
+				bds_out_info->padded_width =
+				    in_info->padded_width / 2;
+				video_descr->required_bds_factor =
+				    SH_CSS_BDS_FACTOR_2_00;
+			}
+		} else {
+			bds_out_info->res.width = in_info->res.width;
+			bds_out_info->res.height = in_info->res.height;
+			bds_out_info->padded_width = in_info->padded_width;
+			video_descr->required_bds_factor =
+			    SH_CSS_BDS_FACTOR_1_00;
+		}
+#endif
+		pipe->required_bds_factor = video_descr->required_bds_factor;
+
+		/* bayer ds and fractional ds cannot be enabled
+		at the same time, so we disable bds_out_info when
+		fractional ds is used */
+		if (!pipe->extra_config.enable_fractional_ds)
+			video_descr->bds_out_info = bds_out_info;
+		else
+			video_descr->bds_out_info = NULL;
+
+		video_descr->enable_fractional_ds =
+		    pipe->extra_config.enable_fractional_ds;
+		video_descr->stream_config_left_padding = stream_config_left_padding;
+	}
+	return err;
+}
+
+void ia_css_pipe_get_yuvscaler_binarydesc(
+	struct ia_css_pipe * const pipe,
+	struct ia_css_binary_descr *yuv_scaler_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *internal_out_info,
+	struct ia_css_frame_info *vf_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(IA_CSS_BINARY_MAX_OUTPUT_PORTS >= 2);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_yuvscaler_binarydesc() enter:\n");
+
+	in_info->padded_width = in_info->res.width;
+	in_info->format = IA_CSS_FRAME_FORMAT_YUV420;
+	in_info->raw_bit_depth = 0;
+	ia_css_frame_info_set_width(in_info, in_info->res.width, 0);
+	out_infos[0] = out_info;
+	out_infos[1] = internal_out_info;
+	for (i = 2; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe,
+			       IA_CSS_BINARY_MODE_CAPTURE_PP,
+			       yuv_scaler_descr,
+			       in_info, out_infos, vf_info);
+	yuv_scaler_descr->enable_fractional_ds = true;
+}
+
+void ia_css_pipe_get_capturepp_binarydesc(
+	struct ia_css_pipe * const pipe,
+	struct ia_css_binary_descr *capture_pp_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *vf_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(vf_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_capturepp_binarydesc() enter:\n");
+
+	/* the in_info is only used for resolution to enable
+	   bayer down scaling. */
+	if (pipe->out_yuv_ds_input_info.res.width)
+		*in_info = pipe->out_yuv_ds_input_info;
+	else
+		*in_info = pipe->output_info[0];
+	in_info->format = IA_CSS_FRAME_FORMAT_YUV420;
+	in_info->raw_bit_depth = 0;
+	ia_css_frame_info_set_width(in_info, in_info->res.width, 0);
+	out_infos[0] = &pipe->output_info[0];
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe,
+			       IA_CSS_BINARY_MODE_CAPTURE_PP,
+			       capture_pp_descr,
+			       in_info, out_infos, vf_info);
+	capture_pp_descr->enable_fractional_ds = true;
+	capture_pp_descr->enable_xnr =
+		pipe->config.default_capture_config.enable_xnr;
+}
+
+void ia_css_pipe_get_primary_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *prim_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
+{
+	int mode = IA_CSS_BINARY_MODE_PRIMARY;
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	assert(vf_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_primary_binarydesc() enter:\n");
+
+	if (ia_css_util_is_input_format_yuv(pipe->stream->config.format))
+		mode = IA_CSS_BINARY_MODE_COPY;
+
+	in_info->res = pipe->stream->info.effective_info;
+	in_info->padded_width = in_info->res.width;
+
+#if !defined(HAS_NO_PACKED_RAW_PIXELS)
+	if (pipe->stream->config.pack_raw_pixels)
+		in_info->format = IA_CSS_FRAME_FORMAT_RAW_PACKED;
+	else
+#endif
+		in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+
+	in_info->raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe, mode,
+			       prim_descr, in_info, out_infos, vf_info);
+	if (pipe->stream->config.online &&
+	    pipe->stream->config.mode != IA_CSS_INPUT_MODE_MEMORY) {
+		prim_descr->online = true;
+		prim_descr->two_ppc =
+		    (pipe->stream->config.pixels_per_clock == 2);
+		prim_descr->stream_format = pipe->stream->config.format;
+	}
+	if (mode == IA_CSS_BINARY_MODE_PRIMARY) {
+		prim_descr->isp_pipe_version = pipe->config.isp_pipe_version;
+		prim_descr->enable_fractional_ds =
+		    pipe->extra_config.enable_fractional_ds;
+	}
+}
+
+void ia_css_pipe_get_pre_gdc_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *pre_gdc_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_pre_gdc_binarydesc() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_PRE_ISP,
+			       pre_gdc_descr, in_info, out_infos, NULL);
+	pre_gdc_descr->isp_pipe_version = pipe->config.isp_pipe_version;
+}
+
+void ia_css_pipe_get_gdc_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *gdc_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_gdc_binarydesc() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_QPLANE6;
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_GDC,
+			       gdc_descr, in_info, out_infos, NULL);
+}
+
+void ia_css_pipe_get_post_gdc_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *post_gdc_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	assert(vf_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_post_gdc_binarydesc() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_YUV420_16;
+	in_info->raw_bit_depth = 16;
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_POST_ISP,
+			       post_gdc_descr, in_info, out_infos, vf_info);
+	post_gdc_descr->isp_pipe_version = pipe->config.isp_pipe_version;
+}
+
+void ia_css_pipe_get_pre_de_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *pre_de_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_pre_de_binarydesc() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	if (pipe->config.isp_pipe_version == 1)
+		pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_PRE_ISP,
+				       pre_de_descr, in_info, out_infos, NULL);
+	else {
+		pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_PRE_DE,
+				       pre_de_descr, in_info, out_infos, NULL);
+	}
+	if (pipe->stream->config.online) {
+		pre_de_descr->online = true;
+		pre_de_descr->two_ppc =
+		    (pipe->stream->config.pixels_per_clock == 2);
+		pre_de_descr->stream_format = pipe->stream->config.format;
+	}
+	pre_de_descr->isp_pipe_version = pipe->config.isp_pipe_version;
+}
+
+void ia_css_pipe_get_pre_anr_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *pre_anr_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_pre_anr_binarydesc() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_PRE_ISP,
+			       pre_anr_descr, in_info, out_infos, NULL);
+	if (pipe->stream->config.online) {
+		pre_anr_descr->online = true;
+		pre_anr_descr->two_ppc =
+		    (pipe->stream->config.pixels_per_clock == 2);
+		pre_anr_descr->stream_format = pipe->stream->config.format;
+	}
+	pre_anr_descr->isp_pipe_version = pipe->config.isp_pipe_version;
+}
+
+void ia_css_pipe_get_anr_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *anr_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_anr_binarydesc() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_ANR,
+			       anr_descr, in_info, out_infos, NULL);
+	anr_descr->isp_pipe_version = pipe->config.isp_pipe_version;
+}
+
+
+void ia_css_pipe_get_post_anr_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *post_anr_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	assert(vf_info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_pipe_get_post_anr_binarydesc() enter:\n");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_RAW;
+	in_info->raw_bit_depth = ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_infos[i] = NULL;
+	}
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_POST_ISP,
+			       post_anr_descr, in_info, out_infos, vf_info);
+	post_anr_descr->isp_pipe_version = pipe->config.isp_pipe_version;
+}
diff --git a/drivers/media/atomisp2/css2400/camera/pipe/src/pipe_stagedesc.c b/drivers/media/atomisp2/css2400/camera/pipe/src/pipe_stagedesc.c
new file mode 100644
index 0000000..f74d13e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/camera/pipe/src/pipe_stagedesc.c
@@ -0,0 +1,118 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_pipe_stagedesc.h"
+#include "assert_support.h"
+#include "ia_css_debug.h"
+
+void ia_css_pipe_get_generic_stage_desc(
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_binary *binary,
+	struct ia_css_frame *out_frame[],
+	struct ia_css_frame *in_frame,
+	struct ia_css_frame *cc_frame,
+	struct ia_css_frame *vf_frame)
+{
+	unsigned int i;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,"ia_css_pipe_get_generic_stage_desc() enter:\n");
+
+	stage_desc->binary = binary;
+	stage_desc->firmware = NULL;
+	stage_desc->sp_func = IA_CSS_PIPELINE_NO_FUNC;
+	stage_desc->max_input_width = 0;
+	stage_desc->mode = binary->info->sp.mode;
+	stage_desc->cc_frame = cc_frame;
+	stage_desc->in_frame = in_frame;
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		stage_desc->out_frame[i] = out_frame[i];
+	}
+	stage_desc->vf_frame = vf_frame;
+}
+
+void ia_css_pipe_get_firmwares_stage_desc(
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_binary *binary,
+	struct ia_css_frame *out_frame[],
+	struct ia_css_frame *in_frame,
+	struct ia_css_frame *vf_frame,
+	const struct ia_css_fw_info *fw,
+	unsigned int mode)
+{
+	unsigned int i;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,"ia_css_pipe_get_firmwares_stage_desc() enter:\n");
+	stage_desc->binary = binary;
+	stage_desc->firmware = fw;
+	stage_desc->sp_func = IA_CSS_PIPELINE_NO_FUNC;
+	stage_desc->max_input_width = 0;
+	stage_desc->mode = mode;
+	stage_desc->cc_frame = NULL;
+	stage_desc->in_frame = in_frame;
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		stage_desc->out_frame[i] = out_frame[i];
+	}
+	stage_desc->vf_frame = vf_frame;
+}
+
+void ia_css_pipe_get_acc_stage_desc(
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_binary *binary,
+	struct ia_css_fw_info *fw)
+{
+	unsigned int i;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,"ia_css_pipe_get_acc_stage_desc() enter:\n");
+	stage_desc->binary = binary;
+	stage_desc->firmware = fw;
+	stage_desc->sp_func = IA_CSS_PIPELINE_NO_FUNC;
+	stage_desc->max_input_width = 0;
+	stage_desc->mode = IA_CSS_BINARY_MODE_VF_PP;
+	stage_desc->cc_frame = NULL;
+	stage_desc->in_frame = NULL;
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		stage_desc->out_frame[i] = NULL;
+	}
+	stage_desc->vf_frame = NULL;
+}
+
+void ia_css_pipe_get_sp_func_stage_desc(
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_frame *out_frame,
+	enum ia_css_pipeline_stage_sp_func sp_func,
+	unsigned max_input_width)
+{
+	unsigned int i;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,"ia_css_pipe_get_sp_func_stage_desc() enter:\n");
+	stage_desc->binary = NULL;
+	stage_desc->firmware = NULL;
+	stage_desc->sp_func = sp_func;
+	stage_desc->max_input_width = max_input_width;
+	stage_desc->mode = -1;
+	stage_desc->cc_frame = NULL;
+	stage_desc->in_frame = NULL;
+	stage_desc->out_frame[0] = out_frame;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		stage_desc->out_frame[i] = NULL;
+	}
+	stage_desc->vf_frame = NULL;
+}
+
diff --git a/drivers/media/atomisp2/css2400/camera/pipe/src/pipe_util.c b/drivers/media/atomisp2/css2400/camera/pipe/src/pipe_util.c
new file mode 100644
index 0000000..7d3901a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/camera/pipe/src/pipe_util.c
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_pipe_util.h"
+#include "ia_css_util.h"
+#include "assert_support.h"
+
+unsigned int ia_css_pipe_util_pipe_input_format_bpp(
+	const struct ia_css_pipe * const pipe)
+{
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	return ia_css_util_input_format_bpp(pipe->stream->config.format,
+			  pipe->stream->config.pixels_per_clock == 2);
+}
+
+void ia_css_pipe_util_create_output_frames(
+	struct ia_css_frame *frames[])
+{
+	unsigned int i;
+
+	assert(frames != NULL);
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		frames[i] = NULL;
+	}
+}
+
+void ia_css_pipe_util_set_output_frames(
+	struct ia_css_frame *frames[],
+	unsigned int idx,
+	struct ia_css_frame *frame)
+{
+	assert(idx < IA_CSS_BINARY_MAX_OUTPUT_PORTS);
+
+	frames[idx] = frame;
+}
+
diff --git a/drivers/media/atomisp2/css2400/camera/util/interface/ia_css_util.h b/drivers/media/atomisp2/css2400/camera/util/interface/ia_css_util.h
new file mode 100644
index 0000000..f97a041
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/camera/util/interface/ia_css_util.h
@@ -0,0 +1,114 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_UTIL_H__
+#define __IA_CSS_UTIL_H__
+
+#include <ia_css_err.h>
+#include <error_support.h>
+#include <type_support.h>
+#include <ia_css_frame_public.h>
+#include <ia_css_stream_public.h>
+#include <ia_css_stream_format.h>
+
+/** @brief convert "errno" error code to "ia_css_err" error code
+ *
+ * @param[in]	"errno" error code
+ * @return   	"ia_css_err" error code
+ *
+ */
+enum ia_css_err ia_css_convert_errno(
+	int in_err);
+
+/** @brief check vf frame info.
+ *
+ * @param[in] info
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+ */
+extern enum ia_css_err ia_css_util_check_vf_info(
+	const struct ia_css_frame_info * const info);
+
+/** @brief check input configuration.
+ *
+ * @param[in] stream_config
+ * @param[in] must_be_raw
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+ */
+extern enum ia_css_err ia_css_util_check_input(
+	const struct ia_css_stream_config * const stream_config,
+	bool must_be_raw,
+	bool must_be_yuv);
+
+/** @brief check vf and out frame info.
+ *
+ * @param[in] out_info
+ * @param[in] vf_info
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+ */
+extern enum ia_css_err ia_css_util_check_vf_out_info(
+	const struct ia_css_frame_info * const out_info,
+	const struct ia_css_frame_info * const vf_info);
+
+/** @brief check width and height
+ *
+ * @param[in] width
+ * @param[in] height
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+ */
+extern enum ia_css_err ia_css_util_check_res(
+	unsigned int width,
+	unsigned int height);
+
+/** @brief check width and height
+ *
+ * @param[in] stream_format
+ * @param[in] two_ppc
+ * @return bits per pixel based on given parameters.
+ *
+ */
+extern unsigned int ia_css_util_input_format_bpp(
+	enum ia_css_stream_format stream_format,
+	bool two_ppc);
+
+/** @brief check if input format it raw
+ *
+ * @param[in] stream_format
+ * @return true if the input format is raw or false otherwise
+ *
+ */
+extern bool ia_css_util_is_input_format_raw(
+	enum ia_css_stream_format stream_format);
+
+/** @brief check if input format it yuv
+ *
+ * @param[in] stream_format
+ * @return true if the input format is yuv or false otherwise
+ *
+ */
+extern bool ia_css_util_is_input_format_yuv(
+	enum ia_css_stream_format stream_format);
+
+#endif /* __IA_CSS_UTIL_H__ */
+
diff --git a/drivers/media/atomisp2/css2400/camera/util/src/util.c b/drivers/media/atomisp2/css2400/camera/util/src/util.c
new file mode 100644
index 0000000..8023117
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/camera/util/src/util.c
@@ -0,0 +1,211 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_util.h"
+#include <ia_css_frame.h>
+#include <assert_support.h>
+#include <math_support.h>
+
+/* for ia_css_binary_max_vf_width() */
+#include "ia_css_binary.h"
+
+
+enum ia_css_err ia_css_convert_errno(
+				int in_err)
+{
+	enum ia_css_err out_err;
+
+	switch (in_err) {
+		case 0:
+			out_err = IA_CSS_SUCCESS;
+			break;
+		case EINVAL:
+			out_err = IA_CSS_ERR_INVALID_ARGUMENTS;
+			break;
+		case ENODATA:
+			out_err = IA_CSS_ERR_QUEUE_IS_EMPTY;
+			break;
+		case ENOSYS:
+		case ENOTSUP:
+			out_err = IA_CSS_ERR_INTERNAL_ERROR;
+			break;
+		case ENOBUFS:
+			out_err = IA_CSS_ERR_QUEUE_IS_FULL;
+			break;
+		default:
+			out_err = IA_CSS_ERR_INTERNAL_ERROR;
+			break;
+	}
+	return out_err;
+}
+
+/* MW: Table look-up ??? */
+unsigned int ia_css_util_input_format_bpp(
+	enum ia_css_stream_format format,
+	bool two_ppc)
+{
+	unsigned int rval = 0;
+	switch (format) {
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+	case IA_CSS_STREAM_FORMAT_EMBEDDED:
+		rval = 8;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+		rval = 10;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+		rval = 4;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+		rval = 5;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+		rval = 65;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+		rval = 6;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+		rval = 7;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+		rval = 12;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+		if (two_ppc)
+			rval = 14;
+		else
+			rval = 12;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+		if (two_ppc)
+			rval = 16;
+		else
+			rval = 12;
+		break;
+	default:
+		rval = 0;
+		break;
+
+	}
+return rval;
+}
+
+enum ia_css_err ia_css_util_check_vf_info(
+	const struct ia_css_frame_info * const info)
+{
+	enum ia_css_err err;
+	assert(info != NULL);
+	err = ia_css_frame_check_info(info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (info->res.width > ia_css_binary_max_vf_width()*2)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_util_check_vf_out_info(
+	const struct ia_css_frame_info * const out_info,
+	const struct ia_css_frame_info * const vf_info)
+{
+	enum ia_css_err err;
+
+	assert(out_info != NULL);
+	assert(vf_info != NULL);
+
+	err = ia_css_frame_check_info(out_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = ia_css_util_check_vf_info(vf_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (vf_info->res.width > out_info->res.width ||
+	    vf_info->res.height > out_info->res.height)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_util_check_res(unsigned int width, unsigned int height)
+{
+	/* height can be odd number for jpeg/embedded data from ISYS2401 */
+	if (((width  == 0)   ||
+	     (height == 0)   ||
+	     IS_ODD(width))) {
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	return IA_CSS_SUCCESS;
+}
+
+bool ia_css_util_is_input_format_raw(enum ia_css_stream_format format)
+{
+	return ((format == IA_CSS_STREAM_FORMAT_RAW_6) ||
+		(format == IA_CSS_STREAM_FORMAT_RAW_7) ||
+		(format == IA_CSS_STREAM_FORMAT_RAW_8) ||
+		(format == IA_CSS_STREAM_FORMAT_RAW_10) ||
+		(format == IA_CSS_STREAM_FORMAT_RAW_12));
+	/* raw_14 and raw_16 are not supported as input formats to the ISP.
+	 * They can only be copied to a frame in memory using the
+	 * copy binary.
+	 */
+}
+
+bool ia_css_util_is_input_format_yuv(enum ia_css_stream_format format)
+{
+	return format == IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY ||
+	    format == IA_CSS_STREAM_FORMAT_YUV420_8 ||
+	    format == IA_CSS_STREAM_FORMAT_YUV420_10 ||
+	    format == IA_CSS_STREAM_FORMAT_YUV422_8 ||
+	    format == IA_CSS_STREAM_FORMAT_YUV422_10;
+}
+
+enum ia_css_err ia_css_util_check_input(
+	const struct ia_css_stream_config * const stream_config,
+	bool must_be_raw,
+	bool must_be_yuv)
+{
+	assert(stream_config != NULL);
+
+	if (stream_config == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (stream_config->effective_res.width == 0 ||
+	    stream_config->effective_res.height == 0)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (must_be_raw &&
+	    !ia_css_util_is_input_format_raw(stream_config->format))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (must_be_yuv &&
+	    !ia_css_util_is_input_format_yuv(stream_config->format))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	return IA_CSS_SUCCESS;
+}
+
diff --git a/drivers/media/atomisp2/css2400/css_api_version.h b/drivers/media/atomisp2/css2400/css_api_version.h
new file mode 100644
index 0000000..98c4542
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/css_api_version.h
@@ -0,0 +1,36 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+// CSS API version file
+
+#ifndef __CSS_API_VERSION_H
+#define __CSS_API_VERSION_H
+
+#define CSS_API_VERSION_STRING	"2.0.1.0"
+
+/*
+Change log
+V2.0.1.0, initial version:
+ - added API verioning
+*/
+
+
+#endif __CSS_API_VERSION_H
diff --git a/drivers/media/atomisp2/css2400/css_version.h b/drivers/media/atomisp2/css2400/css_version.h
new file mode 100644
index 0000000..fc2b96e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/css_version.h
@@ -0,0 +1,70 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+//
+// CSS version file
+//
+
+#ifndef __CSS_VERSION_H
+#define __CSS_VERSION_H
+
+#define VER	0
+#define SUBVER	8
+
+/*
+Changelog
+---------
+
+
+VER 0.5, released 05/02/14:
+	- Added versioning
+
+VER 0.6, released 11/02/14:
+	- Version release mainly for driver and AIC bug fixes
+
+	Changes/Fixes:
+		AIC bugs  : 1399,1588,1590,1589,1703 (Linearization hang)
+		FW versioning added
+		FW tracer for debug in DMEM2
+		Removed A0 support from code
+		Fixed corrupted fields of gird x/y_end for AWB & AE
+
+
+VER 0.7, released 17/02/14:
+        - Version release mainly for driver and AIC bug fixes
+
+        Changes/Fixes:
+                AIC bugs  : 1703 RGB gamma enable
+		1st striping pipe in smoketest - if_striped
+
+
+VER 0.8, released 24/02/14:
+        - Version release mainly for validation IGK and SVOS run  (patch 1667)
+
+        Changes/Fixes:
+		added missing file to css_skycam_a0t_system.proj.mk
+		Updated reset function in mini_vid.c
+		added prepare function to mini_vid.c
+
+
+*/
+
+#endif /* __CSS_VERSION_H */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/debug_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/debug_global.h
new file mode 100644
index 0000000..077fe71
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/debug_global.h
@@ -0,0 +1,87 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DEBUG_GLOBAL_H_INCLUDED__
+#define __DEBUG_GLOBAL_H_INCLUDED__
+
+#include <type_support.h>
+
+#define DEBUG_BUF_SIZE	1024
+#define DEBUG_BUF_MASK	(DEBUG_BUF_SIZE - 1)
+
+#define DEBUG_DATA_ENABLE_ADDR		0x00
+#define DEBUG_DATA_BUF_MODE_ADDR	0x04
+#define DEBUG_DATA_HEAD_ADDR		0x08
+#define DEBUG_DATA_TAIL_ADDR		0x0C
+#define DEBUG_DATA_BUF_ADDR			0x10
+
+#define DEBUG_DATA_ENABLE_DDR_ADDR		0x00
+#define DEBUG_DATA_BUF_MODE_DDR_ADDR	HIVE_ISP_DDR_WORD_BYTES
+#define DEBUG_DATA_HEAD_DDR_ADDR		(2 * HIVE_ISP_DDR_WORD_BYTES)
+#define DEBUG_DATA_TAIL_DDR_ADDR		(3 * HIVE_ISP_DDR_WORD_BYTES)
+#define DEBUG_DATA_BUF_DDR_ADDR			(4 * HIVE_ISP_DDR_WORD_BYTES)
+
+#define DEBUG_BUFFER_ISP_DMEM_ADDR       0x0
+
+/* Enable HAS_WATCHDOG_SP_THREAD_DEBUG for additional SP thread and
+   pipe information on watchdog output */
+//#define HAS_WATCHDOG_SP_THREAD_DEBUG
+#undef HAS_WATCHDOG_SP_THREAD_DEBUG
+
+/*
+ * The linear buffer mode will accept data until the first
+ * overflow and then stop accepting new data
+ * The circular buffer mode will accept if there is place
+ * and discard the data if the buffer is full
+ */
+typedef enum {
+	DEBUG_BUFFER_MODE_LINEAR = 0,
+	DEBUG_BUFFER_MODE_CIRCULAR,
+	N_DEBUG_BUFFER_MODE
+} debug_buf_mode_t;
+
+struct debug_data_s {
+	uint32_t			enable;
+	uint32_t			bufmode;
+	uint32_t			head;
+	uint32_t			tail;
+	uint32_t			buf[DEBUG_BUF_SIZE];
+};
+
+/* thread.sp.c doesn't have a notion of HIVE_ISP_DDR_WORD_BYTES
+   still one point of control is needed for debug purposes */
+
+#ifdef HIVE_ISP_DDR_WORD_BYTES
+struct debug_data_ddr_s {
+	uint32_t			enable;
+	int8_t				padding1[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
+	uint32_t			bufmode;
+	int8_t				padding2[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
+	uint32_t			head;
+	int8_t				padding3[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
+	uint32_t			tail;
+	int8_t				padding4[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
+	uint32_t			buf[DEBUG_BUF_SIZE];
+};
+#endif
+
+#endif /* __DEBUG_GLOBAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/dma_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/dma_global.h
new file mode 100644
index 0000000..344b9f1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/dma_global.h
@@ -0,0 +1,314 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DMA_GLOBAL_H_INCLUDED__
+#define __DMA_GLOBAL_H_INCLUDED__
+
+#include <type_support.h>
+
+#define IS_DMA_VERSION_2
+
+#define HIVE_ISP_NUM_DMA_CONNS		3
+#define HIVE_ISP_NUM_DMA_CHANNELS	32
+
+#define N_DMA_CHANNEL_ID	HIVE_ISP_NUM_DMA_CHANNELS
+
+#include "dma_v2_defs.h"
+
+/*
+ * Command token bit mappings
+ *
+ * transfer / config
+ *    param id[4] channel id[5] cmd id[6]
+ *	| b14 .. b11 | b10 ... b6 | b5 ... b0 |
+ *
+ *
+ * fast transfer:
+ *    height[5]     width[8]      width[8]  channel id[5] cmd id[6]
+ *	| b31 .. b26 | b25 .. b18 | b17 .. b11 | b10 ... b6 | b5 ... b0 |
+ *
+ */
+
+#define _DMA_PACKING_SETUP_PARAM	_DMA_V2_PACKING_SETUP_PARAM
+#define _DMA_HEIGHT_PARAM			_DMA_V2_HEIGHT_PARAM
+#define _DMA_STRIDE_A_PARAM			_DMA_V2_STRIDE_A_PARAM
+#define _DMA_ELEM_CROPPING_A_PARAM	_DMA_V2_ELEM_CROPPING_A_PARAM
+#define _DMA_WIDTH_A_PARAM			_DMA_V2_WIDTH_A_PARAM
+#define _DMA_STRIDE_B_PARAM			_DMA_V2_STRIDE_B_PARAM
+#define _DMA_ELEM_CROPPING_B_PARAM	_DMA_V2_ELEM_CROPPING_B_PARAM
+#define _DMA_WIDTH_B_PARAM			_DMA_V2_WIDTH_B_PARAM
+
+#define _DMA_ZERO_EXTEND     _DMA_V2_ZERO_EXTEND
+#define _DMA_SIGN_EXTEND     _DMA_V2_SIGN_EXTEND
+
+
+typedef unsigned int dma_channel;
+
+typedef enum {
+  dma_isp_to_bus_connection = HIVE_DMA_ISP_BUS_CONN,
+  dma_isp_to_ddr_connection = HIVE_DMA_ISP_DDR_CONN,
+  dma_bus_to_ddr_connection = HIVE_DMA_BUS_DDR_CONN,
+} dma_connection;
+
+typedef enum {
+  dma_zero_extension = _DMA_ZERO_EXTEND,
+  dma_sign_extension = _DMA_SIGN_EXTEND
+} dma_extension;
+
+
+#define DMA_PROP_SHIFT(val, param)       ((val) << _DMA_V2_ ## param ## _IDX)
+#define DMA_PROP_MASK(param)             ((1U << _DMA_V2_ ## param ## _BITS)-1)
+#define DMA_PACK(val, param)             DMA_PROP_SHIFT((val) & DMA_PROP_MASK(param), param)
+
+#define DMA_PACK_COMMAND(cmd)            DMA_PACK(cmd, CMD)
+#define DMA_PACK_CHANNEL(ch)             DMA_PACK(ch,  CHANNEL)
+#define DMA_PACK_PARAM(par)              DMA_PACK(par, PARAM)
+#define DMA_PACK_EXTENSION(ext)          DMA_PACK(ext, EXTENSION)
+#define DMA_PACK_LEFT_CROPPING(lc)       DMA_PACK(lc,  LEFT_CROPPING)
+#define DMA_PACK_WIDTH_A(w)              DMA_PACK(w,   SPEC_DEV_A_XB)
+#define DMA_PACK_WIDTH_B(w)              DMA_PACK(w,   SPEC_DEV_B_XB)
+#define DMA_PACK_HEIGHT(h)               DMA_PACK(h,   SPEC_YB)
+
+#define DMA_PACK_CMD_CHANNEL(cmd, ch)	 (DMA_PACK_COMMAND(cmd) | DMA_PACK_CHANNEL(ch))
+#define DMA_PACK_SETUP(conn, ext)        ((conn) | DMA_PACK_EXTENSION(ext))
+#define DMA_PACK_CROP_ELEMS(elems, crop) ((elems) | DMA_PACK_LEFT_CROPPING(crop))
+
+#define hive_dma_snd(dma_id, token) OP_std_snd(dma_id, (unsigned int)(token))
+
+#define DMA_PACK_BLOCK_CMD(cmd, ch, width_a, width_b, height) \
+  (DMA_PACK_COMMAND(cmd)     | \
+   DMA_PACK_CHANNEL(ch)      | \
+   DMA_PACK_WIDTH_A(width_a) | \
+   DMA_PACK_WIDTH_B(width_b) | \
+   DMA_PACK_HEIGHT(height))
+
+#ifdef __HIVECC
+#define hive_dma_move_data(dma_id, read, channel, addr_a, addr_b, to_is_var, from_is_var) \
+{ \
+  /*hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read?_DMA_V2_MOVE_B2A_COMMAND:_DMA_V2_MOVE_A2B_COMMAND, channel)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_b):(unsigned)(addr_a)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_a):(unsigned)(addr_b)); */\
+  if (read) { \
+    hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_MOVE_B2A_COMMAND, channel)); \
+    hive_dma_snd(dma_id, (unsigned)(addr_b)); \
+    hive_dma_snd(dma_id, (unsigned)(addr_a)); \
+  } else { \
+    hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_MOVE_A2B_COMMAND, channel)); \
+    hive_dma_snd(dma_id, (unsigned)(addr_a)); \
+    hive_dma_snd(dma_id, (unsigned)(addr_b)); \
+  } \
+}
+#define hive_dma_move_data_no_ack(dma_id, read, channel, addr_a, addr_b, to_is_var, from_is_var) \
+{ \
+  /*hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read?_DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND:_DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND, channel)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_b):(unsigned)(addr_a)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_a):(unsigned)(addr_b)); */\
+  if (read) { \
+    hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND, channel)); \
+    hive_dma_snd(dma_id, (unsigned)(addr_b)); \
+    hive_dma_snd(dma_id, (unsigned)(addr_a)); \
+  } else { \
+    hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND, channel)); \
+    hive_dma_snd(dma_id, (unsigned)(addr_a)); \
+    hive_dma_snd(dma_id, (unsigned)(addr_b)); \
+  } \
+}
+#else
+#define hive_dma_move_data(dma_id, read, channel, addr_a, addr_b, to_is_var, from_is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read?_DMA_V2_MOVE_B2A_COMMAND:_DMA_V2_MOVE_A2B_COMMAND, channel)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_b):(unsigned)(addr_a)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_a):(unsigned)(addr_b)); \
+  hive_dma_snd(dma_id, to_is_var); \
+  hive_dma_snd(dma_id, from_is_var); \
+}
+#define hive_dma_move_data_no_ack(dma_id, read, channel, addr_a, addr_b, to_is_var, from_is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read?_DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND:_DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND, channel)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_b):(unsigned)(addr_a)); \
+  hive_dma_snd(dma_id, read?(unsigned)(addr_a):(unsigned)(addr_b)); \
+  hive_dma_snd(dma_id, to_is_var); \
+  hive_dma_snd(dma_id, from_is_var); \
+}
+#endif
+
+#define hive_dma_move_b2a_data(dma_id, channel, to_addr, from_addr, to_is_var, from_is_var) \
+{ \
+  hive_dma_move_data(dma_id, true, channel, to_addr, from_addr, to_is_var, from_is_var) \
+}
+
+#define hive_dma_move_a2b_data(dma_id, channel, from_addr, to_addr, from_is_var, to_is_var) \
+{ \
+  hive_dma_move_data(dma_id, false, channel, from_addr, to_addr, from_is_var, to_is_var) \
+}
+
+#ifdef __HIVECC
+#define hive_dma_set_data(dma_id, channel, address, value, is_var) \
+{ \
+  hive_dma_snd(dma_id, _DMA_V2_PACK_CHANNEL_CMD(_DMA_V2_INIT_A_COMMAND, channel)); \
+  hive_dma_snd(dma_id, value); \
+  hive_dma_snd(dma_id, address); \
+}
+#else
+#define hive_dma_set_data(dma_id, channel, address, value, is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_INIT_A_COMMAND, channel)); \
+  hive_dma_snd(dma_id, value); \
+  hive_dma_snd(dma_id, address); \
+  hive_dma_snd(dma_id, is_var); \
+}
+#endif
+
+#define hive_dma_clear_data(dma_id, channel, address, is_var) hive_dma_set_data(dma_id, channel, address, 0, is_var)
+
+#define hive_dma_configure(dma_id, channel, connection, extension, height, \
+	stride_A, elems_A, cropping_A, width_A, \
+	stride_B, elems_B, cropping_B, width_B) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_CONFIG_CHANNEL_COMMAND, channel)); \
+  hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension)); \
+  hive_dma_snd(dma_id, stride_A); \
+  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, cropping_A)); \
+  hive_dma_snd(dma_id, width_A); \
+  hive_dma_snd(dma_id, stride_B); \
+  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, cropping_B)); \
+  hive_dma_snd(dma_id, width_B); \
+  hive_dma_snd(dma_id, height); \
+}
+
+#ifdef __HIVECC
+/* If the command is "set" the 5th argument holds the value */
+#define hive_dma_execute(dma_id, channel, cmd, to_addr, from_addr_value, to_is_var, from_is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(cmd, channel)); \
+  hive_dma_snd(dma_id, to_addr); \
+  hive_dma_snd(dma_id, from_addr_value); \
+}
+#else
+#define hive_dma_execute(dma_id, channel, cmd, to_addr, from_addr_value, to_is_var, from_is_var) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK(_DMA_V2_SET_CRUN_COMMAND, CMD)); \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(cmd, channel)); \
+  hive_dma_snd(dma_id, to_addr); \
+  hive_dma_snd(dma_id, from_addr_value); \
+  hive_dma_snd(dma_id, to_is_var); \
+  if ((cmd & DMA_CLEAR_CMDBIT) == 0) { \
+	hive_dma_snd(dma_id, from_is_var); \
+  } \
+}
+#endif
+
+#define hive_dma_configure_fast(dma_id, channel, connection, extension, elems_A, elems_B) \
+{ \
+  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_V2_CONFIG_CHANNEL_COMMAND, channel)); \
+  hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension)); \
+  hive_dma_snd(dma_id, 0); \
+  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, 0)); \
+  hive_dma_snd(dma_id, 0); \
+  hive_dma_snd(dma_id, 0); \
+  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, 0)); \
+  hive_dma_snd(dma_id, 0); \
+  hive_dma_snd(dma_id, 1); \
+}
+
+#define hive_dma_set_parameter(dma_id, channel, param, value) \
+{ \
+  hive_dma_snd(dma_id, _DMA_V2_SET_CHANNEL_PARAM_COMMAND | DMA_PACK_CHANNEL(channel) | DMA_PACK_PARAM(param)); \
+  hive_dma_snd(dma_id, value); \
+}
+
+#define	DMA_SPECIFIC_CMDBIT	0x01
+#define	DMA_CHECK_CMDBIT	0x02
+#define	DMA_RW_CMDBIT		0x04
+#define	DMA_CLEAR_CMDBIT	0x08
+#define	DMA_ACK_CMDBIT		0x10
+#define	DMA_CFG_CMDBIT		0x20
+#define	DMA_PARAM_CMDBIT	0x01
+
+/* Write complete check not necessary if there's no ack */
+#define	DMA_NOACK_CMD		(DMA_ACK_CMDBIT | DMA_CHECK_CMDBIT)
+#define	DMA_CFG_CMD			(DMA_CFG_CMDBIT)
+#define	DMA_CFGPARAM_CMD	(DMA_CFG_CMDBIT | DMA_PARAM_CMDBIT)
+
+#define DMA_CMD_NEEDS_ACK(cmd) ((cmd & DMA_NOACK_CMD) == 0)
+#define DMA_CMD_IS_TRANSFER(cmd) ((cmd & DMA_CFG_CMDBIT) == 0)
+#define DMA_CMD_IS_WR(cmd) ((cmd & DMA_RW_CMDBIT) != 0)
+#define DMA_CMD_IS_RD(cmd) ((cmd & DMA_RW_CMDBIT) == 0)
+#define DMA_CMD_IS_CLR(cmd) ((cmd & DMA_CLEAR_CMDBIT) != 0)
+#define DMA_CMD_IS_CFG(cmd) ((cmd & DMA_CFG_CMDBIT) != 0)
+#define DMA_CMD_IS_PARAMCFG(cmd) ((cmd & DMA_CFGPARAM_CMD) == DMA_CFGPARAM_CMD)
+
+/* As a matter of convention */
+#define DMA_TRANSFER_READ		DMA_TRANSFER_B2A
+#define DMA_TRANSFER_WRITE		DMA_TRANSFER_A2B
+/* store/load from the PoV of the system(memory) */
+#define DMA_TRANSFER_STORE		DMA_TRANSFER_B2A
+#define DMA_TRANSFER_LOAD		DMA_TRANSFER_A2B
+#define DMA_TRANSFER_CLEAR		DMA_TRANSFER_CLEAR_A
+
+typedef enum {
+	DMA_TRANSFER_CLEAR_A = DMA_CLEAR_CMDBIT,                                       /* 8 */
+	DMA_TRANSFER_CLEAR_B = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT,                       /* 12 */
+	DMA_TRANSFER_A2B = DMA_RW_CMDBIT,                                              /* 4 */
+	DMA_TRANSFER_B2A = 0,                                                          /* 0 */
+	DMA_TRANSFER_CLEAR_A_NOACK = DMA_CLEAR_CMDBIT | DMA_NOACK_CMD,                 /* 26 */
+	DMA_TRANSFER_CLEAR_B_NOACK = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT | DMA_NOACK_CMD, /* 30 */
+	DMA_TRANSFER_A2B_NOACK = DMA_RW_CMDBIT | DMA_NOACK_CMD,                        /* 22 */
+	DMA_TRANSFER_B2A_NOACK = DMA_NOACK_CMD,                                        /* 18 */
+	DMA_FASTTRANSFER_CLEAR_A = DMA_CLEAR_CMDBIT | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_CLEAR_B = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_A2B = DMA_RW_CMDBIT | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_B2A = DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_CLEAR_A_NOACK = DMA_CLEAR_CMDBIT | DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_CLEAR_B_NOACK = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT | DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_A2B_NOACK = DMA_RW_CMDBIT | DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
+	DMA_FASTTRANSFER_B2A_NOACK = DMA_NOACK_CMD | DMA_SPECIFIC_CMDBIT,
+} dma_transfer_type_t;
+
+typedef enum {
+	DMA_CONFIG_SETUP = _DMA_V2_PACKING_SETUP_PARAM,
+	DMA_CONFIG_HEIGHT = _DMA_V2_HEIGHT_PARAM,
+	DMA_CONFIG_STRIDE_A_ = _DMA_V2_STRIDE_A_PARAM,
+	DMA_CONFIG_CROP_ELEM_A = _DMA_V2_ELEM_CROPPING_A_PARAM,
+	DMA_CONFIG_WIDTH_A = _DMA_V2_WIDTH_A_PARAM,
+	DMA_CONFIG_STRIDE_B_ = _DMA_V2_STRIDE_B_PARAM,
+	DMA_CONFIG_CROP_ELEM_B = _DMA_V2_ELEM_CROPPING_B_PARAM,
+	DMA_CONFIG_WIDTH_B = _DMA_V2_WIDTH_B_PARAM,
+} dma_config_type_t;
+
+struct dma_port_config {
+	uint8_t  crop, elems;
+	uint16_t width;
+	uint32_t stride;
+};
+
+/* Descriptor for dma configuration */
+struct dma_channel_config {
+	uint8_t  connection;
+	uint8_t  extension;
+	uint8_t  height;
+	struct dma_port_config a, b;
+};
+
+#endif /* __DMA_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/event_fifo_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/event_fifo_global.h
new file mode 100644
index 0000000..2b276d4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/event_fifo_global.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __EVENT_FIFO_GLOBAL_H
+#define __EVENT_FIFO_GLOBAL_H
+
+/*#error "event_global.h: No global event information permitted"*/
+
+#endif /* __EVENT_FIFO_GLOBAL_H */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/fifo_monitor_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/fifo_monitor_global.h
new file mode 100644
index 0000000..2eff5a7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/fifo_monitor_global.h
@@ -0,0 +1,39 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __FIFO_MONITOR_GLOBAL_H_INCLUDED__
+#define __FIFO_MONITOR_GLOBAL_H_INCLUDED__
+
+#define IS_FIFO_MONITOR_VERSION_2
+
+/*
+#define HIVE_ISP_CSS_STREAM_SWITCH_NONE      0
+#define HIVE_ISP_CSS_STREAM_SWITCH_SP        1
+#define HIVE_ISP_CSS_STREAM_SWITCH_ISP       2
+ *
+ * Actually, "HIVE_ISP_CSS_STREAM_SWITCH_SP = 1", "HIVE_ISP_CSS_STREAM_SWITCH_ISP = 0"
+ * "hive_isp_css_stream_switch_hrt.h"
+ */
+#define HIVE_ISP_CSS_STREAM_SWITCH_ISP       0
+#define HIVE_ISP_CSS_STREAM_SWITCH_SP        1
+#define HIVE_ISP_CSS_STREAM_SWITCH_NONE      2
+
+#endif /* __FIFO_MONITOR_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gdc_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gdc_global.h
new file mode 100644
index 0000000..4987c16
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gdc_global.h
@@ -0,0 +1,97 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GDC_GLOBAL_H_INCLUDED__
+#define __GDC_GLOBAL_H_INCLUDED__
+
+#define IS_GDC_VERSION_2
+
+#include <type_support.h>
+#include "gdc_v2_defs.h"
+
+/*
+ * Storage addresses for packed data transfer
+ */
+#define GDC_PARAM_ICX_LEFT_ROUNDED_IDX            0
+#define GDC_PARAM_OXDIM_FLOORED_IDX               1
+#define GDC_PARAM_OXDIM_LAST_IDX                  2
+#define GDC_PARAM_WOIX_LAST_IDX                   3
+#define GDC_PARAM_IY_TOPLEFT_IDX                  4
+#define GDC_PARAM_CHUNK_CNT_IDX                   5
+/*#define GDC_PARAM_ELEMENTS_PER_XMEM_ADDR_IDX    6 */		/* Derived from bpp */
+#define GDC_PARAM_BPP_IDX                         6
+#define GDC_PARAM_BLOCK_HEIGHT_IDX                7
+/*#define GDC_PARAM_DMA_CHANNEL_STRIDE_A_IDX      8*/		/* The DMA stride == the GDC buffer stride */
+#define GDC_PARAM_WOIX_IDX                        8
+#define GDC_PARAM_DMA_CHANNEL_STRIDE_B_IDX        9
+#define GDC_PARAM_DMA_CHANNEL_WIDTH_A_IDX        10
+#define GDC_PARAM_DMA_CHANNEL_WIDTH_B_IDX        11
+#define GDC_PARAM_VECTORS_PER_LINE_IN_IDX        12
+#define GDC_PARAM_VECTORS_PER_LINE_OUT_IDX       13
+#define GDC_PARAM_VMEM_IN_DIMY_IDX               14
+#define GDC_PARAM_COMMAND_IDX                    15
+#define N_GDC_PARAM                              16
+
+/* Because of the packed parameter transfer max(params) == max(fragments) */
+#define	N_GDC_FRAGMENTS		N_GDC_PARAM
+
+/* The GDC is capable of higher internal precision than the parameter data structures */
+#define HRT_GDC_COORD_SCALE_BITS	6
+#define HRT_GDC_COORD_SCALE			(1 << HRT_GDC_COORD_SCALE_BITS)
+
+typedef enum {
+	GDC_CH0_ID = 0,
+	N_GDC_CHANNEL_ID
+} gdc_channel_ID_t;
+
+typedef enum {
+	gdc_8_bpp  = 8,
+	gdc_10_bpp = 10,
+	gdc_12_bpp = 12,
+	gdc_14_bpp = 14
+} gdc_bits_per_pixel_t;
+
+typedef struct gdc_scale_param_mem_s {
+	uint16_t  params[N_GDC_PARAM];
+	uint16_t  ipx_start_array[N_GDC_PARAM];
+	uint16_t  ibuf_offset[N_GDC_PARAM];
+	uint16_t  obuf_offset[N_GDC_PARAM];
+} gdc_scale_param_mem_t;
+
+typedef struct {
+	unsigned int      origin_x;
+	unsigned int      origin_y;
+	unsigned int      in_addr_offset;
+	unsigned int      in_block_width;
+	unsigned int      in_block_height;
+	unsigned int      p0_x;
+	unsigned int      p0_y;
+	unsigned int      p1_x;
+	unsigned int      p1_y;
+	unsigned int      p2_x;
+	unsigned int      p2_y;
+	unsigned int      p3_x;
+	unsigned int      p3_y;
+	unsigned int      padding[3];
+} gdc_warp_param_mem_t;
+
+
+#endif /* __GDC_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gp_device_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gp_device_global.h
new file mode 100644
index 0000000..49ba8db
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gp_device_global.h
@@ -0,0 +1,92 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GP_DEVICE_GLOBAL_H_INCLUDED__
+#define __GP_DEVICE_GLOBAL_H_INCLUDED__
+
+#define IS_GP_DEVICE_VERSION_2
+
+#define _REG_GP_IRQ_REQ0_ADDR				0x08
+#define _REG_GP_IRQ_REQ1_ADDR				0x0C
+/* The SP sends SW interrupt info to this register */
+#define _REG_GP_IRQ_REQUEST0_ADDR			_REG_GP_IRQ_REQ0_ADDR
+#define _REG_GP_IRQ_REQUEST1_ADDR			_REG_GP_IRQ_REQ1_ADDR
+
+/* The SP configures FIFO switches in these registers */
+#define _REG_GP_SWITCH_IF_ADDR						0x40
+#define _REG_GP_SWITCH_GDC1_ADDR					0x44
+#define _REG_GP_SWITCH_GDC2_ADDR					0x48
+/* @ INPUT_FORMATTER_BASE -> GP_DEVICE_BASE */
+#define _REG_GP_IFMT_input_switch_lut_reg0			0x00030800
+#define _REG_GP_IFMT_input_switch_lut_reg1			0x00030804
+#define _REG_GP_IFMT_input_switch_lut_reg2			0x00030808
+#define _REG_GP_IFMT_input_switch_lut_reg3			0x0003080C
+#define _REG_GP_IFMT_input_switch_lut_reg4			0x00030810
+#define _REG_GP_IFMT_input_switch_lut_reg5			0x00030814
+#define _REG_GP_IFMT_input_switch_lut_reg6			0x00030818
+#define _REG_GP_IFMT_input_switch_lut_reg7			0x0003081C
+#define _REG_GP_IFMT_input_switch_fsync_lut			0x00030820
+#define _REG_GP_IFMT_srst							0x00030824
+#define _REG_GP_IFMT_slv_reg_srst					0x00030828
+#define _REG_GP_IFMT_input_switch_ch_id_fmt_type	0x0003082C
+
+/* @ GP_DEVICE_BASE */
+#define _REG_GP_SYNCGEN_ENABLE_ADDR					0x00090000
+#define _REG_GP_SYNCGEN_FREE_RUNNING_ADDR			0x00090004
+#define _REG_GP_SYNCGEN_PAUSE_ADDR					0x00090008
+#define _REG_GP_NR_FRAMES_ADDR						0x0009000C
+#define _REG_GP_SYNGEN_NR_PIX_ADDR					0x00090010
+#define _REG_GP_SYNGEN_NR_LINES_ADDR				0x00090014
+#define _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR			0x00090018
+#define _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR			0x0009001C
+#define _REG_GP_ISEL_SOF_ADDR						0x00090020
+#define _REG_GP_ISEL_EOF_ADDR						0x00090024
+#define _REG_GP_ISEL_SOL_ADDR						0x00090028
+#define _REG_GP_ISEL_EOL_ADDR						0x0009002C
+#define _REG_GP_ISEL_LFSR_ENABLE_ADDR				0x00090030
+#define _REG_GP_ISEL_LFSR_ENABLE_B_ADDR				0x00090034
+#define _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR			0x00090038
+#define _REG_GP_ISEL_TPG_ENABLE_ADDR				0x0009003C
+#define _REG_GP_ISEL_TPG_ENABLE_B_ADDR				0x00090040
+#define _REG_GP_ISEL_HOR_CNT_MASK_ADDR				0x00090044
+#define _REG_GP_ISEL_VER_CNT_MASK_ADDR				0x00090048
+#define _REG_GP_ISEL_XY_CNT_MASK_ADDR				0x0009004C
+#define _REG_GP_ISEL_HOR_CNT_DELTA_ADDR				0x00090050
+#define _REG_GP_ISEL_VER_CNT_DELTA_ADDR				0x00090054
+#define _REG_GP_ISEL_TPG_MODE_ADDR					0x00090058
+#define _REG_GP_ISEL_TPG_RED1_ADDR					0x0009005C
+#define _REG_GP_ISEL_TPG_GREEN1_ADDR				0x00090060
+#define _REG_GP_ISEL_TPG_BLUE1_ADDR					0x00090064
+#define _REG_GP_ISEL_TPG_RED2_ADDR					0x00090068
+#define _REG_GP_ISEL_TPG_GREEN2_ADDR				0x0009006C
+#define _REG_GP_ISEL_TPG_BLUE2_ADDR					0x00090070
+#define _REG_GP_ISEL_CH_ID_ADDR						0x00090074
+#define _REG_GP_ISEL_FMT_TYPE_ADDR					0x00090078
+#define _REG_GP_ISEL_DATA_SEL_ADDR					0x0009007C
+#define _REG_GP_ISEL_SBAND_SEL_ADDR					0x00090080
+#define _REG_GP_ISEL_SYNC_SEL_ADDR					0x00090084
+#define _REG_GP_SYNCGEN_HOR_CNT_ADDR				0x00090088
+#define _REG_GP_SYNCGEN_VER_CNT_ADDR				0x0009008C
+#define _REG_GP_SYNCGEN_FRAME_CNT_ADDR				0x00090090
+#define _REG_GP_SOFT_RESET_ADDR						0x00090094
+
+
+#endif /* __GP_DEVICE_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gpio_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gpio_global.h
new file mode 100644
index 0000000..7ad3e57
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/gpio_global.h
@@ -0,0 +1,52 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GPIO_GLOBAL_H_INCLUDED__
+#define __GPIO_GLOBAL_H_INCLUDED__
+
+#define IS_GPIO_VERSION_1
+
+#include <gpio_block_defs.h>
+
+/* pqiao: following part only defines in hive_isp_css_defs.h in fpga system.
+	port it here
+*/
+
+/* GPIO pin defines */
+/*#define HIVE_GPIO_CAMERA_BOARD_RESET_PIN_NR                   0
+#define HIVE_GPIO_LCD_CLOCK_SELECT_PIN_NR                     7
+#define HIVE_GPIO_HDMI_CLOCK_SELECT_PIN_NR                    8
+#define HIVE_GPIO_LCD_VERT_FLIP_PIN_NR                        8
+#define HIVE_GPIO_LCD_HOR_FLIP_PIN_NR                         9
+#define HIVE_GPIO_AS3683_GPIO_P0_PIN_NR                       1
+#define HIVE_GPIO_AS3683_DATA_P1_PIN_NR                       2
+#define HIVE_GPIO_AS3683_CLK_P2_PIN_NR                        3
+#define HIVE_GPIO_AS3683_T1_F0_PIN_NR                         4
+#define HIVE_GPIO_AS3683_SFL_F1_PIN_NR                        5
+#define HIVE_GPIO_AS3683_STROBE_F2_PIN_NR                     6
+#define HIVE_GPIO_MAX1577_EN1_PIN_NR                          1
+#define HIVE_GPIO_MAX1577_EN2_PIN_NR                          2
+#define HIVE_GPIO_MAX8685A_EN_PIN_NR                          3
+#define HIVE_GPIO_MAX8685A_TRIG_PIN_NR                        4*/
+
+#define HIVE_GPIO_STROBE_TRIGGER_PIN						2
+
+#endif /* __GPIO_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/hmem_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/hmem_global.h
new file mode 100644
index 0000000..8ff7d9a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/hmem_global.h
@@ -0,0 +1,52 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __HMEM_GLOBAL_H_INCLUDED__
+#define __HMEM_GLOBAL_H_INCLUDED__
+
+#include <type_support.h>
+
+#define IS_HMEM_VERSION_1
+
+#include "isp.h"
+
+/*
+#define ISP_HIST_ADDRESS_BITS                  12
+#define ISP_HIST_ALIGNMENT                     4
+#define ISP_HIST_COMP_IN_PREC                  12
+#define ISP_HIST_DEPTH                         1024
+#define ISP_HIST_WIDTH                         24
+#define ISP_HIST_COMPONENTS                    4
+*/
+#define ISP_HIST_ALIGNMENT_LOG2		2
+
+#define HMEM_SIZE_LOG2		(ISP_HIST_ADDRESS_BITS-ISP_HIST_ALIGNMENT_LOG2)
+#define HMEM_SIZE			ISP_HIST_DEPTH
+
+#define HMEM_UNIT_SIZE		(HMEM_SIZE/ISP_HIST_COMPONENTS)
+#define HMEM_UNIT_COUNT		ISP_HIST_COMPONENTS
+
+#define HMEM_RANGE_LOG2		ISP_HIST_WIDTH
+#define HMEM_RANGE			(1UL<<HMEM_RANGE_LOG2)
+
+typedef uint32_t			hmem_data_t;
+
+#endif /* __HMEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug.c
new file mode 100644
index 0000000..3e98e1d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug.c
@@ -0,0 +1,85 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "debug.h"
+
+#ifndef __INLINE_DEBUG__
+#include "debug_private.h"
+#endif /* __INLINE_DEBUG__ */
+
+#include "memory_access.h"
+
+#define __INLINE_SP__
+#include "sp.h"
+
+#include "assert_support.h"
+
+/* The address of the remote copy */
+hrt_address	debug_buffer_address = (hrt_address)-1;
+hrt_vaddress	debug_buffer_ddr_address = (hrt_vaddress)-1;
+/* The local copy */
+debug_data_t		debug_data;
+debug_data_t		*debug_data_ptr = &debug_data;
+
+void debug_buffer_init(
+	const hrt_address		addr)
+{
+	debug_buffer_address = addr;
+
+	debug_data.head = 0;
+	debug_data.tail = 0;
+return;
+}
+
+void debug_buffer_ddr_init(
+	const hrt_vaddress		addr)
+{
+	debug_buf_mode_t mode = DEBUG_BUFFER_MODE_LINEAR;
+	uint32_t enable = 1;
+	uint32_t head = 0;
+	uint32_t tail = 0;
+	/* set the ddr queue */
+	debug_buffer_ddr_address = addr;
+	mmgr_store(addr + DEBUG_DATA_BUF_MODE_DDR_ADDR,
+				&mode, sizeof(debug_buf_mode_t));
+	mmgr_store(addr + DEBUG_DATA_HEAD_DDR_ADDR,
+				&head, sizeof(uint32_t));
+	mmgr_store(addr + DEBUG_DATA_TAIL_DDR_ADDR,
+				&tail, sizeof(uint32_t));
+	mmgr_store(addr + DEBUG_DATA_ENABLE_DDR_ADDR,
+				&enable, sizeof(uint32_t));
+
+	/* set the local copy */
+	debug_data.head = 0;
+	debug_data.tail = 0;
+return;
+}
+
+void debug_buffer_setmode(
+	const debug_buf_mode_t	mode)
+{
+	assert(debug_buffer_address != ((hrt_address)-1));
+
+	sp_dmem_store_uint32(SP0_ID,
+		debug_buffer_address + DEBUG_DATA_BUF_MODE_ADDR, mode);
+return;
+}
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_local.h
new file mode 100644
index 0000000..07fbdb2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_local.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DEBUG_LOCAL_H_INCLUDED__
+#define __DEBUG_LOCAL_H_INCLUDED__
+
+#include "debug_global.h"
+
+#endif /* __DEBUG_LOCAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_private.h
new file mode 100644
index 0000000..8d400fe
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/debug_private.h
@@ -0,0 +1,109 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DEBUG_PRIVATE_H_INCLUDED__
+#define __DEBUG_PRIVATE_H_INCLUDED__
+
+#include "debug_public.h"
+
+#include "sp.h"
+
+#define __INLINE_ISP__
+#include "isp.h"
+
+#include "memory_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_DEBUG_C bool is_debug_buffer_empty(void)
+{
+return (debug_data_ptr->head == debug_data_ptr->tail);
+}
+
+STORAGE_CLASS_DEBUG_C hrt_data debug_dequeue(void)
+{
+	hrt_data	value = 0;
+
+assert(debug_buffer_address != ((hrt_address)-1));
+
+	debug_synch_queue();
+
+	if (!is_debug_buffer_empty()) {
+		value = debug_data_ptr->buf[debug_data_ptr->head];
+		debug_data_ptr->head = (debug_data_ptr->head + 1) & DEBUG_BUF_MASK;
+		sp_dmem_store_uint32(SP0_ID, debug_buffer_address + DEBUG_DATA_HEAD_ADDR, debug_data_ptr->head);
+	}
+
+return value;
+}
+
+STORAGE_CLASS_DEBUG_C void debug_synch_queue(void)
+{
+	uint32_t	remote_tail	= sp_dmem_load_uint32(SP0_ID, debug_buffer_address + DEBUG_DATA_TAIL_ADDR);
+/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
+	if (remote_tail > debug_data_ptr->tail) {
+		size_t	delta = remote_tail - debug_data_ptr->tail;
+		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+	} else if (remote_tail < debug_data_ptr->tail) {
+		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
+		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR, (void *)&(debug_data_ptr->buf[0]), remote_tail*sizeof(uint32_t));
+	} /* else we are up to date */
+	debug_data_ptr->tail = remote_tail;
+return;
+}
+
+STORAGE_CLASS_DEBUG_C void debug_synch_queue_isp(void)
+{
+	uint32_t	remote_tail	= isp_dmem_load_uint32(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_TAIL_ADDR);
+/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
+	if (remote_tail > debug_data_ptr->tail) {
+		size_t	delta = remote_tail - debug_data_ptr->tail;
+		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+	} else if (remote_tail < debug_data_ptr->tail) {
+		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
+		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR, (void *)&(debug_data_ptr->buf[0]), remote_tail*sizeof(uint32_t));
+	} /* else we are up to date */
+	debug_data_ptr->tail = remote_tail;
+return;
+}
+
+STORAGE_CLASS_DEBUG_C void debug_synch_queue_ddr(void)
+{
+	uint32_t	remote_tail;
+
+	mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_TAIL_DDR_ADDR, &remote_tail, sizeof(uint32_t));
+/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
+	if (remote_tail > debug_data_ptr->tail) {
+		size_t	delta = remote_tail - debug_data_ptr->tail;
+		mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+	} else if (remote_tail < debug_data_ptr->tail) {
+		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
+		mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
+		mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR, (void *)&(debug_data_ptr->buf[0]), remote_tail*sizeof(uint32_t));
+	} /* else we are up to date */
+	debug_data_ptr->tail = remote_tail;
+return;
+}
+
+#endif /* __DEBUG_PRIVATE_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma.c
new file mode 100644
index 0000000..e6d1e92
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma.c
@@ -0,0 +1,300 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <stddef.h>		/* NULL */
+
+#include "dma.h"
+
+#include "assert_support.h"
+
+#ifndef __INLINE_DMA__
+#include "dma_private.h"
+#endif /* __INLINE_DMA__ */
+
+void dma_get_state(
+	const dma_ID_t		ID,
+	dma_state_t			*state)
+{
+	int			i;
+	hrt_data	tmp;
+
+	assert(ID < N_DMA_ID);
+	assert(state != NULL);
+
+	tmp = dma_reg_load(ID, DMA_COMMAND_FSM_REG_IDX);
+	//reg  [3:0] : flags error [3], stall, run, idle [0]
+	//reg  [9:4] : command
+	//reg[14:10] : channel
+	//reg [23:15] : param
+	state->fsm_command_idle = tmp & 0x1;
+	state->fsm_command_run = tmp & 0x2;
+	state->fsm_command_stalling = tmp & 0x4;
+	state->fsm_command_error    = tmp & 0x8;
+	state->last_command_channel = (tmp>>10 & 0x1F);
+	state->last_command_param =  (tmp>>15 & 0x0F);
+	tmp = (tmp>>4) & 0x3F;
+/* state->last_command = (dma_commands_t)tmp; */
+/* if the enumerator is made non-linear */
+	/* AM: the list below does not cover all the cases*/
+	/*  and these are not correct */
+	/* therefore for just dumpinmg this command*/
+	state->last_command = tmp;
+
+/*
+	if (tmp == 0)
+		state->last_command = DMA_COMMAND_READ;
+	if (tmp == 1)
+		state->last_command = DMA_COMMAND_WRITE;
+	if (tmp == 2)
+		state->last_command = DMA_COMMAND_SET_CHANNEL;
+	if (tmp == 3)
+		state->last_command = DMA_COMMAND_SET_PARAM;
+	if (tmp == 4)
+		state->last_command = DMA_COMMAND_READ_SPECIFIC;
+	if (tmp == 5)
+		state->last_command = DMA_COMMAND_WRITE_SPECIFIC;
+	if (tmp == 8)
+		state->last_command = DMA_COMMAND_INIT;
+	if (tmp == 12)
+		state->last_command = DMA_COMMAND_INIT_SPECIFIC;
+	if (tmp == 15)
+		state->last_command = DMA_COMMAND_RST;
+*/
+
+/* No sub-fields, idx = 0 */
+	state->current_command = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(0, _DMA_FSM_GROUP_CMD_IDX));
+	state->current_addr_a = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(0, _DMA_FSM_GROUP_ADDR_A_IDX));
+	state->current_addr_b = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(0, _DMA_FSM_GROUP_ADDR_B_IDX));
+
+	tmp =  dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_STATE_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_idle = tmp & 0x1;
+	state->fsm_ctrl_run = tmp & 0x2;
+	state->fsm_ctrl_stalling = tmp & 0x4;
+	state->fsm_ctrl_error = tmp & 0x8;
+	tmp = tmp >> 4;
+/* state->fsm_ctrl_state = (dma_ctrl_states_t)tmp; */
+	if (tmp == 0)
+		state->fsm_ctrl_state = DMA_CTRL_STATE_IDLE;
+	if (tmp == 1)
+		state->fsm_ctrl_state = DMA_CTRL_STATE_REQ_RCV;
+	if (tmp == 2)
+		state->fsm_ctrl_state = DMA_CTRL_STATE_RCV;
+	if (tmp == 3)
+		state->fsm_ctrl_state = DMA_CTRL_STATE_RCV_REQ;
+	if (tmp == 4)
+		state->fsm_ctrl_state = DMA_CTRL_STATE_INIT;
+	state->fsm_ctrl_source_dev = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_source_addr = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_source_stride = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_source_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_REQ_XB_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_source_height = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_REQ_YB_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_source_dev = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_dest_dev = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_dest_addr = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_dest_stride = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_source_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_dest_height = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_dest_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_source_elems = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_dest_elems = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+	state->fsm_ctrl_pack_extension = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX,
+		_DMA_FSM_GROUP_FSM_CTRL_IDX));
+
+	tmp = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_PACK_STATE_IDX,
+		_DMA_FSM_GROUP_FSM_PACK_IDX));
+	state->pack_idle     = tmp & 0x1;
+	state->pack_run      = tmp & 0x2;
+	state->pack_stalling = tmp & 0x4;
+	state->pack_error    = tmp & 0x8;
+	state->pack_cnt_height = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_PACK_CNT_YB_IDX,
+		_DMA_FSM_GROUP_FSM_PACK_IDX));
+	state->pack_src_cnt_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX,
+		_DMA_FSM_GROUP_FSM_PACK_IDX));
+	state->pack_dest_cnt_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX,
+		_DMA_FSM_GROUP_FSM_PACK_IDX));
+
+	tmp = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_REQ_STATE_IDX,
+		_DMA_FSM_GROUP_FSM_REQ_IDX));
+/* state->read_state = (dma_rw_states_t)tmp; */
+	if (tmp == 0)
+		state->read_state = DMA_RW_STATE_IDLE;
+	if (tmp == 1)
+		state->read_state = DMA_RW_STATE_REQ;
+	if (tmp == 2)
+		state->read_state = DMA_RW_STATE_NEXT_LINE;
+	if (tmp == 3)
+		state->read_state = DMA_RW_STATE_UNLOCK_CHANNEL;
+	state->read_cnt_height = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_REQ_CNT_YB_IDX,
+		_DMA_FSM_GROUP_FSM_REQ_IDX));
+	state->read_cnt_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_REQ_CNT_XB_IDX,
+		_DMA_FSM_GROUP_FSM_REQ_IDX));
+
+	tmp = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_WR_STATE_IDX,
+		_DMA_FSM_GROUP_FSM_WR_IDX));
+/* state->write_state = (dma_rw_states_t)tmp; */
+	if (tmp == 0)
+		state->write_state = DMA_RW_STATE_IDLE;
+	if (tmp == 1)
+		state->write_state = DMA_RW_STATE_REQ;
+	if (tmp == 2)
+		state->write_state = DMA_RW_STATE_NEXT_LINE;
+	if (tmp == 3)
+		state->write_state = DMA_RW_STATE_UNLOCK_CHANNEL;
+	state->write_height = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_WR_CNT_YB_IDX,
+		_DMA_FSM_GROUP_FSM_WR_IDX));
+	state->write_width = dma_reg_load(ID,
+		DMA_CG_INFO_REG_IDX(
+		_DMA_FSM_GROUP_FSM_WR_CNT_XB_IDX,
+		_DMA_FSM_GROUP_FSM_WR_IDX));
+
+	for (i = 0; i < HIVE_ISP_NUM_DMA_CONNS; i++) {
+		dma_port_state_t *port = &(state->port_states[i]);
+
+		tmp = dma_reg_load(ID, DMA_DEV_INFO_REG_IDX(0, i));
+		port->req_cs   = ((tmp & 0x1) != 0);
+		port->req_we_n = ((tmp & 0x2) != 0);
+		port->req_run  = ((tmp & 0x4) != 0);
+		port->req_ack  = ((tmp & 0x8) != 0);
+
+		tmp = dma_reg_load(ID, DMA_DEV_INFO_REG_IDX(1, i));
+		port->send_cs   = ((tmp & 0x1) != 0);
+		port->send_we_n = ((tmp & 0x2) != 0);
+		port->send_run  = ((tmp & 0x4) != 0);
+		port->send_ack  = ((tmp & 0x8) != 0);
+
+		tmp = dma_reg_load(ID, DMA_DEV_INFO_REG_IDX(2, i));
+		if (tmp & 0x1)
+			port->fifo_state = DMA_FIFO_STATE_WILL_BE_FULL;
+		if (tmp & 0x2)
+			port->fifo_state = DMA_FIFO_STATE_FULL;
+		if (tmp & 0x4)
+			port->fifo_state = DMA_FIFO_STATE_EMPTY;
+		port->fifo_counter = tmp >> 3;
+	}
+
+	for (i = 0; i < HIVE_DMA_NUM_CHANNELS; i++) {
+		dma_channel_state_t *ch = &(state->channel_states[i]);
+
+		ch->connection = DMA_GET_CONNECTION(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_PACKING_SETUP_PARAM)));
+		ch->sign_extend = DMA_GET_EXTENSION(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_PACKING_SETUP_PARAM)));
+		ch->height = dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_HEIGHT_PARAM));
+		ch->stride_a = dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_STRIDE_A_PARAM));
+		ch->elems_a = DMA_GET_ELEMENTS(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_ELEM_CROPPING_A_PARAM)));
+		ch->cropping_a = DMA_GET_CROPPING(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_ELEM_CROPPING_A_PARAM)));
+		ch->width_a = dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_WIDTH_A_PARAM));
+		ch->stride_b = dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_STRIDE_B_PARAM));
+		ch->elems_b = DMA_GET_ELEMENTS(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_ELEM_CROPPING_B_PARAM)));
+		ch->cropping_b = DMA_GET_CROPPING(dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_ELEM_CROPPING_B_PARAM)));
+		ch->width_b = dma_reg_load(ID,
+			DMA_CHANNEL_PARAM_REG_IDX(i,
+			_DMA_WIDTH_B_PARAM));
+	}
+
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_local.h
new file mode 100644
index 0000000..bb69883
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_local.h
@@ -0,0 +1,212 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DMA_LOCAL_H_INCLUDED__
+#define __DMA_LOCAL_H_INCLUDED__
+
+#include <type_support.h>
+#include "dma_global.h"
+
+#include <hrt/defs.h>				/* HRTCAT() */
+#include <hrt/bits.h>				/* _hrt_get_bits() */
+#include <hive_isp_css_defs.h>		/* HIVE_DMA_NUM_CHANNELS */
+#include <dma_v2_defs.h>
+
+#define _DMA_FSM_GROUP_CMD_IDX						_DMA_V2_FSM_GROUP_CMD_IDX
+#define _DMA_FSM_GROUP_ADDR_A_IDX					_DMA_V2_FSM_GROUP_ADDR_SRC_IDX
+#define _DMA_FSM_GROUP_ADDR_B_IDX					_DMA_V2_FSM_GROUP_ADDR_DEST_IDX
+
+#define _DMA_FSM_GROUP_CMD_CTRL_IDX					_DMA_V2_FSM_GROUP_CMD_CTRL_IDX
+
+#define _DMA_FSM_GROUP_FSM_CTRL_IDX					_DMA_V2_FSM_GROUP_FSM_CTRL_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_STATE_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_XB_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_XB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_REQ_YB_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_REQ_YB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX			_DMA_V2_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX	_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX
+#define _DMA_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX		_DMA_V2_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX
+
+#define _DMA_FSM_GROUP_FSM_PACK_IDX					_DMA_V2_FSM_GROUP_FSM_PACK_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_STATE_IDX			_DMA_V2_FSM_GROUP_FSM_PACK_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_CNT_YB_IDX			_DMA_V2_FSM_GROUP_FSM_PACK_CNT_YB_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX		_DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX
+#define _DMA_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX		_DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX
+
+#define _DMA_FSM_GROUP_FSM_REQ_IDX					_DMA_V2_FSM_GROUP_FSM_REQ_IDX
+#define _DMA_FSM_GROUP_FSM_REQ_STATE_IDX			_DMA_V2_FSM_GROUP_FSM_REQ_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_REQ_CNT_YB_IDX			_DMA_V2_FSM_GROUP_FSM_REQ_CNT_YB_IDX
+#define _DMA_FSM_GROUP_FSM_REQ_CNT_XB_IDX			_DMA_V2_FSM_GROUP_FSM_REQ_CNT_XB_IDX
+
+#define _DMA_FSM_GROUP_FSM_WR_IDX					_DMA_V2_FSM_GROUP_FSM_WR_IDX
+#define _DMA_FSM_GROUP_FSM_WR_STATE_IDX				_DMA_V2_FSM_GROUP_FSM_WR_STATE_IDX
+#define _DMA_FSM_GROUP_FSM_WR_CNT_YB_IDX			_DMA_V2_FSM_GROUP_FSM_WR_CNT_YB_IDX
+#define _DMA_FSM_GROUP_FSM_WR_CNT_XB_IDX			_DMA_V2_FSM_GROUP_FSM_WR_CNT_XB_IDX
+
+/*
+ * Macro's to compute the DMA parameter register indices
+ */
+#define DMA_SEL_COMP(comp)     (((comp)  & _hrt_ones(_DMA_V2_ADDR_SEL_COMP_BITS))            << _DMA_V2_ADDR_SEL_COMP_IDX)
+#define DMA_SEL_CH(ch)         (((ch)    & _hrt_ones(_DMA_V2_ADDR_SEL_CH_REG_BITS))          << _DMA_V2_ADDR_SEL_CH_REG_IDX)
+#define DMA_SEL_PARAM(param)   (((param) & _hrt_ones(_DMA_V2_ADDR_SEL_PARAM_BITS))           << _DMA_V2_ADDR_SEL_PARAM_IDX)
+/* CG = Connection Group */
+#define DMA_SEL_CG_INFO(info)  (((info)  & _hrt_ones(_DMA_V2_ADDR_SEL_GROUP_COMP_INFO_BITS)) << _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_IDX)
+#define DMA_SEL_CG_COMP(comp)  (((comp)  & _hrt_ones(_DMA_V2_ADDR_SEL_GROUP_COMP_BITS))      << _DMA_V2_ADDR_SEL_GROUP_COMP_IDX)
+#define DMA_SEL_DEV_INFO(info) (((info)  & _hrt_ones(_DMA_V2_ADDR_SEL_DEV_INTERF_INFO_BITS)) << _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_IDX)
+#define DMA_SEL_DEV_ID(dev)    (((dev)   & _hrt_ones(_DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS))  << _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX)
+
+#define DMA_COMMAND_FSM_REG_IDX					(DMA_SEL_COMP(_DMA_V2_SEL_FSM_CMD) >> 2)
+#define DMA_CHANNEL_PARAM_REG_IDX(ch, param)	((DMA_SEL_COMP(_DMA_V2_SEL_CH_REG) | DMA_SEL_CH(ch) | DMA_SEL_PARAM(param)) >> 2)
+#define DMA_CG_INFO_REG_IDX(info_id, comp_id)	((DMA_SEL_COMP(_DMA_V2_SEL_CONN_GROUP) | DMA_SEL_CG_INFO(info_id) | DMA_SEL_CG_COMP(comp_id)) >> 2)
+#define DMA_DEV_INFO_REG_IDX(info_id, dev_id)	((DMA_SEL_COMP(_DMA_V2_SEL_DEV_INTERF) | DMA_SEL_DEV_INFO(info_id) | DMA_SEL_DEV_ID(dev_id)) >> 2)
+#define DMA_RST_REG_IDX							(DMA_SEL_COMP(_DMA_V2_SEL_RESET) >> 2)
+
+#define DMA_GET_CONNECTION(val)    _hrt_get_bits(val, _DMA_V2_CONNECTION_IDX,    _DMA_V2_CONNECTION_BITS)
+#define DMA_GET_EXTENSION(val)     _hrt_get_bits(val, _DMA_V2_EXTENSION_IDX,     _DMA_V2_EXTENSION_BITS)
+#define DMA_GET_ELEMENTS(val)      _hrt_get_bits(val, _DMA_V2_ELEMENTS_IDX,      _DMA_V2_ELEMENTS_BITS)
+#define DMA_GET_CROPPING(val)      _hrt_get_bits(val, _DMA_V2_LEFT_CROPPING_IDX, _DMA_V2_LEFT_CROPPING_BITS)
+
+typedef enum {
+	DMA_CTRL_STATE_IDLE,
+	DMA_CTRL_STATE_REQ_RCV,
+	DMA_CTRL_STATE_RCV,
+	DMA_CTRL_STATE_RCV_REQ,
+	DMA_CTRL_STATE_INIT,
+	N_DMA_CTRL_STATES
+} dma_ctrl_states_t;
+
+typedef enum {
+	DMA_COMMAND_READ,
+	DMA_COMMAND_WRITE,
+	DMA_COMMAND_SET_CHANNEL,
+	DMA_COMMAND_SET_PARAM,
+	DMA_COMMAND_READ_SPECIFIC,
+	DMA_COMMAND_WRITE_SPECIFIC,
+	DMA_COMMAND_INIT,
+	DMA_COMMAND_INIT_SPECIFIC,
+	DMA_COMMAND_RST,
+	N_DMA_COMMANDS
+} dma_commands_t;
+
+typedef enum {
+	DMA_RW_STATE_IDLE,
+	DMA_RW_STATE_REQ,
+	DMA_RW_STATE_NEXT_LINE,
+	DMA_RW_STATE_UNLOCK_CHANNEL,
+	N_DMA_RW_STATES
+} dma_rw_states_t;
+
+typedef enum {
+	DMA_FIFO_STATE_WILL_BE_FULL,
+	DMA_FIFO_STATE_FULL,
+	DMA_FIFO_STATE_EMPTY,
+	N_DMA_FIFO_STATES
+} dma_fifo_states_t;
+
+/* typedef struct dma_state_s			dma_state_t; */
+typedef struct dma_channel_state_s	dma_channel_state_t;
+typedef struct dma_port_state_s		dma_port_state_t;
+
+struct dma_port_state_s {
+	bool                       req_cs;
+	bool                       req_we_n;
+	bool                       req_run;
+	bool                       req_ack;
+	bool                       send_cs;
+	bool                       send_we_n;
+	bool                       send_run;
+	bool                       send_ack;
+	dma_fifo_states_t          fifo_state;
+	int                        fifo_counter;
+};
+
+struct dma_channel_state_s {
+	int                        connection;
+	bool                       sign_extend;
+	int                        height;
+	int                        stride_a;
+	int                        elems_a;
+	int                        cropping_a;
+	int                        width_a;
+	int                        stride_b;
+	int                        elems_b;
+	int                        cropping_b;
+	int                        width_b;
+};
+
+struct dma_state_s {
+	bool                       fsm_command_idle;
+	bool                       fsm_command_run;
+	bool                       fsm_command_stalling;
+	bool                       fsm_command_error;
+	dma_commands_t             last_command;
+	int                        last_command_channel;
+	int                        last_command_param;
+	dma_commands_t             current_command;
+	int                        current_addr_a;
+	int                        current_addr_b;
+	bool                       fsm_ctrl_idle;
+	bool                       fsm_ctrl_run;
+	bool                       fsm_ctrl_stalling;
+	bool                       fsm_ctrl_error;
+	dma_ctrl_states_t          fsm_ctrl_state;
+	int                        fsm_ctrl_source_dev;
+	int                        fsm_ctrl_source_addr;
+	int                        fsm_ctrl_source_stride;
+	int                        fsm_ctrl_source_width;
+	int                        fsm_ctrl_source_height;
+	int                        fsm_ctrl_pack_source_dev;
+	int                        fsm_ctrl_pack_dest_dev;
+	int                        fsm_ctrl_dest_addr;
+	int                        fsm_ctrl_dest_stride;
+	int                        fsm_ctrl_pack_source_width;
+	int                        fsm_ctrl_pack_dest_height;
+	int                        fsm_ctrl_pack_dest_width;
+	int                        fsm_ctrl_pack_source_elems;
+	int                        fsm_ctrl_pack_dest_elems;
+	int                        fsm_ctrl_pack_extension;
+	int						   pack_idle;
+	int	                       pack_run;
+	int		               	   pack_stalling;
+	int		                   pack_error;
+	int                        pack_cnt_height;
+	int                        pack_src_cnt_width;
+	int                        pack_dest_cnt_width;
+	dma_rw_states_t            read_state;
+	int                        read_cnt_height;
+	int                        read_cnt_width;
+	dma_rw_states_t            write_state;
+	int                        write_height;
+	int                        write_width;
+	dma_port_state_t           port_states[HIVE_ISP_NUM_DMA_CONNS];
+	dma_channel_state_t        channel_states[HIVE_DMA_NUM_CHANNELS];
+};
+
+#endif /* __DMA_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_private.h
new file mode 100644
index 0000000..d99448e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/dma_private.h
@@ -0,0 +1,51 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DMA_PRIVATE_H_INCLUDED__
+#define __DMA_PRIVATE_H_INCLUDED__
+
+#include "dma_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_DMA_C void dma_reg_store(
+	const dma_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+assert(ID < N_DMA_ID);
+assert(DMA_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(DMA_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_DMA_C hrt_data dma_reg_load(
+	const dma_ID_t		ID,
+	const unsigned int	reg)
+{
+assert(ID < N_DMA_ID);
+assert(DMA_BASE[ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(DMA_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __DMA_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_fifo.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_fifo.c
new file mode 100644
index 0000000..3c9b4fd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_fifo.c
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+
+#include "event_fifo.h"
+
+#ifndef __INLINE_EVENT__
+#include "event_fifo_private.h"
+#endif /* __INLINE_EVENT__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_fifo_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_fifo_local.h
new file mode 100644
index 0000000..3d2e8fb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_fifo_local.h
@@ -0,0 +1,64 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _EVENT_FIFO_LOCAL_H
+#define _EVENT_FIFO_LOCAL_H
+
+/*
+ * All events come from connections mapped on the system
+ * bus but do not use a global IRQ
+ */
+#include "event_fifo_global.h"
+
+typedef enum {
+	SP0_EVENT_ID,
+	ISP0_EVENT_ID,
+	STR2MIPI_EVENT_ID,
+	N_EVENT_ID
+} event_ID_t;
+
+#define	EVENT_QUERY_BIT		0
+
+/* Events are read from FIFO */
+static const hrt_address event_source_addr[N_EVENT_ID] = {
+	0x0000000000380000ULL,
+	0x0000000000380004ULL,
+	0xffffffffffffffffULL};
+
+/* Read from FIFO are blocking, query data availability */
+static const hrt_address event_source_query_addr[N_EVENT_ID] = {
+	0x0000000000380010ULL,
+	0x0000000000380014ULL,
+	0xffffffffffffffffULL};
+
+/* Events are written to FIFO */
+static const hrt_address event_sink_addr[N_EVENT_ID] = {
+	0x0000000000380008ULL,
+	0x000000000038000CULL,
+	0x0000000000090104ULL};
+
+/* Writes to FIFO are blocking, query data space */
+static const hrt_address event_sink_query_addr[N_EVENT_ID] = {
+	0x0000000000380018ULL,
+	0x000000000038001CULL,
+	0x000000000009010CULL};
+
+#endif /* _EVENT_FIFO_LOCAL_H */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_fifo_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_fifo_private.h
new file mode 100644
index 0000000..a22678b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/event_fifo_private.h
@@ -0,0 +1,90 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __EVENT_FIFO_PRIVATE_H
+#define __EVENT_FIFO_PRIVATE_H
+
+#include "event_fifo_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+#include <hrt/bits.h>			/* _hrt_get_bits() */
+
+STORAGE_CLASS_EVENT_C void event_wait_for(
+	const event_ID_t		ID)
+{
+assert(ID < N_EVENT_ID);
+assert(event_source_addr[ID] != ((hrt_address)-1));
+	(void)ia_css_device_load_uint32(event_source_addr[ID]);
+return;
+}
+
+STORAGE_CLASS_EVENT_C void cnd_event_wait_for(
+	const event_ID_t		ID,
+	const bool				cnd)
+{
+	if (cnd) {
+		event_wait_for(ID);
+	}
+return;
+}
+
+STORAGE_CLASS_EVENT_C hrt_data event_receive_token(
+	const event_ID_t		ID)
+{
+assert(ID < N_EVENT_ID);
+assert(event_source_addr[ID] != ((hrt_address)-1));
+return ia_css_device_load_uint32(event_source_addr[ID]);
+}
+
+STORAGE_CLASS_EVENT_C void event_send_token(
+	const event_ID_t		ID,
+	const hrt_data			token)
+{
+assert(ID < N_EVENT_ID);
+assert(event_sink_addr[ID] != ((hrt_address)-1));
+	ia_css_device_store_uint32(event_sink_addr[ID], token);
+return;
+}
+
+STORAGE_CLASS_EVENT_C bool is_event_pending(
+	const event_ID_t		ID)
+{
+	hrt_data	value;
+assert(ID < N_EVENT_ID);
+assert(event_source_query_addr[ID] != ((hrt_address)-1));
+	value = ia_css_device_load_uint32(event_source_query_addr[ID]);
+return !_hrt_get_bit(value, EVENT_QUERY_BIT);
+}
+
+STORAGE_CLASS_EVENT_C bool can_event_send_token(
+	const event_ID_t		ID)
+{
+	hrt_data	value;
+assert(ID < N_EVENT_ID);
+assert(event_sink_query_addr[ID] != ((hrt_address)-1));
+	value = ia_css_device_load_uint32(event_sink_query_addr[ID]);
+return !_hrt_get_bit(value, EVENT_QUERY_BIT);
+}
+
+#endif /* __EVENT_FIFO_PRIVATE_H */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor.c
new file mode 100644
index 0000000..f6d08b4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor.c
@@ -0,0 +1,574 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "fifo_monitor.h"
+
+#include <type_support.h>
+#include "device_access.h"
+
+#include <hrt/bits.h>
+
+#include "gp_device.h"
+
+#include "assert_support.h"
+
+#ifndef __INLINE_FIFO_MONITOR__
+#define STORAGE_CLASS_FIFO_MONITOR_DATA static const
+#else
+#define STORAGE_CLASS_FIFO_MONITOR_DATA const
+#endif /* __INLINE_FIFO_MONITOR__ */
+
+STORAGE_CLASS_FIFO_MONITOR_DATA unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH] = {
+	_REG_GP_SWITCH_IF_ADDR,
+	_REG_GP_SWITCH_GDC1_ADDR,
+	_REG_GP_SWITCH_GDC2_ADDR};
+
+#ifndef __INLINE_FIFO_MONITOR__
+#include "fifo_monitor_private.h"
+#endif /* __INLINE_FIFO_MONITOR__ */
+
+STORAGE_CLASS_INLINE bool fifo_monitor_status_valid (
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const unsigned int			port_id);
+
+STORAGE_CLASS_INLINE bool fifo_monitor_status_accept(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const unsigned int			port_id);
+
+
+void fifo_channel_get_state(
+	const fifo_monitor_ID_t		ID,
+	const fifo_channel_t		channel_id,
+	fifo_channel_state_t		*state)
+{
+	assert(channel_id < N_FIFO_CHANNEL);
+	assert(state != NULL);
+
+	switch (channel_id) {
+	case FIFO_CHANNEL_ISP0_TO_SP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_SP); /* ISP_STR_MON_PORT_ISP2SP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_SP);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_ISP); /* ISP_STR_MON_PORT_SP2ISP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_ISP);
+		break;
+	case FIFO_CHANNEL_SP0_TO_ISP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_ISP); /* ISP_STR_MON_PORT_SP2ISP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_ISP);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_SP); /* ISP_STR_MON_PORT_ISP2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_SP);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_IF0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_A); /* ISP_STR_MON_PORT_ISP2PIFA */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A); /* MOD_STR_MON_PORT_CELLS2PIFA */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A);
+		break;
+	case FIFO_CHANNEL_IF0_TO_ISP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A); /* MOD_STR_MON_PORT_PIFA2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_A); /* ISP_STR_MON_PORT_PIFA2ISP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_A);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_IF1:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_B); /* ISP_STR_MON_PORT_ISP2PIFA */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B); /* MOD_STR_MON_PORT_CELLS2PIFB */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B);
+		break;
+	case FIFO_CHANNEL_IF1_TO_ISP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B); /* MOD_STR_MON_PORT_PIFB2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B); /* ISP_STR_MON_PORT_PIFB2ISP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_DMA0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_DMA); /* ISP_STR_MON_PORT_ISP2DMA */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_DMA);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_ISP); /* MOD_STR_MON_PORT_ISP2DMA */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_ISP);
+		break;
+	case FIFO_CHANNEL_DMA0_TO_ISP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2ISP); /* MOD_STR_MON_PORT_DMA2ISP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2ISP);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_DMA); /* ISP_STR_MON_PORT_DMA2ISP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_DMA);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_GDC0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GDC); /* ISP_STR_MON_PORT_ISP2GDC1 */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GDC);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_GDC); /* MOD_STR_MON_PORT_CELLS2GDC1 */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_GDC);
+		break;
+	case FIFO_CHANNEL_GDC0_TO_ISP0:
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_GDC); /* MOD_STR_MON_PORT_GDC12CELLS */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_GDC);
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GDC); /* ISP_STR_MON_PORT_GDC12ISP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GDC);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_GDC1:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_ISP2GDC2);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_ISP2GDC2);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
+		break;
+	case FIFO_CHANNEL_GDC1_TO_ISP0:
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_GDC22ISP);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_GDC22ISP);
+		break;
+	case FIFO_CHANNEL_ISP0_TO_HOST0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GPD); /* ISP_STR_MON_PORT_ISP2GPD */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_SND_GPD);
+		{
+		hrt_data	value = ia_css_device_load_uint32(0x0000000000380014ULL);
+		state->fifo_valid  = !_hrt_get_bit(value, 0);
+		state->sink_accept = false; /* no monitor connected */
+		}
+		break;
+	case FIFO_CHANNEL_HOST0_TO_ISP0:
+		{
+		hrt_data	value = ia_css_device_load_uint32(0x000000000038001CULL);
+		state->fifo_valid  = false; /* no monitor connected */
+		state->sink_accept = !_hrt_get_bit(value, 0);
+		}
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GPD); /* ISP_STR_MON_PORT_FA2ISP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_GPD);
+		break;
+	case FIFO_CHANNEL_SP0_TO_IF0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_A); /* SP_STR_MON_PORT_SP2PIFA */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A); /* MOD_STR_MON_PORT_CELLS2PIFA */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_A);
+		break;
+	case FIFO_CHANNEL_IF0_TO_SP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A); /* MOD_STR_MON_PORT_PIFA2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_A);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_PIF_A); /* SP_STR_MON_PORT_PIFA2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_PIF_A);
+		break;
+	case FIFO_CHANNEL_SP0_TO_IF1:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_B); /* SP_STR_MON_PORT_SP2PIFB */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B); /* MOD_STR_MON_PORT_CELLS2PIFB */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_PIF_B);
+		break;
+	case FIFO_CHANNEL_IF1_TO_SP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B); /* MOD_STR_MON_PORT_PIFB2CELLS */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_PIF_B);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B); /* SP_STR_MON_PORT_PIFB2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			ISP_STR_MON_PORT_RCV_PIF_B);
+		break;
+	case FIFO_CHANNEL_SP0_TO_IF2:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_SIF); /* SP_STR_MON_PORT_SP2SIF */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_SIF);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_SIF); /* MOD_STR_MON_PORT_SP2SIF */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_SIF);
+		break;
+	case FIFO_CHANNEL_IF2_TO_SP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_SIF); /* MOD_STR_MON_PORT_SIF2SP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_SIF);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_SIF); /* SP_STR_MON_PORT_SIF2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_SIF);
+		break;
+	case FIFO_CHANNEL_SP0_TO_DMA0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_DMA); /* SP_STR_MON_PORT_SP2DMA */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_DMA);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_SP); /* MOD_STR_MON_PORT_SP2DMA */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_DMA_FR_SP);
+		break;
+	case FIFO_CHANNEL_DMA0_TO_SP0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2SP); /* MOD_STR_MON_PORT_DMA2SP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_DMA2SP);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_DMA); /* SP_STR_MON_PORT_DMA2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_DMA);
+		break;
+	case FIFO_CHANNEL_SP0_TO_GDC0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC1);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC1);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC1);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC1);
+		break;
+	case FIFO_CHANNEL_GDC0_TO_SP0:
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC12CELLS);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC12CELLS);
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC12SP);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC12SP);
+		break;
+	case FIFO_CHANNEL_SP0_TO_GDC1:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC2);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_SP2GDC2);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_CELLS2GDC2);
+		break;
+	case FIFO_CHANNEL_GDC1_TO_SP0:
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_GDC22CELLS);
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC22SP);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_B_IDX,
+			SP_STR_MON_PORT_B_GDC22SP);
+		break;
+	case FIFO_CHANNEL_SP0_TO_HOST0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_GPD); /* SP_STR_MON_PORT_SP2GPD */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_GPD);
+		{
+		hrt_data	value = ia_css_device_load_uint32(0x0000000000380010ULL);
+		state->fifo_valid  = !_hrt_get_bit(value, 0);
+		state->sink_accept = false; /* no monitor connected */
+		}
+		break;
+	case FIFO_CHANNEL_HOST0_TO_SP0:
+		{
+		hrt_data	value = ia_css_device_load_uint32(0x0000000000380018ULL);
+		state->fifo_valid  = false; /* no monitor connected */
+		state->sink_accept = !_hrt_get_bit(value, 0);
+		}
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_GPD); /* SP_STR_MON_PORT_FA2SP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_GPD);
+		break;
+	case FIFO_CHANNEL_SP0_TO_STREAM2MEM0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_MC); /* SP_STR_MON_PORT_SP2MC */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SND_MC);
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_MC); /* MOD_STR_MON_PORT_SP2MC */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_RCV_MC);
+		break;
+	case FIFO_CHANNEL_STREAM2MEM0_TO_SP0:
+		state->fifo_valid  = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_MC); /* SP_STR_MON_PORT_MC2SP */
+		state->sink_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
+			MOD_STR_MON_PORT_SND_MC);
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_MC); /* MOD_STR_MON_PORT_MC2SP */
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_RCV_MC);
+		break;
+	case FIFO_CHANNEL_SP0_TO_INPUT_SYSTEM0:
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SP2ISYS);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_SP2ISYS);
+		state->fifo_valid  = false;
+		state->sink_accept = false;
+		break;
+	case FIFO_CHANNEL_INPUT_SYSTEM0_TO_SP0:
+		state->fifo_valid  = false;
+		state->sink_accept = false;
+		state->src_valid   = fifo_monitor_status_valid(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_ISYS2SP);
+		state->fifo_accept = fifo_monitor_status_accept(ID,
+			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
+			SP_STR_MON_PORT_ISYS2SP);
+		break;
+	default:
+		assert(0);
+		break;
+	}
+
+	return;
+}
+
+void fifo_switch_get_state(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id,
+	fifo_switch_state_t			*state)
+{
+	hrt_data		data = (hrt_data)-1;
+
+	assert(ID == FIFO_MONITOR0_ID);
+	assert(switch_id < N_FIFO_SWITCH);
+	assert(state != NULL);
+
+	(void)ID;
+
+	data = gp_device_reg_load(GP_DEVICE0_ID, FIFO_SWITCH_ADDR[switch_id]);
+
+	state->is_none = (data == HIVE_ISP_CSS_STREAM_SWITCH_NONE);
+	state->is_sp = (data == HIVE_ISP_CSS_STREAM_SWITCH_SP);
+	state->is_isp = (data == HIVE_ISP_CSS_STREAM_SWITCH_ISP);
+
+	return;
+}
+
+void fifo_monitor_get_state(
+	const fifo_monitor_ID_t		ID,
+	fifo_monitor_state_t		*state)
+{
+	fifo_channel_t	ch_id;
+	fifo_switch_t	sw_id;
+
+	assert(ID < N_FIFO_MONITOR_ID);
+	assert(state != NULL);
+
+	for (ch_id = 0; ch_id < N_FIFO_CHANNEL; ch_id++) {
+		fifo_channel_get_state(ID, ch_id,
+			&(state->fifo_channels[ch_id]));
+	}
+
+	for (sw_id = 0; sw_id < N_FIFO_SWITCH; sw_id++) {
+		fifo_switch_get_state(ID, sw_id,
+			&(state->fifo_switches[sw_id]));
+	}
+	return;
+}
+
+STORAGE_CLASS_INLINE bool fifo_monitor_status_valid (
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const unsigned int			port_id)
+{
+	hrt_data	data = fifo_monitor_reg_load(ID, reg);
+
+	return (data >> (((port_id * 2) + _hive_str_mon_valid_offset))) & 0x1;
+}
+
+STORAGE_CLASS_INLINE bool fifo_monitor_status_accept(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const unsigned int			port_id)
+{
+	hrt_data	data = fifo_monitor_reg_load(ID, reg);
+
+	return (data >> (((port_id * 2) + _hive_str_mon_accept_offset))) & 0x1;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_local.h
new file mode 100644
index 0000000..3239eae
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_local.h
@@ -0,0 +1,106 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __FIFO_MONITOR_LOCAL_H_INCLUDED__
+#define __FIFO_MONITOR_LOCAL_H_INCLUDED__
+
+#include <type_support.h>
+#include "fifo_monitor_global.h"
+
+#include "hive_isp_css_defs.h"	/* ISP_STR_MON_PORT_SND_SP, ... */
+
+#define _hive_str_mon_valid_offset   0
+#define _hive_str_mon_accept_offset  1
+
+#define	FIFO_CHANNEL_SP_VALID_MASK		0x55555555
+#define	FIFO_CHANNEL_SP_VALID_B_MASK	0x00000055
+#define	FIFO_CHANNEL_ISP_VALID_MASK		0x15555555
+#define	FIFO_CHANNEL_MOD_VALID_MASK		0x55555555
+
+typedef enum fifo_switch {
+	FIFO_SWITCH_IF,
+	FIFO_SWITCH_GDC0,
+	FIFO_SWITCH_GDC1,
+	N_FIFO_SWITCH
+} fifo_switch_t;
+
+typedef enum fifo_channel {
+	FIFO_CHANNEL_ISP0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_IF0,
+	FIFO_CHANNEL_IF0_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_IF1,
+	FIFO_CHANNEL_IF1_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_DMA0,
+	FIFO_CHANNEL_DMA0_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_GDC0,
+	FIFO_CHANNEL_GDC0_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_GDC1,
+	FIFO_CHANNEL_GDC1_TO_ISP0,
+	FIFO_CHANNEL_ISP0_TO_HOST0,
+	FIFO_CHANNEL_HOST0_TO_ISP0,
+	FIFO_CHANNEL_SP0_TO_IF0,
+	FIFO_CHANNEL_IF0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_IF1,
+	FIFO_CHANNEL_IF1_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_IF2,
+	FIFO_CHANNEL_IF2_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_DMA0,
+	FIFO_CHANNEL_DMA0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_GDC0,
+	FIFO_CHANNEL_GDC0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_GDC1,
+	FIFO_CHANNEL_GDC1_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_HOST0,
+	FIFO_CHANNEL_HOST0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_STREAM2MEM0,
+	FIFO_CHANNEL_STREAM2MEM0_TO_SP0,
+	FIFO_CHANNEL_SP0_TO_INPUT_SYSTEM0,
+	FIFO_CHANNEL_INPUT_SYSTEM0_TO_SP0,
+/*
+ * No clue what this is
+ *
+	FIFO_CHANNEL_SP0_TO_IRQ0,
+	FIFO_CHANNEL_IRQ0_TO_SP0,
+ */
+	N_FIFO_CHANNEL
+} fifo_channel_t;
+
+struct fifo_channel_state_s {
+	bool	src_valid;
+	bool	fifo_accept;
+	bool	fifo_valid;
+	bool	sink_accept;
+};
+
+/* The switch is tri-state */
+struct fifo_switch_state_s {
+	bool	is_none;
+	bool	is_isp;
+	bool	is_sp;
+};
+
+struct fifo_monitor_state_s {
+	struct fifo_channel_state_s	fifo_channels[N_FIFO_CHANNEL];
+	struct fifo_switch_state_s	fifo_switches[N_FIFO_SWITCH];
+};
+
+#endif /* __FIFO_MONITOR_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_private.h
new file mode 100644
index 0000000..b7d24ff
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/fifo_monitor_private.h
@@ -0,0 +1,86 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __FIFO_MONITOR_PRIVATE_H_INCLUDED__
+#define __FIFO_MONITOR_PRIVATE_H_INCLUDED__
+
+#include "fifo_monitor_public.h"
+
+#define __INLINE_GP_DEVICE__
+#include "gp_device.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+#ifdef __INLINE_FIFO_MONITOR__
+extern const unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH];
+#endif
+
+STORAGE_CLASS_FIFO_MONITOR_C void fifo_switch_set(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id,
+	const hrt_data				sel)
+{
+assert(ID == FIFO_MONITOR0_ID);
+assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
+assert(switch_id < N_FIFO_SWITCH);
+	(void)ID;
+
+	gp_device_reg_store(GP_DEVICE0_ID, FIFO_SWITCH_ADDR[switch_id], sel);
+
+return;
+}
+
+STORAGE_CLASS_FIFO_MONITOR_C hrt_data fifo_switch_get(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id)
+{
+assert(ID == FIFO_MONITOR0_ID);
+assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
+assert(switch_id < N_FIFO_SWITCH);
+	(void)ID;
+
+return gp_device_reg_load(GP_DEVICE0_ID, FIFO_SWITCH_ADDR[switch_id]);
+}
+
+
+STORAGE_CLASS_FIFO_MONITOR_C void fifo_monitor_reg_store(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const hrt_data				value)
+{
+assert(ID < N_FIFO_MONITOR_ID);
+assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(FIFO_MONITOR_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_FIFO_MONITOR_C hrt_data fifo_monitor_reg_load(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg)
+{
+assert(ID < N_FIFO_MONITOR_ID);
+assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(FIFO_MONITOR_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __FIFO_MONITOR_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc.c
new file mode 100644
index 0000000..4743c9c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc.c
@@ -0,0 +1,102 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+
+/* The name "gdc.h is already taken" */
+#include "gdc_device.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+/*
+ * Local function declarations
+ */
+STORAGE_CLASS_INLINE void gdc_reg_store(
+	const gdc_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+STORAGE_CLASS_INLINE hrt_data gdc_reg_load(
+	const gdc_ID_t		ID,
+	const unsigned int	reg);
+
+
+#ifndef __INLINE_GDC__
+#include "gdc_private.h"
+#endif /* __INLINE_GDC__ */
+
+/*
+ * Exported function implementations
+ */
+void gdc_lut_store(
+	const gdc_ID_t		ID,
+	const int			data[4][HRT_GDC_N])
+{
+	unsigned int i, lut_offset = HRT_GDC_LUT_IDX;
+
+	assert(ID < N_GDC_ID);
+	assert(HRT_GDC_LUT_COEFF_OFFSET <= (4*sizeof(hrt_data)));
+
+	for (i = 0; i < HRT_GDC_N; i++) {
+		hrt_data	entry_0 = data[0][i] & HRT_GDC_BCI_COEF_MASK;
+		hrt_data	entry_1 = data[1][i] & HRT_GDC_BCI_COEF_MASK;
+		hrt_data	entry_2 = data[2][i] & HRT_GDC_BCI_COEF_MASK;
+		hrt_data	entry_3 = data[3][i] & HRT_GDC_BCI_COEF_MASK;
+
+		hrt_data	word_0 = entry_0 |
+			(entry_1 << HRT_GDC_LUT_COEFF_OFFSET);
+		hrt_data	word_1 = entry_2 |
+			(entry_3 << HRT_GDC_LUT_COEFF_OFFSET);
+
+		gdc_reg_store(ID, lut_offset++, word_0);
+		gdc_reg_store(ID, lut_offset++, word_1);
+	}
+return;
+}
+
+int gdc_get_unity(
+	const gdc_ID_t		ID)
+{
+	assert(ID < N_GDC_ID);
+	(void)ID;
+return (int)(1UL << HRT_GDC_FRAC_BITS);
+}
+
+
+/*
+ * Local function implementations
+ */
+STORAGE_CLASS_INLINE void gdc_reg_store(
+	const gdc_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+	ia_css_device_store_uint32(GDC_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_INLINE hrt_data gdc_reg_load(
+	const gdc_ID_t		ID,
+	const unsigned int	reg)
+{
+return ia_css_device_load_uint32(GDC_BASE[ID] + reg*sizeof(hrt_data));
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_local.h
new file mode 100644
index 0000000..adfb119
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_local.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GDC_LOCAL_H_INCLUDED__
+#define __GDC_LOCAL_H_INCLUDED__
+
+#include "gdc_global.h"
+
+#endif /* __GDC_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_private.h
new file mode 100644
index 0000000..e4632b2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gdc_private.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GDC_PRIVATE_H_INCLUDED__
+#define __GDC_PRIVATE_H_INCLUDED__
+
+#include "gdc_public.h"
+
+#endif /* __GDC_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device.c
new file mode 100644
index 0000000..badaffa
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device.c
@@ -0,0 +1,115 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "assert_support.h"
+#include "gp_device.h"
+
+#ifndef __INLINE_GP_DEVICE__
+#include "gp_device_private.h"
+#endif /* __INLINE_GP_DEVICE__ */
+
+void gp_device_get_state(
+	const gp_device_ID_t		ID,
+	gp_device_state_t			*state)
+{
+	assert(ID < N_GP_DEVICE_ID);
+	assert(state != NULL);
+
+	state->syncgen_enable = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_ENABLE_ADDR);
+	state->syncgen_free_running = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_FREE_RUNNING_ADDR);
+	state->syncgen_pause = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_PAUSE_ADDR);
+	state->nr_frames = gp_device_reg_load(ID,
+		_REG_GP_NR_FRAMES_ADDR);
+	state->syngen_nr_pix = gp_device_reg_load(ID,
+		_REG_GP_SYNGEN_NR_PIX_ADDR);
+	state->syngen_nr_pix = gp_device_reg_load(ID,
+		_REG_GP_SYNGEN_NR_PIX_ADDR);
+	state->syngen_nr_lines = gp_device_reg_load(ID,
+		_REG_GP_SYNGEN_NR_LINES_ADDR);
+	state->syngen_hblank_cycles = gp_device_reg_load(ID,
+		_REG_GP_SYNGEN_HBLANK_CYCLES_ADDR);
+	state->syngen_vblank_cycles = gp_device_reg_load(ID,
+		_REG_GP_SYNGEN_VBLANK_CYCLES_ADDR);
+	state->isel_sof = gp_device_reg_load(ID,
+		_REG_GP_ISEL_SOF_ADDR);
+	state->isel_eof = gp_device_reg_load(ID,
+		_REG_GP_ISEL_EOF_ADDR);
+	state->isel_sol = gp_device_reg_load(ID,
+		_REG_GP_ISEL_SOL_ADDR);
+	state->isel_eol = gp_device_reg_load(ID,
+		_REG_GP_ISEL_EOL_ADDR);
+	state->isel_lfsr_enable = gp_device_reg_load(ID,
+		_REG_GP_ISEL_LFSR_ENABLE_ADDR);
+	state->isel_lfsr_enable_b = gp_device_reg_load(ID,
+		_REG_GP_ISEL_LFSR_ENABLE_B_ADDR);
+	state->isel_lfsr_reset_value = gp_device_reg_load(ID,
+		_REG_GP_ISEL_LFSR_RESET_VALUE_ADDR);
+	state->isel_tpg_enable = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_ENABLE_ADDR);
+	state->isel_tpg_enable_b = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_ENABLE_B_ADDR);
+	state->isel_hor_cnt_mask = gp_device_reg_load(ID,
+		_REG_GP_ISEL_HOR_CNT_MASK_ADDR);
+	state->isel_ver_cnt_mask = gp_device_reg_load(ID,
+		_REG_GP_ISEL_VER_CNT_MASK_ADDR);
+	state->isel_xy_cnt_mask = gp_device_reg_load(ID,
+		_REG_GP_ISEL_XY_CNT_MASK_ADDR);
+	state->isel_hor_cnt_delta = gp_device_reg_load(ID,
+		_REG_GP_ISEL_HOR_CNT_DELTA_ADDR);
+	state->isel_ver_cnt_delta = gp_device_reg_load(ID,
+		_REG_GP_ISEL_VER_CNT_DELTA_ADDR);
+	state->isel_tpg_mode = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_MODE_ADDR);
+	state->isel_tpg_red1 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_RED1_ADDR);
+	state->isel_tpg_green1 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_GREEN1_ADDR);
+	state->isel_tpg_blue1 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_BLUE1_ADDR);
+	state->isel_tpg_red2 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_RED2_ADDR);
+	state->isel_tpg_green2 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_GREEN2_ADDR);
+	state->isel_tpg_blue2 = gp_device_reg_load(ID,
+		_REG_GP_ISEL_TPG_BLUE2_ADDR);
+	state->isel_ch_id = gp_device_reg_load(ID,
+		_REG_GP_ISEL_CH_ID_ADDR);
+	state->isel_fmt_type = gp_device_reg_load(ID,
+		_REG_GP_ISEL_FMT_TYPE_ADDR);
+	state->isel_data_sel = gp_device_reg_load(ID,
+		_REG_GP_ISEL_DATA_SEL_ADDR);
+	state->isel_sband_sel = gp_device_reg_load(ID,
+		_REG_GP_ISEL_SBAND_SEL_ADDR);
+	state->isel_sync_sel = gp_device_reg_load(ID,
+		_REG_GP_ISEL_SYNC_SEL_ADDR);
+	state->syncgen_hor_cnt = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_HOR_CNT_ADDR);
+	state->syncgen_ver_cnt = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_VER_CNT_ADDR);
+	state->syncgen_frame_cnt = gp_device_reg_load(ID,
+		_REG_GP_SYNCGEN_FRAME_CNT_ADDR);
+	state->soft_reset = gp_device_reg_load(ID,
+		_REG_GP_SOFT_RESET_ADDR);
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_local.h
new file mode 100644
index 0000000..d021af7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_local.h
@@ -0,0 +1,150 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GP_DEVICE_LOCAL_H_INCLUDED__
+#define __GP_DEVICE_LOCAL_H_INCLUDED__
+
+#include "gp_device_global.h"
+
+/* @ GP_REGS_BASE -> GP_DEVICE_BASE */
+#define _REG_GP_SDRAM_WAKEUP_ADDR					0x00
+#define _REG_GP_IDLE_ADDR							0x04
+/* #define _REG_GP_IRQ_REQ0_ADDR					0x08 */
+/* #define _REG_GP_IRQ_REQ1_ADDR					0x0C */
+#define _REG_GP_SP_STREAM_STAT_ADDR					0x10
+#define _REG_GP_SP_STREAM_STAT_B_ADDR				0x14
+#define _REG_GP_ISP_STREAM_STAT_ADDR				0x18
+#define _REG_GP_MOD_STREAM_STAT_ADDR				0x1C
+#define _REG_GP_SP_STREAM_STAT_IRQ_COND_ADDR		0x20
+#define _REG_GP_SP_STREAM_STAT_B_IRQ_COND_ADDR		0x24
+#define _REG_GP_ISP_STREAM_STAT_IRQ_COND_ADDR		0x28
+#define _REG_GP_MOD_STREAM_STAT_IRQ_COND_ADDR		0x2C
+#define _REG_GP_SP_STREAM_STAT_IRQ_ENABLE_ADDR		0x30
+#define _REG_GP_SP_STREAM_STAT_B_IRQ_ENABLE_ADDR	0x34
+#define _REG_GP_ISP_STREAM_STAT_IRQ_ENABLE_ADDR		0x38
+#define _REG_GP_MOD_STREAM_STAT_IRQ_ENABLE_ADDR		0x3C
+/*
+#define _REG_GP_SWITCH_IF_ADDR						0x40
+#define _REG_GP_SWITCH_GDC1_ADDR					0x44
+#define _REG_GP_SWITCH_GDC2_ADDR					0x48
+*/
+#define _REG_GP_SLV_REG_RST_ADDR					0x50
+#define _REG_GP_SWITCH_ISYS2401_ADDR				0x54
+
+/* @ INPUT_FORMATTER_BASE -> GP_DEVICE_BASE */
+/*
+#define _REG_GP_IFMT_input_switch_lut_reg0			0x00030800
+#define _REG_GP_IFMT_input_switch_lut_reg1			0x00030804
+#define _REG_GP_IFMT_input_switch_lut_reg2			0x00030808
+#define _REG_GP_IFMT_input_switch_lut_reg3			0x0003080C
+#define _REG_GP_IFMT_input_switch_lut_reg4			0x00030810
+#define _REG_GP_IFMT_input_switch_lut_reg5			0x00030814
+#define _REG_GP_IFMT_input_switch_lut_reg6			0x00030818
+#define _REG_GP_IFMT_input_switch_lut_reg7			0x0003081C
+#define _REG_GP_IFMT_input_switch_fsync_lut			0x00030820
+#define _REG_GP_IFMT_srst							0x00030824
+#define _REG_GP_IFMT_slv_reg_srst					0x00030828
+#define _REG_GP_IFMT_input_switch_ch_id_fmt_type	0x0003082C
+*/
+/* @ GP_DEVICE_BASE */
+/*
+#define _REG_GP_SYNCGEN_ENABLE_ADDR					0x00090000
+#define _REG_GP_SYNCGEN_FREE_RUNNING_ADDR			0x00090004
+#define _REG_GP_SYNCGEN_PAUSE_ADDR					0x00090008
+#define _REG_GP_NR_FRAMES_ADDR						0x0009000C
+#define _REG_GP_SYNGEN_NR_PIX_ADDR					0x00090010
+#define _REG_GP_SYNGEN_NR_LINES_ADDR				0x00090014
+#define _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR			0x00090018
+#define _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR			0x0009001C
+#define _REG_GP_ISEL_SOF_ADDR						0x00090020
+#define _REG_GP_ISEL_EOF_ADDR						0x00090024
+#define _REG_GP_ISEL_SOL_ADDR						0x00090028
+#define _REG_GP_ISEL_EOL_ADDR						0x0009002C
+#define _REG_GP_ISEL_LFSR_ENABLE_ADDR				0x00090030
+#define _REG_GP_ISEL_LFSR_ENABLE_B_ADDR				0x00090034
+#define _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR			0x00090038
+#define _REG_GP_ISEL_TPG_ENABLE_ADDR				0x0009003C
+#define _REG_GP_ISEL_TPG_ENABLE_B_ADDR				0x00090040
+#define _REG_GP_ISEL_HOR_CNT_MASK_ADDR				0x00090044
+#define _REG_GP_ISEL_VER_CNT_MASK_ADDR				0x00090048
+#define _REG_GP_ISEL_XY_CNT_MASK_ADDR				0x0009004C
+#define _REG_GP_ISEL_HOR_CNT_DELTA_ADDR				0x00090050
+#define _REG_GP_ISEL_VER_CNT_DELTA_ADDR				0x00090054
+#define _REG_GP_ISEL_TPG_MODE_ADDR					0x00090058
+#define _REG_GP_ISEL_TPG_RED1_ADDR					0x0009005C
+#define _REG_GP_ISEL_TPG_GREEN1_ADDR				0x00090060
+#define _REG_GP_ISEL_TPG_BLUE1_ADDR					0x00090064
+#define _REG_GP_ISEL_TPG_RED2_ADDR					0x00090068
+#define _REG_GP_ISEL_TPG_GREEN2_ADDR				0x0009006C
+#define _REG_GP_ISEL_TPG_BLUE2_ADDR					0x00090070
+#define _REG_GP_ISEL_CH_ID_ADDR						0x00090074
+#define _REG_GP_ISEL_FMT_TYPE_ADDR					0x00090078
+#define _REG_GP_ISEL_DATA_SEL_ADDR					0x0009007C
+#define _REG_GP_ISEL_SBAND_SEL_ADDR					0x00090080
+#define _REG_GP_ISEL_SYNC_SEL_ADDR					0x00090084
+#define _REG_GP_SYNCGEN_HOR_CNT_ADDR				0x00090088
+#define _REG_GP_SYNCGEN_VER_CNT_ADDR				0x0009008C
+#define _REG_GP_SYNCGEN_FRAME_CNT_ADDR				0x00090090
+#define _REG_GP_SOFT_RESET_ADDR						0x00090094
+*/
+
+struct gp_device_state_s {
+	int syncgen_enable;
+	int syncgen_free_running;
+	int syncgen_pause;
+	int nr_frames;
+	int syngen_nr_pix;
+	int syngen_nr_lines;
+	int syngen_hblank_cycles;
+	int syngen_vblank_cycles;
+	int isel_sof;
+	int isel_eof;
+	int isel_sol;
+	int isel_eol;
+	int isel_lfsr_enable;
+	int isel_lfsr_enable_b;
+	int isel_lfsr_reset_value;
+	int isel_tpg_enable;
+	int isel_tpg_enable_b;
+	int isel_hor_cnt_mask;
+	int isel_ver_cnt_mask;
+	int isel_xy_cnt_mask;
+	int isel_hor_cnt_delta;
+	int isel_ver_cnt_delta;
+	int isel_tpg_mode;
+	int isel_tpg_red1;
+	int isel_tpg_green1;
+	int isel_tpg_blue1;
+	int isel_tpg_red2;
+	int isel_tpg_green2;
+	int isel_tpg_blue2;
+	int isel_ch_id;
+	int isel_fmt_type;
+	int isel_data_sel;
+	int isel_sband_sel;
+	int isel_sync_sel;
+	int syncgen_hor_cnt;
+	int syncgen_ver_cnt;
+	int syncgen_frame_cnt;
+	int soft_reset;
+};
+
+#endif /* __GP_DEVICE_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_private.h
new file mode 100644
index 0000000..15e2d1f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gp_device_private.h
@@ -0,0 +1,53 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GP_DEVICE_PRIVATE_H_INCLUDED__
+#define __GP_DEVICE_PRIVATE_H_INCLUDED__
+
+#include "gp_device_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_GP_DEVICE_C void gp_device_reg_store(
+	const gp_device_ID_t	ID,
+	const unsigned int		reg_addr,
+	const hrt_data			value)
+{
+assert(ID < N_GP_DEVICE_ID);
+assert(GP_DEVICE_BASE[ID] != (hrt_address)-1);
+assert((reg_addr % sizeof(hrt_data)) == 0);
+	ia_css_device_store_uint32(GP_DEVICE_BASE[ID] + reg_addr, value);
+return;
+}
+
+STORAGE_CLASS_GP_DEVICE_C hrt_data gp_device_reg_load(
+	const gp_device_ID_t	ID,
+	const hrt_address	reg_addr)
+{
+assert(ID < N_GP_DEVICE_ID);
+assert(GP_DEVICE_BASE[ID] != (hrt_address)-1);
+assert((reg_addr % sizeof(hrt_data)) == 0);
+return ia_css_device_load_uint32(GP_DEVICE_BASE[ID] + reg_addr);
+}
+
+#endif /* __GP_DEVICE_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_local.h
new file mode 100644
index 0000000..de1237f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_local.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GPIO_LOCAL_H_INCLUDED__
+#define __GPIO_LOCAL_H_INCLUDED__
+
+#include "gpio_global.h"
+
+#endif /* __GPIO_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_private.h
new file mode 100644
index 0000000..40e9c63
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/gpio_private.h
@@ -0,0 +1,51 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GPIO_PRIVATE_H_INCLUDED__
+#define __GPIO_PRIVATE_H_INCLUDED__
+
+#include "gpio_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_GPIO_C void gpio_reg_store(
+	const gpio_ID_t	ID,
+	const unsigned int		reg,
+	const hrt_data			value)
+{
+OP___assert(ID < N_GPIO_ID);
+OP___assert(GPIO_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(GPIO_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_GPIO_C hrt_data gpio_reg_load(
+	const gpio_ID_t	ID,
+	const unsigned int		reg)
+{
+OP___assert(ID < N_GPIO_ID);
+OP___assert(GPIO_BASE[ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(GPIO_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __GPIO_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_ddr_hrt_modified.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_ddr_hrt_modified.h
new file mode 100644
index 0000000..68fd840
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_ddr_hrt_modified.h
@@ -0,0 +1,155 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _hive_isp_css_dma_hrt_h_
+#define _hive_isp_css_dma_hrt_h_
+
+#include <hmm_64/hmm.h>
+
+/* This function reads an image from DDR and stores it in the img_buf array
+   that has been allocated by the caller.
+   The specifics of how the pixels are stored into DDR by the DMA are taken
+   into account (bits padded to a width of 256, depending on the number of
+   elements per ddr word).
+   The DMA specific parameters give to this function (elems_per_xword and sign_extend)
+   should correspond to those given to the DMA engine.
+   The address is a virtual address which will be translated to a physical address before
+   data is loaded from or stored to that address.
+
+   The return value is 0 in case of success and 1 in case of failure.
+ */
+unsigned int
+hrt_isp_css_read_image_from_ddr(
+    unsigned short *img_buf,
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword,
+    unsigned int sign_extend,
+    hmm_ptr virt_addr);
+
+/* This function writes an image to DDR, keeping the same aspects into account as the read_image function
+   above. */
+unsigned int
+hrt_isp_css_write_image_to_ddr(
+    const unsigned short *img_buf,
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword,
+    unsigned int sign_extend,
+    hmm_ptr virt_addr);
+
+/* return the size in bytes of an image (frame or plane). */
+unsigned int
+hrt_isp_css_sizeof_image_in_ddr(
+    unsigned int width,
+    unsigned int height,
+    unsigned int bits_per_element);
+
+unsigned int
+hrt_isp_css_stride_of_image_in_ddr(
+    unsigned int width,
+    unsigned int bits_per_element);
+
+hmm_ptr
+hrt_isp_css_alloc_image_in_ddr(
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword);
+
+hmm_ptr
+hrt_isp_css_calloc_image_in_ddr(
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword);
+
+#ifndef HIVE_ISP_NO_GDC
+#include "gdc_v2_defs.h"
+
+hmm_ptr
+hrt_isp_css_alloc_gdc_lut_in_ddr(void);
+
+void
+hrt_isp_css_write_gdc_lut_to_ddr(
+    short values[4][HRT_GDC_N],
+    hmm_ptr virt_addr);
+#endif
+
+#ifdef _HIVE_ISP_CSS_FPGA_SYSTEM
+hmm_ptr
+hrt_isp_css_alloc_image_for_display(
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword);
+
+hmm_ptr
+hrt_isp_css_calloc_image_for_display(
+    unsigned int width,
+    unsigned int height,
+    unsigned int elems_per_xword);
+#endif
+
+/* New set of functions, these do not require the elems_per_xword, but use bits_per_element instead,
+   this way the user does not need to know about the width of a DDR word. */
+unsigned int
+hrt_isp_css_read_unsigned(
+    unsigned short *target,
+    unsigned int width,
+    unsigned int height,
+    unsigned int source_bits_per_element,
+    hmm_ptr source);
+
+unsigned int
+hrt_isp_css_read_signed(
+    short *target,
+    unsigned int width,
+    unsigned int height,
+    unsigned int source_bits_per_element,
+    hmm_ptr source);
+
+unsigned int
+hrt_isp_css_write_unsigned(
+    const unsigned short *source,
+    unsigned int width,
+    unsigned int height,
+    unsigned int target_bits_per_element,
+    hmm_ptr target);
+
+unsigned int
+hrt_isp_css_write_signed(
+    const short *source,
+    unsigned int width,
+    unsigned int height,
+    unsigned int target_bits_per_element,
+    hmm_ptr target);
+
+hmm_ptr
+hrt_isp_css_alloc(
+    unsigned int width,
+    unsigned int height,
+    unsigned int bits_per_element);
+
+hmm_ptr
+hrt_isp_css_calloc(
+    unsigned int width,
+    unsigned int height,
+    unsigned int bits_per_element);
+
+#endif /* _hive_isp_css_dma_hrt_h_ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_hrt_modified.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_hrt_modified.h
new file mode 100644
index 0000000..d1c704a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hive_isp_css_hrt_modified.h
@@ -0,0 +1,102 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _hive_isp_css_hrt_h
+#define _hive_isp_css_hrt_h
+
+#include "system_types.h"
+
+#include "hive_isp_css_host_ids_hrt.h"
+#include "hive_isp_css_defs.h"
+
+#ifdef HRT_ISP_CSS_CUSTOM_HOST
+#ifndef HRT_USE_VIR_ADDRS
+#define HRT_USE_VIR_ADDRS
+#endif
+/*#include "hive_isp_css_custom_host_hrt.h"*/
+#endif
+
+#include <gpio_block.h>
+#include <gp_regs.h>
+#include <gp_timer_hrt.h>
+#ifdef _HIVE_ISP_CSS_FPGA_SYSTEM
+  #include <i2c_api.h>
+  #include <dis_sensor.h>
+  #include <display_driver.h>
+  #include <display.h>
+  #include <display_driver.h>
+  #include <shi_sensor_api.h>
+#define hrt_gdc_slave_port(gdc_id)    HRTCAT(gdc_id,_sl_in)
+  #include <isp2400_mamoiada_demo_params.h>
+  #include <isp2400_support.h>
+  #include "isp_css_dev_flash_hrt.h"
+  #include "isp_css_dev_display_hrt.h"
+  #include "isp_css_dev_i2c_hrt.h"
+  #include "isp_css_dev_tb.h"
+#else /* CSS ASIC system */
+  #include <css_receiver_2400_hrt.h>
+//  #include <isp2400_mamoiada_params.h>
+//  #include <isp2400_support.h>
+  /* insert idle signal clearing and setting around hrt_main */
+  #if !defined(HRT_HW) || defined(HRT_ISP_CSS_INSERT_IDLE_SIGNAL)
+    #define hrt_main _hrt_isp_css_main
+  #endif
+  #ifdef _HIVE_ISP_CSS_SPECMAN_SYSTEM
+    #include "hive_isp_css_2400_specman_system.h"
+  #else
+#if defined(IS_ISP_2400_MAMOIADA_SYSTEM)
+    #include "hive_isp_css_2400_system.h"
+#elif defined(IS_ISP_2401_MAMOIADA_SYSTEM)
+    #include "hive_isp_css_2401_system.h"
+#else
+#error "hive_isp_css_hrt_modified.h: SYSTEM must be one of {2400_MAMOIADA_SYSTEM, 2401_MAMOIADA_SYSTEM}"
+#endif
+  #endif
+#endif /* _HIVE_ISP_CSS_FPGA_SYSTEM */
+#include <sp_hrt.h>
+#include <input_system_hrt.h>
+#include <input_selector_hrt.h>
+#include <sig_monitor_hrt.h>
+
+#include "hive_isp_css_sdram_wakeup_hrt.h"
+#include "hive_isp_css_idle_signal_hrt.h"
+#include "hive_isp_css_sp_hrt.h"
+#include "hive_isp_css_isp_hrt.h"
+#include "hive_isp_css_streaming_to_mipi_hrt.h"
+#include "hive_isp_css_testbench_hrt.h"
+#include "hive_isp_css_streaming_monitors_hrt.h"
+#include "hive_isp_css_gp_regs_hrt.h"
+#if defined(IS_ISP_2400_MAMOIADA_SYSTEM)
+#include "hive_isp_css_irq_hrt.h"
+#elif defined(IS_ISP_2401_MAMOIADA_SYSTEM)
+#include "hive_isp_css_2401_irq_hrt.h"
+#else
+#error "hive_isp_css_hrt_modified.h: SYSTEM must be one of {2400_MAMOIADA_SYSTEM, 2401_MAMOIADA_SYSTEM}"
+#endif
+
+#include "hive_isp_css_stream_switch_hrt.h"
+
+#include "hive_isp_css_ddr_hrt_modified.h"
+#include "hive_isp_css_dma_set_hrt.h"
+
+#define HIVE_ISP_CSS_NO_STREAM_SWITCH 1
+
+#endif /* _hive_isp_css_hrt_h */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem.c
new file mode 100644
index 0000000..6416311
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem.c
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+
+#include "hmem.h"
+
+#ifndef __INLINE_HMEM__
+#include "hmem_private.h"
+#endif /* __INLINE_HMEM__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_local.h
new file mode 100644
index 0000000..9c1a178
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_local.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __HMEM_LOCAL_H_INCLUDED__
+#define __HMEM_LOCAL_H_INCLUDED__
+
+#include "hmem_global.h"
+
+#endif /* __HMEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_private.h
new file mode 100644
index 0000000..91e5769
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/hmem_private.h
@@ -0,0 +1,37 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __HMEM_PRIVATE_H_INCLUDED__
+#define __HMEM_PRIVATE_H_INCLUDED__
+
+#include "hmem_public.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_HMEM_C size_t sizeof_hmem(
+	const hmem_ID_t		ID)
+{
+assert(ID < N_HMEM_ID);
+	(void)ID;
+return HMEM_SIZE*sizeof(hmem_data_t);
+}
+
+#endif /* __HMEM_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter.c
new file mode 100644
index 0000000..b59251d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter.c
@@ -0,0 +1,229 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "input_formatter.h"
+#include <type_support.h>
+#include "gp_device.h"
+
+#include "assert_support.h"
+
+#ifndef __INLINE_INPUT_FORMATTER__
+#include "input_formatter_private.h"
+#endif /* __INLINE_INPUT_FORMATTER__ */
+
+const hrt_address HIVE_IF_SRST_ADDRESS[N_INPUT_FORMATTER_ID] = {
+	INPUT_FORMATTER0_SRST_OFFSET,
+	INPUT_FORMATTER1_SRST_OFFSET,
+	INPUT_FORMATTER2_SRST_OFFSET,
+	INPUT_FORMATTER3_SRST_OFFSET};
+
+const hrt_data HIVE_IF_SRST_MASK[N_INPUT_FORMATTER_ID] = {
+	INPUT_FORMATTER0_SRST_MASK,
+	INPUT_FORMATTER1_SRST_MASK,
+	INPUT_FORMATTER2_SRST_MASK,
+	INPUT_FORMATTER3_SRST_MASK};
+
+const uint8_t HIVE_IF_SWITCH_CODE[N_INPUT_FORMATTER_ID] = {
+	HIVE_INPUT_SWITCH_SELECT_IF_PRIM,
+	HIVE_INPUT_SWITCH_SELECT_IF_PRIM,
+	HIVE_INPUT_SWITCH_SELECT_IF_SEC,
+	HIVE_INPUT_SWITCH_SELECT_STR_TO_MEM};
+
+/* MW Should be part of system_global.h, where we have the main enumeration */
+const bool HIVE_IF_BIN_COPY[N_INPUT_FORMATTER_ID] = {
+	false, false, false, true};
+
+void input_formatter_rst(
+	const input_formatter_ID_t		ID)
+{
+	hrt_address	addr;
+	hrt_data	rst;
+
+	assert(ID < N_INPUT_FORMATTER_ID);
+
+	addr = HIVE_IF_SRST_ADDRESS[ID];
+	rst = HIVE_IF_SRST_MASK[ID];
+
+	/* TEMPORARY HACK: THIS RESET BREAKS THE METADATA FEATURE
+	 * WICH USES THE STREAM2MEMRY BLOCK.
+	 * MUST BE FIXED PROPERLY
+	 */
+	if (!HIVE_IF_BIN_COPY[ID]) {
+		input_formatter_reg_store(ID, addr, rst);
+	}
+
+	return;
+}
+
+unsigned int input_formatter_get_alignment(
+	const input_formatter_ID_t		ID)
+{
+	assert(ID < N_INPUT_FORMATTER_ID);
+
+	return input_formatter_alignment[ID];
+}
+
+void input_formatter_set_fifo_blocking_mode(
+	const input_formatter_ID_t		ID,
+	const bool						enable)
+{
+	assert(ID < N_INPUT_FORMATTER_ID);
+
+	/* cnd_input_formatter_reg_store() */
+	if (!HIVE_IF_BIN_COPY[ID]) {
+		input_formatter_reg_store(ID,
+			 HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS, enable);
+	}
+	return;
+}
+
+void input_formatter_get_switch_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_switch_state_t	*state)
+{
+	assert(ID < N_INPUT_FORMATTER_ID);
+	assert(state != NULL);
+
+	/* We'll change this into an intelligent function to get switch info per IF */
+	(void)ID;
+
+	state->if_input_switch_lut_reg[0] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg0);
+	state->if_input_switch_lut_reg[1] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg1);
+	state->if_input_switch_lut_reg[2] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg2);
+	state->if_input_switch_lut_reg[3] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg3);
+	state->if_input_switch_lut_reg[4] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg4);
+	state->if_input_switch_lut_reg[5] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg5);
+	state->if_input_switch_lut_reg[6] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg6);
+	state->if_input_switch_lut_reg[7] = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_lut_reg7);
+	state->if_input_switch_fsync_lut = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_fsync_lut);
+	state->if_input_switch_ch_id_fmt_type = gp_device_reg_load(GP_DEVICE0_ID, _REG_GP_IFMT_input_switch_ch_id_fmt_type);
+
+	return;
+}
+
+void input_formatter_get_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_state_t			*state)
+{
+	assert(ID < N_INPUT_FORMATTER_ID);
+	assert(state != NULL);
+/*
+	state->reset = input_formatter_reg_load(ID,
+		HIVE_IF_RESET_ADDRESS);
+ */
+	state->start_line = input_formatter_reg_load(ID,
+		HIVE_IF_START_LINE_ADDRESS);
+	state->start_column = input_formatter_reg_load(ID,
+		HIVE_IF_START_COLUMN_ADDRESS);
+	state->cropped_height = input_formatter_reg_load(ID,
+		HIVE_IF_CROPPED_HEIGHT_ADDRESS);
+	state->cropped_width = input_formatter_reg_load(ID,
+		HIVE_IF_CROPPED_WIDTH_ADDRESS);
+	state->ver_decimation = input_formatter_reg_load(ID,
+		HIVE_IF_VERTICAL_DECIMATION_ADDRESS);
+	state->hor_decimation = input_formatter_reg_load(ID,
+		HIVE_IF_HORIZONTAL_DECIMATION_ADDRESS);
+	state->hor_deinterleaving = input_formatter_reg_load(ID,
+		HIVE_IF_H_DEINTERLEAVING_ADDRESS);
+	state->left_padding = input_formatter_reg_load(ID,
+		HIVE_IF_LEFTPADDING_WIDTH_ADDRESS);
+	state->eol_offset = input_formatter_reg_load(ID,
+		HIVE_IF_END_OF_LINE_OFFSET_ADDRESS);
+	state->vmem_start_address = input_formatter_reg_load(ID,
+		HIVE_IF_VMEM_START_ADDRESS_ADDRESS);
+	state->vmem_end_address = input_formatter_reg_load(ID,
+		HIVE_IF_VMEM_END_ADDRESS_ADDRESS);
+	state->vmem_increment = input_formatter_reg_load(ID,
+		HIVE_IF_VMEM_INCREMENT_ADDRESS);
+	state->is_yuv420 = input_formatter_reg_load(ID,
+		HIVE_IF_YUV_420_FORMAT_ADDRESS);
+	state->vsync_active_low = input_formatter_reg_load(ID,
+		HIVE_IF_VSYNCK_ACTIVE_LOW_ADDRESS);
+	state->hsync_active_low = input_formatter_reg_load(ID,
+		HIVE_IF_HSYNCK_ACTIVE_LOW_ADDRESS);
+	state->allow_fifo_overflow = input_formatter_reg_load(ID,
+		HIVE_IF_ALLOW_FIFO_OVERFLOW_ADDRESS);
+	state->block_fifo_when_no_req = input_formatter_reg_load(ID,
+		HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS);
+	state->ver_deinterleaving = input_formatter_reg_load(ID,
+		HIVE_IF_V_DEINTERLEAVING_ADDRESS);
+/* FSM */
+	state->fsm_sync_status = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_SYNC_STATUS);
+	state->fsm_sync_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_SYNC_COUNTER);
+	state->fsm_crop_status = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_CROP_STATUS);
+	state->fsm_crop_line_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_CROP_LINE_COUNTER);
+	state->fsm_crop_pixel_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_CROP_PIXEL_COUNTER);
+	state->fsm_deinterleaving_index = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_DEINTERLEAVING_IDX);
+	state->fsm_dec_h_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_DECIMATION_H_COUNTER);
+	state->fsm_dec_v_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_DECIMATION_V_COUNTER);
+	state->fsm_dec_block_v_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_DECIMATION_BLOCK_V_COUNTER);
+	state->fsm_padding_status = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_PADDING_STATUS);
+	state->fsm_padding_elem_counter = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_PADDING_ELEMENT_COUNTER);
+	state->fsm_vector_support_error = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_VECTOR_SUPPORT_ERROR);
+	state->fsm_vector_buffer_full = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_VECTOR_SUPPORT_BUFF_FULL);
+	state->vector_support = input_formatter_reg_load(ID,
+		HIVE_IF_FSM_VECTOR_SUPPORT);
+	state->sensor_data_lost = input_formatter_reg_load(ID,
+		HIVE_IF_FIFO_SENSOR_STATUS);
+
+	return;
+}
+
+void input_formatter_bin_get_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_bin_state_t		*state)
+{
+	assert(ID < N_INPUT_FORMATTER_ID);
+	assert(state != NULL);
+
+	state->reset = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_SOFT_RESET_REG_ADDRESS);
+	state->input_endianness = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_INPUT_ENDIANNESS_REG_ADDRESS);
+	state->output_endianness = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_OUTPUT_ENDIANNESS_REG_ADDRESS);
+	state->bitswap = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_BIT_SWAPPING_REG_ADDRESS);
+	state->block_synch = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_BLOCK_SYNC_LEVEL_REG_ADDRESS);
+	state->packet_synch = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_PACKET_SYNC_LEVEL_REG_ADDRESS);
+	state->readpostwrite_synch = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ADDRESS);
+	state->is_2ppc = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ADDRESS);
+	state->en_status_update = input_formatter_reg_load(ID,
+		HIVE_STR2MEM_EN_STAT_UPDATE_ADDRESS);
+	return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_local.h
new file mode 100644
index 0000000..9f476c1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_local.h
@@ -0,0 +1,127 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __INPUT_FORMATTER_LOCAL_H_INCLUDED__
+#define __INPUT_FORMATTER_LOCAL_H_INCLUDED__
+
+#include "input_formatter_global.h"
+
+#include "isp.h"		/* ISP_VEC_ALIGN */
+
+typedef struct input_formatter_switch_state_s	input_formatter_switch_state_t;
+typedef struct input_formatter_state_s			input_formatter_state_t;
+typedef struct input_formatter_bin_state_s		input_formatter_bin_state_t;
+
+#define HIVE_IF_FSM_SYNC_STATUS                 0x100
+#define HIVE_IF_FSM_SYNC_COUNTER                0x104
+#define HIVE_IF_FSM_DEINTERLEAVING_IDX          0x114
+#define HIVE_IF_FSM_DECIMATION_H_COUNTER        0x118
+#define HIVE_IF_FSM_DECIMATION_V_COUNTER        0x11C
+#define HIVE_IF_FSM_DECIMATION_BLOCK_V_COUNTER  0x120
+#define HIVE_IF_FSM_PADDING_STATUS              0x124
+#define HIVE_IF_FSM_PADDING_ELEMENT_COUNTER     0x128
+#define HIVE_IF_FSM_VECTOR_SUPPORT_ERROR        0x12C
+#define HIVE_IF_FSM_VECTOR_SUPPORT_BUFF_FULL    0x130
+#define HIVE_IF_FSM_VECTOR_SUPPORT              0x134
+#define HIVE_IF_FIFO_SENSOR_STATUS              0x138
+
+/*
+ * The switch LUT's coding defines a sink for each
+ * single channel ID + channel format type. Conversely
+ * the sink (i.e. an input formatter) can be reached
+ * from multiple channel & format type combinations
+ *
+ * LUT[0,1] channel=0, format type {0,1,...31}
+ * LUT[2,3] channel=1, format type {0,1,...31}
+ * LUT[4,5] channel=2, format type {0,1,...31}
+ * LUT[6,7] channel=3, format type {0,1,...31}
+ *
+ * Each register hold 16 2-bit fields encoding the sink
+ * {0,1,2,3}, "0" means unconnected.
+ *
+ * The single FSYNCH register uses four 3-bit fields of 1-hot
+ * encoded sink information, "0" means unconnected.
+ *
+ * The encoding is redundant. The FSYNCH setting will connect
+ * a channel to a sink. At that point the LUT's belonging to
+ * that channel can be directed to another sink. Thus the data
+ * goes to another place than the synch
+ */
+struct input_formatter_switch_state_s {
+	int	if_input_switch_lut_reg[8];
+	int	if_input_switch_fsync_lut;
+	int	if_input_switch_ch_id_fmt_type;
+	bool if_input_switch_map[HIVE_SWITCH_N_CHANNELS][HIVE_SWITCH_N_FORMATTYPES];
+};
+
+struct input_formatter_state_s {
+/*	int	reset; */
+	int	start_line;
+	int	start_column;
+	int	cropped_height;
+	int	cropped_width;
+	int	ver_decimation;
+	int	hor_decimation;
+	int	ver_deinterleaving;
+	int	hor_deinterleaving;
+	int	left_padding;
+	int	eol_offset;
+	int	vmem_start_address;
+	int	vmem_end_address;
+	int	vmem_increment;
+	int	is_yuv420;
+	int	vsync_active_low;
+	int	hsync_active_low;
+	int	allow_fifo_overflow;
+	int block_fifo_when_no_req;
+	int	fsm_sync_status;
+	int	fsm_sync_counter;
+	int	fsm_crop_status;
+	int	fsm_crop_line_counter;
+	int	fsm_crop_pixel_counter;
+	int	fsm_deinterleaving_index;
+	int	fsm_dec_h_counter;
+	int	fsm_dec_v_counter;
+	int	fsm_dec_block_v_counter;
+	int	fsm_padding_status;
+	int	fsm_padding_elem_counter;
+	int	fsm_vector_support_error;
+	int	fsm_vector_buffer_full;
+	int	vector_support;
+	int	sensor_data_lost;
+};
+
+struct input_formatter_bin_state_s {
+	uint32_t	reset;
+	uint32_t	input_endianness;
+	uint32_t	output_endianness;
+	uint32_t	bitswap;
+	uint32_t	block_synch;
+	uint32_t	packet_synch;
+	uint32_t	readpostwrite_synch;
+	uint32_t	is_2ppc;
+	uint32_t	en_status_update;
+};
+
+static const unsigned int input_formatter_alignment[N_INPUT_FORMATTER_ID] = {
+	ISP_VEC_ALIGN, ISP_VEC_ALIGN, HIVE_ISP_CTRL_DATA_BYTES};
+
+#endif /* __INPUT_FORMATTER_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_private.h
new file mode 100644
index 0000000..e005d12
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_formatter_private.h
@@ -0,0 +1,53 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __INPUT_FORMATTER_PRIVATE_H_INCLUDED__
+#define __INPUT_FORMATTER_PRIVATE_H_INCLUDED__
+
+#include "input_formatter_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_INPUT_FORMATTER_C void input_formatter_reg_store(
+	const input_formatter_ID_t		ID,
+	const hrt_address			reg_addr,
+	const hrt_data				value)
+{
+assert(ID < N_INPUT_FORMATTER_ID);
+assert(INPUT_FORMATTER_BASE[ID] != (hrt_address)-1);
+assert((reg_addr % sizeof(hrt_data)) == 0);
+	ia_css_device_store_uint32(INPUT_FORMATTER_BASE[ID] + reg_addr, value);
+return;
+}
+
+STORAGE_CLASS_INPUT_FORMATTER_C hrt_data input_formatter_reg_load(
+	const input_formatter_ID_t	ID,
+	const unsigned int			reg_addr)
+{
+assert(ID < N_INPUT_FORMATTER_ID);
+assert(INPUT_FORMATTER_BASE[ID] != (hrt_address)-1);
+assert((reg_addr % sizeof(hrt_data)) == 0);
+return ia_css_device_load_uint32(INPUT_FORMATTER_BASE[ID] + reg_addr);
+}
+
+#endif /* __INPUT_FORMATTER_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system.c
new file mode 100644
index 0000000..cc40a16
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system.c
@@ -0,0 +1,1826 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "input_system.h"
+#include <type_support.h>
+#include "gp_device.h"
+
+#include "assert_support.h"
+
+#ifndef __INLINE_INPUT_SYSTEM__
+#include "input_system_private.h"
+#endif /* __INLINE_INPUT_SYSTEM__ */
+
+#define ZERO (0x0)
+#define ONE  (1U)
+
+const ib_buffer_t   IB_BUFFER_NULL = {0 ,0, 0 };
+
+static input_system_error_t input_system_configure_channel(
+	const channel_cfg_t		channel);
+
+static input_system_error_t input_system_configure_channel_sensor(
+	const channel_cfg_t		channel);
+
+static input_system_error_t input_buffer_configuration(void);
+
+static input_system_error_t configuration_to_registers(void);
+
+static void receiver_rst(const rx_ID_t ID);
+static void input_system_network_rst(const input_system_ID_t ID);
+
+static void capture_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ib_buffer_t* const		cfg);
+
+static void acquisition_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ib_buffer_t* const		cfg);
+
+static void ctrl_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ctrl_unit_cfg_t* const	cfg);
+
+static void input_system_network_configure(
+	const input_system_ID_t			ID,
+	const input_system_network_cfg_t * const	cfg);
+
+// MW: CSI is previously named as "rx" short for "receiver"
+static input_system_error_t set_csi_cfg(
+	csi_cfg_t* const						lhs,
+	const csi_cfg_t* const					rhs,
+	input_system_config_flags_t* const 		flags);
+
+static input_system_error_t set_source_type(
+	input_system_source_t* const 			lhs,
+	const input_system_source_t	 			rhs,
+	input_system_config_flags_t* const		flags);
+
+static input_system_error_t input_system_multiplexer_cfg(
+	input_system_multiplex_t* const			lhs,
+	const input_system_multiplex_t			rhs,
+	input_system_config_flags_t* const		flags);
+
+
+
+STORAGE_CLASS_INLINE void capture_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	capture_unit_state_t			*state);
+
+STORAGE_CLASS_INLINE void acquisition_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	acquisition_unit_state_t		*state);
+
+STORAGE_CLASS_INLINE void ctrl_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	ctrl_unit_state_t				*state);
+
+STORAGE_CLASS_INLINE void mipi_port_get_state(
+	const rx_ID_t					ID,
+	const mipi_port_ID_t			port_ID,
+	mipi_port_state_t				*state);
+
+STORAGE_CLASS_INLINE void rx_channel_get_state(
+	const rx_ID_t					ID,
+	const unsigned int				ch_id,
+	rx_channel_state_t				*state);
+
+static void gp_device_rst(const gp_device_ID_t		ID);
+
+static void input_selector_cfg_for_sensor(const gp_device_ID_t	ID);
+
+static void input_switch_rst(const gp_device_ID_t	ID);
+
+static void input_switch_cfg(
+	const gp_device_ID_t				ID,
+	const input_switch_cfg_t * const	cfg
+);
+
+void input_system_get_state(
+	const input_system_ID_t			ID,
+	input_system_state_t			*state)
+{
+	sub_system_ID_t	sub_id;
+
+	assert(ID < N_INPUT_SYSTEM_ID);
+	assert(state != NULL);
+
+	state->str_multicastA_sel = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_A_IDX);
+	state->str_multicastB_sel = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_B_IDX);
+	state->str_multicastC_sel = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_C_IDX);
+	state->str_mux_sel = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MUX_IDX);
+	state->str_mon_status = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_STRMON_STAT_IDX);
+	state->str_mon_irq_cond = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_STRMON_COND_IDX);
+	state->str_mon_irq_en = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_STRMON_IRQ_EN_IDX);
+	state->isys_srst = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_SRST_IDX);
+	state->isys_slv_reg_srst = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_SLV_REG_SRST_IDX);
+	state->str_deint_portA_cnt = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_REG_PORT_A_IDX);
+	state->str_deint_portB_cnt = input_system_sub_system_reg_load(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_REG_PORT_B_IDX);
+
+	for (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID; sub_id++) {
+		capture_unit_get_state(ID, sub_id,
+			&(state->capture_unit[sub_id - CAPTURE_UNIT0_ID]));
+	}
+	for (sub_id = ACQUISITION_UNIT0_ID; sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {
+		acquisition_unit_get_state(ID, sub_id,
+			&(state->acquisition_unit[sub_id - ACQUISITION_UNIT0_ID]));
+	}
+	for (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID; sub_id++) {
+		ctrl_unit_get_state(ID, sub_id,
+			&(state->ctrl_unit_state[sub_id - CTRL_UNIT0_ID]));
+	}
+
+return;
+}
+
+void receiver_get_state(
+	const rx_ID_t				ID,
+	receiver_state_t			*state)
+{
+	mipi_port_ID_t	port_id;
+	unsigned int	ch_id;
+
+	assert(ID < N_RX_ID);
+	assert(state != NULL);
+
+	state->fs_to_ls_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_FS_TO_LS_DELAY_REG_IDX);
+	state->ls_to_data_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_LS_TO_DATA_DELAY_REG_IDX);
+	state->data_to_le_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_DATA_TO_LE_DELAY_REG_IDX);
+	state->le_to_fe_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_LE_TO_FE_DELAY_REG_IDX);
+	state->fe_to_fs_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_FE_TO_FS_DELAY_REG_IDX);
+	state->le_to_fs_delay = (uint8_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_LE_TO_LS_DELAY_REG_IDX);
+	state->is_two_ppc = (bool)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX);
+	state->backend_rst = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BACKEND_RST_REG_IDX);
+	state->raw18 = (uint16_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_RAW18_REG_IDX);
+	state->force_raw8 = (bool)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_FORCE_RAW8_REG_IDX);
+	state->raw16 = (uint16_t)receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_RAW16_REG_IDX);
+
+	for (port_id = (mipi_port_ID_t)0; port_id < N_MIPI_PORT_ID; port_id++) {
+		mipi_port_get_state(ID, port_id,
+			&(state->mipi_port_state[port_id]));
+	}
+	for (ch_id = (unsigned int)0; ch_id < N_RX_CHANNEL_ID; ch_id++) {
+		rx_channel_get_state(ID, ch_id,
+			&(state->rx_channel_state[ch_id]));
+	}
+
+	state->be_gsp_acc_ovl = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_GSP_ACC_OVL_REG_IDX);
+	state->be_srst = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_SRST_REG_IDX);
+	state->be_is_two_ppc = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX);
+	state->be_comp_format0 = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG0_IDX);
+	state->be_comp_format1 = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG1_IDX);
+	state->be_comp_format2 = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG2_IDX);
+	state->be_comp_format3 = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG3_IDX);
+	state->be_sel = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_SEL_REG_IDX);
+	state->be_raw16_config = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_RAW16_CONFIG_REG_IDX);
+	state->be_raw18_config = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_RAW18_CONFIG_REG_IDX);
+	state->be_force_raw8 = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_FORCE_RAW8_REG_IDX);
+	state->be_irq_status = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_IRQ_STATUS_REG_IDX);
+	state->be_irq_clear = receiver_reg_load(ID,
+		_HRT_CSS_RECEIVER_BE_IRQ_CLEAR_REG_IDX);
+
+return;
+}
+
+bool is_mipi_format_yuv420(
+	const mipi_format_t			mipi_format)
+{
+	bool	is_yuv420 = (
+		(mipi_format == MIPI_FORMAT_YUV420_8) ||
+		(mipi_format == MIPI_FORMAT_YUV420_10) ||
+		(mipi_format == MIPI_FORMAT_YUV420_8_SHIFT) ||
+		(mipi_format == MIPI_FORMAT_YUV420_10_SHIFT));
+/* MIPI_FORMAT_YUV420_8_LEGACY is not YUV420 */
+
+return is_yuv420;
+}
+
+void receiver_set_compression(
+	const rx_ID_t			ID,
+	const unsigned int		cfg_ID,
+	const mipi_compressor_t		comp,
+	const mipi_predictor_t		pred)
+{
+	const unsigned int		field_id = cfg_ID % N_MIPI_FORMAT_CUSTOM;
+	const unsigned int		ch_id = cfg_ID / N_MIPI_FORMAT_CUSTOM;
+	hrt_data			val;
+	hrt_address			addr = 0;
+	hrt_data			reg;
+
+	assert(ID < N_RX_ID);
+	assert(cfg_ID < N_MIPI_COMPRESSOR_CONTEXT);
+	assert(field_id < N_MIPI_FORMAT_CUSTOM);
+	assert(ch_id < N_RX_CHANNEL_ID);
+	assert(comp < N_MIPI_COMPRESSOR_METHODS);
+	assert(pred < N_MIPI_PREDICTOR_TYPES);
+
+	val = (((uint8_t)pred) << 3) | comp;
+
+	switch (ch_id) {
+	case 0: addr = ((field_id<6)?_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX:_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX);
+		break;
+	case 1: addr = ((field_id<6)?_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX:_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX);
+		break;
+	case 2: addr = ((field_id<6)?_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX:_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX);
+		break;
+	case 3: addr = ((field_id<6)?_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX:_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX);
+		break;
+	default:
+		/* should not happen */
+		assert(false);
+		return;
+	}
+
+	reg = ((field_id < 6)?(val << (field_id * 5)):(val << ((field_id - 6) * 5)));
+	receiver_reg_store(ID, addr, reg);
+
+return;
+}
+
+void receiver_port_enable(
+	const rx_ID_t			ID,
+	const mipi_port_ID_t		port_ID,
+	const bool			cnd)
+{
+	hrt_data	reg = receiver_port_reg_load(ID, port_ID,
+		_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
+
+	if (cnd) {
+		reg |= 0x01;
+	} else {
+		reg &= ~0x01;
+	}
+
+	receiver_port_reg_store(ID, port_ID,
+		_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX, reg);
+return;
+}
+
+bool is_receiver_port_enabled(
+	const rx_ID_t			ID,
+	const mipi_port_ID_t		port_ID)
+{
+	hrt_data	reg = receiver_port_reg_load(ID, port_ID,
+		_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
+return ((reg & 0x01) != 0);
+}
+
+void receiver_irq_enable(
+	const rx_ID_t			ID,
+	const mipi_port_ID_t		port_ID,
+	const rx_irq_info_t		irq_info)
+{
+	receiver_port_reg_store(ID,
+		port_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, irq_info);
+return;
+}
+
+rx_irq_info_t receiver_get_irq_info(
+	const rx_ID_t			ID,
+	const mipi_port_ID_t		port_ID)
+{
+return receiver_port_reg_load(ID,
+	port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
+}
+
+void receiver_irq_clear(
+	const rx_ID_t			ID,
+	const mipi_port_ID_t		port_ID,
+	const rx_irq_info_t		irq_info)
+{
+	receiver_port_reg_store(ID,
+		port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX, irq_info);
+return;
+}
+
+STORAGE_CLASS_INLINE void capture_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	capture_unit_state_t			*state)
+{
+	assert(/*(sub_id >= CAPTURE_UNIT0_ID) &&*/ (sub_id <= CAPTURE_UNIT2_ID));
+	assert(state != NULL);
+
+	state->StartMode = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_START_MODE_REG_ID);
+	state->Start_Addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_START_ADDR_REG_ID);
+	state->Mem_Region_Size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_MEM_REGION_SIZE_REG_ID);
+	state->Num_Mem_Regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_NUM_MEM_REGIONS_REG_ID);
+//	AM: Illegal read from following registers.
+/*	state->Init = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_INIT_REG_ID);
+	state->Start = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_START_REG_ID);
+	state->Stop = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_STOP_REG_ID);
+*/
+	state->Packet_Length = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_PACKET_LENGTH_REG_ID);
+	state->Received_Length = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_RECEIVED_LENGTH_REG_ID);
+	state->Received_Short_Packets = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_RECEIVED_SHORT_PACKETS_REG_ID);
+	state->Received_Long_Packets = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_RECEIVED_LONG_PACKETS_REG_ID);
+	state->Last_Command = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_LAST_COMMAND_REG_ID);
+	state->Next_Command = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_NEXT_COMMAND_REG_ID);
+	state->Last_Acknowledge = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_LAST_ACKNOWLEDGE_REG_ID);
+	state->Next_Acknowledge = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_NEXT_ACKNOWLEDGE_REG_ID);
+	state->FSM_State_Info = input_system_sub_system_reg_load(ID,
+		sub_id,
+		CAPT_FSM_STATE_INFO_REG_ID);
+
+return;
+}
+
+STORAGE_CLASS_INLINE void acquisition_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	acquisition_unit_state_t		*state)
+{
+	assert(sub_id == ACQUISITION_UNIT0_ID);
+	assert(state != NULL);
+
+	state->Start_Addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_START_ADDR_REG_ID);
+	state->Mem_Region_Size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_MEM_REGION_SIZE_REG_ID);
+	state->Num_Mem_Regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_NUM_MEM_REGIONS_REG_ID);
+//	AM: Illegal read from following registers.
+/*	state->Init = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_INIT_REG_ID);
+*/
+	state->Received_Short_Packets = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_RECEIVED_SHORT_PACKETS_REG_ID);
+	state->Received_Long_Packets = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_RECEIVED_LONG_PACKETS_REG_ID);
+	state->Last_Command = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_LAST_COMMAND_REG_ID);
+	state->Next_Command = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_NEXT_COMMAND_REG_ID);
+	state->Last_Acknowledge = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_LAST_ACKNOWLEDGE_REG_ID);
+	state->Next_Acknowledge = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_NEXT_ACKNOWLEDGE_REG_ID);
+	state->FSM_State_Info = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_FSM_STATE_INFO_REG_ID);
+	state->Int_Cntr_Info = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ACQ_INT_CNTR_INFO_REG_ID);
+
+return;
+}
+
+STORAGE_CLASS_INLINE void ctrl_unit_get_state(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	ctrl_unit_state_t			*state)
+{
+	assert(sub_id == CTRL_UNIT0_ID);
+	assert(state != NULL);
+
+	state->captA_start_addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_A_REG_ID);
+	state->captB_start_addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_B_REG_ID);
+	state->captC_start_addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_C_REG_ID);
+	state->captA_mem_region_size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID);
+	state->captB_mem_region_size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID);
+	state->captC_mem_region_size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID);
+	state->captA_num_mem_regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID);
+	state->captB_num_mem_regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID);
+	state->captC_num_mem_regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID);
+	state->acq_start_addr = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_START_ADDR_REG_ID);
+	state->acq_mem_region_size = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID);
+	state->acq_num_mem_regions = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID);
+//	AM: Illegal read from following registers.
+/*	state->ctrl_init = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_INIT_REG_ID);
+*/
+	state->last_cmd = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_LAST_COMMAND_REG_ID);
+	state->next_cmd = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_NEXT_COMMAND_REG_ID);
+	state->last_ack = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_LAST_ACKNOWLEDGE_REG_ID);
+	state->next_ack = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_ID);
+	state->top_fsm_state = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_FSM_STATE_INFO_REG_ID);
+	state->captA_fsm_state = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_ID);
+	state->captB_fsm_state = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_ID);
+	state->captC_fsm_state = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_ID);
+	state->acq_fsm_state = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_ID);
+	state->capt_reserve_one_mem_region = input_system_sub_system_reg_load(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID);
+
+return;
+}
+
+STORAGE_CLASS_INLINE void mipi_port_get_state(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t			port_ID,
+	mipi_port_state_t			*state)
+{
+	int	i;
+
+	assert(ID < N_RX_ID);
+	assert(port_ID < N_MIPI_PORT_ID);
+	assert(state != NULL);
+
+	state->device_ready = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
+	state->irq_status = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
+	state->irq_enable = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
+	state->timeout_count = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_TIMEOUT_COUNT_REG_IDX);
+	state->init_count = (uint16_t)receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_INIT_COUNT_REG_IDX);
+	state->raw16_18 = (uint16_t)receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_RAW16_18_DATAID_REG_IDX);
+	state->sync_count = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_SYNC_COUNT_REG_IDX);
+	state->rx_count = receiver_port_reg_load(ID,
+		port_ID, _HRT_CSS_RECEIVER_RX_COUNT_REG_IDX);
+
+	for (i = 0; i < MIPI_4LANE_CFG ; i++) {
+		state->lane_sync_count[i] = (uint8_t)((state->sync_count)>>(i*8));
+		state->lane_rx_count[i] = (uint8_t)((state->rx_count)>>(i*8));
+	}
+
+return;
+}
+
+STORAGE_CLASS_INLINE void rx_channel_get_state(
+	const rx_ID_t					ID,
+	const unsigned int				ch_id,
+	rx_channel_state_t				*state)
+{
+	int	i;
+
+	assert(ID < N_RX_ID);
+	assert(ch_id < N_RX_CHANNEL_ID);
+	assert(state != NULL);
+
+	switch (ch_id) {
+		case 0:
+			state->comp_scheme0 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX);
+			state->comp_scheme1 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX);
+	break;
+		case 1:
+			state->comp_scheme0 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX);
+			state->comp_scheme1 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX);
+	break;
+		case 2:
+			state->comp_scheme0 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX);
+			state->comp_scheme1 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX);
+	break;
+		case 3:
+			state->comp_scheme0 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX);
+			state->comp_scheme1 = receiver_reg_load(ID,
+				_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX);
+	break;
+	}
+
+/* See Table 7.1.17,..., 7.1.24 */
+	for (i = 0; i < 6; i++) {
+		uint8_t	val = (uint8_t)((state->comp_scheme0)>>(i*5)) & 0x1f;
+		state->comp[i] = (mipi_compressor_t)(val & 0x07);
+		state->pred[i] = (mipi_predictor_t)((val & 0x18) >> 3);
+	}
+	for (i = 6; i < N_MIPI_FORMAT_CUSTOM; i++) {
+		uint8_t	val = (uint8_t)((state->comp_scheme0)>>((i-6)*5)) & 0x1f;
+		state->comp[i] = (mipi_compressor_t)(val & 0x07);
+		state->pred[i] = (mipi_predictor_t)((val & 0x18) >> 3);
+	}
+
+return;
+}
+
+// MW: "2400" in the name is not good, but this is to avoid a naming conflict
+input_system_cfg2400_t config;
+
+static void receiver_rst(
+	const rx_ID_t				ID)
+{
+	mipi_port_ID_t		port_id;
+
+	assert(ID < N_RX_ID);
+
+// Disable all ports.
+	for (port_id = MIPI_PORT0_ID; port_id < N_MIPI_PORT_ID; port_id++) {
+		receiver_port_enable(ID, port_id, false);
+	}
+
+	// AM: Additional actions for stopping receiver?
+
+	return;
+}
+
+//Single function to reset all the devices mapped via GP_DEVICE.
+static void gp_device_rst(const gp_device_ID_t		ID)
+{
+	assert(ID < N_GP_DEVICE_ID);
+
+	gp_device_reg_store(ID, _REG_GP_SYNCGEN_ENABLE_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNCGEN_FREE_RUNNING_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNCGEN_PAUSE_ADDR, ONE);
+	// gp_device_reg_store(ID, _REG_GP_NR_FRAMES_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNGEN_NR_PIX_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNGEN_NR_PIX_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNGEN_NR_LINES_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR, ZERO);
+	// gp_device_reg_store(ID, _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR, ZERO);
+// AM: Following calls cause strange warnings. Probably they should not be initialized.
+//	gp_device_reg_store(ID, _REG_GP_ISEL_SOF_ADDR, ZERO);
+//	gp_device_reg_store(ID, _REG_GP_ISEL_EOF_ADDR, ZERO);
+//	gp_device_reg_store(ID, _REG_GP_ISEL_SOL_ADDR, ZERO);
+//	gp_device_reg_store(ID, _REG_GP_ISEL_EOL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_LFSR_ENABLE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_LFSR_ENABLE_B_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_ENABLE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_ENABLE_B_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_HOR_CNT_MASK_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_VER_CNT_MASK_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_XY_CNT_MASK_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_HOR_CNT_DELTA_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_VER_CNT_DELTA_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_MODE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_RED1_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_GREEN1_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_BLUE1_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_RED2_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_GREEN2_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_TPG_BLUE2_ADDR, ZERO);
+	//gp_device_reg_store(ID, _REG_GP_ISEL_CH_ID_ADDR, ZERO);
+	//gp_device_reg_store(ID, _REG_GP_ISEL_FMT_TYPE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_DATA_SEL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_SBAND_SEL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_SYNC_SEL_ADDR, ZERO);
+	//	gp_device_reg_store(ID, _REG_GP_SYNCGEN_HOR_CNT_ADDR, ZERO);
+	//	gp_device_reg_store(ID, _REG_GP_SYNCGEN_VER_CNT_ADDR, ZERO);
+	//	gp_device_reg_store(ID, _REG_GP_SYNCGEN_FRAME_CNT_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_SOFT_RESET_ADDR, ZERO); // AM: Maybe this soft reset is not safe.
+
+	return;
+}
+
+static void input_selector_cfg_for_sensor(const gp_device_ID_t ID)
+{
+	assert(ID < N_GP_DEVICE_ID);
+
+	gp_device_reg_store(ID, _REG_GP_ISEL_SOF_ADDR, ONE);
+	gp_device_reg_store(ID, _REG_GP_ISEL_EOF_ADDR, ONE);
+	gp_device_reg_store(ID, _REG_GP_ISEL_SOL_ADDR, ONE);
+	gp_device_reg_store(ID, _REG_GP_ISEL_EOL_ADDR, ONE);
+	gp_device_reg_store(ID, _REG_GP_ISEL_CH_ID_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_FMT_TYPE_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_DATA_SEL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_SBAND_SEL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_ISEL_SYNC_SEL_ADDR, ZERO);
+	gp_device_reg_store(ID, _REG_GP_SOFT_RESET_ADDR, ZERO);
+
+	return;
+}
+
+static void input_switch_rst(const gp_device_ID_t ID)
+{
+	int addr;
+
+	assert(ID < N_GP_DEVICE_ID);
+
+	// Initialize the data&hsync LUT.
+	for (addr = _REG_GP_IFMT_input_switch_lut_reg0;
+			 addr <= _REG_GP_IFMT_input_switch_lut_reg7; addr += SIZEOF_HRT_REG) {
+
+		gp_device_reg_store(ID, addr, ZERO);
+	}
+
+	// Initialize the vsync LUT.
+	gp_device_reg_store(ID,
+		_REG_GP_IFMT_input_switch_fsync_lut,
+		ZERO);
+
+	return;
+}
+
+static void input_switch_cfg(
+	const gp_device_ID_t			ID,
+	const input_switch_cfg_t * const	cfg)
+{
+	int addr_offset;
+
+	assert(ID < N_GP_DEVICE_ID);
+	assert(cfg != NULL);
+
+	// Initialize the data&hsync LUT.
+	for (addr_offset = 0; addr_offset < N_RX_CHANNEL_ID * 2; addr_offset++) {
+		assert(addr_offset * SIZEOF_HRT_REG + _REG_GP_IFMT_input_switch_lut_reg0 <= _REG_GP_IFMT_input_switch_lut_reg7);
+		gp_device_reg_store(ID,
+			_REG_GP_IFMT_input_switch_lut_reg0 + addr_offset * SIZEOF_HRT_REG,
+			cfg->hsync_data_reg[addr_offset]);
+	}
+
+	// Initialize the vsync LUT.
+	gp_device_reg_store(ID,
+		_REG_GP_IFMT_input_switch_fsync_lut,
+		cfg->vsync_data_reg);
+
+	return;
+}
+
+
+static void input_system_network_rst(const input_system_ID_t ID)
+{
+	unsigned int sub_id;
+
+	// Reset all 3 multicasts.
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_A_IDX,
+		INPUT_SYSTEM_DISCARD_ALL);
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_B_IDX,
+		INPUT_SYSTEM_DISCARD_ALL);
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_C_IDX,
+		INPUT_SYSTEM_DISCARD_ALL);
+
+	// Reset stream mux.
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MUX_IDX,
+		N_INPUT_SYSTEM_MULTIPLEX);
+
+	// Reset 3 capture units.
+	for (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID; sub_id++) {
+		input_system_sub_system_reg_store(ID,
+			sub_id,
+			CAPT_INIT_REG_ID,
+			1U << CAPT_INIT_RST_REG_BIT);
+	}
+
+	// Reset acquisition unit.
+	for (sub_id = ACQUISITION_UNIT0_ID; sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {
+		input_system_sub_system_reg_store(ID,
+			sub_id,
+			ACQ_INIT_REG_ID,
+			1U << ACQ_INIT_RST_REG_BIT);
+	}
+
+	// DMA unit reset is not needed.
+
+	// Reset controller units.
+	// NB: In future we need to keep part of ctrl_state for split capture and
+	for (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID; sub_id++) {
+		input_system_sub_system_reg_store(ID,
+			sub_id,
+			ISYS_CTRL_INIT_REG_ID,
+			1U); //AM: Is there any named constant?
+	}
+
+	return;
+}
+
+// Function that resets current configuration.
+input_system_error_t input_system_configuration_reset(void)
+{
+	unsigned int i;
+
+	receiver_rst(RX0_ID);
+
+	input_system_network_rst(INPUT_SYSTEM0_ID);
+
+	gp_device_rst(INPUT_SYSTEM0_ID);
+
+	input_switch_rst(INPUT_SYSTEM0_ID);
+
+	//target_rst();
+
+	// Reset IRQ_CTRLs.
+
+	// Reset configuration data structures.
+	for (i = 0; i < N_CHANNELS; i++ ) {
+		config.ch_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;
+		config.target_isp_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;
+		config.target_sp_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;
+		config.target_strm2mem_flags[i] = INPUT_SYSTEM_CFG_FLAG_RESET;
+	}
+
+	for (i = 0; i < N_CSI_PORTS; i++ ) {
+		config.csi_buffer_flags[i]	 = INPUT_SYSTEM_CFG_FLAG_RESET;
+		config.multicast[i]		 = INPUT_SYSTEM_CFG_FLAG_RESET;
+	}
+
+	config.source_type_flags				 = INPUT_SYSTEM_CFG_FLAG_RESET;
+	config.acquisition_buffer_unique_flags	 = INPUT_SYSTEM_CFG_FLAG_RESET;
+	config.unallocated_ib_mem_words			 = IB_CAPACITY_IN_WORDS;
+	//config.acq_allocated_ib_mem_words		 = 0;
+
+	// Set the start of the session cofiguration.
+	config.session_flags = INPUT_SYSTEM_CFG_FLAG_REQUIRED;
+
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+// MW: Comments are good, but doxygen is required, place it at the declaration
+// Function that appends the channel to current configuration.
+static input_system_error_t input_system_configure_channel(
+	const channel_cfg_t		channel)
+{
+	input_system_error_t error = INPUT_SYSTEM_ERR_NO_ERROR;
+	// Check if channel is not already configured.
+	if (config.ch_flags[channel.ch_id] & INPUT_SYSTEM_CFG_FLAG_SET){
+		return INPUT_SYSTEM_ERR_CHANNEL_ALREADY_SET;
+	} else {
+		switch (channel.source_type){
+			case INPUT_SYSTEM_SOURCE_SENSOR :
+				error = input_system_configure_channel_sensor(channel);
+				break;
+			case INPUT_SYSTEM_SOURCE_TPG :
+				return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+				break;
+			case INPUT_SYSTEM_SOURCE_PRBS :
+				return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+				break;
+			case INPUT_SYSTEM_SOURCE_FIFO :
+				return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+				break;
+			default :
+				return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+				break;
+		}
+
+		if (error != INPUT_SYSTEM_ERR_NO_ERROR) return error;
+		// Input switch channel configurations must be combined in united config.
+		config.input_switch_cfg.hsync_data_reg[channel.source_cfg.csi_cfg.csi_port * 2] =
+				channel.target_cfg.input_switch_channel_cfg.hsync_data_reg[0];
+		config.input_switch_cfg.hsync_data_reg[channel.source_cfg.csi_cfg.csi_port * 2 + 1] =
+				channel.target_cfg.input_switch_channel_cfg.hsync_data_reg[1];
+		config.input_switch_cfg.vsync_data_reg |=
+				 (channel.target_cfg.input_switch_channel_cfg.vsync_data_reg & 0x7) << (channel.source_cfg.csi_cfg.csi_port * 3);
+
+		// Other targets are just copied and marked as set.
+		config.target_isp[channel.source_cfg.csi_cfg.csi_port] = channel.target_cfg.target_isp_cfg;
+		config.target_sp[channel.source_cfg.csi_cfg.csi_port] = channel.target_cfg.target_sp_cfg;
+		config.target_strm2mem[channel.source_cfg.csi_cfg.csi_port] = channel.target_cfg.target_strm2mem_cfg;
+		config.target_isp_flags[channel.source_cfg.csi_cfg.csi_port] |= INPUT_SYSTEM_CFG_FLAG_SET;
+		config.target_sp_flags[channel.source_cfg.csi_cfg.csi_port] |= INPUT_SYSTEM_CFG_FLAG_SET;
+		config.target_strm2mem_flags[channel.source_cfg.csi_cfg.csi_port] |= INPUT_SYSTEM_CFG_FLAG_SET;
+
+		config.ch_flags[channel.ch_id] = INPUT_SYSTEM_CFG_FLAG_SET;
+	}
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+// Function that partitions input buffer space with determining addresses.
+static input_system_error_t input_buffer_configuration(void)
+{
+	uint32_t current_address    = 0;
+	uint32_t unallocated_memory = IB_CAPACITY_IN_WORDS;
+
+	ib_buffer_t 	candidate_buffer_acq  = IB_BUFFER_NULL;
+	uint32_t size_requested;
+	input_system_config_flags_t 	acq_already_specified = INPUT_SYSTEM_CFG_FLAG_RESET;
+	input_system_csi_port_t port;
+	for (port = INPUT_SYSTEM_PORT_A; port < N_INPUT_SYSTEM_PORTS; port++) {
+
+		csi_cfg_t source = config.csi_value[port];//.csi_cfg;
+
+		if ( config.csi_flags[port] & INPUT_SYSTEM_CFG_FLAG_SET) {
+
+			uint32_t size_requested;
+			// Check and set csi buffer in input buffer.
+			switch (source.buffering_mode) {
+				case INPUT_SYSTEM_FIFO_CAPTURE :
+				case INPUT_SYSTEM_XMEM_ACQUIRE :
+					config.csi_buffer_flags[port] = INPUT_SYSTEM_CFG_FLAG_BLOCKED; // Well, not used.
+					break;
+
+				case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING :
+				case INPUT_SYSTEM_SRAM_BUFFERING :
+				case INPUT_SYSTEM_XMEM_BUFFERING :
+				case INPUT_SYSTEM_XMEM_CAPTURE :
+					size_requested = source.csi_buffer.mem_reg_size * source.csi_buffer.nof_mem_regs;
+					if (source.csi_buffer.mem_reg_size > 0
+						&& source.csi_buffer.nof_mem_regs >0
+						&& size_requested <= unallocated_memory
+						) {
+							config.csi_buffer[port].mem_reg_addr = current_address;
+							config.csi_buffer[port].mem_reg_size = source.csi_buffer.mem_reg_size;
+							config.csi_buffer[port].nof_mem_regs = source.csi_buffer.nof_mem_regs;
+							current_address		+= size_requested;
+							unallocated_memory 	-= size_requested;
+							config.csi_buffer_flags[port] = INPUT_SYSTEM_CFG_FLAG_SET;
+					} else {
+							config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+							return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+					}
+					break;
+
+				default :
+					config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+					return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+					break;
+			}
+
+			// Check acquisition buffer specified but set it later since it has to be unique.
+			switch (source.buffering_mode) {
+				case INPUT_SYSTEM_FIFO_CAPTURE :
+				case INPUT_SYSTEM_SRAM_BUFFERING :
+				case INPUT_SYSTEM_XMEM_CAPTURE :
+					// Nothing to do.
+					break;
+
+				case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING :
+				case INPUT_SYSTEM_XMEM_BUFFERING :
+				case INPUT_SYSTEM_XMEM_ACQUIRE :
+					if (acq_already_specified == INPUT_SYSTEM_CFG_FLAG_RESET) {
+						uint32_t size_requested = source.acquisition_buffer.mem_reg_size
+													* source.acquisition_buffer.nof_mem_regs;
+						if (source.acquisition_buffer.mem_reg_size > 0
+							&& source.acquisition_buffer.nof_mem_regs >0
+							&& size_requested <= unallocated_memory
+							) {
+								candidate_buffer_acq = source.acquisition_buffer;
+								acq_already_specified = INPUT_SYSTEM_CFG_FLAG_SET;
+						}
+					} else {
+						// Check if specified acquisition buffer is the same as specified before.
+						if (source.acquisition_buffer.mem_reg_size != candidate_buffer_acq.mem_reg_size
+							|| source.acquisition_buffer.nof_mem_regs !=  candidate_buffer_acq.nof_mem_regs
+						   ) {
+							config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+							return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+						}
+					}
+					break;
+
+				default :
+					return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+					break;
+			}
+		} else {
+			config.csi_buffer_flags[port] = INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+		}
+	} // end of for ( port )
+
+	// Set the acquisition buffer at the end.
+	size_requested = candidate_buffer_acq.mem_reg_size * candidate_buffer_acq.nof_mem_regs;
+	if (acq_already_specified == INPUT_SYSTEM_CFG_FLAG_SET
+		&& size_requested <= unallocated_memory) {
+		config.acquisition_buffer_unique.mem_reg_addr = current_address;
+		config.acquisition_buffer_unique.mem_reg_size = candidate_buffer_acq.mem_reg_size;
+		config.acquisition_buffer_unique.nof_mem_regs = candidate_buffer_acq.nof_mem_regs;
+		current_address		+= size_requested;
+		unallocated_memory 	-= size_requested;
+		config.acquisition_buffer_unique_flags = INPUT_SYSTEM_CFG_FLAG_SET;
+
+		assert(current_address <= IB_CAPACITY_IN_WORDS);
+	}
+
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+static void capture_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ib_buffer_t* const		cfg)
+{
+	assert(ID < N_INPUT_SYSTEM_ID);
+	assert(/*(sub_id >= CAPTURE_UNIT0_ID) &&*/ (sub_id <= CAPTURE_UNIT2_ID)); // Commented part is always true.
+	assert(cfg != NULL);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		CAPT_START_ADDR_REG_ID,
+		cfg->mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		CAPT_MEM_REGION_SIZE_REG_ID,
+		cfg->mem_reg_size);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		CAPT_NUM_MEM_REGIONS_REG_ID,
+		cfg->nof_mem_regs);
+
+	return;
+}
+
+
+static void acquisition_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ib_buffer_t* const		cfg)
+{
+	assert(ID < N_INPUT_SYSTEM_ID);
+	assert(sub_id == ACQUISITION_UNIT0_ID);
+	assert(cfg != NULL);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ACQ_START_ADDR_REG_ID,
+		cfg->mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ACQ_NUM_MEM_REGIONS_REG_ID,
+		cfg->nof_mem_regs);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ACQ_MEM_REGION_SIZE_REG_ID,
+		cfg->mem_reg_size);
+
+	return;
+}
+
+
+static void ctrl_unit_configure(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_id,
+	const ctrl_unit_cfg_t* const		cfg)
+{
+	assert(ID < N_INPUT_SYSTEM_ID);
+	assert(sub_id == CTRL_UNIT0_ID);
+	assert(cfg != NULL);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_A_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT0_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT0_ID].mem_reg_size);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT0_ID].nof_mem_regs);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_B_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT1_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT1_ID].mem_reg_size);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT1_ID].nof_mem_regs);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_START_ADDR_C_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT2_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT2_ID].mem_reg_size);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID,
+		cfg->buffer_mipi[CAPTURE_UNIT2_ID].nof_mem_regs);
+
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_START_ADDR_REG_ID,
+		cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].mem_reg_addr);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID,
+		cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].mem_reg_size);
+	input_system_sub_system_reg_store(ID,
+		sub_id,
+		ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID,
+		cfg->buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID].nof_mem_regs);
+	input_system_sub_system_reg_store(ID,
+                sub_id,
+                ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID,
+		0);
+	return;
+}
+
+static void input_system_network_configure(
+	const input_system_ID_t				ID,
+	const input_system_network_cfg_t * const 	cfg)
+{
+	uint32_t sub_id;
+
+	assert(ID < N_INPUT_SYSTEM_ID);
+	assert(cfg != NULL);
+
+	// Set all 3 multicasts.
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_A_IDX,
+		cfg->multicast_cfg[CAPTURE_UNIT0_ID]);
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_B_IDX,
+		cfg->multicast_cfg[CAPTURE_UNIT1_ID]);
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MULTICAST_C_IDX,
+		cfg->multicast_cfg[CAPTURE_UNIT2_ID]);
+
+	// Set stream mux.
+	input_system_sub_system_reg_store(ID,
+		GPREGS_UNIT0_ID,
+		HIVE_ISYS_GPREG_MUX_IDX,
+		cfg->mux_cfg);
+
+	// Set capture units.
+	for (sub_id = CAPTURE_UNIT0_ID; sub_id < CAPTURE_UNIT0_ID + N_CAPTURE_UNIT_ID; sub_id++) {
+		capture_unit_configure(ID,
+			sub_id,
+			&(cfg->ctrl_unit_cfg[ID].buffer_mipi[sub_id - CAPTURE_UNIT0_ID]));
+	}
+
+	// Set acquisition units.
+	for (sub_id = ACQUISITION_UNIT0_ID; sub_id < ACQUISITION_UNIT0_ID + N_ACQUISITION_UNIT_ID; sub_id++) {
+		acquisition_unit_configure(ID,
+			sub_id,
+			&(cfg->ctrl_unit_cfg[sub_id - ACQUISITION_UNIT0_ID].buffer_acquire[sub_id - ACQUISITION_UNIT0_ID]));
+	}
+
+	// No DMA configuration needed. Ctrl_unit will fully control it.
+
+	// Set controller units.
+	for (sub_id = CTRL_UNIT0_ID; sub_id < CTRL_UNIT0_ID + N_CTRL_UNIT_ID; sub_id++) {
+		ctrl_unit_configure(ID,
+			sub_id,
+			&(cfg->ctrl_unit_cfg[sub_id - CTRL_UNIT0_ID]));
+	}
+
+	return;
+}
+
+static input_system_error_t configuration_to_registers(void)
+{
+	input_system_network_cfg_t input_system_network_cfg;
+	int i;
+
+	assert(config.source_type_flags & INPUT_SYSTEM_CFG_FLAG_SET);
+
+	switch (config.source_type) {
+		case INPUT_SYSTEM_SOURCE_SENSOR :
+
+			// Determine stream multicasts setting based on the mode of csi_cfg_t.
+			// AM: This should be moved towards earlier function call, e.g. in
+			// the commit function.
+			for (i = MIPI_PORT0_ID; i < N_MIPI_PORT_ID; i++) {
+				if (config.csi_flags[i] & INPUT_SYSTEM_CFG_FLAG_SET) {
+
+					switch (config.csi_value[i].buffering_mode) {
+
+						case INPUT_SYSTEM_FIFO_CAPTURE:
+							config.multicast[i] = INPUT_SYSTEM_CSI_BACKEND;
+							break;
+
+						case INPUT_SYSTEM_XMEM_CAPTURE:
+						case INPUT_SYSTEM_SRAM_BUFFERING:
+						case INPUT_SYSTEM_XMEM_BUFFERING:
+							config.multicast[i] = INPUT_SYSTEM_INPUT_BUFFER;
+							break;
+
+						case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING:
+							config.multicast[i] = INPUT_SYSTEM_MULTICAST;
+							break;
+
+						case INPUT_SYSTEM_XMEM_ACQUIRE:
+							config.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;
+							break;
+
+						default:
+							config.multicast[i] = INPUT_SYSTEM_DISCARD_ALL;
+							return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+							//break;
+					}
+				} else {
+					config.multicast[i]= INPUT_SYSTEM_DISCARD_ALL;
+				}
+
+				input_system_network_cfg.multicast_cfg[i] = config.multicast[i];
+
+			} // for
+
+			input_system_network_cfg.mux_cfg = config.multiplexer;
+
+			input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT0_ID] = config.csi_buffer[MIPI_PORT0_ID];
+			input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT1_ID] = config.csi_buffer[MIPI_PORT1_ID];
+			input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID].buffer_mipi[CAPTURE_UNIT2_ID] = config.csi_buffer[MIPI_PORT2_ID];
+			input_system_network_cfg.ctrl_unit_cfg[CTRL_UNIT0_ID - CTRL_UNIT0_ID].buffer_acquire[ACQUISITION_UNIT0_ID - ACQUISITION_UNIT0_ID] =
+					config.acquisition_buffer_unique;
+
+			// First set input network around CSI receiver.
+			input_system_network_configure(INPUT_SYSTEM0_ID, &input_system_network_cfg);
+
+			// Set the CSI receiver.
+			//...
+			break;
+
+		case INPUT_SYSTEM_SOURCE_TPG :
+
+			break;
+
+		case INPUT_SYSTEM_SOURCE_PRBS :
+
+			break;
+
+		case INPUT_SYSTEM_SOURCE_FIFO :
+			break;
+
+		default :
+			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+			break;
+
+	} // end of switch (source_type)
+
+	// Set input selector.
+	input_selector_cfg_for_sensor(INPUT_SYSTEM0_ID);
+
+	// Set input switch.
+	input_switch_cfg(INPUT_SYSTEM0_ID, &config.input_switch_cfg);
+
+	// Set input formatters.
+	// AM: IF are set dynamically.
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+
+// Function that applies the whole configuration.
+input_system_error_t input_system_configuration_commit(void)
+{
+	// The last configuration step is to configure the input buffer.
+	input_system_error_t error = input_buffer_configuration();
+	if (error != INPUT_SYSTEM_ERR_NO_ERROR) {
+		return error;
+	}
+
+	// Translate the whole configuration into registers.
+	error = configuration_to_registers();
+	if (error != INPUT_SYSTEM_ERR_NO_ERROR) {
+		return error;
+	}
+
+	// Translate the whole configuration into ctrl commands etc.
+
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+
+
+// FIFO
+
+input_system_error_t	input_system_csi_fifo_channel_cfg(
+		uint32_t		ch_id,
+		input_system_csi_port_t	port,
+		backend_channel_cfg_t	backend_ch,
+		target_cfg2400_t	target
+)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	channel.backend_ch 	= backend_ch;
+	channel.source_type = INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_FIFO_CAPTURE;
+	channel.source_cfg.csi_cfg.csi_buffer 			= IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.acquisition_buffer	= IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= 0;
+
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+input_system_error_t	input_system_csi_fifo_channel_with_counting_cfg(
+		uint32_t				ch_id,
+		uint32_t				nof_frames,
+		input_system_csi_port_t			port,
+		backend_channel_cfg_t			backend_ch,
+		uint32_t				csi_mem_reg_size,
+		uint32_t				csi_nof_mem_regs,
+		target_cfg2400_t			target
+)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	channel.backend_ch 	= backend_ch;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs 		= csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer			= IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_frames;
+
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+// SRAM
+
+input_system_error_t	input_system_csi_sram_channel_cfg(
+		uint32_t				ch_id,
+		input_system_csi_port_t			port,
+		backend_channel_cfg_t			backend_ch,
+		uint32_t				csi_mem_reg_size,
+		uint32_t				csi_nof_mem_regs,
+	//	uint32_t				acq_mem_reg_size,
+	//	uint32_t				acq_nof_mem_regs,
+		target_cfg2400_t 			target
+)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	channel.backend_ch 	= backend_ch;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_SRAM_BUFFERING;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs 		= csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer			= IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= 0;
+
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+//XMEM
+
+// Collects all parameters and puts them in channel_cfg_t.
+input_system_error_t	input_system_csi_xmem_channel_cfg(
+		uint32_t 				ch_id,
+		input_system_csi_port_t			port,
+		backend_channel_cfg_t			backend_ch,
+		uint32_t 				csi_mem_reg_size,
+		uint32_t 				csi_nof_mem_regs,
+		uint32_t 				acq_mem_reg_size,
+		uint32_t 				acq_nof_mem_regs,
+		target_cfg2400_t 			target,
+		uint32_t 				nof_xmem_buffers
+)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	channel.backend_ch 	= backend_ch;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_XMEM_BUFFERING;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs 		= csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size	= acq_mem_reg_size;
+	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs 	= acq_nof_mem_regs;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr	= 0;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_xmem_buffers;
+
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+
+
+input_system_error_t	input_system_csi_xmem_acquire_only_channel_cfg(
+		uint32_t 				ch_id,
+		uint32_t 				nof_frames,
+		input_system_csi_port_t			port,
+		backend_channel_cfg_t			backend_ch,
+		uint32_t 				acq_mem_reg_size,
+		uint32_t 				acq_nof_mem_regs,
+		target_cfg2400_t 			target)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	channel.backend_ch 	= backend_ch;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_XMEM_ACQUIRE;
+	channel.source_cfg.csi_cfg.csi_buffer		= IB_BUFFER_NULL;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size	= acq_mem_reg_size;
+	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs 	= acq_nof_mem_regs;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr	= 0;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_frames;
+
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+input_system_error_t	input_system_csi_xmem_capture_only_channel_cfg(
+		uint32_t 				ch_id,
+		uint32_t 				nof_frames,
+		input_system_csi_port_t			port,
+		uint32_t 				csi_mem_reg_size,
+		uint32_t 				csi_nof_mem_regs,
+		uint32_t 				acq_mem_reg_size,
+		uint32_t 				acq_nof_mem_regs,
+		target_cfg2400_t 			target)
+{
+	channel_cfg_t channel;
+
+	channel.ch_id 	= ch_id;
+	//channel.backend_ch 	= backend_ch;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_SENSOR;
+	//channel.source
+	channel.source_cfg.csi_cfg.csi_port			= port;
+	//channel.source_cfg.csi_cfg.backend_ch 		= backend_ch;
+	channel.source_cfg.csi_cfg.buffering_mode	= INPUT_SYSTEM_XMEM_CAPTURE;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_size		= csi_mem_reg_size;
+	channel.source_cfg.csi_cfg.csi_buffer.nof_mem_regs 		= csi_nof_mem_regs;
+	channel.source_cfg.csi_cfg.csi_buffer.mem_reg_addr		= 0;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_size	= acq_mem_reg_size;
+	channel.source_cfg.csi_cfg.acquisition_buffer.nof_mem_regs 	= acq_nof_mem_regs;
+	channel.source_cfg.csi_cfg.acquisition_buffer.mem_reg_addr	= 0;
+	channel.source_cfg.csi_cfg.nof_xmem_buffers	= nof_frames;
+
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+
+
+// Non - CSI
+
+input_system_error_t	input_system_prbs_channel_cfg(
+		uint32_t 		ch_id,
+		uint32_t		nof_frames,//not used yet
+		uint32_t		seed,
+		uint32_t		sync_gen_width,
+		uint32_t		sync_gen_height,
+		uint32_t		sync_gen_hblank_cycles,
+		uint32_t		sync_gen_vblank_cycles,
+		target_cfg2400_t	target
+)
+{
+	channel_cfg_t channel;
+
+	(void)nof_frames;
+
+	channel.ch_id 	= ch_id;
+	channel.source_type= INPUT_SYSTEM_SOURCE_PRBS;
+
+	channel.source_cfg.prbs_cfg.seed = seed;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.width         	= sync_gen_width;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.height        	= sync_gen_height;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.hblank_cycles	= sync_gen_hblank_cycles;
+	channel.source_cfg.prbs_cfg.sync_gen_cfg.vblank_cycles 	= sync_gen_vblank_cycles;
+
+	channel.target_cfg	= target;
+
+	return input_system_configure_channel(channel);
+}
+
+
+
+input_system_error_t	input_system_tpg_channel_cfg(
+		uint32_t 		ch_id,
+		uint32_t 		nof_frames,//not used yet
+		uint32_t		x_mask,
+		uint32_t		y_mask,
+		uint32_t		x_delta,
+		uint32_t		y_delta,
+		uint32_t		xy_mask,
+		uint32_t		sync_gen_width,
+		uint32_t		sync_gen_height,
+		uint32_t		sync_gen_hblank_cycles,
+		uint32_t		sync_gen_vblank_cycles,
+		target_cfg2400_t	target
+)
+{
+	channel_cfg_t channel;
+
+	(void)nof_frames;
+
+	channel.ch_id 	= ch_id;
+	channel.source_type		= INPUT_SYSTEM_SOURCE_TPG;
+
+	channel.source_cfg.tpg_cfg.x_mask	= x_mask;
+	channel.source_cfg.tpg_cfg.y_mask	= y_mask;
+	channel.source_cfg.tpg_cfg.x_delta	= x_delta;
+	channel.source_cfg.tpg_cfg.y_delta	= y_delta;
+	channel.source_cfg.tpg_cfg.xy_mask	= xy_mask;
+	channel.source_cfg.tpg_cfg.sync_gen_cfg.width         	= sync_gen_width;
+	channel.source_cfg.tpg_cfg.sync_gen_cfg.height        	= sync_gen_height;
+	channel.source_cfg.tpg_cfg.sync_gen_cfg.hblank_cycles	= sync_gen_hblank_cycles;
+	channel.source_cfg.tpg_cfg.sync_gen_cfg.vblank_cycles 	= sync_gen_vblank_cycles;
+
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+// MW: Don't use system specific names, (even in system specific files) "cfg2400" -> cfg
+input_system_error_t	input_system_gpfifo_channel_cfg(
+		uint32_t 		ch_id,
+		uint32_t 		nof_frames, //not used yet
+		target_cfg2400_t	target)
+{
+	channel_cfg_t channel;
+
+	(void)nof_frames;
+
+	channel.ch_id 	= ch_id;
+	channel.source_type	= INPUT_SYSTEM_SOURCE_FIFO;
+
+	channel.target_cfg	= target;
+	return input_system_configure_channel(channel);
+}
+
+///////////////////////////////////////////////////////////////////////////
+//
+// Private specialized functions for channel setting.
+//
+///////////////////////////////////////////////////////////////////////////
+
+// Fills the parameters to config.csi_value[port]
+static input_system_error_t input_system_configure_channel_sensor(
+	const channel_cfg_t channel)
+{
+	const uint32_t port = channel.source_cfg.csi_cfg.csi_port;
+	input_system_error_t status = INPUT_SYSTEM_ERR_NO_ERROR;
+
+	input_system_multiplex_t mux;
+
+	if (port >= N_INPUT_SYSTEM_PORTS)
+		return INPUT_SYSTEM_ERR_GENERIC;
+
+	//check if port > N_INPUT_SYSTEM_MULTIPLEX
+
+	status = set_source_type(&(config.source_type), channel.source_type, &config.source_type_flags);
+	if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+
+	// Check for conflicts on source (implicitly on multicast, capture unit and input buffer).
+
+	status = set_csi_cfg(&(config.csi_value[port]), &channel.source_cfg.csi_cfg, &(config.csi_flags[port]));
+	if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+
+
+	switch (channel.source_cfg.csi_cfg.buffering_mode){
+		case INPUT_SYSTEM_FIFO_CAPTURE:
+
+			// Check for conflicts on mux.
+			mux = INPUT_SYSTEM_MIPI_PORT0 + port;
+			status = input_system_multiplexer_cfg(&config.multiplexer, mux, &config.multiplexer_flags);
+			if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+			config.multicast[port] = INPUT_SYSTEM_CSI_BACKEND;
+
+			// Shared resource, so it should be blocked.
+			//config.mux_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+
+			break;
+		case INPUT_SYSTEM_SRAM_BUFFERING :
+
+			// Check for conflicts on mux.
+			mux = INPUT_SYSTEM_ACQUISITION_UNIT;
+			status = input_system_multiplexer_cfg(&config.multiplexer, mux, &config.multiplexer_flags);
+			if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+			config.multicast[port] = INPUT_SYSTEM_INPUT_BUFFER;
+
+			// Shared resource, so it should be blocked.
+			//config.mux_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+
+			break;
+		case INPUT_SYSTEM_XMEM_BUFFERING :
+
+			// Check for conflicts on mux.
+			mux = INPUT_SYSTEM_ACQUISITION_UNIT;
+			status = input_system_multiplexer_cfg(&config.multiplexer, mux, &config.multiplexer_flags);
+			if (status != INPUT_SYSTEM_ERR_NO_ERROR) return status;
+			config.multicast[port] = INPUT_SYSTEM_INPUT_BUFFER;
+
+			// Shared resource, so it should be blocked.
+			//config.mux_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.csi_buffer_flags[port] |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+			//config.acquisition_buffer_unique_flags |= INPUT_SYSTEM_CFG_FLAG_BLOCKED;
+
+			break;
+		case INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING :
+			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+			break;
+		case INPUT_SYSTEM_XMEM_CAPTURE :
+			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+			break;
+		case INPUT_SYSTEM_XMEM_ACQUIRE :
+			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+			break;
+		default :
+			return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+			break;
+	}
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+// Test flags and set structure.
+static input_system_error_t set_source_type(
+		input_system_source_t * const 			lhs,
+		const input_system_source_t 			rhs,
+		input_system_config_flags_t * const	 	flags)
+{
+	// MW: Not enough asserts
+	assert(lhs != NULL);
+	assert(flags != NULL);
+
+	if ((*flags) & INPUT_SYSTEM_CFG_FLAG_BLOCKED) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+	}
+
+	if ((*flags) & INPUT_SYSTEM_CFG_FLAG_SET) {
+		// Check for consistency with already set value.
+		if ((*lhs) == (rhs)) {
+			return INPUT_SYSTEM_ERR_NO_ERROR;
+		}
+		else {
+			*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+			return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+		}
+	}
+	// Check the value (individually).
+	if (rhs >= N_INPUT_SYSTEM_SOURCE) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+	}
+	// Set the value.
+	*lhs = rhs;
+
+	*flags |= INPUT_SYSTEM_CFG_FLAG_SET;
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+
+// Test flags and set structure.
+static input_system_error_t set_csi_cfg(
+		csi_cfg_t* const 			lhs,
+		const csi_cfg_t* const 			rhs,
+		input_system_config_flags_t * const 	flags)
+{
+	uint32_t memory_required;
+	uint32_t acq_memory_required;
+
+	assert(lhs != NULL);
+	assert(flags != NULL);
+
+	if ((*flags) & INPUT_SYSTEM_CFG_FLAG_BLOCKED) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+	}
+
+	if (*flags & INPUT_SYSTEM_CFG_FLAG_SET) {
+		// check for consistency with already set value.
+		if (/*lhs->backend_ch == rhs.backend_ch
+			&&*/ lhs->buffering_mode == rhs->buffering_mode
+			&& lhs->csi_buffer.mem_reg_size == rhs->csi_buffer.mem_reg_size
+			&& lhs->csi_buffer.nof_mem_regs  == rhs->csi_buffer.nof_mem_regs
+			&& lhs->acquisition_buffer.mem_reg_size == rhs->acquisition_buffer.mem_reg_size
+			&& lhs->acquisition_buffer.nof_mem_regs  == rhs->acquisition_buffer.nof_mem_regs
+			&& lhs->nof_xmem_buffers  == rhs->nof_xmem_buffers
+			) {
+			return INPUT_SYSTEM_ERR_NO_ERROR;
+		}
+		else {
+			*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+			return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+		}
+	}
+	// Check the value (individually).
+	// no check for backend_ch
+	// no check for nof_xmem_buffers
+	memory_required = rhs->csi_buffer.mem_reg_size * rhs->csi_buffer.nof_mem_regs;
+	acq_memory_required = rhs->acquisition_buffer.mem_reg_size * rhs->acquisition_buffer.nof_mem_regs;
+	if (rhs->buffering_mode >= N_INPUT_SYSTEM_BUFFERING_MODE
+		||
+	// Check if required memory is available in input buffer (SRAM).
+		(memory_required + acq_memory_required )> config.unallocated_ib_mem_words
+
+		) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+	}
+	// Set the value.
+	//lhs[port]->backend_ch 		= rhs.backend_ch;
+	lhs->buffering_mode 	= rhs->buffering_mode;
+	lhs->nof_xmem_buffers = rhs->nof_xmem_buffers;
+
+	lhs->csi_buffer.mem_reg_size = rhs->csi_buffer.mem_reg_size;
+	lhs->csi_buffer.nof_mem_regs  = rhs->csi_buffer.nof_mem_regs;
+	lhs->acquisition_buffer.mem_reg_size = rhs->acquisition_buffer.mem_reg_size;
+	lhs->acquisition_buffer.nof_mem_regs  = rhs->acquisition_buffer.nof_mem_regs;
+    // ALX: NB: Here we just set buffer parameters, but still not allocate it
+	// (no addresses determined). That will be done during commit.
+
+	//  FIXIT:	acq_memory_required is not deducted, since it can be allocated multiple times.
+	config.unallocated_ib_mem_words -= memory_required;
+//assert(config.unallocated_ib_mem_words >=0);
+	*flags |= INPUT_SYSTEM_CFG_FLAG_SET;
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
+
+
+// Test flags and set structure.
+static input_system_error_t input_system_multiplexer_cfg(
+	input_system_multiplex_t* const		lhs,
+	const input_system_multiplex_t		rhs,
+	input_system_config_flags_t* const	flags)
+{
+	assert(lhs != NULL);
+	assert(flags != NULL);
+
+	if ((*flags) & INPUT_SYSTEM_CFG_FLAG_BLOCKED) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+	}
+
+	if ((*flags) & INPUT_SYSTEM_CFG_FLAG_SET) {
+		// Check for consistency with already set value.
+		if ((*lhs) == (rhs)) {
+			return INPUT_SYSTEM_ERR_NO_ERROR;
+		}
+		else {
+			*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+			return INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE;
+		}
+	}
+	// Check the value (individually).
+	if (rhs >= N_INPUT_SYSTEM_MULTIPLEX) {
+		*flags |= INPUT_SYSTEM_CFG_FLAG_CONFLICT;
+		return INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED;
+	}
+	// Set the value.
+	*lhs = rhs;
+
+	*flags |= INPUT_SYSTEM_CFG_FLAG_SET;
+	return INPUT_SYSTEM_ERR_NO_ERROR;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_local.h
new file mode 100644
index 0000000..dfdec41
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_local.h
@@ -0,0 +1,540 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __INPUT_SYSTEM_LOCAL_H_INCLUDED__
+#define __INPUT_SYSTEM_LOCAL_H_INCLUDED__
+
+#include <type_support.h>
+
+#include "input_system_global.h"
+
+#include "input_system_defs.h"		/* HIVE_ISYS_GPREG_MULTICAST_A_IDX,... */
+#include "css_receiver_2400_defs.h"	/* _HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX, _HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX,... */
+#if defined(IS_ISP_2400_MAMOIADA_SYSTEM)
+#include "isp_capture_defs.h"
+#elif defined(IS_ISP_2401_MAMOIADA_SYSTEM)
+/* Same name, but keep the distinction,it is a different device */
+#include "isp_capture_defs.h"
+#else
+#error "input_system_local.h: 2400_SYSTEM must be one of {2400, 2401 }"
+#endif
+#include "isp_acquisition_defs.h"
+#include "input_system_ctrl_defs.h"
+
+
+typedef enum {
+	INPUT_SYSTEM_ERR_NO_ERROR = 0,
+	INPUT_SYSTEM_ERR_GENERIC,
+	INPUT_SYSTEM_ERR_CHANNEL_ALREADY_SET,
+	INPUT_SYSTEM_ERR_CONFLICT_ON_RESOURCE,
+	INPUT_SYSTEM_ERR_PARAMETER_NOT_SUPPORTED,
+	N_INPUT_SYSTEM_ERR
+} input_system_error_t;
+
+typedef enum {
+	INPUT_SYSTEM_PORT_A = 0,
+	INPUT_SYSTEM_PORT_B,
+	INPUT_SYSTEM_PORT_C,
+	N_INPUT_SYSTEM_PORTS
+} input_system_csi_port_t;
+
+typedef struct ctrl_unit_cfg_s			ctrl_unit_cfg_t;
+typedef struct input_system_network_cfg_s	input_system_network_cfg_t;
+typedef struct target_cfg2400_s 		target_cfg2400_t;
+typedef struct channel_cfg_s 			channel_cfg_t;
+typedef struct backend_channel_cfg_s 		backend_channel_cfg_t;
+typedef struct input_system_cfg2400_s 		input_system_cfg2400_t;
+typedef struct mipi_port_state_s		mipi_port_state_t;
+typedef struct rx_channel_state_s		rx_channel_state_t;
+typedef struct input_switch_cfg_channel_s 	input_switch_cfg_channel_t;
+typedef struct input_switch_cfg_s 		input_switch_cfg_t;
+
+struct ctrl_unit_cfg_s {
+	ib_buffer_t		buffer_mipi[N_CAPTURE_UNIT_ID];
+	ib_buffer_t		buffer_acquire[N_ACQUISITION_UNIT_ID];
+};
+
+struct input_system_network_cfg_s {
+	input_system_connection_t	multicast_cfg[N_CAPTURE_UNIT_ID];
+	input_system_multiplex_t	mux_cfg;
+	ctrl_unit_cfg_t				ctrl_unit_cfg[N_CTRL_UNIT_ID];
+};
+
+typedef struct {
+// TBD.
+	uint32_t 	dummy_parameter;
+} target_isp_cfg_t;
+
+
+typedef struct {
+// TBD.
+	uint32_t 	dummy_parameter;
+} target_sp_cfg_t;
+
+
+typedef struct {
+// TBD.
+	uint32_t 	dummy_parameter;
+} target_strm2mem_cfg_t;
+
+struct input_switch_cfg_channel_s {
+	uint32_t hsync_data_reg[2];
+	uint32_t vsync_data_reg;
+};
+
+struct target_cfg2400_s {
+	input_switch_cfg_channel_t 		input_switch_channel_cfg;
+	target_isp_cfg_t	target_isp_cfg;
+	target_sp_cfg_t		target_sp_cfg;
+	target_strm2mem_cfg_t	target_strm2mem_cfg;
+};
+
+struct backend_channel_cfg_s {
+	uint32_t	fmt_control_word_1; // Format config.
+	uint32_t	fmt_control_word_2;
+	uint32_t	no_side_band;
+};
+
+typedef union  {
+	csi_cfg_t	csi_cfg;
+	tpg_cfg_t	tpg_cfg;
+	prbs_cfg_t	prbs_cfg;
+	gpfifo_cfg_t	gpfifo_cfg;
+} source_cfg_t;
+
+
+struct input_switch_cfg_s {
+	uint32_t hsync_data_reg[N_RX_CHANNEL_ID * 2];
+	uint32_t vsync_data_reg;
+};
+
+// Configuration of a channel.
+struct channel_cfg_s {
+	uint32_t		ch_id;
+	backend_channel_cfg_t	backend_ch;
+	input_system_source_t	source_type;
+	source_cfg_t		source_cfg;
+	target_cfg2400_t	target_cfg;
+};
+
+
+// Complete configuration for input system.
+struct input_system_cfg2400_s {
+
+	input_system_source_t source_type;				input_system_config_flags_t	source_type_flags;
+	//channel_cfg_t		channel[N_CHANNELS];
+	input_system_config_flags_t	ch_flags[N_CHANNELS];
+	//  This is the place where the buffers' settings are collected, as given.
+	csi_cfg_t			csi_value[N_CSI_PORTS];		input_system_config_flags_t	csi_flags[N_CSI_PORTS];
+
+	// Possible another struct for ib.
+	// This buffers set at the end, based on the all configurations.
+	ib_buffer_t			csi_buffer[N_CSI_PORTS];	input_system_config_flags_t	csi_buffer_flags[N_CSI_PORTS];
+	ib_buffer_t			acquisition_buffer_unique;	input_system_config_flags_t	acquisition_buffer_unique_flags;
+	uint32_t			unallocated_ib_mem_words; // Used for check.DEFAULT = IB_CAPACITY_IN_WORDS.
+	//uint32_t			acq_allocated_ib_mem_words;
+
+	input_system_connection_t		multicast[N_CSI_PORTS];
+	input_system_multiplex_t		multiplexer;   					input_system_config_flags_t		multiplexer_flags;
+
+
+	tpg_cfg_t			tpg_value;			input_system_config_flags_t	tpg_flags;
+	prbs_cfg_t			prbs_value;			input_system_config_flags_t	prbs_flags;
+	gpfifo_cfg_t		gpfifo_value;		input_system_config_flags_t	gpfifo_flags;
+
+
+	input_switch_cfg_t		input_switch_cfg;
+
+
+	target_isp_cfg_t		target_isp      [N_CHANNELS];	input_system_config_flags_t	target_isp_flags      [N_CHANNELS];
+	target_sp_cfg_t			target_sp       [N_CHANNELS];	input_system_config_flags_t	target_sp_flags       [N_CHANNELS];
+	target_strm2mem_cfg_t	target_strm2mem [N_CHANNELS];	input_system_config_flags_t	target_strm2mem_flags [N_CHANNELS];
+
+	input_system_config_flags_t		session_flags;
+
+};
+
+/*
+ * For each MIPI port
+ */
+#define _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX			_HRT_CSS_RECEIVER_2400_DEVICE_READY_REG_IDX
+#define _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX			_HRT_CSS_RECEIVER_2400_IRQ_STATUS_REG_IDX
+#define _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX			_HRT_CSS_RECEIVER_2400_IRQ_ENABLE_REG_IDX
+#define _HRT_CSS_RECEIVER_TIMEOUT_COUNT_REG_IDX		    _HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX
+#define _HRT_CSS_RECEIVER_INIT_COUNT_REG_IDX			_HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX
+/* new regs for each MIPI port w.r.t. 2300 */
+#define _HRT_CSS_RECEIVER_RAW16_18_DATAID_REG_IDX       _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_REG_IDX
+#define _HRT_CSS_RECEIVER_SYNC_COUNT_REG_IDX            _HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX
+#define _HRT_CSS_RECEIVER_RX_COUNT_REG_IDX              _HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX
+
+/* _HRT_CSS_RECEIVER_2400_COMP_FORMAT_REG_IDX is not defined per MIPI port but per channel */
+/* _HRT_CSS_RECEIVER_2400_COMP_PREDICT_REG_IDX is not defined per MIPI port but per channel */
+#define _HRT_CSS_RECEIVER_FS_TO_LS_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_FS_TO_LS_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_LS_TO_DATA_DELAY_REG_IDX      _HRT_CSS_RECEIVER_2400_LS_TO_DATA_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_DATA_TO_LE_DELAY_REG_IDX      _HRT_CSS_RECEIVER_2400_DATA_TO_LE_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_LE_TO_FE_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_LE_TO_FE_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_FE_TO_FS_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_FE_TO_FS_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_LE_TO_LS_DELAY_REG_IDX        _HRT_CSS_RECEIVER_2400_LE_TO_LS_DELAY_REG_IDX
+#define _HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX			_HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX
+#define _HRT_CSS_RECEIVER_BACKEND_RST_REG_IDX           _HRT_CSS_RECEIVER_2400_BACKEND_RST_REG_IDX
+#define _HRT_CSS_RECEIVER_RAW18_REG_IDX                 _HRT_CSS_RECEIVER_2400_RAW18_REG_IDX
+#define _HRT_CSS_RECEIVER_FORCE_RAW8_REG_IDX            _HRT_CSS_RECEIVER_2400_FORCE_RAW8_REG_IDX
+#define _HRT_CSS_RECEIVER_RAW16_REG_IDX                 _HRT_CSS_RECEIVER_2400_RAW16_REG_IDX
+
+/* Previously MIPI port regs, now 2x2 logical channel regs */
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC0_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC0_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC1_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC1_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC2_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC2_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC3_REG0_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX
+#define _HRT_CSS_RECEIVER_COMP_SCHEME_VC3_REG1_IDX		_HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX
+
+/* Second backend is at offset 0x0700 w.r.t. the first port at offset 0x0100 */
+#define _HRT_CSS_BE_OFFSET                              448
+#define _HRT_CSS_RECEIVER_BE_GSP_ACC_OVL_REG_IDX        (_HRT_CSS_RECEIVER_2400_BE_GSP_ACC_OVL_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_SRST_REG_IDX               (_HRT_CSS_RECEIVER_2400_BE_SRST_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX            (_HRT_CSS_RECEIVER_2400_BE_TWO_PPC_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG0_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG0_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG1_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG1_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG2_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG2_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_COMP_FORMAT_REG3_IDX       (_HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG3_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_SEL_REG_IDX                (_HRT_CSS_RECEIVER_2400_BE_SEL_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_RAW16_CONFIG_REG_IDX       (_HRT_CSS_RECEIVER_2400_BE_RAW16_CONFIG_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_RAW18_CONFIG_REG_IDX       (_HRT_CSS_RECEIVER_2400_BE_RAW18_CONFIG_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_FORCE_RAW8_REG_IDX         (_HRT_CSS_RECEIVER_2400_BE_FORCE_RAW8_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_IRQ_STATUS_REG_IDX         (_HRT_CSS_RECEIVER_2400_BE_IRQ_STATUS_REG_IDX + _HRT_CSS_BE_OFFSET)
+#define _HRT_CSS_RECEIVER_BE_IRQ_CLEAR_REG_IDX          (_HRT_CSS_RECEIVER_2400_BE_IRQ_CLEAR_REG_IDX + _HRT_CSS_BE_OFFSET)
+
+
+#define _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT		_HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_BIT
+#define _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT		_HRT_CSS_RECEIVER_2400_IRQ_RESERVED_BIT
+#define _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT	_HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_BIT
+#define _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT	_HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT	_HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_BIT
+#define _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT		_HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_BIT
+#define _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT		_HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_BIT
+
+#define _HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX		_HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX
+#define	_HRT_CSS_RECEIVER_DATA_TIMEOUT_IDX		_HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_IDX
+#define	_HRT_CSS_RECEIVER_DATA_TIMEOUT_BITS		_HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_BITS
+
+typedef struct capture_unit_state_s	capture_unit_state_t;
+typedef struct acquisition_unit_state_s	acquisition_unit_state_t;
+typedef struct ctrl_unit_state_s	ctrl_unit_state_t;
+
+/*
+ * In 2300 ports can be configured independently and stream
+ * formats need to be specified. In 2400, there are only 8
+ * supported configurations but the HW is fused to support
+ * only a single one.
+ *
+ * In 2300 the compressed format types are programmed by the
+ * user. In 2400 all stream formats are encoded on the stream.
+ *
+ * Use the enum to check validity of a user configuration
+ */
+typedef enum {
+	MONO_4L_1L_0L = 0,
+	MONO_3L_1L_0L,
+	MONO_2L_1L_0L,
+	MONO_1L_1L_0L,
+	STEREO_2L_1L_2L,
+	STEREO_3L_1L_1L,
+	STEREO_2L_1L_1L,
+	STEREO_1L_1L_1L,
+	N_RX_MODE
+} rx_mode_t;
+
+typedef enum {
+	MIPI_PREDICTOR_NONE = 0,
+	MIPI_PREDICTOR_TYPE1,
+	MIPI_PREDICTOR_TYPE2,
+	N_MIPI_PREDICTOR_TYPES
+} mipi_predictor_t;
+
+typedef enum {
+	MIPI_COMPRESSOR_NONE = 0,
+	MIPI_COMPRESSOR_10_6_10,
+	MIPI_COMPRESSOR_10_7_10,
+	MIPI_COMPRESSOR_10_8_10,
+	MIPI_COMPRESSOR_12_6_12,
+	MIPI_COMPRESSOR_12_7_12,
+	MIPI_COMPRESSOR_12_8_12,
+	N_MIPI_COMPRESSOR_METHODS
+} mipi_compressor_t;
+
+typedef enum {
+	MIPI_FORMAT_RGB888 = 0,
+	MIPI_FORMAT_RGB555,
+	MIPI_FORMAT_RGB444,
+	MIPI_FORMAT_RGB565,
+	MIPI_FORMAT_RGB666,
+	MIPI_FORMAT_RAW8,		/* 5 */
+	MIPI_FORMAT_RAW10,
+	MIPI_FORMAT_RAW6,
+	MIPI_FORMAT_RAW7,
+	MIPI_FORMAT_RAW12,
+	MIPI_FORMAT_RAW14,		/* 10 */
+	MIPI_FORMAT_YUV420_8,
+	MIPI_FORMAT_YUV420_10,
+	MIPI_FORMAT_YUV422_8,
+	MIPI_FORMAT_YUV422_10,
+	MIPI_FORMAT_CUSTOM0,	/* 15 */
+	MIPI_FORMAT_YUV420_8_LEGACY,
+	MIPI_FORMAT_EMBEDDED,
+	MIPI_FORMAT_CUSTOM1,
+	MIPI_FORMAT_CUSTOM2,
+	MIPI_FORMAT_CUSTOM3,	/* 20 */
+	MIPI_FORMAT_CUSTOM4,
+	MIPI_FORMAT_CUSTOM5,
+	MIPI_FORMAT_CUSTOM6,
+	MIPI_FORMAT_CUSTOM7,
+	MIPI_FORMAT_YUV420_8_SHIFT,	/* 25 */
+	MIPI_FORMAT_YUV420_10_SHIFT,
+	MIPI_FORMAT_RAW16,
+	MIPI_FORMAT_RAW18,
+	N_MIPI_FORMAT,
+} mipi_format_t;
+
+#define MIPI_FORMAT_JPEG		MIPI_FORMAT_CUSTOM0
+#define MIPI_FORMAT_BINARY_8	MIPI_FORMAT_CUSTOM0
+#define N_MIPI_FORMAT_CUSTOM	8
+
+/* The number of stores for compressed format types */
+#define	N_MIPI_COMPRESSOR_CONTEXT	(N_RX_CHANNEL_ID * N_MIPI_FORMAT_CUSTOM)
+
+typedef enum {
+	RX_IRQ_INFO_BUFFER_OVERRUN   = 1UL << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT,
+	RX_IRQ_INFO_INIT_TIMEOUT     = 1UL << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT,
+	RX_IRQ_INFO_ENTER_SLEEP_MODE = 1UL << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT,
+	RX_IRQ_INFO_EXIT_SLEEP_MODE  = 1UL << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT,
+	RX_IRQ_INFO_ECC_CORRECTED    = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT,
+	RX_IRQ_INFO_ERR_SOT          = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT,
+	RX_IRQ_INFO_ERR_SOT_SYNC     = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT,
+	RX_IRQ_INFO_ERR_CONTROL      = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT,
+	RX_IRQ_INFO_ERR_ECC_DOUBLE   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT,
+/*	RX_IRQ_INFO_NO_ERR           = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT, */
+	RX_IRQ_INFO_ERR_CRC          = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT,
+	RX_IRQ_INFO_ERR_UNKNOWN_ID   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT,
+	RX_IRQ_INFO_ERR_FRAME_SYNC   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT,
+	RX_IRQ_INFO_ERR_FRAME_DATA   = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT,
+	RX_IRQ_INFO_ERR_DATA_TIMEOUT = 1UL << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT,
+	RX_IRQ_INFO_ERR_UNKNOWN_ESC  = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT,
+	RX_IRQ_INFO_ERR_LINE_SYNC    = 1UL << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT,
+}  rx_irq_info_t;
+
+typedef struct rx_cfg_s		rx_cfg_t;
+
+/*
+ * Applied per port
+ */
+struct rx_cfg_s {
+	rx_mode_t			mode;	/* The HW config */
+	mipi_port_ID_t		port;	/* The port ID to apply the control on */
+	unsigned int		timeout;
+	unsigned int		initcount;
+	unsigned int		synccount;
+	unsigned int		rxcount;
+	mipi_predictor_t	comp;	/* Just for backward compatibility */
+	bool                is_two_ppc;
+};
+
+/* NOTE: The base has already an offset of 0x0100 */
+static const hrt_address MIPI_PORT_OFFSET[N_MIPI_PORT_ID] = {
+	0x00000000UL,
+	0x00000100UL,
+	0x00000200UL};
+
+static const mipi_lane_cfg_t MIPI_PORT_MAXLANES[N_MIPI_PORT_ID] = {
+	MIPI_4LANE_CFG,
+	MIPI_1LANE_CFG,
+	MIPI_2LANE_CFG};
+
+static const bool MIPI_PORT_ACTIVE[N_RX_MODE][N_MIPI_PORT_ID] = {
+	{true, true, false},
+	{true, true, false},
+	{true, true, false},
+	{true, true, false},
+	{true, true, true},
+	{true, true, true},
+	{true, true, true},
+	{true, true, true}};
+
+static const mipi_lane_cfg_t MIPI_PORT_LANES[N_RX_MODE][N_MIPI_PORT_ID] = {
+	{MIPI_4LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
+	{MIPI_3LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
+	{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
+	{MIPI_1LANE_CFG, MIPI_1LANE_CFG, MIPI_0LANE_CFG},
+	{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_2LANE_CFG},
+	{MIPI_3LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG},
+	{MIPI_2LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG},
+	{MIPI_1LANE_CFG, MIPI_1LANE_CFG, MIPI_1LANE_CFG}};
+
+static const hrt_address SUB_SYSTEM_OFFSET[N_SUB_SYSTEM_ID] = {
+	0x00001000UL,
+	0x00002000UL,
+	0x00003000UL,
+	0x00004000UL,
+	0x00005000UL,
+	0x00009000UL,
+	0x0000A000UL,
+	0x0000B000UL,
+	0x0000C000UL};
+
+struct capture_unit_state_s {
+	int	Packet_Length;
+	int	Received_Length;
+	int	Received_Short_Packets;
+	int	Received_Long_Packets;
+	int	Last_Command;
+	int	Next_Command;
+	int	Last_Acknowledge;
+	int	Next_Acknowledge;
+	int	FSM_State_Info;
+	int	StartMode;
+	int	Start_Addr;
+	int	Mem_Region_Size;
+	int	Num_Mem_Regions;
+/*	int	Init;   write-only registers
+	int	Start;
+	int	Stop;      */
+};
+
+struct acquisition_unit_state_s {
+/*	int	Init;   write-only register */
+	int	Received_Short_Packets;
+	int	Received_Long_Packets;
+	int	Last_Command;
+	int	Next_Command;
+	int	Last_Acknowledge;
+	int	Next_Acknowledge;
+	int	FSM_State_Info;
+	int	Int_Cntr_Info;
+	int	Start_Addr;
+	int	Mem_Region_Size;
+	int	Num_Mem_Regions;
+};
+
+struct ctrl_unit_state_s {
+	int	last_cmd;
+	int	next_cmd;
+	int	last_ack;
+	int	next_ack;
+	int	top_fsm_state;
+	int	captA_fsm_state;
+	int	captB_fsm_state;
+	int	captC_fsm_state;
+	int	acq_fsm_state;
+	int	captA_start_addr;
+	int	captB_start_addr;
+	int	captC_start_addr;
+	int	captA_mem_region_size;
+	int	captB_mem_region_size;
+	int	captC_mem_region_size;
+	int	captA_num_mem_regions;
+	int	captB_num_mem_regions;
+	int	captC_num_mem_regions;
+	int	acq_start_addr;
+	int	acq_mem_region_size;
+	int	acq_num_mem_regions;
+/*	int	ctrl_init;  write only register */
+	int	capt_reserve_one_mem_region;
+};
+
+struct input_system_state_s {
+	int	str_multicastA_sel;
+	int	str_multicastB_sel;
+	int	str_multicastC_sel;
+	int	str_mux_sel;
+	int	str_mon_status;
+	int	str_mon_irq_cond;
+	int	str_mon_irq_en;
+	int	isys_srst;
+	int	isys_slv_reg_srst;
+	int	str_deint_portA_cnt;
+	int	str_deint_portB_cnt;
+	struct capture_unit_state_s		capture_unit[N_CAPTURE_UNIT_ID];
+	struct acquisition_unit_state_s	acquisition_unit[N_ACQUISITION_UNIT_ID];
+	struct ctrl_unit_state_s		ctrl_unit_state[N_CTRL_UNIT_ID];
+};
+
+struct mipi_port_state_s {
+	int	device_ready;
+	int	irq_status;
+	int	irq_enable;
+	uint32_t	timeout_count;
+	uint16_t	init_count;
+	uint16_t	raw16_18;
+	uint32_t	sync_count;		/*4 x uint8_t */
+	uint32_t	rx_count;		/*4 x uint8_t */
+	uint8_t		lane_sync_count[MIPI_4LANE_CFG];
+	uint8_t		lane_rx_count[MIPI_4LANE_CFG];
+};
+
+struct rx_channel_state_s {
+	uint32_t	comp_scheme0;
+	uint32_t	comp_scheme1;
+	mipi_predictor_t		pred[N_MIPI_FORMAT_CUSTOM];
+	mipi_compressor_t		comp[N_MIPI_FORMAT_CUSTOM];
+};
+
+struct receiver_state_s {
+	uint8_t	fs_to_ls_delay;
+	uint8_t	ls_to_data_delay;
+	uint8_t	data_to_le_delay;
+	uint8_t	le_to_fe_delay;
+	uint8_t	fe_to_fs_delay;
+	uint8_t	le_to_fs_delay;
+	bool	is_two_ppc;
+	int	backend_rst;
+	uint16_t	raw18;
+	bool		force_raw8;
+	uint16_t	raw16;
+	struct mipi_port_state_s	mipi_port_state[N_MIPI_PORT_ID];
+	struct rx_channel_state_s	rx_channel_state[N_RX_CHANNEL_ID];
+	int	be_gsp_acc_ovl;
+	int	be_srst;
+	int	be_is_two_ppc;
+	int	be_comp_format0;
+	int	be_comp_format1;
+	int	be_comp_format2;
+	int	be_comp_format3;
+	int	be_sel;
+	int	be_raw16_config;
+	int	be_raw18_config;
+	int	be_force_raw8;
+	int	be_irq_status;
+	int	be_irq_clear;
+};
+
+#endif /* __INPUT_SYSTEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_private.h
new file mode 100644
index 0000000..b978f73
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/input_system_private.h
@@ -0,0 +1,123 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __INPUT_SYSTEM_PRIVATE_H_INCLUDED__
+#define __INPUT_SYSTEM_PRIVATE_H_INCLUDED__
+
+#include "input_system_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_INPUT_SYSTEM_C void input_system_reg_store(
+	const input_system_ID_t			ID,
+	const hrt_address			reg,
+	const hrt_data				value)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(INPUT_SYSTEM_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data input_system_reg_load(
+	const input_system_ID_t			ID,
+	const hrt_address			reg)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(INPUT_SYSTEM_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C void receiver_reg_store(
+	const rx_ID_t				ID,
+	const hrt_address			reg,
+	const hrt_data				value)
+{
+assert(ID < N_RX_ID);
+assert(RX_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(RX_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_reg_load(
+	const rx_ID_t				ID,
+	const hrt_address			reg)
+{
+assert(ID < N_RX_ID);
+assert(RX_BASE[ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(RX_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C void receiver_port_reg_store(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t			port_ID,
+	const hrt_address			reg,
+	const hrt_data				value)
+{
+assert(ID < N_RX_ID);
+assert(port_ID < N_MIPI_PORT_ID);
+assert(RX_BASE[ID] != (hrt_address)-1);
+assert(MIPI_PORT_OFFSET[port_ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_port_reg_load(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t			port_ID,
+	const hrt_address			reg)
+{
+assert(ID < N_RX_ID);
+assert(port_ID < N_MIPI_PORT_ID);
+assert(RX_BASE[ID] != (hrt_address)-1);
+assert(MIPI_PORT_OFFSET[port_ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] + reg*sizeof(hrt_data));
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C void input_system_sub_system_reg_store(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_ID,
+	const hrt_address			reg,
+	const hrt_data				value)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(sub_ID < N_SUB_SYSTEM_ID);
+assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
+assert(SUB_SYSTEM_OFFSET[sub_ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(INPUT_SYSTEM_BASE[ID] + SUB_SYSTEM_OFFSET[sub_ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_INPUT_SYSTEM_C hrt_data input_system_sub_system_reg_load(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_ID,
+	const hrt_address			reg)
+{
+assert(ID < N_INPUT_SYSTEM_ID);
+assert(sub_ID < N_SUB_SYSTEM_ID);
+assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
+assert(SUB_SYSTEM_OFFSET[sub_ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(INPUT_SYSTEM_BASE[ID] + SUB_SYSTEM_OFFSET[sub_ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __INPUT_SYSTEM_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq.c
new file mode 100644
index 0000000..5edd9fa
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq.c
@@ -0,0 +1,462 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "assert_support.h"
+#include "irq.h"
+
+#ifndef __INLINE_GP_DEVICE__
+#define __INLINE_GP_DEVICE__
+#endif
+#include "gp_device.h"	/* _REG_GP_IRQ_REQUEST_ADDR */
+
+#include "platform_support.h"			/* hrt_sleep() */
+
+STORAGE_CLASS_INLINE void irq_wait_for_write_complete(
+	const irq_ID_t		ID);
+
+STORAGE_CLASS_INLINE bool any_irq_channel_enabled(
+	const irq_ID_t				ID);
+
+STORAGE_CLASS_INLINE irq_ID_t virq_get_irq_id(
+	const virq_id_t		irq_ID,
+	unsigned int		*channel_ID);
+
+#ifndef __INLINE_IRQ__
+#include "irq_private.h"
+#endif /* __INLINE_IRQ__ */
+
+static unsigned short IRQ_N_CHANNEL[N_IRQ_ID] = {
+	IRQ0_ID_N_CHANNEL,
+	IRQ1_ID_N_CHANNEL,
+	IRQ2_ID_N_CHANNEL,
+	IRQ3_ID_N_CHANNEL};
+
+static unsigned short IRQ_N_ID_OFFSET[N_IRQ_ID + 1] = {
+	IRQ0_ID_OFFSET,
+	IRQ1_ID_OFFSET,
+	IRQ2_ID_OFFSET,
+	IRQ3_ID_OFFSET,
+	IRQ_END_OFFSET};
+
+static virq_id_t IRQ_NESTING_ID[N_IRQ_ID] = {
+	N_virq_id,
+	virq_ifmt,
+	virq_isys,
+	virq_isel};
+
+void irq_clear_all(
+	const irq_ID_t				ID)
+{
+	hrt_data	mask = 0xFFFFFFFF;
+
+	assert(ID < N_IRQ_ID);
+	assert(IRQ_N_CHANNEL[ID] <= HRT_DATA_WIDTH);
+
+	if (IRQ_N_CHANNEL[ID] < HRT_DATA_WIDTH) {
+		mask = ~((~(hrt_data)0)>>IRQ_N_CHANNEL[ID]);
+	}
+
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, mask);
+return;
+}
+
+/*
+ * Do we want the user to be able to set the signalling method ?
+ */
+void irq_enable_channel(
+	const irq_ID_t				ID,
+    const unsigned int			irq_id)
+{
+	unsigned int mask = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX);
+	unsigned int enable = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+	unsigned int edge_in = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_EDGE_REG_IDX);
+	unsigned int me = 1U << irq_id;
+
+	assert(ID < N_IRQ_ID);
+	assert(irq_id < IRQ_N_CHANNEL[ID]);
+
+	mask |= me;
+	enable |= me;
+	edge_in |= me;	/* rising edge */
+
+/* to avoid mishaps configuration must follow the following order */
+
+/* mask this interrupt */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask & ~me);
+/* rising edge at input */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_EDGE_REG_IDX, edge_in);
+/* enable interrupt to output */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);
+/* clear current irq only */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);
+/* unmask interrupt from input */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);
+
+	irq_wait_for_write_complete(ID);
+
+return;
+}
+
+void irq_enable_pulse(
+	const irq_ID_t	ID,
+	bool 			pulse)
+{
+	unsigned int edge_out = 0x0;
+
+	if (pulse) {
+		edge_out = 0xffffffff;
+	}
+	/* output is given as edge, not pulse */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX, edge_out);
+return;
+}
+
+void irq_disable_channel(
+	const irq_ID_t				ID,
+	const unsigned int			irq_id)
+{
+	unsigned int mask = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX);
+	unsigned int enable = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+	unsigned int me = 1U << irq_id;
+
+	assert(ID < N_IRQ_ID);
+	assert(irq_id < IRQ_N_CHANNEL[ID]);
+
+	mask &= ~me;
+	enable &= ~me;
+
+/* enable interrupt to output */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);
+/* unmask interrupt from input */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);
+/* clear current irq only */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);
+
+	irq_wait_for_write_complete(ID);
+
+return;
+}
+
+enum hrt_isp_css_irq_status irq_get_channel_id(
+	const irq_ID_t				ID,
+	unsigned int				*irq_id)
+{
+	unsigned int irq_status = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+	unsigned int idx;
+	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_success;
+
+	assert(ID < N_IRQ_ID);
+	assert(irq_id != NULL);
+
+/* find the first irq bit */
+	for (idx = 0; idx < IRQ_N_CHANNEL[ID]; idx++) {
+		if (irq_status & (1U << idx))
+			break;
+	}
+	if (idx == IRQ_N_CHANNEL[ID])
+		return hrt_isp_css_irq_status_error;
+
+/* now check whether there are more bits set */
+	if (irq_status != (1U << idx))
+		status = hrt_isp_css_irq_status_more_irqs;
+
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);
+
+	irq_wait_for_write_complete(ID);
+
+	if (irq_id != NULL)
+		*irq_id = (unsigned int)idx;
+
+return status;
+}
+
+static const hrt_address IRQ_REQUEST_ADDR[N_IRQ_SW_CHANNEL_ID] = {
+	_REG_GP_IRQ_REQUEST0_ADDR,
+	_REG_GP_IRQ_REQUEST1_ADDR};
+
+void irq_raise(
+	const irq_ID_t				ID,
+	const irq_sw_channel_id_t	irq_id)
+{
+	hrt_address		addr;
+
+	OP___assert(ID == IRQ0_ID);
+	OP___assert(IRQ_BASE[ID] != (hrt_address)-1);
+	OP___assert(irq_id < N_IRQ_SW_CHANNEL_ID);
+
+	(void)ID;
+
+	addr = IRQ_REQUEST_ADDR[irq_id];
+/* The SW IRQ pins are remapped to offset zero */
+	gp_device_reg_store(GP_DEVICE0_ID,
+		(unsigned int)addr, 1);
+#ifdef HRT_CSIM
+	hrt_sleep();
+#endif
+	gp_device_reg_store(GP_DEVICE0_ID,
+		(unsigned int)addr, 0);
+return;
+}
+
+void irq_controller_get_state(
+	const irq_ID_t				ID,
+	irq_controller_state_t		*state)
+{
+	assert(ID < N_IRQ_ID);
+	assert(state != NULL);
+
+	state->irq_edge = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_EDGE_REG_IDX);
+	state->irq_mask = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_MASK_REG_IDX);
+	state->irq_status = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+	state->irq_enable = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+	state->irq_level_not_pulse = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX);
+return;
+}
+
+bool any_virq_signal(void)
+{
+	unsigned int irq_status = irq_reg_load(IRQ0_ID,
+		_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+
+return (irq_status != 0);
+}
+
+void cnd_virq_enable_channel(
+	const virq_id_t				irq_ID,
+	const bool					en)
+{
+	irq_ID_t		i;
+	unsigned int	channel_ID;
+	irq_ID_t		ID = virq_get_irq_id(irq_ID, &channel_ID);
+
+	assert(ID < N_IRQ_ID);
+
+	for (i=IRQ1_ID;i<N_IRQ_ID;i++) {
+	/* It is not allowed to enable the pin of a nested IRQ directly */
+		assert(irq_ID != IRQ_NESTING_ID[i]);
+	}
+
+	if (en) {
+		irq_enable_channel(ID, channel_ID);
+		if (IRQ_NESTING_ID[ID] != N_virq_id) {
+/* Single level nesting, otherwise we'd need to recurse */
+			irq_enable_channel(IRQ0_ID, IRQ_NESTING_ID[ID]);
+		}
+	} else {
+		irq_disable_channel(ID, channel_ID);
+		if ((IRQ_NESTING_ID[ID] != N_virq_id) && !any_irq_channel_enabled(ID)) {
+/* Only disable the top if the nested ones are empty */
+			irq_disable_channel(IRQ0_ID, IRQ_NESTING_ID[ID]);
+		}
+	}
+return;
+}
+
+
+void virq_clear_all(void)
+{
+	irq_ID_t	irq_id;
+
+	for (irq_id = (irq_ID_t)0; irq_id < N_IRQ_ID; irq_id++) {
+		irq_clear_all(irq_id);
+	}
+return;
+}
+
+enum hrt_isp_css_irq_status virq_get_channel_signals(
+	virq_info_t					*irq_info)
+{
+	enum hrt_isp_css_irq_status irq_status = hrt_isp_css_irq_status_error;
+	irq_ID_t ID;
+
+	assert(irq_info != NULL);
+
+	for (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {
+		if (any_irq_channel_enabled(ID)) {
+			hrt_data	irq_data = irq_reg_load(ID,
+				_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+
+			if (irq_data != 0) {
+/* The error condition is an IRQ pulse received with no IRQ status written */
+				irq_status = hrt_isp_css_irq_status_success;
+			}
+
+			irq_info->irq_status_reg[ID] |= irq_data;
+
+			irq_reg_store(ID,
+				_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, irq_data);
+
+			irq_wait_for_write_complete(ID);
+		}
+	}
+
+return irq_status;
+}
+
+void virq_clear_info(
+	virq_info_t					*irq_info)
+{
+	irq_ID_t ID;
+
+	assert(irq_info != NULL);
+
+	for (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {
+			irq_info->irq_status_reg[ID] = 0;
+	}
+return;
+}
+
+enum hrt_isp_css_irq_status virq_get_channel_id(
+	virq_id_t					*irq_id)
+{
+	unsigned int irq_status = irq_reg_load(IRQ0_ID,
+		_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+	unsigned int idx;
+	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_success;
+	irq_ID_t ID;
+
+	assert(irq_id != NULL);
+
+/* find the first irq bit on device 0 */
+	for (idx = 0; idx < IRQ_N_CHANNEL[IRQ0_ID]; idx++) {
+		if (irq_status & (1U << idx))
+			break;
+	}
+
+	if (idx == IRQ_N_CHANNEL[IRQ0_ID]) {
+		return hrt_isp_css_irq_status_error;
+	}
+
+/* Check whether there are more bits set on device 0 */
+	if (irq_status != (1U << idx)) {
+		status = hrt_isp_css_irq_status_more_irqs;
+	}
+
+/* Check whether we have an IRQ on one of the nested devices */
+	for (ID = N_IRQ_ID-1 ; ID > (irq_ID_t)0; ID--) {
+		if (IRQ_NESTING_ID[ID] == (virq_id_t)idx) {
+			break;
+		}
+	}
+
+/* If we have a nested IRQ, load that state, discard the device 0 state */
+	if (ID != IRQ0_ID) {
+		irq_status = irq_reg_load(ID,
+			_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
+/* find the first irq bit on device "id" */
+		for (idx = 0; idx < IRQ_N_CHANNEL[ID]; idx++) {
+			if (irq_status & (1U << idx))
+				break;
+		}
+
+		if (idx == IRQ_N_CHANNEL[ID]) {
+			return hrt_isp_css_irq_status_error;
+		}
+
+/* Alternatively check whether there are more bits set on this device */
+		if (irq_status != (1U << idx)) {
+			status = hrt_isp_css_irq_status_more_irqs;
+		} else {
+/* If this device is empty, clear the state on device 0 */
+			irq_reg_store(IRQ0_ID,
+				_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << IRQ_NESTING_ID[ID]);
+		}
+	} /* if (ID != IRQ0_ID) */
+
+/* Here we proceed to clear the IRQ on detected device, if no nested IRQ, this is device 0 */
+	irq_reg_store(ID,
+		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);
+
+	irq_wait_for_write_complete(ID);
+
+	idx += IRQ_N_ID_OFFSET[ID];
+	if (irq_id != NULL)
+		*irq_id = (virq_id_t)idx;
+
+return status;
+}
+
+STORAGE_CLASS_INLINE void irq_wait_for_write_complete(
+	const irq_ID_t		ID)
+{
+assert(ID < N_IRQ_ID);
+assert(IRQ_BASE[ID] != (hrt_address)-1);
+	(void)ia_css_device_load_uint32(IRQ_BASE[ID] +
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX*sizeof(hrt_data));
+#ifdef HRT_CSIM
+	hrt_sleep();
+#endif
+return;
+}
+
+STORAGE_CLASS_INLINE bool any_irq_channel_enabled(
+	const irq_ID_t				ID)
+{
+	hrt_data	en_reg;
+
+	assert(ID < N_IRQ_ID);
+
+	en_reg = irq_reg_load(ID,
+		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
+
+return (en_reg != 0);
+}
+
+STORAGE_CLASS_INLINE irq_ID_t virq_get_irq_id(
+	const virq_id_t		irq_ID,
+	unsigned int		*channel_ID)
+{
+	irq_ID_t ID;
+
+	assert(channel_ID != NULL);
+
+	for (ID = (irq_ID_t)0 ; ID < N_IRQ_ID; ID++) {
+		if (irq_ID < IRQ_N_ID_OFFSET[ID + 1]) {
+			break;
+		}
+	}
+
+	*channel_ID = (unsigned int)irq_ID - IRQ_N_ID_OFFSET[ID];
+
+return ID;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_local.h
new file mode 100644
index 0000000..48f29a2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_local.h
@@ -0,0 +1,143 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IRQ_LOCAL_H_INCLUDED__
+#define __IRQ_LOCAL_H_INCLUDED__
+
+#include "irq_global.h"
+
+#include <irq_controller_defs.h>
+
+/* IRQ0_ID */
+#include "hive_isp_css_defs.h"
+#define HIVE_GP_DEV_IRQ_NUM_IRQS	32
+/* IRQ1_ID */
+#include "input_formatter_subsystem_defs.h"
+#define HIVE_IFMT_IRQ_NUM_IRQS		5
+/* IRQ2_ID */
+#include "input_system_defs.h"
+/* IRQ3_ID */
+#include "input_selector_defs.h"
+
+
+#define	IRQ_ID_OFFSET	32
+#define	IRQ0_ID_OFFSET	0
+#define	IRQ1_ID_OFFSET	IRQ_ID_OFFSET
+#define	IRQ2_ID_OFFSET	(2*IRQ_ID_OFFSET)
+#define	IRQ3_ID_OFFSET	(3*IRQ_ID_OFFSET)
+#define	IRQ_END_OFFSET	(4*IRQ_ID_OFFSET)
+
+#define	IRQ0_ID_N_CHANNEL	HIVE_GP_DEV_IRQ_NUM_IRQS
+#define	IRQ1_ID_N_CHANNEL	HIVE_IFMT_IRQ_NUM_IRQS
+#define	IRQ2_ID_N_CHANNEL	HIVE_ISYS_IRQ_NUM_BITS
+#define	IRQ3_ID_N_CHANNEL	HIVE_ISEL_IRQ_NUM_IRQS
+
+typedef struct virq_info_s					virq_info_t;
+typedef struct irq_controller_state_s		irq_controller_state_t;
+
+
+typedef enum {
+	virq_gpio_pin_0            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID,
+	virq_gpio_pin_1            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID,
+	virq_gpio_pin_2            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID,
+	virq_gpio_pin_3            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID,
+	virq_gpio_pin_4            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID,
+	virq_gpio_pin_5            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID,
+	virq_gpio_pin_6            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID,
+	virq_gpio_pin_7            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID,
+	virq_gpio_pin_8            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID,
+	virq_gpio_pin_9            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID,
+	virq_gpio_pin_10           = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID,
+	virq_gpio_pin_11           = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID,
+	virq_sp                    = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_BIT_ID,
+	virq_isp                   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_BIT_ID,
+	virq_isys                  = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISYS_BIT_ID,
+	virq_isel                  = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISEL_BIT_ID,
+	virq_ifmt                  = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_IFMT_BIT_ID,
+	virq_sp_stream_mon         = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID,
+	virq_isp_stream_mon        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID,
+	virq_mod_stream_mon        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID,
+#if defined(IS_ISP_2400_MAMOIADA_SYSTEM)
+	virq_isp_pmem_error        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID,
+#elif defined(IS_ISP_2401_MAMOIADA_SYSTEM)
+	virq_isys_2401             = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_IS2401_BIT_ID,
+#else
+#error "irq_local.h: 2400_SYSTEM must be one of {2400, 2401 }"
+#endif
+	virq_isp_bamem_error       = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID,
+	virq_isp_dmem_error        = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID,
+	virq_sp_icache_mem_error   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID,
+	virq_sp_dmem_error         = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID,
+	virq_mmu_cache_mem_error   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID,
+	virq_gp_timer_0            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID,
+	virq_gp_timer_1            = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID,
+	virq_sw_pin_0              = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID,
+	virq_sw_pin_1              = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID,
+	virq_dma                   = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_DMA_BIT_ID,
+	virq_sp_stream_mon_b       = IRQ0_ID_OFFSET + HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID,
+
+	virq_ifmt0_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_PRIM_BIT_ID,
+	virq_ifmt1_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_PRIM_B_BIT_ID,
+	virq_ifmt2_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_IFT_SEC_BIT_ID,
+	virq_ifmt3_id              = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_MEM_CPY_BIT_ID,
+	virq_ifmt_sideband_changed = IRQ1_ID_OFFSET + HIVE_IFMT_IRQ_SIDEBAND_CHANGED_BIT_ID,
+
+	virq_isys_sof              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_SOF_BIT_ID,
+	virq_isys_eof              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_EOF_BIT_ID,
+	virq_isys_sol              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_SOL_BIT_ID,
+	virq_isys_eol              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_EOL_BIT_ID,
+	virq_isys_csi              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_RECEIVER_BIT_ID,
+	virq_isys_csi_be           = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CSI_RECEIVER_BE_BIT_ID,
+	virq_isys_capt0_id_no_sop  = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_A_NO_SOP,
+	virq_isys_capt0_id_late_sop= IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_A_LATE_SOP,
+	virq_isys_capt1_id_no_sop  = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_B_NO_SOP,
+	virq_isys_capt1_id_late_sop= IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_B_LATE_SOP,
+	virq_isys_capt2_id_no_sop  = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_C_NO_SOP,
+	virq_isys_capt2_id_late_sop= IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CAP_UNIT_C_LATE_SOP,
+	virq_isys_acq_sop_mismatch = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_ACQ_UNIT_SOP_MISMATCH,
+	virq_isys_ctrl_capt0       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPA,
+	virq_isys_ctrl_capt1       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPB,
+	virq_isys_ctrl_capt2       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_INP_CTRL_CAPC,
+	virq_isys_cio_to_ahb       = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_CIO2AHB,
+	virq_isys_dma              = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_DMA_BIT_ID,
+	virq_isys_fifo_monitor     = IRQ2_ID_OFFSET + HIVE_ISYS_IRQ_STREAM_MON_BIT_ID,
+
+	virq_isel_sof              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_SOF_BIT_ID,
+	virq_isel_eof              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_EOF_BIT_ID,
+	virq_isel_sol              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_SOL_BIT_ID,
+	virq_isel_eol              = IRQ3_ID_OFFSET + HIVE_ISEL_IRQ_SYNC_GEN_EOL_BIT_ID,
+
+	N_virq_id                  = IRQ_END_OFFSET
+} virq_id_t;
+
+struct virq_info_s {
+	hrt_data		irq_status_reg[N_IRQ_ID];
+};
+
+struct irq_controller_state_s {
+	unsigned int	irq_edge;
+	unsigned int	irq_mask;
+	unsigned int	irq_status;
+	unsigned int	irq_enable;
+	unsigned int	irq_level_not_pulse;
+};
+
+#endif /* __IRQ_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_private.h
new file mode 100644
index 0000000..9bae5a0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/irq_private.h
@@ -0,0 +1,51 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IRQ_PRIVATE_H_INCLUDED__
+#define __IRQ_PRIVATE_H_INCLUDED__
+
+#include "irq_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_IRQ_C void irq_reg_store(
+	const irq_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+assert(ID < N_IRQ_ID);
+assert(IRQ_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(IRQ_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_IRQ_C hrt_data irq_reg_load(
+	const irq_ID_t		ID,
+	const unsigned int	reg)
+{
+assert(ID < N_IRQ_ID);
+assert(IRQ_BASE[ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(IRQ_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __IRQ_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp.c
new file mode 100644
index 0000000..3c7b86b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp.c
@@ -0,0 +1,97 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "isp.h"
+
+#ifndef __INLINE_ISP__
+#include "isp_private.h"
+#endif /* __INLINE_ISP__ */
+
+#include "assert_support.h"
+
+void cnd_isp_irq_enable(
+	const isp_ID_t		ID,
+	const bool		cnd)
+{
+	if (cnd) {
+		isp_ctrl_setbit(ID, ISP_IRQ_READY_REG, ISP_IRQ_READY_BIT);
+/* Enabling the IRQ immediately triggers an interrupt, clear it */
+		isp_ctrl_setbit(ID, ISP_IRQ_CLEAR_REG, ISP_IRQ_CLEAR_BIT);
+	} else {
+		isp_ctrl_clearbit(ID, ISP_IRQ_READY_REG,
+			ISP_IRQ_READY_BIT);
+	}
+return;
+}
+
+void isp_get_state(
+	const isp_ID_t		ID,
+	isp_state_t			*state,
+	isp_stall_t			*stall)
+{
+	hrt_data sc = isp_ctrl_load(ID, ISP_SC_REG);
+
+	assert(state != NULL);
+	assert(stall != NULL);
+
+	state->pc = isp_ctrl_load(ID, ISP_PC_REG);
+	state->status_register = sc;
+	state->is_broken = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_BROKEN_BIT);
+	state->is_idle = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_IDLE_BIT);
+	state->is_sleeping = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_SLEEPING_BIT);
+	state->is_stalling = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_STALLING_BIT);
+	stall->stat_ctrl =
+		!isp_ctrl_getbit(ID, ISP_CTRL_SINK_REG, ISP_CTRL_SINK_BIT);
+	stall->pmem =
+		!isp_ctrl_getbit(ID, ISP_PMEM_SINK_REG, ISP_PMEM_SINK_BIT);
+	stall->dmem =
+		!isp_ctrl_getbit(ID, ISP_DMEM_SINK_REG, ISP_DMEM_SINK_BIT);
+	stall->vmem =
+		!isp_ctrl_getbit(ID, ISP_VMEM_SINK_REG, ISP_VMEM_SINK_BIT);
+	stall->fifo0 =
+		!isp_ctrl_getbit(ID, ISP_FIFO0_SINK_REG, ISP_FIFO0_SINK_BIT);
+	stall->fifo1 =
+		!isp_ctrl_getbit(ID, ISP_FIFO1_SINK_REG, ISP_FIFO1_SINK_BIT);
+	stall->fifo2 =
+		!isp_ctrl_getbit(ID, ISP_FIFO2_SINK_REG, ISP_FIFO2_SINK_BIT);
+	stall->fifo3 =
+		!isp_ctrl_getbit(ID, ISP_FIFO3_SINK_REG, ISP_FIFO3_SINK_BIT);
+	stall->fifo4 =
+		!isp_ctrl_getbit(ID, ISP_FIFO4_SINK_REG, ISP_FIFO4_SINK_BIT);
+	stall->fifo5 =
+		!isp_ctrl_getbit(ID, ISP_FIFO5_SINK_REG, ISP_FIFO5_SINK_BIT);
+	stall->fifo6 =
+		!isp_ctrl_getbit(ID, ISP_FIFO6_SINK_REG, ISP_FIFO6_SINK_BIT);
+	stall->vamem1 =
+		!isp_ctrl_getbit(ID, ISP_VAMEM1_SINK_REG, ISP_VAMEM1_SINK_BIT);
+	stall->vamem2 =
+		!isp_ctrl_getbit(ID, ISP_VAMEM2_SINK_REG, ISP_VAMEM2_SINK_BIT);
+	stall->vamem3 =
+		!isp_ctrl_getbit(ID, ISP_VAMEM3_SINK_REG, ISP_VAMEM3_SINK_BIT);
+	stall->hmem =
+		!isp_ctrl_getbit(ID, ISP_HMEM_SINK_REG, ISP_HMEM_SINK_BIT);
+/*
+	stall->icache_master =
+		!isp_ctrl_getbit(ID, ISP_ICACHE_MT_SINK_REG,
+			ISP_ICACHE_MT_SINK_BIT);
+ */
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_local.h
new file mode 100644
index 0000000..d9ee7e7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_local.h
@@ -0,0 +1,64 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP_LOCAL_H_INCLUDED__
+#define __ISP_LOCAL_H_INCLUDED__
+
+#include <stdbool.h>
+
+#include "isp_global.h"
+
+#include <isp2400_support.h>
+
+#define HIVE_ISP_VMEM_MASK	((1U<<ISP_VMEM_ELEMBITS)-1)
+
+typedef struct isp_state_s		isp_state_t;
+typedef struct isp_stall_s		isp_stall_t;
+
+struct isp_state_s {
+	int		pc;
+	int		status_register;
+	bool	is_broken;
+	bool	is_idle;
+	bool	is_sleeping;
+	bool	is_stalling;
+};
+
+struct isp_stall_s {
+	bool	fifo0;
+	bool	fifo1;
+	bool	fifo2;
+	bool	fifo3;
+	bool	fifo4;
+	bool	fifo5;
+	bool	fifo6;
+	bool	stat_ctrl;
+	bool	dmem;
+	bool	vmem;
+	bool	vamem1;
+	bool	vamem2;
+	bool	vamem3;
+	bool	hmem;
+	bool	pmem;
+	bool	icache_master;
+};
+
+#endif /* __ISP_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_private.h
new file mode 100644
index 0000000..abe1ac3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/isp_private.h
@@ -0,0 +1,155 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP_PRIVATE_H_INCLUDED__
+#define __ISP_PRIVATE_H_INCLUDED__
+
+#include "isp_public.h"
+
+#ifdef C_RUN
+#include <string.h>		/* memcpy() */
+#endif
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_ISP_C void isp_ctrl_store(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_CTRL_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(ISP_CTRL_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_ISP_C hrt_data isp_ctrl_load(
+	const isp_ID_t		ID,
+	const unsigned int	reg)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_CTRL_BASE[ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(ISP_CTRL_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+STORAGE_CLASS_ISP_C bool isp_ctrl_getbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit)
+{
+	hrt_data val = isp_ctrl_load(ID, reg);
+return (val & (1UL << bit)) != 0;
+}
+
+STORAGE_CLASS_ISP_C void isp_ctrl_setbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit)
+{
+	hrt_data	data = isp_ctrl_load(ID, reg);
+	isp_ctrl_store(ID, reg, (data | (1UL << bit)));
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_ctrl_clearbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit)
+{
+	hrt_data	data = isp_ctrl_load(ID, reg);
+	isp_ctrl_store(ID, reg, (data & ~(1UL << bit)));
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_dmem_store(
+	const isp_ID_t		ID,
+	unsigned int		addr,
+	const void			*data,
+	const size_t		size)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	ia_css_device_store(ISP_DMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy((void *)addr, data, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_dmem_load(
+	const isp_ID_t		ID,
+	const unsigned int	addr,
+	void				*data,
+	const size_t		size)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	ia_css_device_load(ISP_DMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy(data, (void *)addr, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_ISP_C void isp_dmem_store_uint32(
+	const isp_ID_t		ID,
+	unsigned int		addr,
+	const uint32_t		data)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
+	(void)ID;
+#ifndef C_RUN
+	ia_css_device_store_uint32(ISP_DMEM_BASE[ISP0_ID] + addr, data);
+#else
+	*(uint32_t *)addr = data;
+#endif
+return;
+}
+
+STORAGE_CLASS_ISP_C uint32_t isp_dmem_load_uint32(
+	const isp_ID_t		ID,
+	const unsigned int	addr)
+{
+assert(ID < N_ISP_ID);
+assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
+	(void)ID;
+#ifndef C_RUN
+	return ia_css_device_load_uint32(ISP_DMEM_BASE[ISP0_ID] + addr);
+#else
+	return *(uint32_t *)addr;
+#endif
+}
+
+STORAGE_CLASS_ISP_C uint32_t isp_2w_cat_1w(
+	const uint16_t		x0,
+	const uint16_t		x1)
+{
+	uint32_t out = ((uint32_t)(x1 & HIVE_ISP_VMEM_MASK) << ISP_VMEM_ELEMBITS)
+		| (x0 & HIVE_ISP_VMEM_MASK);
+return out;
+}
+
+#endif /* __ISP_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu.c
new file mode 100644
index 0000000..f2f9929
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu.c
@@ -0,0 +1,59 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+
+
+/* The name "mmu.h is already taken" */
+#include "mmu_device.h"
+
+#ifndef __INLINE_MMU__
+#include "mmu_private.h"
+#endif /* __INLINE_MMU__ */
+
+void mmu_set_page_table_base_index(
+	const mmu_ID_t		ID,
+	const hrt_data		base_index)
+{
+	mmu_reg_store(ID, _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX, base_index);
+return;
+}
+
+hrt_data mmu_get_page_table_base_index(
+	const mmu_ID_t		ID)
+{
+return mmu_reg_load(ID, _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX);
+}
+
+void mmu_invalidate_cache(
+	const mmu_ID_t		ID)
+{
+	mmu_reg_store(ID, _HRT_MMU_INVALIDATE_TLB_REG_IDX, 1);
+return;
+}
+
+void mmu_invalidate_cache_all(void)
+{
+	mmu_ID_t	mmu_id;
+	for (mmu_id = (mmu_ID_t)0;mmu_id < N_MMU_ID; mmu_id++) {
+		mmu_invalidate_cache(mmu_id);
+	}
+}
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_local.h
new file mode 100644
index 0000000..76fd147
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_local.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MMU_LOCAL_H_INCLUDED__
+#define __MMU_LOCAL_H_INCLUDED__
+
+#include "mmu_global.h"
+
+#endif /* __MMU_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_private.h
new file mode 100644
index 0000000..e569663
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/mmu_private.h
@@ -0,0 +1,51 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MMU_PRIVATE_H_INCLUDED__
+#define __MMU_PRIVATE_H_INCLUDED__
+
+#include "mmu_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_MMU_H void mmu_reg_store(
+	const mmu_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value)
+{
+assert(ID < N_MMU_ID);
+assert(MMU_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(MMU_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_MMU_H hrt_data mmu_reg_load(
+	const mmu_ID_t		ID,
+	const unsigned int	reg)
+{
+assert(ID < N_MMU_ID);
+assert(MMU_BASE[ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(MMU_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+#endif /* __MMU_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp.c
new file mode 100644
index 0000000..47af40f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp.c
@@ -0,0 +1,90 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "sp.h"
+
+#ifndef __INLINE_SP__
+#include "sp_private.h"
+#endif /* __INLINE_SP__ */
+
+#include "assert_support.h"
+
+void cnd_sp_irq_enable(
+	const sp_ID_t		ID,
+	const bool		cnd)
+{
+	if (cnd) {
+		sp_ctrl_setbit(ID, SP_IRQ_READY_REG, SP_IRQ_READY_BIT);
+/* Enabling the IRQ immediately triggers an interrupt, clear it */
+		sp_ctrl_setbit(ID, SP_IRQ_CLEAR_REG, SP_IRQ_CLEAR_BIT);
+	} else {
+		sp_ctrl_clearbit(ID, SP_IRQ_READY_REG, SP_IRQ_READY_BIT);
+	}
+return;
+}
+
+void sp_get_state(
+	const sp_ID_t			ID,
+	sp_state_t				*state,
+	sp_stall_t				*stall)
+{
+	hrt_data sc = sp_ctrl_load(ID, SP_SC_REG);
+
+	assert(state != NULL);
+	assert(stall != NULL);
+
+	state->pc = sp_ctrl_load(ID, SP_PC_REG);
+	state->status_register = sc;
+	state->is_broken   = (sc & (1U << SP_BROKEN_BIT)) != 0;
+	state->is_idle     = (sc & (1U << SP_IDLE_BIT)) != 0;
+	state->is_sleeping = (sc & (1U << SP_SLEEPING_BIT)) != 0;
+	state->is_stalling = (sc & (1U << SP_STALLING_BIT)) != 0;
+	stall->fifo0 =
+		!sp_ctrl_getbit(ID, SP_FIFO0_SINK_REG, SP_FIFO0_SINK_BIT);
+	stall->fifo1 =
+		!sp_ctrl_getbit(ID, SP_FIFO1_SINK_REG, SP_FIFO1_SINK_BIT);
+	stall->fifo2 =
+		!sp_ctrl_getbit(ID, SP_FIFO2_SINK_REG, SP_FIFO2_SINK_BIT);
+	stall->fifo3 =
+		!sp_ctrl_getbit(ID, SP_FIFO3_SINK_REG, SP_FIFO3_SINK_BIT);
+	stall->fifo4 =
+		!sp_ctrl_getbit(ID, SP_FIFO4_SINK_REG, SP_FIFO4_SINK_BIT);
+	stall->fifo5 =
+		!sp_ctrl_getbit(ID, SP_FIFO5_SINK_REG, SP_FIFO5_SINK_BIT);
+	stall->fifo6 =
+		!sp_ctrl_getbit(ID, SP_FIFO6_SINK_REG, SP_FIFO6_SINK_BIT);
+	stall->fifo7 =
+		!sp_ctrl_getbit(ID, SP_FIFO7_SINK_REG, SP_FIFO7_SINK_BIT);
+	stall->fifo8 =
+		!sp_ctrl_getbit(ID, SP_FIFO8_SINK_REG, SP_FIFO8_SINK_BIT);
+	stall->fifo9 =
+		!sp_ctrl_getbit(ID, SP_FIFO9_SINK_REG, SP_FIFO9_SINK_BIT);
+	stall->fifoa =
+		!sp_ctrl_getbit(ID, SP_FIFOA_SINK_REG, SP_FIFOA_SINK_BIT);
+	stall->dmem =
+		!sp_ctrl_getbit(ID, SP_DMEM_SINK_REG, SP_DMEM_SINK_BIT);
+	stall->control_master =
+		!sp_ctrl_getbit(ID, SP_CTRL_MT_SINK_REG, SP_CTRL_MT_SINK_BIT);
+	stall->icache_master =
+		!sp_ctrl_getbit(ID, SP_ICACHE_MT_SINK_REG,
+			SP_ICACHE_MT_SINK_BIT);
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_local.h
new file mode 100644
index 0000000..e477127
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_local.h
@@ -0,0 +1,131 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SP_LOCAL_H_INCLUDED__
+#define __SP_LOCAL_H_INCLUDED__
+
+#include <type_support.h>
+#include "sp_global.h"
+
+struct sp_state_s {
+	int		pc;
+	int		status_register;
+	bool	is_broken;
+	bool	is_idle;
+	bool	is_sleeping;
+	bool	is_stalling;
+};
+
+struct sp_stall_s {
+	bool	fifo0;
+	bool	fifo1;
+	bool	fifo2;
+	bool	fifo3;
+	bool	fifo4;
+	bool	fifo5;
+	bool	fifo6;
+	bool	fifo7;
+	bool	fifo8;
+	bool	fifo9;
+	bool	fifoa;
+	bool	dmem;
+	bool	control_master;
+	bool	icache_master;
+};
+
+#ifdef C_RUN
+#include "hive_isp_css_sp_hrt.h"
+#define sp_address_of(var)	_hrt_cell_get_crun_indexed_symbol(SP, var)
+#ifdef C_RUN_DYNAMIC_LINK_PROGRAMS
+#ifndef DUMMY_HRT_SYSMEM_FUNCTIONS
+#define DUMMY_HRT_SYSMEM_FUNCTIONS
+/* These two inline functions prevent gcc from generating compiler warnings
+ * about unused static functions. */
+static inline void *
+dummy__hrt_sysmem_ident_address(hive_device_id mem, const char *sym)
+{
+	return __hrt_sysmem_ident_address(mem, sym);
+}
+
+static inline void
+dummy_hrt_sysmem_map_var(hive_mem_id mem, const char *ident, volatile void *native_address, unsigned int size)
+{
+	_hrt_sysmem_map_var(mem, ident, native_address, size);
+}
+#endif /* DUMMY_HRT_SYSMEM_FUNCTIONS */
+#endif /* C_RUN */
+#else
+#define sp_address_of(var)	(HIVE_ADDR_ ## var)
+#endif
+
+/*
+ * deprecated
+ */
+#define store_sp_int(var, value) \
+	sp_dmem_store_uint32(SP0_ID, (unsigned)sp_address_of(var), \
+		(uint32_t)(value))
+
+#define store_sp_ptr(var, value) \
+	sp_dmem_store_uint32(SP0_ID, (unsigned)sp_address_of(var), \
+		(uint32_t)(value))
+
+#define load_sp_uint(var) \
+	sp_dmem_load_uint32(SP0_ID, (unsigned)sp_address_of(var))
+
+#define load_sp_array_uint8(array_name, index) \
+	sp_dmem_load_uint8(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint8_t))
+
+#define load_sp_array_uint16(array_name, index) \
+	sp_dmem_load_uint16(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint16_t))
+
+#define load_sp_array_uint(array_name, index) \
+	sp_dmem_load_uint32(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint32_t))
+
+#define store_sp_var(var, data, bytes) \
+	sp_dmem_store(SP0_ID, (unsigned)sp_address_of(var), data, bytes)
+
+#define store_sp_array_uint8(array_name, index, value) \
+	sp_dmem_store_uint8(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint8_t), value)
+
+#define store_sp_array_uint16(array_name, index, value) \
+	sp_dmem_store_uint16(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint16_t), value)
+
+#define store_sp_array_uint(array_name, index, value) \
+	sp_dmem_store_uint32(SP0_ID, (unsigned)sp_address_of(array_name) + \
+		(index)*sizeof(uint32_t), value)
+
+#define store_sp_var_with_offset(var, offset, data, bytes) \
+	sp_dmem_store(SP0_ID, (unsigned)sp_address_of(var) + \
+		offset, data, bytes)
+
+#define load_sp_var(var, data, bytes) \
+	sp_dmem_load(SP0_ID, (unsigned)sp_address_of(var), data, bytes)
+
+#define load_sp_var_with_offset(var, offset, data, bytes) \
+	sp_dmem_load(SP0_ID, (unsigned)sp_address_of(var) + offset, \
+		data, bytes)
+
+#endif /* __SP_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_private.h
new file mode 100644
index 0000000..cd5a081
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/sp_private.h
@@ -0,0 +1,205 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SP_PRIVATE_H_INCLUDED__
+#define __SP_PRIVATE_H_INCLUDED__
+
+#include "sp_public.h"
+
+#include "device_access.h"
+#ifdef C_RUN
+#include <string.h>	/* memcpy() */
+#endif
+
+#include "assert_support.h"
+
+STORAGE_CLASS_SP_C void sp_ctrl_store(
+	const sp_ID_t		ID,
+	const hrt_address	reg,
+	const hrt_data		value)
+{
+assert(ID < N_SP_ID);
+assert(SP_CTRL_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(SP_CTRL_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+STORAGE_CLASS_SP_C hrt_data sp_ctrl_load(
+	const sp_ID_t		ID,
+	const hrt_address	reg)
+{
+assert(ID < N_SP_ID);
+assert(SP_CTRL_BASE[ID] != (hrt_address)-1);
+return ia_css_device_load_uint32(SP_CTRL_BASE[ID] + reg*sizeof(hrt_data));
+}
+
+STORAGE_CLASS_SP_C bool sp_ctrl_getbit(
+	const sp_ID_t		ID,
+	const hrt_address	reg,
+	const unsigned int	bit)
+{
+	hrt_data val = sp_ctrl_load(ID, reg);
+return (val & (1UL << bit)) != 0;
+}
+
+STORAGE_CLASS_SP_C void sp_ctrl_setbit(
+	const sp_ID_t		ID,
+	const hrt_address	reg,
+	const unsigned int	bit)
+{
+	hrt_data	data = sp_ctrl_load(ID, reg);
+	sp_ctrl_store(ID, reg, (data | (1UL << bit)));
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_ctrl_clearbit(
+	const sp_ID_t		ID,
+	const hrt_address	reg,
+	const unsigned int	bit)
+{
+	hrt_data	data = sp_ctrl_load(ID, reg);
+	sp_ctrl_store(ID, reg, (data & ~(1UL << bit)));
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_dmem_store(
+	const sp_ID_t		ID,
+	hrt_address		addr,
+	const void			*data,
+	const size_t		size)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	ia_css_device_store(SP_DMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy((void *)(uint32_t)addr, data, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_dmem_load(
+	const sp_ID_t		ID,
+	const hrt_address	addr,
+	void				*data,
+	const size_t		size)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+#ifndef C_RUN
+	ia_css_device_load(SP_DMEM_BASE[ID] + addr, data, size);
+#else
+	memcpy(data, (void *)(uint32_t)addr, size);
+#endif
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_dmem_store_uint8(
+	const sp_ID_t		ID,
+	hrt_address		addr,
+	const uint8_t		data)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+	(void)ID;
+#ifndef C_RUN
+	ia_css_device_store_uint8(SP_DMEM_BASE[SP0_ID] + addr, data);
+#else
+	*(uint8_t *)(uint32_t)addr = data;
+#endif
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_dmem_store_uint16(
+	const sp_ID_t		ID,
+	hrt_address		addr,
+	const uint16_t		data)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+	(void)ID;
+#ifndef C_RUN
+	ia_css_device_store_uint16(SP_DMEM_BASE[SP0_ID] + addr, data);
+#else
+	*(uint16_t *)(uint32_t)addr = data;
+#endif
+return;
+}
+
+STORAGE_CLASS_SP_C void sp_dmem_store_uint32(
+	const sp_ID_t		ID,
+	hrt_address		addr,
+	const uint32_t		data)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+	(void)ID;
+#ifndef C_RUN
+	ia_css_device_store_uint32(SP_DMEM_BASE[SP0_ID] + addr, data);
+#else
+	*(uint32_t *)(uint32_t)addr = data;
+#endif
+return;
+}
+
+STORAGE_CLASS_SP_C uint8_t sp_dmem_load_uint8(
+	const sp_ID_t		ID,
+	const hrt_address	addr)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+	(void)ID;
+#ifndef C_RUN
+	return ia_css_device_load_uint8(SP_DMEM_BASE[SP0_ID] + addr);
+#else
+	return *(uint8_t *)(uint32_t)addr;
+#endif
+}
+
+STORAGE_CLASS_SP_C uint16_t sp_dmem_load_uint16(
+	const sp_ID_t		ID,
+	const hrt_address	addr)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+	(void)ID;
+#ifndef C_RUN
+	return ia_css_device_load_uint16(SP_DMEM_BASE[SP0_ID] + addr);
+#else
+	return *(uint16_t *)(uint32_t)addr;
+#endif
+}
+
+STORAGE_CLASS_SP_C uint32_t sp_dmem_load_uint32(
+	const sp_ID_t		ID,
+	const hrt_address	addr)
+{
+assert(ID < N_SP_ID);
+assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
+	(void)ID;
+#ifndef C_RUN
+	return ia_css_device_load_uint32(SP_DMEM_BASE[SP0_ID] + addr);
+#else
+	return *(uint32_t *)(uint32_t)addr;
+#endif
+}
+
+#endif /* __SP_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/system_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/system_local.h
new file mode 100644
index 0000000..719a228
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/system_local.h
@@ -0,0 +1,294 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SYSTEM_LOCAL_H_INCLUDED__
+#define __SYSTEM_LOCAL_H_INCLUDED__
+
+#ifdef HRT_ISP_CSS_CUSTOM_HOST
+#ifndef HRT_USE_VIR_ADDRS
+#define HRT_USE_VIR_ADDRS
+#endif
+/* This interface is deprecated */
+/*#include "hive_isp_css_custom_host_hrt.h"*/
+#endif
+
+#include "system_global.h"
+
+#ifdef __FIST__
+#define HRT_ADDRESS_WIDTH	32		/* Surprise, this is a local property and even differs per platform */
+#else
+#define HRT_ADDRESS_WIDTH	64		/* Surprise, this is a local property */
+#endif
+
+#if !defined(__KERNEL__) || (1==1)
+/* This interface is deprecated */
+#include "hrt/hive_types.h"
+#else  /* __KERNEL__ */
+#include <linux/types.h>
+
+#if HRT_ADDRESS_WIDTH==64
+typedef uint64_t			hrt_address;
+#elif HRT_ADDRESS_WIDTH==32
+typedef uint32_t			hrt_address;
+#else
+#error "system_local.h: HRT_ADDRESS_WIDTH must be one of {32,64}"
+#endif
+
+typedef uint32_t			hrt_vaddress;
+typedef uint32_t			hrt_data;
+#endif /* __KERNEL__ */
+
+/*
+ * Cell specific address maps
+ */
+#if HRT_ADDRESS_WIDTH==64
+
+#define GP_FIFO_BASE   ((hrt_address)0x0000000000090104)		/* This is NOT a base address */
+
+/* DDR */
+static const hrt_address DDR_BASE[N_DDR_ID] = {
+	(hrt_address)0x0000000120000000ULL};
+
+/* ISP */
+static const hrt_address ISP_CTRL_BASE[N_ISP_ID] = {
+	(hrt_address)0x0000000000020000ULL};
+
+static const hrt_address ISP_DMEM_BASE[N_ISP_ID] = {
+	(hrt_address)0xffffffffffffffffULL};
+
+static const hrt_address ISP_BAMEM_BASE[N_BAMEM_ID] = {
+	(hrt_address)0xffffffffffffffffULL};
+
+static const hrt_address ISP_VAMEM_BASE[N_VAMEM_ID] = {
+	(hrt_address)0xffffffffffffffffULL,
+	(hrt_address)0xffffffffffffffffULL,
+	(hrt_address)0xffffffffffffffffULL};
+
+static const hrt_address ISP_HMEM_BASE[N_HMEM_ID] = {
+	(hrt_address)0xffffffffffffffffULL};
+
+/* SP */
+static const hrt_address SP_CTRL_BASE[N_SP_ID] = {
+	(hrt_address)0x0000000000010000ULL};
+
+static const hrt_address SP_DMEM_BASE[N_SP_ID] = {
+	(hrt_address)0x0000000000300000ULL};
+
+/* MMU */
+#if defined (IS_ISP_2400_MAMOIADA_SYSTEM) || defined (IS_ISP_2401_MAMOIADA_SYSTEM)
+/*
+ * MMU0_ID: The data MMU
+ * MMU1_ID: The icache MMU
+ */
+static const hrt_address MMU_BASE[N_MMU_ID] = {
+	(hrt_address)0x0000000000070000ULL,
+	(hrt_address)0x00000000000A0000ULL};
+#else
+#error "system_local.h: SYSTEM must be one of {2400, 2401 }"
+#endif
+
+/* DMA */
+static const hrt_address DMA_BASE[N_DMA_ID] = {
+	(hrt_address)0x0000000000040000ULL};
+
+/* IRQ */
+static const hrt_address IRQ_BASE[N_IRQ_ID] = {
+	(hrt_address)0x0000000000000500ULL,
+	(hrt_address)0x0000000000030A00ULL,
+	(hrt_address)0x000000000008C000ULL,
+	(hrt_address)0x0000000000090200ULL};
+/*
+	(hrt_address)0x0000000000000500ULL};
+ */
+
+/* GDC */
+static const hrt_address GDC_BASE[N_GDC_ID] = {
+	(hrt_address)0x0000000000050000ULL,
+	(hrt_address)0x0000000000060000ULL};
+
+/* FIFO_MONITOR (not a subset of GP_DEVICE) */
+static const hrt_address FIFO_MONITOR_BASE[N_FIFO_MONITOR_ID] = {
+	(hrt_address)0x0000000000000000ULL};
+
+/*
+static const hrt_address GP_REGS_BASE[N_GP_REGS_ID] = {
+	(hrt_address)0x0000000000000000ULL};
+
+static const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
+	(hrt_address)0x0000000000090000ULL};
+*/
+
+/* GP_DEVICE (single base for all separate GP_REG instances) */
+static const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
+	(hrt_address)0x0000000000000000ULL};
+
+/* GPIO */
+static const hrt_address GPIO_BASE[N_GPIO_ID] = {
+	(hrt_address)0x0000000000000400ULL};
+
+/* TIMED_CTRL */
+static const hrt_address TIMED_CTRL_BASE[N_TIMED_CTRL_ID] = {
+	(hrt_address)0x0000000000000100ULL};
+
+
+/* INPUT_FORMATTER */
+static const hrt_address INPUT_FORMATTER_BASE[N_INPUT_FORMATTER_ID] = {
+	(hrt_address)0x0000000000030000ULL,
+	(hrt_address)0x0000000000030200ULL,
+	(hrt_address)0x0000000000030400ULL,
+	(hrt_address)0x0000000000030600ULL}; /* memcpy() */
+
+/* INPUT_SYSTEM */
+static const hrt_address INPUT_SYSTEM_BASE[N_INPUT_SYSTEM_ID] = {
+	(hrt_address)0x0000000000080000ULL};
+/*	(hrt_address)0x0000000000081000ULL, */ /* capture A */
+/*	(hrt_address)0x0000000000082000ULL, */ /* capture B */
+/*	(hrt_address)0x0000000000083000ULL, */ /* capture C */
+/*	(hrt_address)0x0000000000084000ULL, */ /* Acquisition */
+/*	(hrt_address)0x0000000000085000ULL, */ /* DMA */
+/*	(hrt_address)0x0000000000089000ULL, */ /* ctrl */
+/*	(hrt_address)0x000000000008A000ULL, */ /* GP regs */
+/*	(hrt_address)0x000000000008B000ULL, */ /* FIFO */
+/*	(hrt_address)0x000000000008C000ULL, */ /* IRQ */
+
+/* RX, the MIPI lane control regs start at offset 0 */
+static const hrt_address RX_BASE[N_RX_ID] = {
+	(hrt_address)0x0000000000080100ULL};
+
+#elif HRT_ADDRESS_WIDTH==32
+
+#define GP_FIFO_BASE   ((hrt_address)0x00090104)		/* This is NOT a base address */
+
+/* DDR : Attention, this value not defined in 32-bit */
+static const hrt_address DDR_BASE[N_DDR_ID] = {
+	(hrt_address)0x00000000UL};
+
+/* ISP */
+static const hrt_address ISP_CTRL_BASE[N_ISP_ID] = {
+	(hrt_address)0x00020000UL};
+
+static const hrt_address ISP_DMEM_BASE[N_ISP_ID] = {
+	(hrt_address)0xffffffffUL};
+
+static const hrt_address ISP_BAMEM_BASE[N_BAMEM_ID] = {
+	(hrt_address)0xffffffffUL};
+
+static const hrt_address ISP_VAMEM_BASE[N_VAMEM_ID] = {
+	(hrt_address)0xffffffffUL,
+	(hrt_address)0xffffffffUL,
+	(hrt_address)0xffffffffUL};
+
+static const hrt_address ISP_HMEM_BASE[N_HMEM_ID] = {
+	(hrt_address)0xffffffffUL};
+
+/* SP */
+static const hrt_address SP_CTRL_BASE[N_SP_ID] = {
+	(hrt_address)0x00010000UL};
+
+static const hrt_address SP_DMEM_BASE[N_SP_ID] = {
+	(hrt_address)0x00300000UL};
+
+/* MMU */
+#if defined (IS_ISP_2400_MAMOIADA_SYSTEM) || defined (IS_ISP_2401_MAMOIADA_SYSTEM)
+/*
+ * MMU0_ID: The data MMU
+ * MMU1_ID: The icache MMU
+ */
+static const hrt_address MMU_BASE[N_MMU_ID] = {
+	(hrt_address)0x00070000UL,
+	(hrt_address)0x000A0000UL};
+#else
+#error "system_local.h: SYSTEM must be one of {2400, 2401 }"
+#endif
+
+/* DMA */
+static const hrt_address DMA_BASE[N_DMA_ID] = {
+	(hrt_address)0x00040000UL};
+
+/* IRQ */
+static const hrt_address IRQ_BASE[N_IRQ_ID] = {
+	(hrt_address)0x00000500UL,
+	(hrt_address)0x00030A00UL,
+	(hrt_address)0x0008C000UL,
+	(hrt_address)0x00090200UL};
+/*
+	(hrt_address)0x00000500UL};
+ */
+
+/* GDC */
+static const hrt_address GDC_BASE[N_GDC_ID] = {
+	(hrt_address)0x00050000UL,
+	(hrt_address)0x00060000UL};
+
+/* FIFO_MONITOR (not a subset of GP_DEVICE) */
+static const hrt_address FIFO_MONITOR_BASE[N_FIFO_MONITOR_ID] = {
+	(hrt_address)0x00000000UL};
+
+/*
+static const hrt_address GP_REGS_BASE[N_GP_REGS_ID] = {
+	(hrt_address)0x00000000UL};
+
+static const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
+	(hrt_address)0x00090000UL};
+*/
+
+/* GP_DEVICE (single base for all separate GP_REG instances) */
+static const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
+	(hrt_address)0x00000000UL};
+
+/* GPIO */
+static const hrt_address GPIO_BASE[N_GPIO_ID] = {
+	(hrt_address)0x00000400UL};
+
+/* TIMED_CTRL */
+static const hrt_address TIMED_CTRL_BASE[N_TIMED_CTRL_ID] = {
+	(hrt_address)0x00000100UL};
+
+
+/* INPUT_FORMATTER */
+static const hrt_address INPUT_FORMATTER_BASE[N_INPUT_FORMATTER_ID] = {
+	(hrt_address)0x00030000UL,
+	(hrt_address)0x00030200UL,
+	(hrt_address)0x00030400UL};
+/*	(hrt_address)0x00030600UL, */ /* memcpy() */
+
+/* INPUT_SYSTEM */
+static const hrt_address INPUT_SYSTEM_BASE[N_INPUT_SYSTEM_ID] = {
+	(hrt_address)0x00080000UL};
+/*	(hrt_address)0x00081000UL, */ /* capture A */
+/*	(hrt_address)0x00082000UL, */ /* capture B */
+/*	(hrt_address)0x00083000UL, */ /* capture C */
+/*	(hrt_address)0x00084000UL, */ /* Acquisition */
+/*	(hrt_address)0x00085000UL, */ /* DMA */
+/*	(hrt_address)0x00089000UL, */ /* ctrl */
+/*	(hrt_address)0x0008A000UL, */ /* GP regs */
+/*	(hrt_address)0x0008B000UL, */ /* FIFO */
+/*	(hrt_address)0x0008C000UL, */ /* IRQ */
+
+/* RX, the MIPI lane control regs start at offset 0 */
+static const hrt_address RX_BASE[N_RX_ID] = {
+	(hrt_address)0x00080100UL};
+
+#else
+#error "system_local.h: HRT_ADDRESS_WIDTH must be one of {32,64}"
+#endif
+
+#endif /* __SYSTEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl.c
new file mode 100644
index 0000000..ae01bef
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl.c
@@ -0,0 +1,84 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "timed_ctrl.h"
+
+#ifndef __INLINE_TIMED_CTRL__
+#include "timed_ctrl_private.h"
+#endif /* __INLINE_TIMED_CTRL__ */
+
+#include "assert_support.h"
+
+void timed_ctrl_snd_commnd(
+	const timed_ctrl_ID_t			ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	hrt_address				addr,
+	hrt_data				value)
+{
+	OP___assert(ID == TIMED_CTRL0_ID);
+	OP___assert(TIMED_CTRL_BASE[ID] != (hrt_address)-1);
+
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, mask);
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, condition);
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, counter);
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, (hrt_data)addr);
+	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, value);
+return;
+}
+
+/* pqiao TODO: make sure the following commands get
+	correct BASE address both for csim and android */
+
+void timed_ctrl_snd_sp_commnd(
+	const timed_ctrl_ID_t			ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	const sp_ID_t				SP_ID,
+	hrt_address				offset,
+	hrt_data				value)
+{
+	OP___assert(SP_ID < N_SP_ID);
+	OP___assert(SP_DMEM_BASE[SP_ID] != (hrt_address)-1);
+
+	timed_ctrl_snd_commnd(ID, mask, condition, counter,
+				SP_DMEM_BASE[SP_ID]+offset, value);
+return;
+}
+
+void timed_ctrl_snd_gpio_commnd(
+	const timed_ctrl_ID_t			ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	const gpio_ID_t				GPIO_ID,
+	hrt_address				offset,
+	hrt_data				value)
+{
+	OP___assert(GPIO_ID < N_GPIO_ID);
+	OP___assert(GPIO_BASE[GPIO_ID] != (hrt_address)-1);
+
+	timed_ctrl_snd_commnd(ID, mask, condition, counter,
+				GPIO_BASE[GPIO_ID]+offset, value);
+return;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_local.h
new file mode 100644
index 0000000..e3aa39e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_local.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TIMED_CTRL_LOCAL_H_INCLUDED__
+#define __TIMED_CTRL_LOCAL_H_INCLUDED__
+
+#include "timed_ctrl_global.h"
+
+#endif /* __TIMED_CTRL_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_private.h
new file mode 100644
index 0000000..c974627
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/timed_ctrl_private.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TIMED_CTRL_PRIVATE_H_INCLUDED__
+#define __TIMED_CTRL_PRIVATE_H_INCLUDED__
+
+#include "timed_ctrl_public.h"
+
+#include "device_access.h"
+
+#include "assert_support.h"
+
+STORAGE_CLASS_TIMED_CTRL_C void timed_ctrl_reg_store(
+	const timed_ctrl_ID_t	ID,
+	const unsigned int		reg,
+	const hrt_data			value)
+{
+OP___assert(ID < N_TIMED_CTRL_ID);
+OP___assert(TIMED_CTRL_BASE[ID] != (hrt_address)-1);
+	ia_css_device_store_uint32(TIMED_CTRL_BASE[ID] + reg*sizeof(hrt_data), value);
+return;
+}
+
+#endif /* __GP_DEVICE_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vamem_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vamem_local.h
new file mode 100644
index 0000000..9a747be
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vamem_local.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VAMEM_LOCAL_H_INCLUDED__
+#define __VAMEM_LOCAL_H_INCLUDED__
+
+#include "vamem_global.h"
+
+#endif /* __VAMEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vmem_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vmem_local.h
new file mode 100644
index 0000000..3ceb33c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vmem_local.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VMEM_LOCAL_H_INCLUDED__
+#define __VMEM_LOCAL_H_INCLUDED__
+
+#include "vmem_global.h"
+
+#define VMEM_ARRAY(x,s) uint16_t x[s/ISP_NWAY][ISP_NWAY]
+
+#endif /* __VMEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vmem_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vmem_private.h
new file mode 100644
index 0000000..a488f59
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/host/vmem_private.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VMEM_PRIVATE_H_INCLUDED__
+#define __VMEM_PRIVATE_H_INCLUDED__
+
+#include "vmem_public.h"
+
+#endif /* __VMEM_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_formatter_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_formatter_global.h
new file mode 100644
index 0000000..70b5dc0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_formatter_global.h
@@ -0,0 +1,137 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __INPUT_FORMATTER_GLOBAL_H_INCLUDED__
+#define __INPUT_FORMATTER_GLOBAL_H_INCLUDED__
+
+#define IS_INPUT_FORMATTER_VERSION2
+#define IS_INPUT_SWITCH_VERSION2
+
+#include <type_support.h>
+#include <system_types.h>
+#include "if_defs.h"
+#include "str2mem_defs.h"
+#include "input_switch_2400_defs.h"
+
+#define _HIVE_INPUT_SWITCH_GET_FSYNC_REG_LSB(ch_id)        ((ch_id) * 3)
+
+#define HIVE_SWITCH_N_CHANNELS				4
+#define HIVE_SWITCH_N_FORMATTYPES			32
+#define HIVE_SWITCH_N_SWITCH_CODE			4
+#define HIVE_SWITCH_M_CHANNELS				0x00000003
+#define HIVE_SWITCH_M_FORMATTYPES			0x0000001f
+#define HIVE_SWITCH_M_SWITCH_CODE			0x00000003
+#define HIVE_SWITCH_M_FSYNC					0x00000007
+
+#define HIVE_SWITCH_ENCODE_FSYNC(x) \
+	(1U<<(((x)-1)&HIVE_SWITCH_M_CHANNELS))
+
+#define _HIVE_INPUT_SWITCH_GET_LUT_FIELD(reg, bit_index) \
+	(((reg) >> (bit_index)) & HIVE_SWITCH_M_SWITCH_CODE)
+#define _HIVE_INPUT_SWITCH_SET_LUT_FIELD(reg, bit_index, val) \
+	(((reg) & ~(HIVE_SWITCH_M_SWITCH_CODE<<(bit_index))) | (((hrt_data)(val)&HIVE_SWITCH_M_SWITCH_CODE)<<(bit_index)))
+#define _HIVE_INPUT_SWITCH_GET_FSYNC_FIELD(reg, bit_index) \
+	(((reg) >> (bit_index)) & HIVE_SWITCH_M_FSYNC)
+#define _HIVE_INPUT_SWITCH_SET_FSYNC_FIELD(reg, bit_index, val) \
+	(((reg) & ~(HIVE_SWITCH_M_FSYNC<<(bit_index))) | (((hrt_data)(val)&HIVE_SWITCH_M_FSYNC)<<(bit_index)))
+
+typedef struct input_formatter_cfg_s	input_formatter_cfg_t;
+
+/* Hardware registers */
+/*#define HIVE_IF_RESET_ADDRESS                   0x000*/ /* deprecated */
+#define HIVE_IF_START_LINE_ADDRESS              0x004
+#define HIVE_IF_START_COLUMN_ADDRESS            0x008
+#define HIVE_IF_CROPPED_HEIGHT_ADDRESS          0x00C
+#define HIVE_IF_CROPPED_WIDTH_ADDRESS           0x010
+#define HIVE_IF_VERTICAL_DECIMATION_ADDRESS     0x014
+#define HIVE_IF_HORIZONTAL_DECIMATION_ADDRESS   0x018
+#define HIVE_IF_H_DEINTERLEAVING_ADDRESS        0x01C
+#define HIVE_IF_LEFTPADDING_WIDTH_ADDRESS       0x020
+#define HIVE_IF_END_OF_LINE_OFFSET_ADDRESS      0x024
+#define HIVE_IF_VMEM_START_ADDRESS_ADDRESS      0x028
+#define HIVE_IF_VMEM_END_ADDRESS_ADDRESS        0x02C
+#define HIVE_IF_VMEM_INCREMENT_ADDRESS          0x030
+#define HIVE_IF_YUV_420_FORMAT_ADDRESS          0x034
+#define HIVE_IF_VSYNCK_ACTIVE_LOW_ADDRESS       0x038
+#define HIVE_IF_HSYNCK_ACTIVE_LOW_ADDRESS       0x03C
+#define HIVE_IF_ALLOW_FIFO_OVERFLOW_ADDRESS     0x040
+#define HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS       0x044
+#define HIVE_IF_V_DEINTERLEAVING_ADDRESS        0x048
+#define HIVE_IF_FSM_CROP_PIXEL_COUNTER          0x110
+#define HIVE_IF_FSM_CROP_LINE_COUNTER           0x10C
+#define HIVE_IF_FSM_CROP_STATUS                 0x108
+
+/* Registers only for simulation */
+#define HIVE_IF_CRUN_MODE_ADDRESS               0x04C
+#define HIVE_IF_DUMP_OUTPUT_ADDRESS             0x050
+
+/* Follow the DMA syntax, "cmd" last */
+#define IF_PACK(val, cmd)             ((val & 0x0fff) | (cmd /*& 0xf000*/))
+
+#define HIVE_STR2MEM_SOFT_RESET_REG_ADDRESS                   (_STR2MEM_SOFT_RESET_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_INPUT_ENDIANNESS_REG_ADDRESS             (_STR2MEM_INPUT_ENDIANNESS_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_OUTPUT_ENDIANNESS_REG_ADDRESS            (_STR2MEM_OUTPUT_ENDIANNESS_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_BIT_SWAPPING_REG_ADDRESS                 (_STR2MEM_BIT_SWAPPING_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_BLOCK_SYNC_LEVEL_REG_ADDRESS             (_STR2MEM_BLOCK_SYNC_LEVEL_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_PACKET_SYNC_LEVEL_REG_ADDRESS            (_STR2MEM_PACKET_SYNC_LEVEL_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ADDRESS  (_STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ADDRESS     (_STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ID * _STR2MEM_REG_ALIGN)
+#define HIVE_STR2MEM_EN_STAT_UPDATE_ADDRESS                   (_STR2MEM_EN_STAT_UPDATE_ID * _STR2MEM_REG_ALIGN)
+
+/*
+ * This data structure is shared between host and SP
+ */
+struct input_formatter_cfg_s {
+	uint32_t	start_line;
+	uint32_t	start_column;
+	uint32_t	left_padding;
+	uint32_t	cropped_height;
+	uint32_t	cropped_width;
+	uint32_t	deinterleaving;
+	uint32_t	buf_vecs;
+	uint32_t	buf_start_index;
+	uint32_t	buf_increment;
+	uint32_t	buf_eol_offset;
+	uint32_t	is_yuv420_format;
+	uint32_t	block_no_reqs;
+};
+
+#define DEFAULT_IF_CONFIG \
+{ \
+	0,          /* start_line */\
+	0,          /* start_column */\
+	0,          /* left_padding */\
+	0,          /* cropped_height */\
+	0,          /* cropped_width */\
+	0,          /* deinterleaving */\
+	0,          /*.buf_vecs */\
+	0,          /* buf_start_index */\
+	0,          /* buf_increment */\
+	0,          /* buf_eol_offset */\
+	false,      /* is_yuv420_format */\
+	false       /* block_no_reqs */\
+}
+
+extern const hrt_address HIVE_IF_SRST_ADDRESS[N_INPUT_FORMATTER_ID];
+extern const hrt_data HIVE_IF_SRST_MASK[N_INPUT_FORMATTER_ID];
+extern const uint8_t HIVE_IF_SWITCH_CODE[N_INPUT_FORMATTER_ID];
+
+#endif /* __INPUT_FORMATTER_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_system_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_system_global.h
new file mode 100644
index 0000000..9df76e1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/input_system_global.h
@@ -0,0 +1,162 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __INPUT_SYSTEM_GLOBAL_H_INCLUDED__
+#define __INPUT_SYSTEM_GLOBAL_H_INCLUDED__
+
+#define IS_INPUT_SYSTEM_VERSION_2
+
+#include <type_support.h>
+
+//CSI reveiver has 3 ports.
+#define		N_CSI_PORTS (3)
+//AM: Use previous define for this.
+
+//MIPI allows upto 4 channels.
+#define		N_CHANNELS  (4)
+// 12KB = 256bit x 384 words
+#define		IB_CAPACITY_IN_WORDS (384)
+
+typedef enum {
+	MIPI_0LANE_CFG = 0,
+	MIPI_1LANE_CFG = 1,
+	MIPI_2LANE_CFG = 2,
+	MIPI_3LANE_CFG = 3,
+	MIPI_4LANE_CFG = 4
+} mipi_lane_cfg_t;
+
+typedef enum {
+	INPUT_SYSTEM_SOURCE_SENSOR = 0,
+	INPUT_SYSTEM_SOURCE_FIFO,
+	INPUT_SYSTEM_SOURCE_TPG,
+	INPUT_SYSTEM_SOURCE_PRBS,
+	INPUT_SYSTEM_SOURCE_MEMORY,
+	N_INPUT_SYSTEM_SOURCE
+} input_system_source_t;
+
+/* internal routing configuration */
+typedef enum {
+	INPUT_SYSTEM_DISCARD_ALL = 0,
+	INPUT_SYSTEM_CSI_BACKEND = 1,
+	INPUT_SYSTEM_INPUT_BUFFER = 2,
+	INPUT_SYSTEM_MULTICAST = 3,
+	N_INPUT_SYSTEM_CONNECTION
+} input_system_connection_t;
+
+typedef enum {
+	INPUT_SYSTEM_MIPI_PORT0,
+	INPUT_SYSTEM_MIPI_PORT1,
+	INPUT_SYSTEM_MIPI_PORT2,
+	INPUT_SYSTEM_ACQUISITION_UNIT,
+	N_INPUT_SYSTEM_MULTIPLEX
+} input_system_multiplex_t;
+
+typedef enum {
+	INPUT_SYSTEM_SINK_MEMORY = 0,
+	INPUT_SYSTEM_SINK_ISP,
+	INPUT_SYSTEM_SINK_SP,
+	N_INPUT_SYSTEM_SINK
+} input_system_sink_t;
+
+typedef enum {
+	INPUT_SYSTEM_FIFO_CAPTURE = 0,
+	INPUT_SYSTEM_FIFO_CAPTURE_WITH_COUNTING,
+	INPUT_SYSTEM_SRAM_BUFFERING,
+	INPUT_SYSTEM_XMEM_BUFFERING,
+	INPUT_SYSTEM_XMEM_CAPTURE,
+	INPUT_SYSTEM_XMEM_ACQUIRE,
+	N_INPUT_SYSTEM_BUFFERING_MODE
+} buffering_mode_t;
+
+typedef struct input_system_cfg_s	input_system_cfg_t;
+typedef struct sync_generator_cfg_s	sync_generator_cfg_t;
+typedef struct tpg_cfg_s			tpg_cfg_t;
+typedef struct prbs_cfg_s			prbs_cfg_t;
+
+/* MW: uint16_t should be sufficient */
+struct input_system_cfg_s {
+	uint32_t	no_side_band;
+	uint32_t	fmt_type;
+	uint32_t	ch_id;
+	uint32_t	input_mode;
+};
+
+struct sync_generator_cfg_s {
+	uint32_t	width;
+	uint32_t	height;
+	uint32_t	hblank_cycles;
+	uint32_t	vblank_cycles;
+};
+
+/* MW: tpg & prbs are exclusive */
+struct tpg_cfg_s {
+	uint32_t	x_mask;
+	uint32_t	y_mask;
+	uint32_t	x_delta;
+	uint32_t	y_delta;
+	uint32_t	xy_mask;
+	sync_generator_cfg_t sync_gen_cfg;
+};
+
+struct prbs_cfg_s {
+	uint32_t	seed;
+	sync_generator_cfg_t sync_gen_cfg;
+};
+
+struct gpfifo_cfg_s {
+// TBD.
+	sync_generator_cfg_t sync_gen_cfg;
+};
+
+typedef struct gpfifo_cfg_s		gpfifo_cfg_t;
+
+//ALX:Commented out to pass the compilation.
+//typedef struct input_system_cfg_s input_system_cfg_t;
+
+struct ib_buffer_s {
+	uint32_t	mem_reg_size;
+	uint32_t	nof_mem_regs;
+	uint32_t	mem_reg_addr;
+};
+
+typedef struct ib_buffer_s	ib_buffer_t;
+
+struct csi_cfg_s {
+	uint32_t			csi_port;
+    buffering_mode_t	buffering_mode;
+	ib_buffer_t			csi_buffer;
+	ib_buffer_t			acquisition_buffer;
+	uint32_t			nof_xmem_buffers;
+};
+
+typedef struct csi_cfg_s	 csi_cfg_t;
+
+typedef enum {
+	INPUT_SYSTEM_CFG_FLAG_RESET	= 0,
+	INPUT_SYSTEM_CFG_FLAG_SET		= 1U << 0,
+	INPUT_SYSTEM_CFG_FLAG_BLOCKED	= 1U << 1,
+	INPUT_SYSTEM_CFG_FLAG_REQUIRED	= 1U << 2,
+	INPUT_SYSTEM_CFG_FLAG_CONFLICT	= 1U << 3	// To mark a conflicting configuration.
+} input_system_cfg_flag_t;
+
+typedef uint32_t input_system_config_flags_t;
+
+#endif /* __INPUT_SYSTEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/irq_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/irq_global.h
new file mode 100644
index 0000000..9107e82
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/irq_global.h
@@ -0,0 +1,52 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IRQ_GLOBAL_H_INCLUDED__
+#define __IRQ_GLOBAL_H_INCLUDED__
+
+#include <system_types.h>
+
+#define IS_IRQ_VERSION_2
+#define IS_IRQ_MAP_VERSION_2
+
+/* We cannot include the (hrt host ID) file defining the "CSS_RECEIVER" property without side effects */
+#ifndef HAS_NO_RX
+#if defined(IS_ISP_2400_MAMOIADA_SYSTEM)
+/*#define CSS_RECEIVER testbench_isp_inp_sys_csi_receiver*/
+#include "hive_isp_css_irq_types_hrt.h"	/* enum	hrt_isp_css_irq */
+#elif defined(IS_ISP_2401_MAMOIADA_SYSTEM)
+/*#define CSS_RECEIVER testbench_isp_is_2400_inp_sys_csi_receiver*/
+#include "hive_isp_css_2401_irq_types_hrt.h"	/* enum	hrt_isp_css_irq */
+#else
+#error "irq_global.h: 2400_SYSTEM must be one of {2400, 2401 }"
+#endif
+#endif
+
+/* The IRQ is not mapped uniformly on its related interfaces */
+#define	IRQ_SW_CHANNEL_OFFSET	hrt_isp_css_irq_sw_pin_0
+
+typedef enum {
+	IRQ_SW_CHANNEL0_ID = hrt_isp_css_irq_sw_pin_0 - IRQ_SW_CHANNEL_OFFSET,
+	IRQ_SW_CHANNEL1_ID = hrt_isp_css_irq_sw_pin_1 - IRQ_SW_CHANNEL_OFFSET,
+	N_IRQ_SW_CHANNEL_ID
+} irq_sw_channel_id_t;
+
+#endif /* __IRQ_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/isp_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/isp_global.h
new file mode 100644
index 0000000..ea913be
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/isp_global.h
@@ -0,0 +1,99 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP_GLOBAL_H_INCLUDED__
+#define __ISP_GLOBAL_H_INCLUDED__
+
+#include <system_types.h>
+
+#if defined (HAS_ISP_2401_MAMOIADA)
+#define IS_ISP_2401_MAMOIADA
+
+#include "isp2401_mamoiada_params.h"
+#elif defined (HAS_ISP_2400_MAMOIADA)
+#define IS_ISP_2400_MAMOIADA
+
+#include "isp2400_mamoiada_params.h"
+#else
+#error "isp_global_h: ISP_2400_MAMOIDA must be one of {2400, 2401 }"
+#endif
+
+#define ISP_PMEM_WIDTH_LOG2		ISP_LOG2_PMEM_WIDTH
+#define ISP_PMEM_SIZE			ISP_PMEM_DEPTH
+
+#define ISP_NWAY_LOG2			6
+#define ISP_VEC_NELEMS_LOG2		ISP_NWAY_LOG2
+
+/* The number of data bytes in a vector disregarding the reduced precision */
+#define ISP_VEC_BYTES			(ISP_VEC_NELEMS*sizeof(uint16_t))
+
+/* ISP SC Registers */
+#define ISP_SC_REG				0x00
+#define ISP_PC_REG				0x07
+#define ISP_IRQ_READY_REG		0x00
+#define ISP_IRQ_CLEAR_REG		0x00
+
+/* ISP SC Register bits */
+#define ISP_RST_BIT				0x00
+#define ISP_START_BIT			0x01
+#define ISP_BREAK_BIT			0x02
+#define ISP_RUN_BIT				0x03
+#define ISP_BROKEN_BIT			0x04
+#define ISP_IDLE_BIT			0x05     /* READY */
+#define ISP_STALLING_BIT		0x07
+#define ISP_IRQ_CLEAR_BIT		0x08
+#define ISP_IRQ_READY_BIT		0x0A
+#define ISP_SLEEPING_BIT		0x0B     /* SLEEPING_IRQ_MASK */
+
+/* ISP Register bits */
+#define ISP_CTRL_SINK_BIT		0x00
+#define ISP_PMEM_SINK_BIT		0x01
+#define ISP_DMEM_SINK_BIT		0x02
+#define ISP_FIFO0_SINK_BIT		0x03
+#define ISP_FIFO1_SINK_BIT		0x04
+#define ISP_FIFO2_SINK_BIT		0x05
+#define ISP_FIFO3_SINK_BIT		0x06
+#define ISP_FIFO4_SINK_BIT		0x07
+#define ISP_FIFO5_SINK_BIT		0x08
+#define ISP_FIFO6_SINK_BIT		0x09
+#define ISP_VMEM_SINK_BIT		0x0A
+#define ISP_VAMEM1_SINK_BIT		0x0B
+#define ISP_VAMEM2_SINK_BIT		0x0C
+#define ISP_VAMEM3_SINK_BIT		0x0D
+#define ISP_HMEM_SINK_BIT		0x0E
+
+#define ISP_CTRL_SINK_REG		0x08
+#define ISP_PMEM_SINK_REG		0x08
+#define ISP_DMEM_SINK_REG		0x08
+#define ISP_FIFO0_SINK_REG		0x08
+#define ISP_FIFO1_SINK_REG		0x08
+#define ISP_FIFO2_SINK_REG		0x08
+#define ISP_FIFO3_SINK_REG		0x08
+#define ISP_FIFO4_SINK_REG		0x08
+#define ISP_FIFO5_SINK_REG		0x08
+#define ISP_FIFO6_SINK_REG		0x08
+#define ISP_VMEM_SINK_REG		0x08
+#define ISP_VAMEM1_SINK_REG		0x08
+#define ISP_VAMEM2_SINK_REG		0x08
+#define ISP_VAMEM3_SINK_REG		0x08
+#define ISP_HMEM_SINK_REG		0x08
+
+#endif /* __ISP_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/mmu_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/mmu_global.h
new file mode 100644
index 0000000..1040679
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/mmu_global.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MMU_GLOBAL_H_INCLUDED__
+#define __MMU_GLOBAL_H_INCLUDED__
+
+#define IS_MMU_VERSION_2
+
+#include <mmu_defs.h>
+
+#endif /* __MMU_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/resource_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/resource_global.h
new file mode 100644
index 0000000..9e73dff
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/resource_global.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __RESOURCE_GLOBAL_H_INCLUDED__
+#define __RESOURCE_GLOBAL_H_INCLUDED__
+
+#define IS_RESOURCE_VERSION_1
+
+typedef enum {
+	DMA_CHANNEL_RESOURCE_TYPE,
+	IRQ_CHANNEL_RESOURCE_TYPE,
+	MEM_SECTION_RESOURCE_TYPE,
+	N_RESOURCE_TYPE
+} resource_type_ID_t;
+
+typedef enum {
+	PERMANENT_RESOURCE_RESERVATION,
+	PERSISTENT_RESOURCE_RESERVATION,
+	DEDICTATED_RESOURCE_RESERVATION,
+	SHARED_RESOURCE_RESERVATION,
+	N_RESOURCE_RESERVATION
+} resource_reservation_t;
+
+#endif /* __RESOURCE_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/sp_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/sp_global.h
new file mode 100644
index 0000000..a8fdad2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/sp_global.h
@@ -0,0 +1,99 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SP_GLOBAL_H_INCLUDED__
+#define __SP_GLOBAL_H_INCLUDED__
+
+#include <system_types.h>
+
+#if defined(HAS_SP_2401)
+#define IS_SP_2401
+/* 2401 uses 2400 */
+#include <scalar_processor_2400_params.h>
+#elif defined(HAS_SP_2400)
+#define IS_SP_2400
+
+#include <scalar_processor_2400_params.h>
+#else
+#error "sp_global.h: SP_2400 must be one of {2400, 2401 }"
+#endif
+
+#define SP_PMEM_WIDTH_LOG2		SP_PMEM_LOG_WIDTH_BITS
+#define SP_PMEM_SIZE			SP_PMEM_DEPTH
+
+#define SP_DMEM_SIZE			0x4000
+
+/* SP Registers */
+#define SP_PC_REG				0x09
+#define SP_SC_REG				0x00
+#define SP_START_ADDR_REG		0x01
+#define SP_ICACHE_ADDR_REG		0x05
+#define SP_IRQ_READY_REG		0x00
+#define SP_IRQ_CLEAR_REG		0x00
+#define SP_ICACHE_INV_REG		0x00
+#define SP_CTRL_SINK_REG		0x0A
+
+/* SP Register bits */
+#define SP_RST_BIT				0x00
+#define SP_START_BIT			0x01
+#define SP_BREAK_BIT			0x02
+#define SP_RUN_BIT				0x03
+#define SP_BROKEN_BIT			0x04
+#define SP_IDLE_BIT				0x05     /* READY */
+#define SP_STALLING_BIT			0x07
+#define SP_IRQ_CLEAR_BIT		0x08
+#define SP_IRQ_READY_BIT		0x0A
+#define SP_SLEEPING_BIT			0x0B     /* SLEEPING_IRQ_MASK */
+
+#define SP_ICACHE_INV_BIT		0x0C
+#define SP_IPREFETCH_EN_BIT		0x0D
+
+#define SP_FIFO0_SINK_BIT		0x00
+#define SP_FIFO1_SINK_BIT		0x01
+#define SP_FIFO2_SINK_BIT		0x02
+#define SP_FIFO3_SINK_BIT		0x03
+#define SP_FIFO4_SINK_BIT		0x04
+#define SP_FIFO5_SINK_BIT		0x05
+#define SP_FIFO6_SINK_BIT		0x06
+#define SP_FIFO7_SINK_BIT		0x07
+#define SP_FIFO8_SINK_BIT		0x08
+#define SP_FIFO9_SINK_BIT		0x09
+#define SP_FIFOA_SINK_BIT		0x0A
+#define SP_DMEM_SINK_BIT		0x0B
+#define SP_CTRL_MT_SINK_BIT		0x0C
+#define SP_ICACHE_MT_SINK_BIT	0x0D
+
+#define SP_FIFO0_SINK_REG		0x0A
+#define SP_FIFO1_SINK_REG		0x0A
+#define SP_FIFO2_SINK_REG		0x0A
+#define SP_FIFO3_SINK_REG		0x0A
+#define SP_FIFO4_SINK_REG		0x0A
+#define SP_FIFO5_SINK_REG		0x0A
+#define SP_FIFO6_SINK_REG		0x0A
+#define SP_FIFO7_SINK_REG		0x0A
+#define SP_FIFO8_SINK_REG		0x0A
+#define SP_FIFO9_SINK_REG		0x0A
+#define SP_FIFOA_SINK_REG		0x0A
+#define SP_DMEM_SINK_REG		0x0A
+#define SP_CTRL_MT_SINK_REG		0x0A
+#define SP_ICACHE_MT_SINK_REG	0x0A
+
+#endif /* __SP_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/system_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/system_global.h
new file mode 100644
index 0000000..b1007bc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/system_global.h
@@ -0,0 +1,308 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SYSTEM_GLOBAL_H_INCLUDED__
+#define __SYSTEM_GLOBAL_H_INCLUDED__
+
+#include <hive_isp_css_defs.h>
+#include <type_support.h>
+
+/*
+ * The longest allowed (uninteruptible) bus transfer, does not
+ * take stalling into account
+ */
+#define HIVE_ISP_MAX_BURST_LENGTH	1024
+
+/*
+ * Create a list of HAS and IS properties that defines the system
+ *
+ * The configuration assumes the following
+ * - The system is hetereogeneous; Multiple cells and devices classes
+ * - The cell and device instances are homogeneous, each device type
+ *   belongs to the same class
+ * - Device instances supporting a subset of the class capabilities are
+ *   allowed
+ *
+ * We could manage different device classes through the enumerated
+ * lists (C) or the use of classes (C++), but that is presently not
+ * fully supported
+ *
+ * N.B. the 3 input formatters are of 2 different classess
+ */
+
+#define IS_ISP_2400_SYSTEM
+/*
+ * Since this file is visible everywhere and the system definition
+ * macros are not, detect the separate definitions for {host, SP, ISP}
+ *
+ * The 2401 system has the nice property that it uses a vanilla 2400 SP
+ * so the SP will believe it is a 2400 system rather than 2401...
+ */
+//#if defined(SYSTEM_hive_isp_css_2401_system) || defined(__isp2401_mamoiada) || defined(__scalar_processor_2401)
+#if defined(SYSTEM_hive_isp_css_2401_system) || defined(__isp2401_mamoiada)
+#define IS_ISP_2401_MAMOIADA_SYSTEM
+#define HAS_ISP_2401_MAMOIADA
+#define HAS_SP_2400
+//#elif defined(SYSTEM_hive_isp_css_2400_system) || defined(__isp2400_mamoiada) || defined(__scalar_processor_2400)
+#elif defined(SYSTEM_hive_isp_css_2400_system) || defined(__isp2400_mamoiada)
+#define IS_ISP_2400_MAMOIADA_SYSTEM
+#define HAS_ISP_2400_MAMOIADA
+#define HAS_SP_2400
+#else
+#error "system_global.h: 2400_SYSTEM must be one of {2400, 2401 }"
+#endif
+
+#define USE_INPUT_SYSTEM_VERSION_2
+
+#define HAS_MMU_VERSION_2
+#define HAS_DMA_VERSION_2
+#define HAS_GDC_VERSION_2
+#define HAS_VAMEM_VERSION_2
+#define HAS_HMEM_VERSION_1
+#define HAS_BAMEM_VERSION_2
+#define HAS_IRQ_VERSION_2
+#define HAS_IRQ_MAP_VERSION_2
+#define HAS_INPUT_FORMATTER_VERSION_2
+/* 2401: HAS_INPUT_SYSTEM_VERSION_2401 */
+#define HAS_INPUT_SYSTEM_VERSION_2
+#define HAS_BUFFERED_SENSOR
+#define HAS_FIFO_MONITORS_VERSION_2
+/* #define HAS_GP_REGS_VERSION_2 */
+#define HAS_GP_DEVICE_VERSION_2
+#define HAS_GPIO_VERSION_1
+#define HAS_TIMED_CTRL_VERSION_1
+#define HAS_RX_VERSION_2
+
+/*
+ * Semi global. "HRT" is accessible from SP, but the HRT types do not fully apply
+ */
+#define HRT_VADDRESS_WIDTH	32
+//#define HRT_ADDRESS_WIDTH	64		/* Surprise, this is a local property*/
+#define HRT_DATA_WIDTH		32
+
+#define SIZEOF_HRT_REG		(HRT_DATA_WIDTH>>3)
+#define HIVE_ISP_CTRL_DATA_BYTES (HIVE_ISP_CTRL_DATA_WIDTH/8)
+
+/* The main bus connecting all devices */
+#define HRT_BUS_WIDTH		HIVE_ISP_CTRL_DATA_WIDTH
+#define HRT_BUS_BYTES		HIVE_ISP_CTRL_DATA_BYTES
+
+typedef uint32_t			hrt_bus_align_t;
+
+/*
+ * Enumerate the devices, device access through the API is by ID, through the DLI by address
+ * The enumerator terminators are used to size the wiring arrays and as an exception value.
+ */
+typedef enum {
+	DDR0_ID = 0,
+	N_DDR_ID
+} ddr_ID_t;
+
+typedef enum {
+	ISP0_ID = 0,
+	N_ISP_ID
+} isp_ID_t;
+
+typedef enum {
+	SP0_ID = 0,
+	N_SP_ID
+} sp_ID_t;
+
+#if defined (IS_ISP_2401_MAMOIADA_SYSTEM)
+typedef enum {
+	MMU0_ID = 0,
+	MMU1_ID,
+	N_MMU_ID
+} mmu_ID_t;
+#elif defined (IS_ISP_2400_MAMOIADA_SYSTEM)
+typedef enum {
+	MMU0_ID = 0,
+	MMU1_ID,
+	N_MMU_ID
+} mmu_ID_t;
+#else
+#error "system_global.h: SYSTEM must be one of {2400, 2401}"
+#endif
+
+typedef enum {
+	DMA0_ID = 0,
+	N_DMA_ID
+} dma_ID_t;
+
+typedef enum {
+	GDC0_ID = 0,
+	GDC1_ID,
+	N_GDC_ID
+} gdc_ID_t;
+
+#define N_GDC_ID_CPP 2 // this extra define is needed because we want to use it also in the preprocessor, and that doesn't work with enums.
+
+typedef enum {
+	VAMEM0_ID = 0,
+	VAMEM1_ID,
+	VAMEM2_ID,
+	N_VAMEM_ID
+} vamem_ID_t;
+
+typedef enum {
+	BAMEM0_ID = 0,
+	N_BAMEM_ID
+} bamem_ID_t;
+
+typedef enum {
+	HMEM0_ID = 0,
+	N_HMEM_ID
+} hmem_ID_t;
+
+/*
+typedef enum {
+	IRQ0_ID = 0,
+	N_IRQ_ID
+} irq_ID_t;
+*/
+
+typedef enum {
+	IRQ0_ID = 0,	// GP IRQ block
+	IRQ1_ID,		// Input formatter
+	IRQ2_ID,		// input system
+	IRQ3_ID,		// input selector
+	N_IRQ_ID
+} irq_ID_t;
+
+typedef enum {
+	FIFO_MONITOR0_ID = 0,
+	N_FIFO_MONITOR_ID
+} fifo_monitor_ID_t;
+
+/*
+ * Deprecated: Since all gp_reg instances are different
+ * and put in the address maps of other devices we cannot
+ * enumerate them as that assumes the instrances are the
+ * same.
+ *
+ * We define a single GP_DEVICE containing all gp_regs
+ * w.r.t. a single base address
+ *
+typedef enum {
+	GP_REGS0_ID = 0,
+	N_GP_REGS_ID
+} gp_regs_ID_t;
+ */
+typedef enum {
+	GP_DEVICE0_ID = 0,
+	N_GP_DEVICE_ID
+} gp_device_ID_t;
+
+typedef enum {
+	GPIO0_ID = 0,
+	N_GPIO_ID
+} gpio_ID_t;
+
+typedef enum {
+	TIMED_CTRL0_ID = 0,
+	N_TIMED_CTRL_ID
+} timed_ctrl_ID_t;
+
+typedef enum {
+	INPUT_FORMATTER0_ID = 0,
+	INPUT_FORMATTER1_ID,
+	INPUT_FORMATTER2_ID,
+	INPUT_FORMATTER3_ID,
+	N_INPUT_FORMATTER_ID
+} input_formatter_ID_t;
+
+/* The IF RST is outside the IF */
+#define INPUT_FORMATTER0_SRST_OFFSET	0x0824
+#define INPUT_FORMATTER1_SRST_OFFSET	0x0624
+#define INPUT_FORMATTER2_SRST_OFFSET	0x0424
+#define INPUT_FORMATTER3_SRST_OFFSET	0x0224
+
+#define INPUT_FORMATTER0_SRST_MASK		0x0001
+#define INPUT_FORMATTER1_SRST_MASK		0x0002
+#define INPUT_FORMATTER2_SRST_MASK		0x0004
+#define INPUT_FORMATTER3_SRST_MASK		0x0008
+
+typedef enum {
+	INPUT_SYSTEM0_ID = 0,
+	N_INPUT_SYSTEM_ID
+} input_system_ID_t;
+
+typedef enum {
+	RX0_ID = 0,
+	N_RX_ID
+} rx_ID_t;
+
+typedef enum {
+	MIPI_PORT0_ID = 0,
+	MIPI_PORT1_ID,
+	MIPI_PORT2_ID,
+	N_MIPI_PORT_ID
+} mipi_port_ID_t;
+
+#define	N_RX_CHANNEL_ID		4
+
+/* Generic port enumeration with an internal port type ID */
+typedef enum {
+	CSI_PORT0_ID = 0,
+	CSI_PORT1_ID,
+	CSI_PORT2_ID,
+	TPG_PORT0_ID,
+	PRBS_PORT0_ID,
+	FIFO_PORT0_ID,
+	MEMORY_PORT0_ID,
+	N_INPUT_PORT_ID
+} input_port_ID_t;
+
+typedef enum {
+	CAPTURE_UNIT0_ID = 0,
+	CAPTURE_UNIT1_ID,
+	CAPTURE_UNIT2_ID,
+	ACQUISITION_UNIT0_ID,
+	DMA_UNIT0_ID,
+	CTRL_UNIT0_ID,
+	GPREGS_UNIT0_ID,
+	FIFO_UNIT0_ID,
+	IRQ_UNIT0_ID,
+	N_SUB_SYSTEM_ID
+} sub_system_ID_t;
+
+#define	N_CAPTURE_UNIT_ID		3
+#define	N_ACQUISITION_UNIT_ID	1
+#define	N_CTRL_UNIT_ID			1
+
+enum ia_css_isp_memories {
+	IA_CSS_ISP_PMEM0 = 0,
+	IA_CSS_ISP_DMEM0,
+	IA_CSS_ISP_VMEM0,
+	IA_CSS_ISP_VAMEM0,
+	IA_CSS_ISP_VAMEM1,
+	IA_CSS_ISP_VAMEM2,
+	IA_CSS_ISP_HMEM0,
+	IA_CSS_SP_DMEM0,
+	IA_CSS_DDR,
+	N_IA_CSS_MEMORIES
+};
+#define IA_CSS_NUM_MEMORIES 9
+/* For driver compatability */
+#define N_IA_CSS_ISP_MEMORIES   IA_CSS_NUM_MEMORIES
+#define IA_CSS_NUM_ISP_MEMORIES IA_CSS_NUM_MEMORIES
+
+#endif /* __SYSTEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/timed_ctrl_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/timed_ctrl_global.h
new file mode 100644
index 0000000..bc81bd3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/timed_ctrl_global.h
@@ -0,0 +1,63 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TIMED_CTRL_GLOBAL_H_INCLUDED__
+#define __TIMED_CTRL_GLOBAL_H_INCLUDED__
+
+#define IS_TIMED_CTRL_VERSION_1
+
+#include <timed_controller_defs.h>
+
+/**
+ * Order of the input bits for the timed controller taken from
+ * ISP_CSS_2401 System Architecture Description valid for
+ * 2400, 2401.
+ *
+ * Check for other systems.
+ */
+#define HIVE_TIMED_CTRL_GPIO_PIN_0_BIT_ID                       0
+#define HIVE_TIMED_CTRL_GPIO_PIN_1_BIT_ID                       1
+#define HIVE_TIMED_CTRL_GPIO_PIN_2_BIT_ID                       2
+#define HIVE_TIMED_CTRL_GPIO_PIN_3_BIT_ID                       3
+#define HIVE_TIMED_CTRL_GPIO_PIN_4_BIT_ID                       4
+#define HIVE_TIMED_CTRL_GPIO_PIN_5_BIT_ID                       5
+#define HIVE_TIMED_CTRL_GPIO_PIN_6_BIT_ID                       6
+#define HIVE_TIMED_CTRL_GPIO_PIN_7_BIT_ID                       7
+#define HIVE_TIMED_CTRL_GPIO_PIN_8_BIT_ID                       8
+#define HIVE_TIMED_CTRL_GPIO_PIN_9_BIT_ID                       9
+#define HIVE_TIMED_CTRL_GPIO_PIN_10_BIT_ID                      10
+#define HIVE_TIMED_CTRL_GPIO_PIN_11_BIT_ID                      11
+#define HIVE_TIMED_CTRL_IRQ_SP_BIT_ID                           12
+#define HIVE_TIMED_CTRL_IRQ_ISP_BIT_ID                          13
+#define HIVE_TIMED_CTRL_IRQ_INPUT_SYSTEM_BIT_ID                 14
+#define HIVE_TIMED_CTRL_IRQ_INPUT_SELECTOR_BIT_ID               15
+#define HIVE_TIMED_CTRL_IRQ_IF_BLOCK_BIT_ID                     16
+#define HIVE_TIMED_CTRL_IRQ_GP_TIMER_0_BIT_ID                   17
+#define HIVE_TIMED_CTRL_IRQ_GP_TIMER_1_BIT_ID                   18
+#define HIVE_TIMED_CTRL_CSI_SOL_BIT_ID                          19
+#define HIVE_TIMED_CTRL_CSI_EOL_BIT_ID                          20
+#define HIVE_TIMED_CTRL_CSI_SOF_BIT_ID                          21
+#define HIVE_TIMED_CTRL_CSI_EOF_BIT_ID                          22
+#define HIVE_TIMED_CTRL_IRQ_IS_STREAMING_MONITOR_BIT_ID         23
+
+
+
+#endif /* __TIMED_CTRL_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/vamem_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/vamem_global.h
new file mode 100644
index 0000000..6ece36a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/vamem_global.h
@@ -0,0 +1,41 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VAMEM_GLOBAL_H_INCLUDED__
+#define __VAMEM_GLOBAL_H_INCLUDED__
+
+#include <type_support.h>
+
+#define IS_VAMEM_VERSION_2
+
+/* (log) stepsize of linear interpolation */
+#define VAMEM_INTERP_STEP_LOG2	4
+#define VAMEM_INTERP_STEP		(1<<VAMEM_INTERP_STEP_LOG2)
+/* (physical) size of the tables */
+#define VAMEM_TABLE_UNIT_SIZE	((1<<(ISP_VAMEM_ADDRESS_BITS-VAMEM_INTERP_STEP_LOG2)) + 1)
+/* (logical) size of the tables */
+#define VAMEM_TABLE_UNIT_STEP	((VAMEM_TABLE_UNIT_SIZE-1)<<1)
+/* Number of tables */
+#define VAMEM_TABLE_UNIT_COUNT	(ISP_VAMEM_DEPTH/VAMEM_TABLE_UNIT_STEP)
+
+typedef uint16_t				vamem_data_t;
+
+#endif /* __VAMEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/vmem_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/vmem_global.h
new file mode 100644
index 0000000..f1231f1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system/vmem_global.h
@@ -0,0 +1,30 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VMEM_GLOBAL_H_INCLUDED__
+#define __VMEM_GLOBAL_H_INCLUDED__
+
+#include "isp.h"
+
+#define VMEM_SIZE	ISP_VMEM_DEPTH
+#define VMEM_ELEMBITS	ISP_VMEM_ELEMBITS
+
+#endif /* __VMEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_configs.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_configs.c
new file mode 100644
index 0000000..b4480a0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_configs.c
@@ -0,0 +1,316 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/* Generated code: do not edit or commmit. */
+
+#include "ia_css.h"
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_pipeline.h"
+#include "ia_css_isp_configs.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_iterator(
+	const struct ia_css_binary *binary,
+	const struct ia_css_iterator_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_iterator() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.iterator;
+
+		if (offset >= 0) {
+			ia_css_iterator_config((struct sh_css_isp_iterator_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_iterator() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_copy_output(
+	const struct ia_css_binary *binary,
+	const struct ia_css_copy_output_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_copy_output() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.copy_output;
+
+		if (offset >= 0) {
+			ia_css_copy_output_config((struct sh_css_isp_copy_output_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_copy_output() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_crop(
+	const struct ia_css_binary *binary,
+	const struct ia_css_crop_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_crop() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.crop;
+
+		if (offset >= 0) {
+			ia_css_crop_config((struct sh_css_isp_crop_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_crop() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_fpn(
+	const struct ia_css_binary *binary,
+	const struct ia_css_fpn_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_fpn() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.fpn;
+
+		if (offset >= 0) {
+			ia_css_fpn_config((struct sh_css_isp_fpn_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_fpn() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_dvs(
+	const struct ia_css_binary *binary,
+	const struct ia_css_dvs_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_dvs() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.dvs;
+
+		if (offset >= 0) {
+			ia_css_dvs_config((struct sh_css_isp_dvs_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_dvs() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_qplane(
+	const struct ia_css_binary *binary,
+	const struct ia_css_qplane_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_qplane() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.qplane;
+
+		if (offset >= 0) {
+			ia_css_qplane_config((struct sh_css_isp_qplane_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_qplane() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_output0(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output0_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_output0() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.output0;
+
+		if (offset >= 0) {
+			ia_css_output0_config((struct sh_css_isp_output_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_output0() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_output1(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output1_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_output1() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.output1;
+
+		if (offset >= 0) {
+			ia_css_output1_config((struct sh_css_isp_output_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_output1() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_output(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_output() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.output;
+
+		if (offset >= 0) {
+			ia_css_output_config((struct sh_css_isp_output_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_output() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_raw(
+	const struct ia_css_binary *binary,
+	const struct ia_css_raw_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_raw() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.raw;
+
+		if (offset >= 0) {
+			ia_css_raw_config((struct sh_css_isp_raw_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_raw() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_tnr(
+	const struct ia_css_binary *binary,
+	const struct ia_css_tnr_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_tnr() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.tnr;
+
+		if (offset >= 0) {
+			ia_css_tnr_config((struct sh_css_isp_tnr_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_tnr() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_ref(
+	const struct ia_css_binary *binary,
+	const struct ia_css_ref_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_ref() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.ref;
+
+		if (offset >= 0) {
+			ia_css_ref_config((struct sh_css_isp_ref_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_ref() leave:\n");
+}
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_vf(
+	const struct ia_css_binary *binary,
+	const struct ia_css_vf_configuration *config_dmem)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_vf() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.config)
+			offset = binary->info->mem_offsets.offsets.config->dmem.vf;
+
+		if (offset >= 0) {
+			ia_css_vf_config((struct sh_css_isp_vf_isp_config *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_CONFIG][IA_CSS_ISP_DMEM].address[offset],
+					config_dmem);		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_configure_vf() leave:\n");
+}
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_configs.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_configs.h
new file mode 100644
index 0000000..0517191
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_configs.h
@@ -0,0 +1,179 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifdef IA_CSS_INCLUDE_CONFIGURATIONS
+#include "isp/kernels/crop/crop_1.0/ia_css_crop.host.h"
+#include "isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h"
+#include "isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h"
+#include "isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h"
+#include "isp/kernels/ob/ob_1.0/ia_css_ob.host.h"
+#include "isp/kernels/output/output_1.0/ia_css_output.host.h"
+#include "isp/kernels/qplane/qplane_2/ia_css_qplane.host.h"
+#include "isp/kernels/raw/raw_1.0/ia_css_raw.host.h"
+#include "isp/kernels/ref/ref_1.0/ia_css_ref.host.h"
+#include "isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h"
+#include "isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h"
+#include "isp/kernels/vf/vf_1.0/ia_css_vf.host.h"
+#include "isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.h"
+#endif /* IA_CSS_INCLUDE_CONFIGURATIONS */
+/* Generated code: do not edit or commmit. */
+
+#ifndef _IA_CSS_ISP_CONFIG_H
+#define _IA_CSS_ISP_CONFIG_H
+
+/* Code generated by genparam/gencode.c:gen_param_enum() */
+
+enum ia_css_configuration_ids {
+	IA_CSS_ITERATOR_CONFIG_ID,
+	IA_CSS_COPY_OUTPUT_CONFIG_ID,
+	IA_CSS_CROP_CONFIG_ID,
+	IA_CSS_FPN_CONFIG_ID,
+	IA_CSS_DVS_CONFIG_ID,
+	IA_CSS_QPLANE_CONFIG_ID,
+	IA_CSS_OUTPUT0_CONFIG_ID,
+	IA_CSS_OUTPUT1_CONFIG_ID,
+	IA_CSS_OUTPUT_CONFIG_ID,
+	IA_CSS_RAW_CONFIG_ID,
+	IA_CSS_TNR_CONFIG_ID,
+	IA_CSS_REF_CONFIG_ID,
+	IA_CSS_VF_CONFIG_ID,
+	IA_CSS_NUM_CONFIGURATION_IDS
+};
+
+/* Code generated by genparam/gencode.c:gen_param_offsets() */
+
+struct ia_css_config_memory_offsets {
+	struct {
+		uint16_t iterator;
+		uint16_t copy_output;
+		uint16_t crop;
+		uint16_t fpn;
+		uint16_t dvs;
+		uint16_t qplane;
+		uint16_t output0;
+		uint16_t output1;
+		uint16_t output;
+		uint16_t raw;
+		uint16_t tnr;
+		uint16_t ref;
+		uint16_t vf;
+	} dmem;
+};
+
+#if defined(IA_CSS_INCLUDE_CONFIGURATIONS)
+
+#include "ia_css.h" /* ia_css_stream */
+#include "ia_css_binary.h" /* ia_css_binary */
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_iterator(
+	const struct ia_css_binary *binary,
+	const struct ia_css_iterator_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_copy_output(
+	const struct ia_css_binary *binary,
+	const struct ia_css_copy_output_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_crop(
+	const struct ia_css_binary *binary,
+	const struct ia_css_crop_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_fpn(
+	const struct ia_css_binary *binary,
+	const struct ia_css_fpn_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_dvs(
+	const struct ia_css_binary *binary,
+	const struct ia_css_dvs_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_qplane(
+	const struct ia_css_binary *binary,
+	const struct ia_css_qplane_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_output0(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output0_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_output1(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output1_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_output(
+	const struct ia_css_binary *binary,
+	const struct ia_css_output_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_raw(
+	const struct ia_css_binary *binary,
+	const struct ia_css_raw_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_tnr(
+	const struct ia_css_binary *binary,
+	const struct ia_css_tnr_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_ref(
+	const struct ia_css_binary *binary,
+	const struct ia_css_ref_configuration *config_dmem);
+
+/* Code generated by genparam/genconfig.c:gen_configure_function() */
+
+void
+ia_css_configure_vf(
+	const struct ia_css_binary *binary,
+	const struct ia_css_vf_configuration *config_dmem);
+
+#endif /* IA_CSS_INCLUDE_CONFIGURATION */
+
+#endif /* _IA_CSS_ISP_CONFIG_H */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_params.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_params.c
new file mode 100644
index 0000000..164e2fd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_params.c
@@ -0,0 +1,2084 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#define IA_CSS_INCLUDE_PARAMETERS
+#include "sh_css_params.h"
+#include "isp/kernels/aa/aa_2/ia_css_aa2.host.h"
+#include "isp/kernels/anr/anr_1.0/ia_css_anr.host.h"
+#include "isp/kernels/bh/bh_2/ia_css_bh.host.h"
+#include "isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h"
+#include "isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h"
+#include "isp/kernels/crop/crop_1.0/ia_css_crop.host.h"
+#include "isp/kernels/csc/csc_1.0/ia_css_csc.host.h"
+#include "isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h"
+#include "isp/kernels/ctc/ctc_2/ia_css_ctc2.host.h"
+#include "isp/kernels/de/de_1.0/ia_css_de.host.h"
+#include "isp/kernels/de/de_2/ia_css_de2.host.h"
+#include "isp/kernels/dp/dp_1.0/ia_css_dp.host.h"
+#include "isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h"
+#include "isp/kernels/gc/gc_1.0/ia_css_gc.host.h"
+#include "isp/kernels/gc/gc_2/ia_css_gc2.host.h"
+#include "isp/kernels/macc/macc_1.0/ia_css_macc.host.h"
+#include "isp/kernels/ob/ob_1.0/ia_css_ob.host.h"
+#include "isp/kernels/raw/raw_1.0/ia_css_raw.host.h"
+#include "isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.h"
+#include "isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h"
+#include "isp/kernels/sc/sc_1.0/ia_css_sc.host.h"
+#include "isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h"
+#include "isp/kernels/uds/uds_1.0/ia_css_uds.host.h"
+#include "isp/kernels/wb/wb_1.0/ia_css_wb.host.h"
+#include "isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.h"
+#include "isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h"
+#include "isp/kernels/ynr/ynr_2/ia_css_ynr2.host.h"
+/* Generated code: do not edit or commmit. */
+
+#include "ia_css.h"
+#include "ia_css_pipeline.h"
+#include "ia_css_isp_params.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_aa(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_aa() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.aa;
+
+		if (offset >= 0) {
+			ia_css_aa_encode((struct sh_css_isp_aa_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->aa_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_aa() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_anr(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_anr() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.anr;
+
+		if (offset >= 0) {
+			ia_css_anr_encode((struct sh_css_isp_anr_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->anr_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_anr() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_bh(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_bh() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.bh;
+
+		if (offset >= 0) {
+			ia_css_bh_encode((struct sh_css_isp_bh_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->s3a_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->hmem0.bh;
+
+		if (offset >= 0) {
+			ia_css_bh_hmem_encode((struct sh_css_isp_bh_hmem_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_HMEM0].address[offset],
+					&params->s3a_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_HMEM0] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_bh() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_cnr(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_cnr() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.cnr;
+
+		if (offset >= 0) {
+			ia_css_cnr_encode((struct sh_css_isp_cnr_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->cnr_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_cnr() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_crop(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_crop() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.crop;
+
+		if (offset >= 0) {
+			ia_css_crop_encode((struct sh_css_isp_crop_isp_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->crop_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_crop() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_csc(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_csc() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.csc;
+
+		if (offset >= 0) {
+			ia_css_csc_encode((struct sh_css_isp_csc_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->cc_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_csc() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_dp(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_dp() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.dp;
+
+		if (offset >= 0) {
+			ia_css_dp_encode((struct sh_css_isp_dp_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->dp_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_dp() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_bnr(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_bnr() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.bnr;
+
+		if (offset >= 0) {
+			ia_css_bnr_encode((struct sh_css_isp_bnr_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->nr_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_bnr() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_de(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_de() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.de;
+
+		if (offset >= 0) {
+			ia_css_de_encode((struct sh_css_isp_de_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->de_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_de() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_ecd(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ecd() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.ecd;
+
+		if (offset >= 0) {
+			ia_css_ecd_encode((struct sh_css_isp_ecd_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->ecd_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ecd() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_fpn(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_fpn() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.fpn;
+
+		if (offset >= 0) {
+			ia_css_fpn_encode((struct sh_css_isp_fpn_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->fpn_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_fpn() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_gc(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_gc() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.gc;
+
+		if (offset >= 0) {
+			ia_css_gc_encode((struct sh_css_isp_gc_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->gc_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->vamem1.gc;
+
+		if (offset >= 0) {
+			ia_css_gc_vamem_encode((struct sh_css_isp_gc_vamem_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM1].address[offset],
+					&params->gc_table);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM1] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_gc() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_ce(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ce() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.ce;
+
+		if (offset >= 0) {
+			ia_css_ce_encode((struct sh_css_isp_ce_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->ce_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ce() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_yuv2rgb(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_yuv2rgb() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.yuv2rgb;
+
+		if (offset >= 0) {
+			ia_css_yuv2rgb_encode((struct sh_css_isp_csc_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->yuv2rgb_cc_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_yuv2rgb() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_rgb2yuv(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_rgb2yuv() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.rgb2yuv;
+
+		if (offset >= 0) {
+			ia_css_rgb2yuv_encode((struct sh_css_isp_csc_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->rgb2yuv_cc_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_rgb2yuv() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_r_gamma(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_r_gamma() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->vamem0.r_gamma;
+
+		if (offset >= 0) {
+			ia_css_r_gamma_vamem_encode((struct sh_css_isp_rgb_gamma_vamem_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM0].address[offset],
+					&params->r_gamma_table);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM0] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_r_gamma() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_g_gamma(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_g_gamma() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->vamem1.g_gamma;
+
+		if (offset >= 0) {
+			ia_css_g_gamma_vamem_encode((struct sh_css_isp_rgb_gamma_vamem_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM1].address[offset],
+					&params->g_gamma_table);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM1] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_g_gamma() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_b_gamma(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_b_gamma() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->vamem2.b_gamma;
+
+		if (offset >= 0) {
+			ia_css_b_gamma_vamem_encode((struct sh_css_isp_rgb_gamma_vamem_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM2].address[offset],
+					&params->b_gamma_table);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM2] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_b_gamma() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_uds(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_uds() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.uds;
+
+		if (offset >= 0) {
+			ia_css_uds_encode((struct sh_css_sp_uds_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->uds_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_uds() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_raa(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_raa() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.raa;
+
+		if (offset >= 0) {
+			ia_css_raa_encode((struct sh_css_isp_aa_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->raa_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_raa() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_s3a(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_s3a() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.s3a;
+
+		if (offset >= 0) {
+			ia_css_s3a_encode((struct sh_css_isp_s3a_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->s3a_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_s3a() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_ob(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ob() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.ob;
+
+		if (offset >= 0) {
+			ia_css_ob_encode((struct sh_css_isp_ob_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->ob_config, &params->stream_configs.ob);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->vmem.ob;
+
+		if (offset >= 0) {
+			ia_css_ob_vmem_encode((struct sh_css_isp_ob_vmem_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VMEM].address[offset],
+					&params->ob_config, &params->stream_configs.ob);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ob() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_sc(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_sc() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.sc;
+
+		if (offset >= 0) {
+			ia_css_sc_encode((struct sh_css_isp_sc_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->sc_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_sc() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_raw(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_raw() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.raw;
+
+		if (offset >= 0) {
+			ia_css_raw_encode((struct sh_css_isp_raw_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->raw_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_raw() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_tnr(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_tnr() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.tnr;
+
+		if (offset >= 0) {
+			ia_css_tnr_encode((struct sh_css_isp_tnr_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->tnr_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_tnr() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_macc(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_macc() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.macc;
+
+		if (offset >= 0) {
+			ia_css_macc_encode((struct sh_css_isp_macc_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->macc_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_macc() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_wb(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_wb() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.wb;
+
+		if (offset >= 0) {
+			ia_css_wb_encode((struct sh_css_isp_wb_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->wb_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_wb() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_nr(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_nr() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.nr;
+
+		if (offset >= 0) {
+			ia_css_nr_encode((struct sh_css_isp_ynr_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->nr_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_nr() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_yee(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_yee() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.yee;
+
+		if (offset >= 0) {
+			ia_css_yee_encode((struct sh_css_isp_yee_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->yee_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_yee() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_ynr(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ynr() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.ynr;
+
+		if (offset >= 0) {
+			ia_css_ynr_encode((struct sh_css_isp_yee2_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->ynr_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ynr() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_fc(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_fc() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.fc;
+
+		if (offset >= 0) {
+			ia_css_fc_encode((struct sh_css_isp_fc_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->fc_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_fc() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_ctc(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ctc() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.ctc;
+
+		if (offset >= 0) {
+			ia_css_ctc_encode((struct sh_css_isp_ctc_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->ctc_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->vamem0.ctc;
+
+		if (offset >= 0) {
+			ia_css_ctc_vamem_encode((struct sh_css_isp_ctc_vamem_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM0].address[offset],
+					&params->ctc_table);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM0] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_ctc() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_xnr_table(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_xnr_table() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->vamem1.xnr_table;
+
+		if (offset >= 0) {
+			ia_css_xnr_table_vamem_encode((struct sh_css_isp_xnr_vamem_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_VAMEM1].address[offset],
+					&params->xnr_table);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_VAMEM1] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_xnr_table() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_process_function() */
+
+static void
+ia_css_process_xnr(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_xnr() enter:\n");
+
+	{
+		short offset = stage->binary->info->mem_offsets.offsets.param->dmem.xnr;
+
+		if (offset >= 0) {
+			ia_css_xnr_encode((struct sh_css_isp_xnr_params *)
+					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
+					&params->xnr_config);
+			params->isp_params_changed = true;
+			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_xnr() leave:\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_param_process_table() */
+
+void (* ia_css_kernel_process_param[IA_CSS_NUM_PARAMETER_IDS])(
+			unsigned pipe_id,
+			const struct ia_css_pipeline_stage *stage,
+			struct ia_css_isp_parameters *params) = {
+	ia_css_process_aa,
+	ia_css_process_anr,
+	ia_css_process_bh,
+	ia_css_process_cnr,
+	ia_css_process_crop,
+	ia_css_process_csc,
+	ia_css_process_dp,
+	ia_css_process_bnr,
+	ia_css_process_de,
+	ia_css_process_ecd,
+	ia_css_process_fpn,
+	ia_css_process_gc,
+	ia_css_process_ce,
+	ia_css_process_yuv2rgb,
+	ia_css_process_rgb2yuv,
+	ia_css_process_r_gamma,
+	ia_css_process_g_gamma,
+	ia_css_process_b_gamma,
+	ia_css_process_uds,
+	ia_css_process_raa,
+	ia_css_process_s3a,
+	ia_css_process_ob,
+	ia_css_process_sc,
+	ia_css_process_raw,
+	ia_css_process_tnr,
+	ia_css_process_macc,
+	ia_css_process_wb,
+	ia_css_process_nr,
+	ia_css_process_yee,
+	ia_css_process_ynr,
+	ia_css_process_fc,
+	ia_css_process_ctc,
+	ia_css_process_xnr_table,
+	ia_css_process_xnr,
+};
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_dp_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_dp_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_dp_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->dp_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_dp_config() leave\n");
+	ia_css_dp_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_dp_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_dp_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_dp_config() enter:\n");
+	ia_css_dp_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->dp_config = *config;
+	params->config_changed[IA_CSS_DP_ID] = true;
+	params->config_changed[IA_CSS_DP_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_dp_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_wb_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_wb_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_wb_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->wb_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_wb_config() leave\n");
+	ia_css_wb_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_wb_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_wb_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_wb_config() enter:\n");
+	ia_css_wb_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->wb_config = *config;
+	params->config_changed[IA_CSS_WB_ID] = true;
+	params->config_changed[IA_CSS_WB_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_wb_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_tnr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_tnr_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_tnr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->tnr_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_tnr_config() leave\n");
+	ia_css_tnr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_tnr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_tnr_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_tnr_config() enter:\n");
+	ia_css_tnr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->tnr_config = *config;
+	params->config_changed[IA_CSS_TNR_ID] = true;
+	params->config_changed[IA_CSS_TNR_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_tnr_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_ob_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ob_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_ob_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ob_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_ob_config() leave\n");
+	ia_css_ob_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_ob_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ob_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_ob_config() enter:\n");
+	ia_css_ob_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->ob_config = *config;
+	params->config_changed[IA_CSS_OB_ID] = true;
+	params->config_changed[IA_CSS_OB_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_ob_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_de_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_de_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_de_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->de_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_de_config() leave\n");
+	ia_css_de_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_de_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_de_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_de_config() enter:\n");
+	ia_css_de_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->de_config = *config;
+	params->config_changed[IA_CSS_DE_ID] = true;
+	params->config_changed[IA_CSS_DE_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_de_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_anr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_anr_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_anr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->anr_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_anr_config() leave\n");
+	ia_css_anr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_anr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_anr_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_anr_config() enter:\n");
+	ia_css_anr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->anr_config = *config;
+	params->config_changed[IA_CSS_ANR_ID] = true;
+	params->config_changed[IA_CSS_ANR_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_anr_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_ce_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ce_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_ce_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ce_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_ce_config() leave\n");
+	ia_css_ce_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_ce_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ce_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_ce_config() enter:\n");
+	ia_css_ce_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->ce_config = *config;
+	params->config_changed[IA_CSS_CE_ID] = true;
+	params->config_changed[IA_CSS_CE_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_ce_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_ecd_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ecd_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_ecd_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ecd_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_ecd_config() leave\n");
+	ia_css_ecd_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_ecd_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ecd_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_ecd_config() enter:\n");
+	ia_css_ecd_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->ecd_config = *config;
+	params->config_changed[IA_CSS_ECD_ID] = true;
+	params->config_changed[IA_CSS_ECD_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_ecd_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_ynr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ynr_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_ynr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ynr_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_ynr_config() leave\n");
+	ia_css_ynr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_ynr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ynr_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_ynr_config() enter:\n");
+	ia_css_ynr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->ynr_config = *config;
+	params->config_changed[IA_CSS_YNR_ID] = true;
+	params->config_changed[IA_CSS_YNR_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_ynr_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_fc_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_fc_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_fc_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->fc_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_fc_config() leave\n");
+	ia_css_fc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_fc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_fc_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_fc_config() enter:\n");
+	ia_css_fc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->fc_config = *config;
+	params->config_changed[IA_CSS_FC_ID] = true;
+	params->config_changed[IA_CSS_FC_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_fc_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_cnr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_cnr_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_cnr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->cnr_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_cnr_config() leave\n");
+	ia_css_cnr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_cnr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_cnr_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_cnr_config() enter:\n");
+	ia_css_cnr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->cnr_config = *config;
+	params->config_changed[IA_CSS_CNR_ID] = true;
+	params->config_changed[IA_CSS_CNR_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_cnr_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_macc_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_macc_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_macc_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->macc_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_macc_config() leave\n");
+	ia_css_macc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_macc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_macc_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_macc_config() enter:\n");
+	ia_css_macc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->macc_config = *config;
+	params->config_changed[IA_CSS_MACC_ID] = true;
+	params->config_changed[IA_CSS_MACC_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_macc_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_ctc_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ctc_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_ctc_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ctc_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_ctc_config() leave\n");
+	ia_css_ctc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_ctc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ctc_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_ctc_config() enter:\n");
+	ia_css_ctc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->ctc_config = *config;
+	params->config_changed[IA_CSS_CTC_ID] = true;
+	params->config_changed[IA_CSS_CTC_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_ctc_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_aa_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_aa_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_aa_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->aa_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_aa_config() leave\n");
+	ia_css_aa_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_aa_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_aa_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_aa_config() enter:\n");
+	ia_css_aa_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->aa_config = *config;
+	params->config_changed[IA_CSS_AA_ID] = true;
+	params->config_changed[IA_CSS_AA_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_aa_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_yuv2rgb_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_cc_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_yuv2rgb_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->yuv2rgb_cc_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_yuv2rgb_config() leave\n");
+	ia_css_yuv2rgb_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_yuv2rgb_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_cc_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_yuv2rgb_config() enter:\n");
+	ia_css_yuv2rgb_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->yuv2rgb_cc_config = *config;
+	params->config_changed[IA_CSS_YUV2RGB_ID] = true;
+	params->config_changed[IA_CSS_YUV2RGB_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_yuv2rgb_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_rgb2yuv_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_cc_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_rgb2yuv_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->rgb2yuv_cc_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_rgb2yuv_config() leave\n");
+	ia_css_rgb2yuv_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_rgb2yuv_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_cc_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_rgb2yuv_config() enter:\n");
+	ia_css_rgb2yuv_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->rgb2yuv_cc_config = *config;
+	params->config_changed[IA_CSS_RGB2YUV_ID] = true;
+	params->config_changed[IA_CSS_RGB2YUV_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_rgb2yuv_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_csc_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_cc_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_csc_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->cc_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_csc_config() leave\n");
+	ia_css_csc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_csc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_cc_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_csc_config() enter:\n");
+	ia_css_csc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->cc_config = *config;
+	params->config_changed[IA_CSS_CSC_ID] = true;
+	params->config_changed[IA_CSS_CSC_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_csc_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_nr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_nr_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_nr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->nr_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_nr_config() leave\n");
+	ia_css_nr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_nr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_nr_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_nr_config() enter:\n");
+	ia_css_nr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->nr_config = *config;
+	params->config_changed[IA_CSS_BNR_ID] = true;
+	params->config_changed[IA_CSS_NR_ID] = true;
+	params->config_changed[IA_CSS_NR_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_nr_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_gc_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_gc_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_gc_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->gc_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_gc_config() leave\n");
+	ia_css_gc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_gc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_gc_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_gc_config() enter:\n");
+	ia_css_gc_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->gc_config = *config;
+	params->config_changed[IA_CSS_GC_ID] = true;
+	params->config_changed[IA_CSS_GC_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_gc_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_r_gamma_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_rgb_gamma_table *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_r_gamma_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->r_gamma_table;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_r_gamma_config() leave\n");
+	ia_css_r_gamma_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_r_gamma_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_rgb_gamma_table *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_r_gamma_config() enter:\n");
+	ia_css_r_gamma_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->r_gamma_table = *config;
+	params->config_changed[IA_CSS_R_GAMMA_ID] = true;
+	params->config_changed[IA_CSS_R_GAMMA_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_r_gamma_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_g_gamma_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_rgb_gamma_table *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_g_gamma_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->g_gamma_table;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_g_gamma_config() leave\n");
+	ia_css_g_gamma_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_g_gamma_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_rgb_gamma_table *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_g_gamma_config() enter:\n");
+	ia_css_g_gamma_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->g_gamma_table = *config;
+	params->config_changed[IA_CSS_G_GAMMA_ID] = true;
+	params->config_changed[IA_CSS_G_GAMMA_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_g_gamma_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_b_gamma_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_rgb_gamma_table *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_b_gamma_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->b_gamma_table;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_b_gamma_config() leave\n");
+	ia_css_b_gamma_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_b_gamma_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_rgb_gamma_table *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_b_gamma_config() enter:\n");
+	ia_css_b_gamma_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->b_gamma_table = *config;
+	params->config_changed[IA_CSS_B_GAMMA_ID] = true;
+	params->config_changed[IA_CSS_B_GAMMA_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_b_gamma_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_xnr_table_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_xnr_table *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_xnr_table_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->xnr_table;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_xnr_table_config() leave\n");
+	ia_css_xnr_table_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_xnr_table_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_xnr_table *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_xnr_table_config() enter:\n");
+	ia_css_xnr_table_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->xnr_table = *config;
+	params->config_changed[IA_CSS_XNR_TABLE_ID] = true;
+	params->config_changed[IA_CSS_XNR_TABLE_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_xnr_table_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_xnr_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_xnr_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_xnr_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->xnr_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_xnr_config() leave\n");
+	ia_css_xnr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_xnr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_xnr_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_xnr_config() enter:\n");
+	ia_css_xnr_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->xnr_config = *config;
+	params->config_changed[IA_CSS_XNR_ID] = true;
+	params->config_changed[IA_CSS_XNR_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_xnr_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_get_function() */
+
+static void
+ia_css_get_s3a_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_3a_config *config){
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_s3a_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->s3a_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_get_s3a_config() leave\n");
+	ia_css_s3a_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_s3a_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_3a_config *config)
+{
+	if (config == NULL)
+		return;
+
+	assert(params != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_set_s3a_config() enter:\n");
+	ia_css_s3a_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+	params->s3a_config = *config;
+	params->config_changed[IA_CSS_BH_ID] = true;
+	params->config_changed[IA_CSS_S3A_ID] = true;
+	params->config_changed[IA_CSS_S3A_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_set_s3a_config() leave: "
+		"return_void\n");
+}
+
+/* Code generated by genparam/gencode.c:gen_global_access_function() */
+
+void
+ia_css_get_configs(struct ia_css_isp_parameters *params,
+		const struct ia_css_isp_config *config)
+{
+	ia_css_get_dp_config(params, config->dp_config);
+	ia_css_get_wb_config(params, config->wb_config);
+	ia_css_get_tnr_config(params, config->tnr_config);
+	ia_css_get_ob_config(params, config->ob_config);
+	ia_css_get_de_config(params, config->de_config);
+	ia_css_get_anr_config(params, config->anr_config);
+	ia_css_get_ce_config(params, config->ce_config);
+	ia_css_get_ecd_config(params, config->ecd_config);
+	ia_css_get_ynr_config(params, config->ynr_config);
+	ia_css_get_fc_config(params, config->fc_config);
+	ia_css_get_cnr_config(params, config->cnr_config);
+	ia_css_get_macc_config(params, config->macc_config);
+	ia_css_get_ctc_config(params, config->ctc_config);
+	ia_css_get_aa_config(params, config->aa_config);
+	ia_css_get_yuv2rgb_config(params, config->yuv2rgb_cc_config);
+	ia_css_get_rgb2yuv_config(params, config->rgb2yuv_cc_config);
+	ia_css_get_csc_config(params, config->cc_config);
+	ia_css_get_nr_config(params, config->nr_config);
+	ia_css_get_gc_config(params, config->gc_config);
+	ia_css_get_r_gamma_config(params, config->r_gamma_table);
+	ia_css_get_g_gamma_config(params, config->g_gamma_table);
+	ia_css_get_b_gamma_config(params, config->b_gamma_table);
+	ia_css_get_xnr_table_config(params, config->xnr_table);
+	ia_css_get_xnr_config(params, config->xnr_config);
+	ia_css_get_s3a_config(params, config->s3a_config);
+}
+
+/* Code generated by genparam/gencode.c:gen_global_access_function() */
+
+void
+ia_css_set_configs(struct ia_css_isp_parameters *params,
+		const struct ia_css_isp_config *config)
+{
+	ia_css_set_dp_config(params, config->dp_config);
+	ia_css_set_wb_config(params, config->wb_config);
+	ia_css_set_tnr_config(params, config->tnr_config);
+	ia_css_set_ob_config(params, config->ob_config);
+	ia_css_set_de_config(params, config->de_config);
+	ia_css_set_anr_config(params, config->anr_config);
+	ia_css_set_ce_config(params, config->ce_config);
+	ia_css_set_ecd_config(params, config->ecd_config);
+	ia_css_set_ynr_config(params, config->ynr_config);
+	ia_css_set_fc_config(params, config->fc_config);
+	ia_css_set_cnr_config(params, config->cnr_config);
+	ia_css_set_macc_config(params, config->macc_config);
+	ia_css_set_ctc_config(params, config->ctc_config);
+	ia_css_set_aa_config(params, config->aa_config);
+	ia_css_set_yuv2rgb_config(params, config->yuv2rgb_cc_config);
+	ia_css_set_rgb2yuv_config(params, config->rgb2yuv_cc_config);
+	ia_css_set_csc_config(params, config->cc_config);
+	ia_css_set_nr_config(params, config->nr_config);
+	ia_css_set_gc_config(params, config->gc_config);
+	ia_css_set_r_gamma_config(params, config->r_gamma_table);
+	ia_css_set_g_gamma_config(params, config->g_gamma_table);
+	ia_css_set_b_gamma_config(params, config->b_gamma_table);
+	ia_css_set_xnr_table_config(params, config->xnr_table);
+	ia_css_set_xnr_config(params, config->xnr_config);
+	ia_css_set_s3a_config(params, config->s3a_config);
+}
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_params.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_params.h
new file mode 100644
index 0000000..a1246b9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_params.h
@@ -0,0 +1,300 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/* Generated code: do not edit or commmit. */
+
+#ifndef _IA_CSS_ISP_PARAM_H
+#define _IA_CSS_ISP_PARAM_H
+
+/* Code generated by genparam/gencode.c:gen_param_enum() */
+
+enum ia_css_parameter_ids {
+	IA_CSS_AA_ID,
+	IA_CSS_ANR_ID,
+	IA_CSS_BH_ID,
+	IA_CSS_CNR_ID,
+	IA_CSS_CROP_ID,
+	IA_CSS_CSC_ID,
+	IA_CSS_DP_ID,
+	IA_CSS_BNR_ID,
+	IA_CSS_DE_ID,
+	IA_CSS_ECD_ID,
+	IA_CSS_FPN_ID,
+	IA_CSS_GC_ID,
+	IA_CSS_CE_ID,
+	IA_CSS_YUV2RGB_ID,
+	IA_CSS_RGB2YUV_ID,
+	IA_CSS_R_GAMMA_ID,
+	IA_CSS_G_GAMMA_ID,
+	IA_CSS_B_GAMMA_ID,
+	IA_CSS_UDS_ID,
+	IA_CSS_RAA_ID,
+	IA_CSS_S3A_ID,
+	IA_CSS_OB_ID,
+	IA_CSS_SC_ID,
+	IA_CSS_RAW_ID,
+	IA_CSS_TNR_ID,
+	IA_CSS_MACC_ID,
+	IA_CSS_WB_ID,
+	IA_CSS_NR_ID,
+	IA_CSS_YEE_ID,
+	IA_CSS_YNR_ID,
+	IA_CSS_FC_ID,
+	IA_CSS_CTC_ID,
+	IA_CSS_XNR_TABLE_ID,
+	IA_CSS_XNR_ID,
+	IA_CSS_NUM_PARAMETER_IDS
+};
+
+/* Code generated by genparam/gencode.c:gen_param_offsets() */
+
+struct ia_css_memory_offsets {
+	struct {
+		uint16_t aa;
+		uint16_t anr;
+		uint16_t bh;
+		uint16_t cnr;
+		uint16_t crop;
+		uint16_t csc;
+		uint16_t dp;
+		uint16_t bnr;
+		uint16_t de;
+		uint16_t ecd;
+		uint16_t fpn;
+		uint16_t gc;
+		uint16_t ce;
+		uint16_t yuv2rgb;
+		uint16_t rgb2yuv;
+		uint16_t uds;
+		uint16_t raa;
+		uint16_t s3a;
+		uint16_t ob;
+		uint16_t sc;
+		uint16_t raw;
+		uint16_t tnr;
+		uint16_t macc;
+		uint16_t wb;
+		uint16_t nr;
+		uint16_t yee;
+		uint16_t ynr;
+		uint16_t fc;
+		uint16_t ctc;
+		uint16_t xnr;
+	} dmem;
+	struct {
+		uint16_t bh;
+	} hmem0;
+	struct {
+		uint16_t gc;
+		uint16_t g_gamma;
+		uint16_t xnr_table;
+	} vamem1;
+	struct {
+		uint16_t r_gamma;
+		uint16_t ctc;
+	} vamem0;
+	struct {
+		uint16_t b_gamma;
+	} vamem2;
+	struct {
+		uint16_t ob;
+	} vmem;
+};
+
+#if defined(IA_CSS_INCLUDE_PARAMETERS)
+
+#include "ia_css.h" /* ia_css_stream */
+#include "ia_css_binary.h" /* ia_css_binary */
+
+/* Code generated by genparam/gencode.c:gen_param_process_table() */
+
+struct ia_css_pipeline_stage; /* forward declaration */
+
+extern void (* ia_css_kernel_process_param[IA_CSS_NUM_PARAMETER_IDS])(
+			unsigned pipe_id,
+			const struct ia_css_pipeline_stage *stage,
+			struct ia_css_isp_parameters *params);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_dp_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_dp_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_wb_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_wb_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_tnr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_tnr_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_ob_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ob_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_de_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_de_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_anr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_anr_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_ce_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ce_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_ecd_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ecd_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_ynr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ynr_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_fc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_fc_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_cnr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_cnr_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_macc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_macc_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_ctc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ctc_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_aa_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_aa_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_yuv2rgb_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_cc_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_rgb2yuv_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_cc_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_csc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_cc_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_nr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_nr_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_gc_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_gc_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_r_gamma_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_rgb_gamma_table *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_g_gamma_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_rgb_gamma_table *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_b_gamma_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_rgb_gamma_table *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_xnr_table_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_xnr_table *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_xnr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_xnr_config *config);
+
+/* Code generated by genparam/gencode.c:gen_set_function() */
+
+void
+ia_css_set_s3a_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_3a_config *config);
+
+/* Code generated by genparam/gencode.c:gen_global_access_function() */
+
+void
+ia_css_get_configs(struct ia_css_isp_parameters *params,
+		const struct ia_css_isp_config *config)
+;
+/* Code generated by genparam/gencode.c:gen_global_access_function() */
+
+void
+ia_css_set_configs(struct ia_css_isp_parameters *params,
+		const struct ia_css_isp_config *config)
+;
+#endif /* IA_CSS_INCLUDE_PARAMETER */
+
+#endif /* _IA_CSS_ISP_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_states.c b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_states.c
new file mode 100644
index 0000000..dbe4c7e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_states.c
@@ -0,0 +1,161 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/* Generated code: do not edit or commmit. */
+
+#include "ia_css.h"
+#include "ia_css_pipeline.h"
+#include "ia_css_isp_states.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+
+/* Code generated by genparam/genstate.c:gen_init_function() */
+
+static void
+ia_css_initialize_cnr_state(const struct ia_css_binary *binary)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_cnr_state() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.state)
+			offset = binary->info->mem_offsets.offsets.state->vmem.cnr;
+
+		if (offset >= 0) {
+			ia_css_init_cnr_state();
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_cnr_state() leave:\n");
+}
+
+/* Code generated by genparam/genstate.c:gen_init_function() */
+
+static void
+ia_css_initialize_cnr2_state(const struct ia_css_binary *binary)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_cnr2_state() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.state)
+			offset = binary->info->mem_offsets.offsets.state->vmem.cnr2;
+
+		if (offset >= 0) {
+			ia_css_init_cnr2_state();
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_cnr2_state() leave:\n");
+}
+
+/* Code generated by genparam/genstate.c:gen_init_function() */
+
+static void
+ia_css_initialize_dp_state(const struct ia_css_binary *binary)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_dp_state() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.state)
+			offset = binary->info->mem_offsets.offsets.state->vmem.dp;
+
+		if (offset >= 0) {
+			ia_css_init_dp_state();
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_dp_state() leave:\n");
+}
+
+/* Code generated by genparam/genstate.c:gen_init_function() */
+
+static void
+ia_css_initialize_de_state(const struct ia_css_binary *binary)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_de_state() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.state)
+			offset = binary->info->mem_offsets.offsets.state->vmem.de;
+
+		if (offset >= 0) {
+			ia_css_init_de_state();
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_de_state() leave:\n");
+}
+
+/* Code generated by genparam/genstate.c:gen_init_function() */
+
+static void
+ia_css_initialize_tnr_state(const struct ia_css_binary *binary)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_tnr_state() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.state)
+			offset = binary->info->mem_offsets.offsets.state->dmem.tnr;
+
+		if (offset >= 0) {
+			ia_css_init_tnr_state((struct sh_css_isp_tnr_dmem_state *)
+					&binary->mem_params.params[IA_CSS_PARAM_CLASS_STATE][IA_CSS_ISP_DMEM].address[offset]);
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_tnr_state() leave:\n");
+}
+
+/* Code generated by genparam/genstate.c:gen_init_function() */
+
+static void
+ia_css_initialize_ynr_state(const struct ia_css_binary *binary)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_ynr_state() enter:\n");
+
+	{
+		short offset = -1;
+		if (binary->info->mem_offsets.offsets.state)
+			offset = binary->info->mem_offsets.offsets.state->vmem.ynr;
+
+		if (offset >= 0) {
+			ia_css_init_ynr_state();
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_ynr_state() leave:\n");
+}
+
+/* Code generated by genparam/genstate.c:gen_state_init_table() */
+
+void (* ia_css_kernel_init_state[IA_CSS_NUM_STATE_IDS])(const struct ia_css_binary *binary) = {
+	ia_css_initialize_cnr_state,
+	ia_css_initialize_cnr2_state,
+	ia_css_initialize_dp_state,
+	ia_css_initialize_de_state,
+	ia_css_initialize_tnr_state,
+	ia_css_initialize_ynr_state,
+};
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_states.h b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_states.h
new file mode 100644
index 0000000..ae67bef
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_2400_system_generated/ia_css_isp_states.h
@@ -0,0 +1,73 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#define IA_CSS_INCLUDE_STATES
+#include "ia_css_memory_access.h"
+#include "isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.h"
+#include "isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h"
+#include "isp/kernels/de/de_1.0/ia_css_de.host.h"
+#include "isp/kernels/dp/dp_1.0/ia_css_dp.host.h"
+#include "isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h"
+#include "isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h"
+/* Generated code: do not edit or commmit. */
+
+#ifndef _IA_CSS_ISP_STATE_H
+#define _IA_CSS_ISP_STATE_H
+
+/* Code generated by genparam/gencode.c:gen_param_enum() */
+
+enum ia_css_state_ids {
+	IA_CSS_CNR_STATE_ID,
+	IA_CSS_CNR2_STATE_ID,
+	IA_CSS_DP_STATE_ID,
+	IA_CSS_DE_STATE_ID,
+	IA_CSS_TNR_STATE_ID,
+	IA_CSS_YNR_STATE_ID,
+	IA_CSS_NUM_STATE_IDS
+};
+
+/* Code generated by genparam/gencode.c:gen_param_offsets() */
+
+struct ia_css_state_memory_offsets {
+	struct {
+		uint16_t cnr;
+		uint16_t cnr2;
+		uint16_t dp;
+		uint16_t de;
+		uint16_t ynr;
+	} vmem;
+	struct {
+		uint16_t tnr;
+	} dmem;
+};
+
+#if defined(IA_CSS_INCLUDE_STATES)
+
+#include "ia_css.h" /* ia_css_stream */
+#include "ia_css_binary.h" /* ia_css_binary */
+
+/* Code generated by genparam/genstate.c:gen_state_init_table() */
+
+extern void (* ia_css_kernel_init_state[IA_CSS_NUM_STATE_IDS])(const struct ia_css_binary *binary);
+
+#endif /* IA_CSS_INCLUDE_STATE */
+
+#endif /* _IA_CSS_ISP_STATE_H */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/assert_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/assert_support.h
new file mode 100644
index 0000000..4593802
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/assert_support.h
@@ -0,0 +1,109 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ASSERT_SUPPORT_H_INCLUDED__
+#define __ASSERT_SUPPORT_H_INCLUDED__
+
+#ifdef __KLOCWORK__
+/* Klocwork does not see that assert will lead to abortion
+ * as there is no good way to tell this to KW and the code
+ * should not depend on assert to function (actually the assert
+ * could be disabled in a release build) it was decided to
+ * disable the assert for KW scans (by defining NDEBUG)
+ * see also: http://www.klocwork.com/products/documentation/current/Tuning_C/C%2B%2B_analysis#Assertions
+ */
+#define NDEBUG
+#endif /* __KLOCWORK__ */
+
+#ifdef NDEBUG
+
+#define assert(cnd) ((void)0)
+
+#else
+
+#if defined(_MSC_VER)
+#include <wdm.h>
+#define assert(cnd) ASSERT(cnd)
+
+#define OP___assert(cnd) assert(cnd)
+#define OP_std_break()	OP___assert(0)
+#define OP___BUG() OP___assert(0)
+
+#elif defined(__HIVECC)
+
+/*
+ * Enabling assert on cells has too many side effects, it should
+ * by default be limited to the unsched CSIM mode, or to only
+ * controller type processors. Presently there are not controls
+ * in place for that
+ */
+#if defined(HRT_SCHED)
+#define OP___assert(cnd) ((void)0)
+#else
+#define OP___assert(cnd) OP___csim_assert(cnd)
+#endif
+
+#define OP___BUG() OP___csim_assert(0)
+
+#elif defined(__KERNEL__) /* a.o. Android builds */
+#include <linux/bug.h>
+
+/*Workaround: removed ia_css_debug_dtrace
+ *to avoid circular dependency of ia_css_debug.h
+ *need to find a better solution
+ */
+
+#define assert(cnd)							\
+	do {								\
+		if (!(cnd)) {						\
+			BUG();						\
+		}							\
+	} while (0)
+
+#define OP___assert(cnd) assert(cnd)
+#define OP_std_break()	OP___assert(0)
+#define OP___BUG() OP___assert(0)
+
+#elif defined(__FIST__)
+
+#include "assert.h"
+#define OP___assert(cnd) assert(cnd)
+
+#elif defined(__GNUC__)
+
+#include "assert.h"
+#define OP___assert(cnd) assert(cnd)
+#define OP___BUG() OP___assert(0)
+#if !defined(__ISP) && !defined(__SP)
+/*
+ * For SP and ISP, SDK provides the definition of OP_std_break
+ * We need it only for host
+ */
+#define OP_std_break()	OP___assert(0)
+#endif
+
+#else /* default is for unknown environments */
+#define assert(cnd) ((void)0)
+#endif
+
+#endif /* NDEBUG */
+
+#endif /* __ASSERT_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/bbb_cfg.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/bbb_cfg.h
new file mode 100644
index 0000000..386a386a4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/bbb_cfg.h
@@ -0,0 +1,49 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __HOST_BBB_CFG_H_INCLUDED__
+#define __HOST_BBB_CFG_H_INCLUDED__
+
+//#define USE2400
+#define USE2600
+
+
+/* consider to use same naming as cfg.dat from the SDK */
+/* N --> number of lanes per vector
+ * B --> bit depth
+ * M --> lanes per slice
+ * W --> bit depth multiplier (1w = single pre 2w = double
+  */
+
+
+#if defined(USE2400)
+#include "isp2400_config.h"
+
+#elif defined(USE2600)
+
+#include "isp2600_config.h"
+
+#else
+#error "bbb_cfg.h: unsupported system. Specify one of {USE2400, USE2600}"
+#endif
+
+
+#endif //__HOST_BBB_CFG_H_INCLUDED__
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/bitop_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/bitop_support.h
new file mode 100644
index 0000000..6ed4429
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/bitop_support.h
@@ -0,0 +1,32 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __BITOP_SUPPORT_H_INCLUDED__
+#define __BITOP_SUPPORT_H_INCLUDED__
+
+#define bitop_setbit(a, b) ((a) |= (1UL << (b)))
+
+#define bitop_getbit(a, b) (((a) & (1UL << (b))) != 0)
+
+#define bitop_clearbit(a, b) ((a) &= ~(1UL << (b)))
+
+#endif /* __BITOP_SUPPORT_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/csi_rx.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/csi_rx.h
new file mode 100644
index 0000000..fe755d0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/csi_rx.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __CSI_RX_H_INCLUDED__
+#define __CSI_RX_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ * - system and cell agnostic interfaces, constants and identifiers
+ * - public:  system agnostic, cell specific interfaces
+ * - private: system dependent, cell specific interfaces &
+ *   inline implementations
+ * - global:  system specific constants and identifiers
+ * - local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "csi_rx_local.h"
+
+#ifndef __INLINE_CSI_RX__
+#define STORAGE_CLASS_CSI_RX_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_CSI_RX_C
+#include "csi_rx_public.h"
+#else  /* __INLINE_CSI_RX__ */
+#define STORAGE_CLASS_CSI_RX_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_CSI_RX_C STORAGE_CLASS_INLINE
+#include "csi_rx_private.h"
+#endif /* __INLINE_CSI_RX__ */
+
+#endif /* __CSI_RX_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/debug.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/debug.h
new file mode 100644
index 0000000..f2d655b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/debug.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DEBUG_H_INCLUDED__
+#define __DEBUG_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the DMA device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "debug_local.h"
+
+#ifndef __INLINE_DEBUG__
+#define STORAGE_CLASS_DEBUG_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_DEBUG_C
+#include "debug_public.h"
+#else  /* __INLINE_DEBUG__ */
+#define STORAGE_CLASS_DEBUG_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_DEBUG_C STORAGE_CLASS_INLINE
+#include "debug_private.h"
+#endif /* __INLINE_DEBUG__ */
+
+#endif /* __DEBUG_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/device_access/device_access.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/device_access/device_access.h
new file mode 100644
index 0000000..5921dad
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/device_access/device_access.h
@@ -0,0 +1,185 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DEVICE_ACCESS_H_INCLUDED__
+#define __DEVICE_ACCESS_H_INCLUDED__
+
+/*!
+ * \brief
+ * Define the public interface for physical system
+ * access functions to SRAM and registers. Access
+ * types are limited to those defined in <stdint.h>
+ * All accesses are aligned
+ *
+ * The address representation is private to the system
+ * and represented as/stored in "hrt_address".
+ *
+ * The system global address can differ by an offset;
+ * The device base address. This offset must be added
+ * by the implementation of the access function
+ *
+ * "store" is a transfer to the device
+ * "load" is a transfer from the device
+ */
+
+#include <type_support.h>
+
+/*
+ * User provided file that defines the system address types:
+ *	- hrt_address	a type that can hold the (sub)system address range
+ */
+#include "system_types.h"
+/*
+ * We cannot assume that the global system address size is the size of
+ * a pointer because a (say) 64-bit host can be simulated in a 32-bit
+ * environment. Only if the host environment is modelled as on the target
+ * we could use a pointer. Even then, prototyping may need to be done
+ * before the target environment is available. AS we cannot wait for that
+ * we are stuck with integer addresses
+ */
+
+/*typedef	char *sys_address;*/
+typedef	hrt_address		sys_address;
+
+/*! Set the (sub)system base address
+
+ \param	base_addr[in]		The offset on which the (sub)system is located
+							in the global address map
+
+ \return none,
+ */
+extern void device_set_base_address(
+	const sys_address		base_addr);
+
+
+/*! Get the (sub)system base address
+
+ \return base_address,
+ */
+extern sys_address device_get_base_address(void);
+
+/*! Read an 8-bit value from a device register or memory in the device
+
+ \param	addr[in]			Local address
+
+ \return device[addr]
+ */
+extern uint8_t ia_css_device_load_uint8(
+	const hrt_address		addr);
+
+/*! Read a 16-bit value from a device register or memory in the device
+
+ \param	addr[in]			Local address
+
+ \return device[addr]
+ */
+extern uint16_t ia_css_device_load_uint16(
+	const hrt_address		addr);
+
+/*! Read a 32-bit value from a device register or memory in the device
+
+ \param	addr[in]			Local address
+
+ \return device[addr]
+ */
+extern uint32_t ia_css_device_load_uint32(
+	const hrt_address		addr);
+
+/*! Read a 64-bit value from a device register or memory in the device
+
+ \param	addr[in]			Local address
+
+ \return device[addr]
+ */
+extern uint64_t ia_css_device_load_uint64(
+	const hrt_address		addr);
+
+/*! Write an 8-bit value to a device register or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[in]			value
+
+ \return none, device[addr] = value
+ */
+extern void ia_css_device_store_uint8(
+	const hrt_address		addr,
+	const uint8_t			data);
+
+/*! Write a 16-bit value to a device register or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[in]			value
+
+ \return none, device[addr] = value
+ */
+extern void ia_css_device_store_uint16(
+	const hrt_address		addr,
+	const uint16_t			data);
+
+/*! Write a 32-bit value to a device register or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[in]			value
+
+ \return none, device[addr] = value
+ */
+extern void ia_css_device_store_uint32(
+	const hrt_address		addr,
+	const uint32_t			data);
+
+/*! Write a 64-bit value to a device register or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[in]			value
+
+ \return none, device[addr] = value
+ */
+extern void ia_css_device_store_uint64(
+	const hrt_address		addr,
+	const uint64_t			data);
+
+/*! Read an array of bytes from device registers or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[out]			pointer to the destination array
+ \param	size[in]			number of bytes to read
+
+ \return none
+ */
+extern void ia_css_device_load(
+	const hrt_address		addr,
+	void					*data,
+	const size_t			size);
+
+/*! Write an array of bytes to device registers or memory in the device
+
+ \param	addr[in]			Local address
+ \param	data[in]			pointer to the source array
+ \param	size[in]			number of bytes to write
+
+ \return none
+ */
+extern void ia_css_device_store(
+	const hrt_address		addr,
+	const void				*data,
+	const size_t			size);
+
+#endif /* __DEVICE_ACCESS_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/dma.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/dma.h
new file mode 100644
index 0000000..726f233
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/dma.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DMA_H_INCLUDED__
+#define __DMA_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the DMA device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "dma_local.h"
+
+#ifndef __INLINE_DMA__
+#define STORAGE_CLASS_DMA_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_DMA_C
+#include "dma_public.h"
+#else  /* __INLINE_DMA__ */
+#define STORAGE_CLASS_DMA_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_DMA_C STORAGE_CLASS_INLINE
+#include "dma_private.h"
+#endif /* __INLINE_DMA__ */
+
+#endif /* __DMA_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/error_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/error_support.h
new file mode 100644
index 0000000..4755ecb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/error_support.h
@@ -0,0 +1,68 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ERROR_SUPPORT_H_INCLUDED__
+#define __ERROR_SUPPORT_H_INCLUDED__
+
+#if defined(_MSC_VER)
+#include <errno.h>
+/*
+ * Put here everything _MSC_VER specific not covered in
+ * "errno.h"
+ */
+#define EINVAL  22
+#define ENODATA 61
+#define ENOTSUP 252
+#define ENOBUFS 233
+
+
+#elif defined(__HIVECC)
+#include <errno.h>
+/*
+ * Put here everything __HIVECC specific not covered in
+ * "errno.h"
+ */
+
+#elif defined(__KERNEL__)
+#include <linux/errno.h>
+/*
+ * Put here everything __KERNEL__ specific not covered in
+ * "errno.h"
+ */
+#define ENOTSUP 252
+
+#elif defined(__GNUC__)
+#include <errno.h>
+/*
+ * Put here everything __GNUC__ specific not covered in
+ * "errno.h"
+ */
+
+#else /* default is for the FIST environment */
+#include <errno.h>
+/*
+ * Put here everything FIST specific not covered in
+ * "errno.h"
+ */
+
+#endif
+
+#endif /* __ERROR_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/event_fifo.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/event_fifo.h
new file mode 100644
index 0000000..43f69b8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/event_fifo.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __EVENT_FIFO_H
+#define __EVENT_FIFO_H
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the IRQ device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "event_fifo_local.h"
+
+#ifndef __INLINE_EVENT__
+#define STORAGE_CLASS_EVENT_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_EVENT_C
+#include "event_fifo_public.h"
+#else  /* __INLINE_EVENT__ */
+#define STORAGE_CLASS_EVENT_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_EVENT_C STORAGE_CLASS_INLINE
+#include "event_fifo_private.h"
+#endif /* __INLINE_EVENT__ */
+
+#endif /* __EVENT_FIFO_H */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/fifo_monitor.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/fifo_monitor.h
new file mode 100644
index 0000000..e9556c0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/fifo_monitor.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __FIFO_MONITOR_H_INCLUDED__
+#define __FIFO_MONITOR_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "fifo_monitor_local.h"
+
+#ifndef __INLINE_FIFO_MONITOR__
+#define STORAGE_CLASS_FIFO_MONITOR_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_FIFO_MONITOR_C
+#include "fifo_monitor_public.h"
+#else  /* __INLINE_FIFO_MONITOR__ */
+#define STORAGE_CLASS_FIFO_MONITOR_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_FIFO_MONITOR_C STORAGE_CLASS_INLINE
+#include "fifo_monitor_private.h"
+#endif /* __INLINE_FIFO_MONITOR__ */
+
+#endif /* __FIFO_MONITOR_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/gdc_device.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/gdc_device.h
new file mode 100644
index 0000000..7cf9f0ab
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/gdc_device.h
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GDC_DEVICE_H_INCLUDED__
+#define __GDC_DEVICE_H_INCLUDED__
+
+/* The file gdc.h already exists */
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the GDC device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "gdc_local.h"
+
+#ifndef __INLINE_GDC__
+#define STORAGE_CLASS_GDC_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_GDC_C
+#include "gdc_public.h"
+#else  /* __INLINE_GDC__ */
+#define STORAGE_CLASS_GDC_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_GDC_C STORAGE_CLASS_INLINE
+#include "gdc_private.h"
+#endif /* __INLINE_GDC__ */
+
+#endif /* __GDC_DEVICE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/gp_device.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/gp_device.h
new file mode 100644
index 0000000..1b25679
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/gp_device.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GP_DEVICE_H_INCLUDED__
+#define __GP_DEVICE_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "gp_device_local.h"
+
+#ifndef __INLINE_GP_DEVICE__
+#define STORAGE_CLASS_GP_DEVICE_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_GP_DEVICE_C
+#include "gp_device_public.h"
+#else  /* __INLINE_GP_DEVICE__ */
+#define STORAGE_CLASS_GP_DEVICE_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_GP_DEVICE_C STORAGE_CLASS_INLINE
+#include "gp_device_private.h"
+#endif /* __INLINE_GP_DEVICE__ */
+
+#endif /* __GP_DEVICE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/gpio.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/gpio.h
new file mode 100644
index 0000000..c215f28
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/gpio.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GPIO_H_INCLUDED__
+#define __GPIO_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "gpio_local.h"
+
+#ifndef __INLINE_GPIO__
+#define STORAGE_CLASS_GPIO_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_GPIO_C
+#include "gpio_public.h"
+#else  /* __INLINE_GPIO__ */
+#define STORAGE_CLASS_GPIO_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_GPIO_C STORAGE_CLASS_INLINE
+#include "gpio_private.h"
+#endif /* __INLINE_GPIO__ */
+
+#endif /* __GPIO_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/hmem.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/hmem.h
new file mode 100644
index 0000000..ede3cc6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/hmem.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __HMEM_H_INCLUDED__
+#define __HMEM_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the HMEM device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "hmem_local.h"
+
+#ifndef __INLINE_HMEM__
+#define STORAGE_CLASS_HMEM_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_HMEM_C
+#include "hmem_public.h"
+#else  /* __INLINE_HMEM__ */
+#define STORAGE_CLASS_HMEM_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_HMEM_C STORAGE_CLASS_INLINE
+#include "hmem_private.h"
+#endif /* __INLINE_HMEM__ */
+
+#endif /* __HMEM_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/csi_rx_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/csi_rx_public.h
new file mode 100644
index 0000000..eb7fc8b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/csi_rx_public.h
@@ -0,0 +1,142 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __CSI_RX_PUBLIC_H_INCLUDED__
+#define __CSI_RX_PUBLIC_H_INCLUDED__
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+/*****************************************************
+ *
+ * Native command interface (NCI).
+ *
+ *****************************************************/
+/**
+ * @brief Get the csi rx frontend state.
+ * Get the state of the csi rx frontend regiester-set.
+ *
+ * @param[in]	id	The global unique ID of the csi rx fe controller.
+ * @param[out]	state	Point to the register-state.
+ */
+STORAGE_CLASS_CSI_RX_H void csi_rx_fe_ctrl_get_state(
+		const csi_rx_frontend_ID_t ID,
+		csi_rx_fe_ctrl_state_t *state);
+/**
+ * @brief Dump the csi rx frontend state.
+ * Dump the state of the csi rx frontend regiester-set.
+ *
+ * @param[in]	id	The global unique ID of the csi rx fe controller.
+ * @param[in]	state	Point to the register-state.
+ */
+STORAGE_CLASS_CSI_RX_H void csi_rx_fe_ctrl_dump_state(
+		const csi_rx_frontend_ID_t ID,
+		csi_rx_fe_ctrl_state_t *state);
+/**
+ * @brief Get the state of the csi rx fe dlane.
+ * Get the state of the register set per dlane process.
+ *
+ * @param[in]	id			The global unique ID of the input-buffer controller.
+ * @param[in]	lane		The lane ID.
+ * @param[out]	state		Point to the dlane state.
+ */
+STORAGE_CLASS_CSI_RX_H void csi_rx_fe_ctrl_get_dlane_state(
+		const csi_rx_frontend_ID_t ID,
+		const uint32_t lane,
+		csi_rx_fe_ctrl_lane_t *dlane_state);
+/**
+ * @brief Get the csi rx backend state.
+ * Get the state of the csi rx backend regiester-set.
+ *
+ * @param[in]	id	The global unique ID of the csi rx be controller.
+ * @param[out]	state	Point to the register-state.
+ */
+STORAGE_CLASS_CSI_RX_H void csi_rx_be_ctrl_get_state(
+		const csi_rx_backend_ID_t ID,
+		csi_rx_be_ctrl_state_t *state);
+/**
+ * @brief Dump the csi rx backend state.
+ * Dump the state of the csi rx backend regiester-set.
+ *
+ * @param[in]	id	The global unique ID of the csi rx be controller.
+ * @param[in]	state	Point to the register-state.
+ */
+STORAGE_CLASS_CSI_RX_H void csi_rx_be_ctrl_dump_state(
+		const csi_rx_backend_ID_t ID,
+		csi_rx_be_ctrl_state_t *state);
+/** end of NCI */
+
+/*****************************************************
+ *
+ * Device level interface (DLI).
+ *
+ *****************************************************/
+/**
+ * @brief Load the register value.
+ * Load the value of the register of the csi rx fe.
+ *
+ * @param[in]	ID	The global unique ID for the ibuf-controller instance.
+ * @param[in]	reg	The offet address of the register.
+ *
+ * @return the value of the register.
+ */
+STORAGE_CLASS_CSI_RX_H hrt_data csi_rx_fe_ctrl_reg_load(
+	const csi_rx_frontend_ID_t ID,
+	const hrt_address reg);
+/**
+ * @brief Store a value to the register.
+ * Store a value to the registe of the csi rx fe.
+ *
+ * @param[in]	ID		The global unique ID for the ibuf-controller instance.
+ * @param[in]	reg		The offet address of the register.
+ * @param[in]	value	The value to be stored.
+ *
+ */
+STORAGE_CLASS_CSI_RX_H void csi_rx_fe_ctrl_reg_store(
+	const csi_rx_frontend_ID_t ID,
+	const hrt_address reg,
+	const hrt_data value);
+/**
+ * @brief Load the register value.
+ * Load the value of the register of the csirx be.
+ *
+ * @param[in]	ID	The global unique ID for the ibuf-controller instance.
+ * @param[in]	reg	The offet address of the register.
+ *
+ * @return the value of the register.
+ */
+STORAGE_CLASS_CSI_RX_H hrt_data csi_rx_be_ctrl_reg_load(
+	const csi_rx_backend_ID_t ID,
+	const hrt_address reg);
+/**
+ * @brief Store a value to the register.
+ * Store a value to the registe of the csi rx be.
+ *
+ * @param[in]	ID		The global unique ID for the ibuf-controller instance.
+ * @param[in]	reg		The offet address of the register.
+ * @param[in]	value	The value to be stored.
+ *
+ */
+STORAGE_CLASS_CSI_RX_H void csi_rx_be_ctrl_reg_store(
+	const csi_rx_backend_ID_t ID,
+	const hrt_address reg,
+	const hrt_data value);
+/** end of DLI */
+#endif /* USE_INPUT_SYSTEM_VERSION_2401 */
+#endif /* __CSI_RX_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/debug_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/debug_public.h
new file mode 100644
index 0000000..864fa92
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/debug_public.h
@@ -0,0 +1,106 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DEBUG_PUBLIC_H_INCLUDED__
+#define __DEBUG_PUBLIC_H_INCLUDED__
+
+#include <type_support.h>
+#include "system_types.h"
+
+/*! brief
+ *
+ * Simple queuing trace buffer for debug data
+ * instantiatable in SP DMEM
+ *
+ * The buffer has a remote and and a local store
+ * which contain duplicate data (when in sync).
+ * The buffers are automatically synched when the
+ * user dequeues, or manualy using the synch function
+ *
+ * An alternative (storage efficient) implementation
+ * could manage the buffers to contain unique data
+ *
+ * The buffer empty status is computed from local
+ * state which does not reflect the presence of data
+ * in the remote buffer (unless the alternative
+ * implementation is followed)
+ */
+
+typedef struct debug_data_s		debug_data_t;
+typedef struct debug_data_ddr_s	debug_data_ddr_t;
+
+extern debug_data_t				*debug_data_ptr;
+extern hrt_address				debug_buffer_address;
+extern hrt_vaddress				debug_buffer_ddr_address;
+
+/*! Check the empty state of the local debug data buffer
+
+ \return isEmpty(buffer)
+ */
+STORAGE_CLASS_DEBUG_H bool is_debug_buffer_empty(void);
+
+/*! Dequeue a token from the debug data buffer
+
+ \return isEmpty(buffer)?0:buffer[head]
+ */
+STORAGE_CLASS_DEBUG_H hrt_data debug_dequeue(void);
+
+/*! Synchronise the remote buffer to the local buffer
+
+ \return none
+ */
+STORAGE_CLASS_DEBUG_H void debug_synch_queue(void);
+
+/*! Synchronise the remote buffer to the local buffer
+
+ \return none
+ */
+STORAGE_CLASS_DEBUG_H void debug_synch_queue_isp(void);
+
+
+/*! Synchronise the remote buffer to the local buffer
+
+ \return none
+ */
+STORAGE_CLASS_DEBUG_H void debug_synch_queue_ddr(void);
+
+/*! Set the offset/address of the (remote) debug buffer
+
+ \return none
+ */
+extern void debug_buffer_init(
+	const hrt_address		addr);
+
+/*! Set the offset/address of the (remote) debug buffer
+
+ \return none
+ */
+extern void debug_buffer_ddr_init(
+	const hrt_vaddress		addr);
+
+/*! Set the (remote) operating mode of the debug buffer
+
+ \return none
+ */
+extern void debug_buffer_setmode(
+	const debug_buf_mode_t	mode);
+
+#endif /* __DEBUG_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/dma_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/dma_public.h
new file mode 100644
index 0000000..c7e4a3f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/dma_public.h
@@ -0,0 +1,65 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DMA_PUBLIC_H_INCLUDED__
+#define __DMA_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+typedef struct dma_state_s		dma_state_t;
+
+/*! Read the control registers of DMA[ID]
+
+ \param	ID[in]				DMA identifier
+ \param	state[out]			input formatter state structure
+
+ \return none, state = DMA[ID].state
+ */
+extern void dma_get_state(
+	const dma_ID_t		ID,
+	dma_state_t			*state);
+
+/*! Write to a control register of DMA[ID]
+
+ \param	ID[in]				DMA identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, DMA[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_DMA_H void dma_reg_store(
+	const dma_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+/*! Read from a control register of DMA[ID]
+
+ \param	ID[in]				DMA identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return DMA[ID].ctrl[reg]
+ */
+STORAGE_CLASS_DMA_H hrt_data dma_reg_load(
+	const dma_ID_t		ID,
+	const unsigned int	reg);
+
+#endif /* __DMA_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/event_fifo_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/event_fifo_public.h
new file mode 100644
index 0000000..0b5e342
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/event_fifo_public.h
@@ -0,0 +1,86 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __EVENT_FIFO_PUBLIC_H
+#define __EVENT_FIFO_PUBLIC_H
+
+#include <type_support.h>
+#include "system_types.h"
+
+/*! Blocking read from an event source EVENT[ID]
+
+ \param	ID[in]				EVENT identifier
+
+ \return none, dequeue(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H void event_wait_for(
+	const event_ID_t		ID);
+
+/*! Conditional blocking wait for an event source EVENT[ID]
+
+ \param	ID[in]				EVENT identifier
+ \param	cnd[in]				predicate
+
+ \return none, if(cnd) dequeue(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H void cnd_event_wait_for(
+	const event_ID_t		ID,
+	const bool				cnd);
+
+/*! Blocking read from an event source EVENT[ID]
+
+ \param	ID[in]				EVENT identifier
+
+ \return dequeue(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H hrt_data event_receive_token(
+	const event_ID_t		ID);
+
+/*! Blocking write to an event sink EVENT[ID]
+
+ \param	ID[in]				EVENT identifier
+ \param	token[in]			token to be written on the event
+
+ \return none, enqueue(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H void event_send_token(
+	const event_ID_t		ID,
+	const hrt_data			token);
+
+/*! Query an event source EVENT[ID]
+
+ \param	ID[in]				EVENT identifier
+
+ \return !isempty(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H bool is_event_pending(
+	const event_ID_t		ID);
+
+/*! Query an event sink EVENT[ID]
+
+ \param	ID[in]				EVENT identifier
+
+ \return !isfull(event_queue[ID])
+ */
+STORAGE_CLASS_EVENT_H bool can_event_send_token(
+	const event_ID_t		ID);
+
+#endif /* __EVENT_FIFO_PUBLIC_H */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/fifo_monitor_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/fifo_monitor_public.h
new file mode 100644
index 0000000..49ca988
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/fifo_monitor_public.h
@@ -0,0 +1,117 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __FIFO_MONITOR_PUBLIC_H_INCLUDED__
+#define __FIFO_MONITOR_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+typedef struct fifo_channel_state_s		fifo_channel_state_t;
+typedef struct fifo_switch_state_s		fifo_switch_state_t;
+typedef struct fifo_monitor_state_s		fifo_monitor_state_t;
+
+/*! Set a fifo switch multiplex
+
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	switch_id[in]		fifo switch identifier
+ \param	sel[in]				fifo switch selector
+
+ \return none, fifo_switch[switch_id].sel = sel
+ */
+STORAGE_CLASS_FIFO_MONITOR_H void fifo_switch_set(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id,
+	const hrt_data				sel);
+
+/*! Get a fifo switch multiplex
+
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	switch_id[in]		fifo switch identifier
+
+ \return fifo_switch[switch_id].sel
+ */
+STORAGE_CLASS_FIFO_MONITOR_H hrt_data fifo_switch_get(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id);
+
+/*! Read the state of FIFO_MONITOR[ID]
+
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	state[out]			fifo monitor state structure
+
+ \return none, state = FIFO_MONITOR[ID].state
+ */
+extern void fifo_monitor_get_state(
+	const fifo_monitor_ID_t		ID,
+	fifo_monitor_state_t		*state);
+
+/*! Read the state of a fifo channel
+
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	channel_id[in]		fifo channel identifier
+ \param	state[out]			fifo channel state structure
+
+ \return none, state = fifo_channel[channel_id].state
+ */
+extern void fifo_channel_get_state(
+	const fifo_monitor_ID_t		ID,
+	const fifo_channel_t		channel_id,
+	fifo_channel_state_t		*state);
+
+/*! Read the state of a fifo switch
+
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	switch_id[in]		fifo switch identifier
+ \param	state[out]			fifo switch state structure
+
+ \return none, state = fifo_switch[switch_id].state
+ */
+extern void fifo_switch_get_state(
+	const fifo_monitor_ID_t		ID,
+	const fifo_switch_t			switch_id,
+	fifo_switch_state_t			*state);
+
+/*! Write to a control register of FIFO_MONITOR[ID]
+
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, FIFO_MONITOR[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_FIFO_MONITOR_H void fifo_monitor_reg_store(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg,
+	const hrt_data				value);
+
+/*! Read from a control register of FIFO_MONITOR[ID]
+
+ \param	ID[in]				FIFO_MONITOR identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return FIFO_MONITOR[ID].ctrl[reg]
+ */
+STORAGE_CLASS_FIFO_MONITOR_H hrt_data fifo_monitor_reg_load(
+	const fifo_monitor_ID_t		ID,
+	const unsigned int			reg);
+
+#endif /* __FIFO_MONITOR_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gdc_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gdc_public.h
new file mode 100644
index 0000000..61e2df7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gdc_public.h
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GDC_PUBLIC_H_INCLUDED__
+#define __GDC_PUBLIC_H_INCLUDED__
+
+/*! Write the bicubic interpolation table of GDC[ID]
+
+ \param	ID[in]				GDC identifier
+ \param data[in]			The data matrix to be written
+
+ \pre
+	- data must point to a matrix[4][HRT_GDC_N]
+
+ \implementation dependent
+	- The value of "HRT_GDC_N" is device specific
+	- The LUT should not be partially written
+	- The LUT format is a quadri-phase interpolation
+	  table. The layout is device specific
+	- The range of the values data[n][m] is device
+	  specific
+
+ \return none, GDC[ID].lut[0...3][0...HRT_GDC_N-1] = data
+ */
+STORAGE_CLASS_EXTERN void gdc_lut_store(
+	const gdc_ID_t		ID,
+	const int			data[4][HRT_GDC_N]);
+
+/*! Return the integer representation of 1.0 of GDC[ID]
+
+ \param	ID[in]				GDC identifier
+
+ \return unity
+ */
+STORAGE_CLASS_EXTERN int gdc_get_unity(
+	const gdc_ID_t		ID);
+
+#endif /* __GDC_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gp_device_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gp_device_public.h
new file mode 100644
index 0000000..797643de
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gp_device_public.h
@@ -0,0 +1,65 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GP_DEVICE_PUBLIC_H_INCLUDED__
+#define __GP_DEVICE_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+typedef struct gp_device_state_s		gp_device_state_t;
+
+/*! Read the state of GP_DEVICE[ID]
+
+ \param	ID[in]				GP_DEVICE identifier
+ \param	state[out]			gp device state structure
+
+ \return none, state = GP_DEVICE[ID].state
+ */
+extern void gp_device_get_state(
+	const gp_device_ID_t		ID,
+	gp_device_state_t			*state);
+
+/*! Write to a control register of GP_DEVICE[ID]
+
+ \param	ID[in]				GP_DEVICE identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return none, GP_DEVICE[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_GP_DEVICE_H void gp_device_reg_store(
+	const gp_device_ID_t	ID,
+	const unsigned int		reg_addr,
+	const hrt_data			value);
+
+/*! Read from a control register of GP_DEVICE[ID]
+
+ \param	ID[in]				GP_DEVICE identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return GP_DEVICE[ID].ctrl[reg]
+ */
+STORAGE_CLASS_GP_DEVICE_H hrt_data gp_device_reg_load(
+	const gp_device_ID_t	ID,
+	const hrt_address	reg_addr);
+
+#endif /* __GP_DEVICE_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gpio_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gpio_public.h
new file mode 100644
index 0000000..8d2ff1f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/gpio_public.h
@@ -0,0 +1,52 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GPIO_PUBLIC_H_INCLUDED__
+#define __GPIO_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+/*! Write to a control register of GPIO[ID]
+
+ \param	ID[in]				GPIO identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return none, GPIO[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_GPIO_H void gpio_reg_store(
+	const gpio_ID_t	ID,
+	const unsigned int		reg_addr,
+	const hrt_data			value);
+
+/*! Read from a control register of GPIO[ID]
+
+ \param	ID[in]				GPIO identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return GPIO[ID].ctrl[reg]
+ */
+STORAGE_CLASS_GPIO_H hrt_data gpio_reg_load(
+	const gpio_ID_t	ID,
+	const unsigned int		reg_addr);
+
+#endif /* __GPIO_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/hmem_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/hmem_public.h
new file mode 100644
index 0000000..082fafe
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/hmem_public.h
@@ -0,0 +1,39 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __HMEM_PUBLIC_H_INCLUDED__
+#define __HMEM_PUBLIC_H_INCLUDED__
+
+#include <stddef.h>		/* size_t */
+
+/*! Return the size of HMEM[ID]
+
+ \param	ID[in]				HMEM identifier
+
+ \Note: The size is the byte size of the area it occupies
+		in the address map. I.e. disregarding internal structure
+
+ \return sizeof(HMEM[ID])
+ */
+STORAGE_CLASS_HMEM_H size_t sizeof_hmem(
+	const hmem_ID_t		ID);
+
+#endif /* __HMEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ibuf_ctrl_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ibuf_ctrl_public.h
new file mode 100644
index 0000000..e6430fc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ibuf_ctrl_public.h
@@ -0,0 +1,100 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IBUF_CTRL_PUBLIC_H_INCLUDED__
+#define __IBUF_CTRL_PUBLIC_H_INCLUDED__
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+/*****************************************************
+ *
+ * Native command interface (NCI).
+ *
+ *****************************************************/
+/**
+ * @brief Get the ibuf-controller state.
+ * Get the state of the ibuf-controller regiester-set.
+ *
+ * @param[in]	id		The global unique ID of the input-buffer controller.
+ * @param[out]	state	Point to the register-state.
+ */
+STORAGE_CLASS_IBUF_CTRL_H void ibuf_ctrl_get_state(
+		const ibuf_ctrl_ID_t ID,
+		ibuf_ctrl_state_t *state);
+
+/**
+ * @brief Get the state of the ibuf-controller process.
+ * Get the state of the register set per buf-controller process.
+ *
+ * @param[in]	id			The global unique ID of the input-buffer controller.
+ * @param[in]	proc_id		The process ID.
+ * @param[out]	state		Point to the process state.
+ */
+STORAGE_CLASS_IBUF_CTRL_H void ibuf_ctrl_get_proc_state(
+		const ibuf_ctrl_ID_t ID,
+		const uint32_t proc_id,
+		ibuf_ctrl_proc_state_t *state);
+/**
+ * @brief Dump the ibuf-controller state.
+ * Dump the state of the ibuf-controller regiester-set.
+ *
+ * @param[in]	id		The global unique ID of the input-buffer controller.
+ * @param[in]	state		Pointer to the register-state.
+ */
+STORAGE_CLASS_IBUF_CTRL_H void ibuf_ctrl_dump_state(
+		const ibuf_ctrl_ID_t ID,
+		ibuf_ctrl_state_t *state);
+/** end of NCI */
+
+/*****************************************************
+ *
+ * Device level interface (DLI).
+ *
+ *****************************************************/
+/**
+ * @brief Load the register value.
+ * Load the value of the register of the ibuf-controller.
+ *
+ * @param[in]	ID	The global unique ID for the ibuf-controller instance.
+ * @param[in]	reg	The offet address of the register.
+ *
+ * @return the value of the register.
+ */
+STORAGE_CLASS_IBUF_CTRL_H hrt_data ibuf_ctrl_reg_load(
+	const ibuf_ctrl_ID_t ID,
+	const hrt_address reg);
+
+/**
+ * @brief Store a value to the register.
+ * Store a value to the registe of the ibuf-controller.
+ *
+ * @param[in]	ID		The global unique ID for the ibuf-controller instance.
+ * @param[in]	reg		The offet address of the register.
+ * @param[in]	value	The value to be stored.
+ *
+ */
+STORAGE_CLASS_IBUF_CTRL_H void ibuf_ctrl_reg_store(
+	const ibuf_ctrl_ID_t ID,
+	const hrt_address reg,
+	const hrt_data value);
+/** end of DLI */
+
+#endif /* USE_INPUT_SYSTEM_VERSION_2401 */
+#endif /* __IBUF_CTRL_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_formatter_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_formatter_public.h
new file mode 100644
index 0000000..6ca0d27
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_formatter_public.h
@@ -0,0 +1,122 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __INPUT_FORMATTER_PUBLIC_H_INCLUDED__
+#define __INPUT_FORMATTER_PUBLIC_H_INCLUDED__
+
+#include <type_support.h>
+#include "system_types.h"
+
+/*! Reset INPUT_FORMATTER[ID]
+
+ \param	ID[in]				INPUT_FORMATTER identifier
+
+ \return none, reset(INPUT_FORMATTER[ID])
+ */
+extern void input_formatter_rst(
+	const input_formatter_ID_t		ID);
+
+/*! Set the blocking mode of INPUT_FORMATTER[ID]
+
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	enable[in]			blocking enable flag
+
+ \use
+	- In HW, the capture unit will deliver an infinite stream of frames,
+	  the input formatter will synchronise on the first SOF. In simulation
+	  there are only a fixed number of frames, presented only once. By
+	  enabling blocking the inputformatter will wait on the first presented
+	  frame, thus avoiding race in the simulation setup.
+
+ \return none, INPUT_FORMATTER[ID].blocking_mode = enable
+ */
+extern void input_formatter_set_fifo_blocking_mode(
+	const input_formatter_ID_t		ID,
+	const bool						enable);
+
+/*! Return the data alignment of INPUT_FORMATTER[ID]
+
+ \param	ID[in]				INPUT_FORMATTER identifier
+
+ \return alignment(INPUT_FORMATTER[ID].data)
+ */
+extern unsigned int input_formatter_get_alignment(
+	const input_formatter_ID_t		ID);
+
+/*! Read the source switch state into INPUT_FORMATTER[ID]
+
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	state[out]			input formatter switch state structure
+
+ \return none, state = INPUT_FORMATTER[ID].switch_state
+ */
+extern void input_formatter_get_switch_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_switch_state_t	*state);
+
+/*! Read the control registers of INPUT_FORMATTER[ID]
+
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	state[out]			input formatter state structure
+
+ \return none, state = INPUT_FORMATTER[ID].state
+ */
+extern void input_formatter_get_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_state_t			*state);
+
+/*! Read the control registers of bin copy INPUT_FORMATTER[ID]
+
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	state[out]			input formatter state structure
+
+ \return none, state = INPUT_FORMATTER[ID].state
+ */
+extern void input_formatter_bin_get_state(
+	const input_formatter_ID_t		ID,
+	input_formatter_bin_state_t		*state);
+
+/*! Write to a control register of INPUT_FORMATTER[ID]
+
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return none, INPUT_FORMATTER[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_INPUT_FORMATTER_H void input_formatter_reg_store(
+	const input_formatter_ID_t	ID,
+	const hrt_address		reg_addr,
+	const hrt_data				value);
+
+/*! Read from a control register of INPUT_FORMATTER[ID]
+
+ \param	ID[in]				INPUT_FORMATTER identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return INPUT_FORMATTER[ID].ctrl[reg]
+ */
+STORAGE_CLASS_INPUT_FORMATTER_H hrt_data input_formatter_reg_load(
+	const input_formatter_ID_t	ID,
+	const unsigned int			reg_addr);
+
+#endif /* __INPUT_FORMATTER_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_system_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_system_public.h
new file mode 100644
index 0000000..0b9ae70
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/input_system_public.h
@@ -0,0 +1,383 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __INPUT_SYSTEM_PUBLIC_H_INCLUDED__
+#define __INPUT_SYSTEM_PUBLIC_H_INCLUDED__
+
+#include <type_support.h>
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+#include "isys_public.h"
+#else
+
+typedef struct input_system_state_s		input_system_state_t;
+typedef struct receiver_state_s			receiver_state_t;
+
+/*! Read the state of INPUT_SYSTEM[ID]
+
+ \param	ID[in]				INPUT_SYSTEM identifier
+ \param	state[out]			input system state structure
+
+ \return none, state = INPUT_SYSTEM[ID].state
+ */
+extern void input_system_get_state(
+	const input_system_ID_t		ID,
+	input_system_state_t		*state);
+
+/*! Read the state of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	state[out]			receiver state structure
+
+ \return none, state = RECEIVER[ID].state
+ */
+extern void receiver_get_state(
+	const rx_ID_t				ID,
+	receiver_state_t			*state);
+
+/*! Flag whether a MIPI format is YUV420
+
+ \param	mipi_format[in]		MIPI format
+
+ \return mipi_format == YUV420
+ */
+extern bool is_mipi_format_yuv420(
+	const mipi_format_t			mipi_format);
+
+/*! Set compression parameters for cfg[cfg_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	cfg_ID[in]			Configuration identifier
+ \param	comp[in]			Compression method
+ \param	pred[in]			Predictor method
+
+ \NOTE: the storage of compression configuration is
+        implementation specific. The config can be
+        carried either on MIPI ports or on MIPI channels
+
+ \return none, RECEIVER[ID].cfg[cfg_ID] = {comp, pred}
+ */
+extern void receiver_set_compression(
+	const rx_ID_t				ID,
+	const unsigned int			cfg_ID,
+	const mipi_compressor_t		comp,
+	const mipi_predictor_t		pred);
+
+/*! Enable PORT[port_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+ \param	cnd[in]				irq predicate
+
+ \return None, enable(RECEIVER[ID].PORT[port_ID])
+ */
+extern void receiver_port_enable(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const bool					cnd);
+
+/*! Flag if PORT[port_ID] of RECEIVER[ID] is enabled
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+
+ \return enable(RECEIVER[ID].PORT[port_ID]) == true
+ */
+extern bool is_receiver_port_enabled(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID);
+
+/*! Enable the IRQ channels of PORT[port_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+ \param	irq_info[in]		irq channels
+
+ \return None, enable(RECEIVER[ID].PORT[port_ID].irq_info)
+ */
+extern void receiver_irq_enable(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const rx_irq_info_t			irq_info);
+
+/*! Return the IRQ status of PORT[port_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+
+ \return RECEIVER[ID].PORT[port_ID].irq_info
+ */
+extern rx_irq_info_t receiver_get_irq_info(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID);
+
+/*! Clear the IRQ status of PORT[port_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+ \param	irq_info[in]		irq status
+
+ \return None, clear(RECEIVER[ID].PORT[port_ID].irq_info)
+ */
+extern void receiver_irq_clear(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t			port_ID,
+	const rx_irq_info_t			irq_info);
+
+/*! Write to a control register of INPUT_SYSTEM[ID]
+
+ \param	ID[in]				INPUT_SYSTEM identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, INPUT_SYSTEM[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H void input_system_reg_store(
+	const input_system_ID_t			ID,
+	const hrt_address			reg,
+	const hrt_data				value);
+
+/*! Read from a control register of INPUT_SYSTEM[ID]
+
+ \param	ID[in]				INPUT_SYSTEM identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return INPUT_SYSTEM[ID].ctrl[reg]
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data input_system_reg_load(
+	const input_system_ID_t			ID,
+	const hrt_address			reg);
+
+/*! Write to a control register of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, RECEIVER[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H void receiver_reg_store(
+	const rx_ID_t				ID,
+	const hrt_address			reg,
+	const hrt_data				value);
+
+/*! Read from a control register of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return RECEIVER[ID].ctrl[reg]
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_reg_load(
+	const rx_ID_t				ID,
+	const hrt_address			reg);
+
+/*! Write to a control register of PORT[port_ID] of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, RECEIVER[ID].PORT[port_ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H void receiver_port_reg_store(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t			port_ID,
+	const hrt_address			reg,
+	const hrt_data				value);
+
+/*! Read from a control register PORT[port_ID] of of RECEIVER[ID]
+
+ \param	ID[in]				RECEIVER identifier
+ \param	port_ID[in]			mipi PORT identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return RECEIVER[ID].PORT[port_ID].ctrl[reg]
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_port_reg_load(
+	const rx_ID_t				ID,
+	const mipi_port_ID_t		port_ID,
+	const hrt_address			reg);
+
+/*! Write to a control register of SUB_SYSTEM[sub_ID] of INPUT_SYSTEM[ID]
+
+ \param	ID[in]				INPUT_SYSTEM identifier
+ \param	port_ID[in]			sub system identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, INPUT_SYSTEM[ID].SUB_SYSTEM[sub_ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H void input_system_sub_system_reg_store(
+	const input_system_ID_t			ID,
+	const sub_system_ID_t			sub_ID,
+	const hrt_address			reg,
+	const hrt_data				value);
+
+/*! Read from a control register SUB_SYSTEM[sub_ID] of INPUT_SYSTEM[ID]
+
+ \param	ID[in]				INPUT_SYSTEM identifier
+ \param	port_ID[in]			sub system identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return INPUT_SYSTEM[ID].SUB_SYSTEM[sub_ID].ctrl[reg]
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H hrt_data input_system_sub_system_reg_load(
+	const input_system_ID_t		ID,
+	const sub_system_ID_t		sub_ID,
+	const hrt_address			reg);
+
+
+
+///////////////////////////////////////////////////////////////////////////
+//
+//    Functions for configuration phase on input system.
+//
+///////////////////////////////////////////////////////////////////////////
+
+// Function that resets current configuration.
+// remove the argument since it should be private.
+input_system_error_t input_system_configuration_reset(void);
+
+// Function that commits current configuration.
+// remove the argument since it should be private.
+input_system_error_t input_system_configuration_commit(void);
+
+///////////////////////////////////////////////////////////////////////////
+//
+// User functions:
+//		(encoded generic function)
+//    - no checking
+//    - decoding name and agruments into the generic (channel) configuration
+//    function.
+//
+///////////////////////////////////////////////////////////////////////////
+
+
+// FIFO channel config function user
+
+input_system_error_t	input_system_csi_fifo_channel_cfg(
+	uint32_t				ch_id,
+	input_system_csi_port_t	port,
+	backend_channel_cfg_t	backend_ch,
+	target_cfg2400_t			target
+);
+
+input_system_error_t	input_system_csi_fifo_channel_with_counting_cfg(
+	uint32_t				ch_id,
+	uint32_t				nof_frame,
+	input_system_csi_port_t	port,
+	backend_channel_cfg_t	backend_ch,
+	uint32_t				mem_region_size,
+	uint32_t				nof_mem_regions,
+	target_cfg2400_t			target
+);
+
+
+// SRAM channel config function user
+
+input_system_error_t	input_system_csi_sram_channel_cfg(
+	uint32_t				ch_id,
+	input_system_csi_port_t	port,
+	backend_channel_cfg_t	backend_ch,
+	uint32_t				csi_mem_region_size,
+	uint32_t				csi_nof_mem_regions,
+	target_cfg2400_t 			target
+);
+
+
+//XMEM channel config function user
+
+input_system_error_t	input_system_csi_xmem_channel_cfg(
+	uint32_t 				ch_id,
+	input_system_csi_port_t port,
+	backend_channel_cfg_t	backend_ch,
+	uint32_t 				mem_region_size,
+	uint32_t 				nof_mem_regions,
+	uint32_t 				acq_mem_region_size,
+	uint32_t 				acq_nof_mem_regions,
+	target_cfg2400_t 			target,
+	uint32_t 				nof_xmem_buffers
+);
+
+input_system_error_t	input_system_csi_xmem_capture_only_channel_cfg(
+	uint32_t 				ch_id,
+	uint32_t 				nof_frames,
+	input_system_csi_port_t port,
+	uint32_t 				csi_mem_region_size,
+	uint32_t 				csi_nof_mem_regions,
+	uint32_t 				acq_mem_region_size,
+	uint32_t 				acq_nof_mem_regions,
+	target_cfg2400_t 			target
+);
+
+input_system_error_t	input_system_csi_xmem_acquire_only_channel_cfg(
+	uint32_t 				ch_id,
+	uint32_t 				nof_frames,
+	input_system_csi_port_t port,
+	backend_channel_cfg_t	backend_ch,
+	uint32_t 				acq_mem_region_size,
+	uint32_t 				acq_nof_mem_regions,
+	target_cfg2400_t 			target
+);
+
+// Non - CSI channel config function user
+
+input_system_error_t	input_system_prbs_channel_cfg(
+	uint32_t 		ch_id,
+	uint32_t		nof_frames,
+	uint32_t		seed,
+	uint32_t		sync_gen_width,
+	uint32_t		sync_gen_height,
+	uint32_t		sync_gen_hblank_cycles,
+	uint32_t		sync_gen_vblank_cycles,
+	target_cfg2400_t	target
+);
+
+
+input_system_error_t	input_system_tpg_channel_cfg(
+	uint32_t 		ch_id,
+	uint32_t 		nof_frames,//not used yet
+	uint32_t		x_mask,
+	uint32_t		y_mask,
+	uint32_t		x_delta,
+	uint32_t		y_delta,
+	uint32_t		xy_mask,
+	uint32_t		sync_gen_width,
+	uint32_t		sync_gen_height,
+	uint32_t		sync_gen_hblank_cycles,
+	uint32_t		sync_gen_vblank_cycles,
+	target_cfg2400_t	target
+);
+
+
+input_system_error_t	input_system_gpfifo_channel_cfg(
+	uint32_t 		ch_id,
+	uint32_t 		nof_frames,
+	target_cfg2400_t	target
+);
+#endif /* #ifdef USE_INPUT_SYSTEM_VERSION_2401 */
+
+#endif /* __INPUT_SYSTEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/irq_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/irq_public.h
new file mode 100644
index 0000000..f7cb0b1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/irq_public.h
@@ -0,0 +1,191 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IRQ_PUBLIC_H_INCLUDED__
+#define __IRQ_PUBLIC_H_INCLUDED__
+
+#include <type_support.h>
+#include "system_types.h"
+
+/*! Read the control registers of IRQ[ID]
+
+ \param	ID[in]				IRQ identifier
+ \param	state[out]			irq controller state structure
+
+ \return none, state = IRQ[ID].state
+ */
+extern void irq_controller_get_state(
+	const irq_ID_t				ID,
+	irq_controller_state_t		*state);
+
+/*! Write to a control register of IRQ[ID]
+
+ \param	ID[in]				IRQ identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, IRQ[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_IRQ_H void irq_reg_store(
+	const irq_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+/*! Read from a control register of IRQ[ID]
+
+ \param	ID[in]				IRQ identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return IRQ[ID].ctrl[reg]
+ */
+STORAGE_CLASS_IRQ_H hrt_data irq_reg_load(
+	const irq_ID_t		ID,
+	const unsigned int	reg);
+
+/*! Enable an IRQ channel of IRQ[ID] with a mode
+
+ \param	ID[in]				IRQ (device) identifier
+ \param	irq[in]				IRQ (channel) identifier
+
+ \return none, enable(IRQ[ID].channel[irq_ID])
+ */
+extern void irq_enable_channel(
+	const irq_ID_t				ID,
+	const unsigned int			irq_ID);
+
+/*! Enable pulse interrupts for IRQ[ID] with a mode
+
+ \param	ID[in]				IRQ (device) identifier
+ \param	enable				enable/disable pulse interrupts
+
+ \return none
+ */
+extern void irq_enable_pulse(
+	const irq_ID_t	ID,
+	bool 			pulse);
+
+/*! Disable an IRQ channel of IRQ[ID]
+
+ \param	ID[in]				IRQ (device) identifier
+ \param	irq[in]				IRQ (channel) identifier
+
+ \return none, disable(IRQ[ID].channel[irq_ID])
+ */
+extern void irq_disable_channel(
+	const irq_ID_t				ID,
+	const unsigned int			irq);
+
+/*! Clear the state of all IRQ channels of IRQ[ID]
+
+ \param	ID[in]				IRQ (device) identifier
+
+ \return none, clear(IRQ[ID].channel[])
+ */
+extern void irq_clear_all(
+	const irq_ID_t				ID);
+
+/*! Return the ID of a signalling IRQ channel of IRQ[ID]
+
+ \param	ID[in]				IRQ (device) identifier
+ \param irq_id[out]			active IRQ (channel) identifier
+
+ \Note: This function operates as strtok(), based on the return
+  state the user is informed if there are additional signalling
+  channels
+
+ \return state(IRQ[ID])
+ */
+extern enum hrt_isp_css_irq_status irq_get_channel_id(
+	const irq_ID_t				ID,
+	unsigned int				*irq_id);
+
+/*! Raise an interrupt on channel irq_id of device IRQ[ID]
+
+ \param	ID[in]				IRQ (device) identifier
+ \param	irq_id[in]			IRQ (channel) identifier
+
+ \return none, signal(IRQ[ID].channel[irq_id])
+ */
+extern void irq_raise(
+	const irq_ID_t				ID,
+	const irq_sw_channel_id_t	irq_id);
+
+/*! Test if any IRQ channel of the virtual super IRQ has raised a signal
+
+ \return any(VIRQ.channel[irq_ID] != 0)
+ */
+extern bool any_virq_signal(void);
+
+/*! Enable an IRQ channel of the virtual super IRQ
+
+ \param	irq[in]				IRQ (channel) identifier
+ \param	en[in]				predicate channel enable
+
+ \return none, VIRQ.channel[irq_ID].enable = en
+ */
+extern void cnd_virq_enable_channel(
+	const virq_id_t				irq_ID,
+	const bool					en);
+
+/*! Clear the state of all IRQ channels of the virtual super IRQ
+
+ \return none, clear(VIRQ.channel[])
+ */
+extern void virq_clear_all(void);
+
+/*! Clear the IRQ info state of the virtual super IRQ
+
+ \param irq_info[in/out]	The IRQ (channel) state
+
+ \return none
+ */
+extern void virq_clear_info(
+	virq_info_t					*irq_info);
+
+/*! Return the ID of a signalling IRQ channel of the virtual super IRQ
+
+ \param irq_id[out]			active IRQ (channel) identifier
+
+ \Note: This function operates as strtok(), based on the return
+  state the user is informed if there are additional signalling
+  channels
+
+ \return state(IRQ[...])
+ */
+extern enum hrt_isp_css_irq_status virq_get_channel_id(
+	virq_id_t					*irq_id);
+
+/*! Return the IDs of all signaling IRQ channels of the virtual super IRQ
+
+ \param irq_info[out]		all active IRQ (channel) identifiers
+
+ \Note: Unlike "irq_get_channel_id()" this function returns all
+  channel signaling info. The new info is OR'd with the current
+  info state. N.B. this is the same as repeatedly calling the function
+  "irq_get_channel_id()" in a (non-blocked) handler routine
+
+ \return (error(state(IRQ[...]))
+ */
+extern enum hrt_isp_css_irq_status virq_get_channel_signals(
+	virq_info_t					*irq_info);
+
+#endif /* __IRQ_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp2400_config.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp2400_config.h
new file mode 100644
index 0000000..a33b278
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp2400_config.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP2400_CONFIG_H_INCLUDED__
+#define __ISP2400_CONFIG_H_INCLUDED__
+
+#define NUM_BITS 14
+#define NUM_SLICE_ELEMS 4
+#define ROUNDMODE           ROUND_NEAREST_EVEN
+
+#endif /* __ISP2400_CONFIG_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp2600_config.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp2600_config.h
new file mode 100644
index 0000000..32be580
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp2600_config.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP2600_CONFIG_H_INCLUDED__
+#define __ISP2600_CONFIG_H_INCLUDED__
+
+#define NUM_BITS 16
+#define NUM_SLICE_ELEMS 8
+#define ROUNDMODE           ROUND_NEAREST_EVEN
+
+#endif /* __ISP2600_CONFIG_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op1w.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op1w.h
new file mode 100644
index 0000000..62ba3bb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op1w.h
@@ -0,0 +1,642 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP_OP1W_H_INCLUDED__
+#define __ISP_OP1W_H_INCLUDED__
+
+/*
+ * This file is part of the Multi-precision vector operations exstension package.
+ */
+
+/*
+ * Single-precision vector operations
+ */
+
+/*
+ * Prerequisites:
+ *
+ */
+
+#ifndef STORAGE_CLASS_ISP_OP1W_H
+#define STORAGE_CLASS_ISP_OP1W_H extern
+#endif
+
+/*
+ * Single-precision data type specification
+ */
+
+#include "isp_op1w_types.h"
+#include "isp_op2w_types.h" // for doubling operations.
+
+/*
+ * Single-precision prototype specification
+ */
+
+/* Arithmetic */
+
+/** @brief bitwise AND
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		bitwise and of both input arguments
+ *
+ * This function will calculate the bitwise and.
+ * result = _a & _b
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_and(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief bitwise OR
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		bitwise or of both input arguments
+ *
+ * This function will calculate the bitwise or.
+ * result = _a | _b
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_or(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief bitwise XOR
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		bitwise xor of both input arguments
+ *
+ * This function will calculate the bitwise xor.
+ * result = _a ^ _b
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_xor(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief bitwise inverse
+ *
+ * @param[in] _a	first argument
+ *
+ * @return		bitwise inverse of both input arguments
+ *
+ * This function will calculate the bitwise inverse.
+ * result = ~_a
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_inv(
+    const tvector1w     _a);
+
+/* Additive */
+
+/** @brief addition
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		sum of both input arguments
+ *
+ * This function will calculate the sum of the input arguments.
+ * in case of overflow it will wrap around.
+ * result = _a + _b
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_add(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief substraction
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_b substracted from _a.
+ *
+ * This function will substract _b from _a.
+ * in case of overflow it will wrap around.
+ * result = _a - _b
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_sub(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief saturated addition
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		saturated sum of both input arguments
+ *
+ * This function will calculate the sum of the input arguments.
+ * in case of overflow it will saturate
+ * result = CLIP(_a + _b, MIN_RANGE, MAX_RANGE);
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_addsat(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief saturated substraction
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		saturated substraction of both input arguments
+ *
+ * This function will substract _b from _a.
+ * in case of overflow it will saturate
+ * result = CLIP(_a - _b, MIN_RANGE, MAX_RANGE);
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_subsat(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief substraction with shift right
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		(a - b) >> 1
+ *
+ * This function will substract _b from _a.
+ * and right shift the result with 1 bit.
+ * result = (_a - _b) >> 1
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_subasr1(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief saturated substraction
+ *
+ * @param[in] _a	input
+ *
+ * @return		absolute value of the input
+ *
+ * This function will calculate the absolute value of the input
+ * if (_a > 0) return _a;<br>
+ * else return -_a;<br>
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_abs(
+    const tvector1w     _a);
+
+/** @brief subabs
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		abs(a-b);
+ *
+ * This function will calculate the absolute value
+ * of the difference of both inputs
+ * result = abs(_a - _b);
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_subabs(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/* Multiplicative */
+
+/** @brief doubling multiply
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		product of _a and _b
+ *
+ * This function will calculate the product
+ * of the input arguments and returns a double
+ * precision result
+ * result = _a * _b;
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector2w OP_1w_muld(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief integer multiply
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		product of _a and _b
+ *
+ * This function will calculate the product
+ * of the input arguments and returns the LSB
+ * aligned single precison result.
+ * result = _a * _b;
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_mul(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief fractional multiply
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		product of _a and _b
+ *
+ * This function will calculate the product
+ * of the input arguments and returns the MSB
+ * aligned single precison result.
+ * result = _a * _b >> NUM_BITS;
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_qmul(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/* Comparative */
+
+/** @brief equal
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a == _b
+ *
+ * This function will return true if both inputs
+ * are equal, and false if not equal.
+ */
+STORAGE_CLASS_ISP_OP1W_H tflags OP_1w_eq(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief not equal
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a != _b
+ *
+ * This function will return false if both inputs
+ * are equal, and true if not equal.
+ */
+STORAGE_CLASS_ISP_OP1W_H tflags OP_1w_ne(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief less or equal
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a <= _b
+ *
+ * This function will return true if _a is smaller
+ * or equal than _b.
+ */
+STORAGE_CLASS_ISP_OP1W_H tflags OP_1w_le(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief less then
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a < _b
+ *
+ * This function will return true if _a is smaller
+ * than _b.
+ */
+STORAGE_CLASS_ISP_OP1W_H tflags OP_1w_lt(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief greater or equal
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a >= _b
+ *
+ * This function will return true if _a is greater
+ * or equal than _b.
+ */
+STORAGE_CLASS_ISP_OP1W_H tflags OP_1w_ge(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief greater than
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a > _b
+ *
+ * This function will return true if _a is greater
+ * than _b.
+ */
+STORAGE_CLASS_ISP_OP1W_H tflags OP_1w_gt(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/* Shift */
+
+/** @brief aritmetic shift right
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a >> _b
+ *
+ * This function will shift _a with _b bits to the right.
+ * preserving the sign bit.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_asr(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief aritmetic shift left
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a << _b
+ *
+ * This function will shift _a with _b bits to the left.
+ *
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_asl(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief aritmetic shift right with rounding
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a >> _b
+ *
+ * This function will shift _a with _b bits to the right.
+ * and depending on the rounding mode of the core
+ * it will round to nearest or to nearest even.
+ *
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_asrrnd(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief logical shift left
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a << _b
+ *
+ * This function will shift _a with _b bits to the left.
+ * It will insert zero's on the right.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_lsl(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief saturated logical shift left
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a << _b
+ *
+ * This function will shift _a with _b bits to the left.
+ * It will insert zero's on the right, and clip the result.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_lslsat(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief logical shift right
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a >> _b
+ *
+ * This function will shift _a with _b bits to the right.
+ * It will insert zero's on the left
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_lsr(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief logical shift right with rounding
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a >> _b
+ *
+ * This function will shift _a with _b bits to the right.
+ * It will insert zero's on the left
+ * and depending on the rounding mode of the core
+ * it will round to nearest or to nearest even.
+ *
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_lsrrnd(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+
+/* Cast */
+
+/** @brief Cast from int to 1w
+ *
+ * @param[in] _a	input
+ *
+ * @return		_a
+ *
+ * This function cast the input from integer type to
+ * single precision. It will also assert on ranges
+ *
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_int_cast_to_1w (
+    const int           _a);
+
+/** @brief Cast from 1w to int
+ *
+ * @param[in] _a	input
+ *
+ * @return		_a
+ *
+ * This function cast the input from single precision type to
+ * integer.
+ *
+ */
+STORAGE_CLASS_ISP_OP1W_H int OP_1w_cast_to_int (
+    const tvector1w      _a);
+
+/** @brief Cast from int to 1w
+ *
+ * @param[in] _a	input
+ *
+ * @return		_a
+ *
+ * This function cast the input from single precision type to
+ * double precision. lsb aligned.
+ *
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector2w OP_1w_cast_to_2w (
+    const tvector1w     _a);
+
+/** @brief Cast from int to 1w
+ *
+ * @param[in] _a	input
+ *
+ * @return		_a
+ *
+ * This function cast the input from double precision type to
+ * single precision. MSB's will be truncated.
+ *
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_2w_cast_to_1w (
+    const tvector2w    _a);
+
+/* clipping */
+
+/** @brief Clip asymetrical
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a clipped between ~_b and b
+ *
+ * This function will clip the first argument between
+ * the negated version of _b and _b.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_clip_asym(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief Clip zero
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a clipped beteween 0 and _b
+ *
+ * This function will clip the first argument between
+ * zero and _b.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_clipz(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/* division */
+
+/** @brief Divide
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a / _b
+ *
+ * This function will divide the first argument by
+ * the second argument.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_div(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief Modulo
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a % _b
+ *
+ * This function will return _a modulo _b.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_mod(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief Square root
+ *
+ * @param[in] _a	input
+ *
+ * @return		square root of _a
+ *
+ * This function will calculate the square root of _a
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_sqrt(
+    const tvector1w     _a);
+
+/* Miscellaneous */
+
+/** @brief Multiplexer
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ * @param[in] _c	condition
+ *
+ * @return		_c ? _a : _b
+ *
+ * This function will return _a if the condition _c
+ * is true and _b otherwise.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_mux(
+    const tvector1w     _a,
+    const tvector1w     _b,
+    const tflags           _c);
+
+/** @brief Average
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		average(_a,_b)
+ *
+ * This function will calculate the average of
+ * the two input arguments.
+ * And depending on the rounding mode of the core
+ * it will round to nearest or to nearest even.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_avgrnd(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief Minimum
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		(_a < _b) ? _a : _b;
+ *
+ * This function will return the smallest of both
+ * input arguments.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_min(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief Maximum
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		(_a > _b) ? _a : _b;
+ *
+ * This function will return the largest of both
+ * input arguments.
+ */
+STORAGE_CLASS_ISP_OP1W_H tvector1w OP_1w_max(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+#endif /* __ISP_OP1W_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op1w_types.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op1w_types.h
new file mode 100644
index 0000000..fa08fa0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op1w_types.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP_OP1W_TYPES_H_INCLUDED__
+#define __ISP_OP1W_TYPES_H_INCLUDED__
+
+/*
+ * This file is part of the Multi-precision vector operations exstension package.
+ */
+
+/*
+ * Single-precision vector operations
+ */
+
+/*
+ * Prerequisites:
+ *
+ */
+
+#include "mpmath.h"
+
+/*
+ * Single-precision data type specification
+ */
+
+
+typedef mpsdata_t       tvector1w;
+typedef mpsdata_t       tscalar1w;
+typedef spsdata_t        tflags;
+
+
+typedef  struct {
+  tvector1w       d;
+  tflags        f;
+} tvector1w_tflags1w;
+
+#endif /* __ISP_OP1W_TYPES_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op2w.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op2w.h
new file mode 100644
index 0000000..5e29307
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op2w.h
@@ -0,0 +1,570 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP_OP2W_H_INCLUDED__
+#define __ISP_OP2W_H_INCLUDED__
+
+/*
+ * This file is part of the Multi-precision vector operations exstension package.
+ */
+
+/*
+ * Single-precision vector operations
+ */
+
+/*
+ * Prerequisites:
+ *
+ */
+
+#ifndef STORAGE_CLASS_ISP_OP2W_H
+#define STORAGE_CLASS_ISP_OP2W_H extern
+#endif
+
+/*
+ * Single-precision data type specification
+ */
+
+#include "isp_op2w_types.h"
+
+/*
+ * Single-precision prototype specification
+ */
+
+/* Arithmetic */
+
+/** @brief bitwise AND
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		bitwise and of both input arguments
+ *
+ * This function will calculate the bitwise and.
+ * result = _a & _b
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_and(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief bitwise OR
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		bitwise or of both input arguments
+ *
+ * This function will calculate the bitwise or.
+ * result = _a | _b
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_or(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief bitwise XOR
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		bitwise xor of both input arguments
+ *
+ * This function will calculate the bitwise xor.
+ * result = _a ^ _b
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_xor(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief bitwise inverse
+ *
+ * @param[in] _a	first argument
+ *
+ * @return		bitwise inverse of both input arguments
+ *
+ * This function will calculate the bitwise inverse.
+ * result = ~_a
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_inv(
+    const tvector2w     _a);
+
+/* Additive */
+
+/** @brief addition
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		sum of both input arguments
+ *
+ * This function will calculate the sum of the input arguments.
+ * in case of overflow it will wrap around.
+ * result = _a + _b
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_add(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief substraction
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_b substracted from _a.
+ *
+ * This function will substract _b from _a.
+ * in case of overflow it will wrap around.
+ * result = _a - _b
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_sub(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief saturated addition
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		saturated sum of both input arguments
+ *
+ * This function will calculate the sum of the input arguments.
+ * in case of overflow it will saturate
+ * result = CLIP(_a + _b, MIN_RANGE, MAX_RANGE);
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_addsat(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief saturated substraction
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		saturated substraction of both input arguments
+ *
+ * This function will substract _b from _a.
+ * in case of overflow it will saturate
+ * result = CLIP(_a - _b, MIN_RANGE, MAX_RANGE);
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_subsat(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief substraction with shift right
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		(a - b) >> 1
+ *
+ * This function will substract _b from _a.
+ * and right shift the result with 1 bit.
+ * result = (_a - _b) >> 1
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_subasr1(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief saturated substraction
+ *
+ * @param[in] _a	input
+ *
+ * @return		absolute value of the input
+ *
+ * This function will calculate the absolute value of the input
+ * if (_a > 0) return _a;<br>
+ * else return -_a;<br>
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_abs(
+    const tvector2w     _a);
+
+/** @brief subabs
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		abs(a-b);
+ *
+ * This function will calculate the absolute value
+ * of the difference of both inputs
+ * result = abs(_a - _b);
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_subabs(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/* Multiplicative */
+
+/** @brief integer multiply
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		product of _a and _b
+ *
+ * This function will calculate the product
+ * of the input arguments and returns the LSB
+ * aligned single precison result.
+ * result = _a * _b;
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_mul(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief fractional multiply
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		product of _a and _b
+ *
+ * This function will calculate the product
+ * of the input arguments and returns the MSB
+ * aligned single precison result.
+ * result = _a * _b >> NUM_BITS;
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_qmul(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/* Comparative */
+
+/** @brief equal
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a == _b
+ *
+ * This function will return true if both inputs
+ * are equal, and false if not equal.
+ */
+STORAGE_CLASS_ISP_OP2W_H tflags OP_2w_eq(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief not equal
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a != _b
+ *
+ * This function will return false if both inputs
+ * are equal, and true if not equal.
+ */
+STORAGE_CLASS_ISP_OP2W_H tflags OP_2w_ne(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief less or equal
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a <= _b
+ *
+ * This function will return true if _a is smaller
+ * or equal than _b.
+ */
+STORAGE_CLASS_ISP_OP2W_H tflags OP_2w_le(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief less then
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a < _b
+ *
+ * This function will return true if _a is smaller
+ * than _b.
+ */
+STORAGE_CLASS_ISP_OP2W_H tflags OP_2w_lt(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief greater or equal
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a >= _b
+ *
+ * This function will return true if _a is greater
+ * or equal than _b.
+ */
+STORAGE_CLASS_ISP_OP2W_H tflags OP_2w_ge(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief greater than
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a > _b
+ *
+ * This function will return true if _a is greater
+ * than _b.
+ */
+STORAGE_CLASS_ISP_OP2W_H tflags OP_2w_gt(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/* Shift */
+
+/** @brief aritmetic shift right
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a >> _b
+ *
+ * This function will shift _a with _b bits to the right.
+ * preserving the sign bit.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_asr(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief aritmetic shift left
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a << _b
+ *
+ * This function will shift _a with _b bits to the left.
+ *
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_asl(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief aritmetic shift right with rounding
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a >> _b
+ *
+ * This function will shift _a with _b bits to the right.
+ * and depending on the rounding mode of the core
+ * it will round to nearest or to nearest even.
+ *
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_asrrnd(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief logical shift left
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a << _b
+ *
+ * This function will shift _a with _b bits to the left.
+ * It will insert zero's on the right.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_lsl(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief saturated logical shift left
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a << _b
+ *
+ * This function will shift _a with _b bits to the left.
+ * It will insert zero's on the right, and clip the result.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_lslsat(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief logical shift right
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a >> _b
+ *
+ * This function will shift _a with _b bits to the right.
+ * It will insert zero's on the left
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_lsr(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief logical shift right with rounding
+ *
+ * @param[in] _a	input
+ * @param[in] _b	shift amount
+ *
+ * @return		_a >> _b
+ *
+ * This function will shift _a with _b bits to the right.
+ * It will insert zero's on the left
+ * and depending on the rounding mode of the core
+ * it will round to nearest or to nearest even.
+ *
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_lsrrnd(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/* clipping */
+
+/** @brief Clip asymetrical
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a clipped between ~_b and b
+ *
+ * This function will clip the first argument between
+ * the negated version of _b and _b.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_clip_asym(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief Clip zero
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a clipped beteween 0 and _b
+ *
+ * This function will clip the first argument between
+ * zero and _b.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_clipz(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/* division */
+
+/** @brief Divide
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a / _b
+ *
+ * This function will divide the first argument by
+ * the second argument.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_div(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief Modulo
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		_a % _b
+ *
+ * This function will return _a modulo _b.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_mod(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief Square root
+ *
+ * @param[in] _a	input
+ *
+ * @return		square root of _a
+ *
+ * This function will calculate the square root of _a
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_sqrt(
+    const tvector2w     _a);
+
+/* Miscellaneous */
+
+/** @brief Multiplexer
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ * @param[in] _c	condition
+ *
+ * @return		_c ? _a : _b
+ *
+ * This function will return _a if the condition _c
+ * is true and _b otherwise.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_mux(
+    const tvector2w     _a,
+    const tvector2w     _b,
+    const tflags           _c);
+
+/** @brief Average
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		average(_a,_b)
+ *
+ * This function will calculate the average of
+ * the two input arguments.
+ * And depending on the rounding mode of the core
+ * it will round to nearest or to nearest even.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_avgrnd(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief Minimum
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		(_a < _b) ? _a : _b;
+ *
+ * This function will return the smallest of both
+ * input arguments.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_min(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief Maximum
+ *
+ * @param[in] _a	first argument
+ * @param[in] _b	second argument
+ *
+ * @return		(_a > _b) ? _a : _b;
+ *
+ * This function will return the largest of both
+ * input arguments.
+ */
+STORAGE_CLASS_ISP_OP2W_H tvector2w OP_2w_max(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+#endif /* __ISP_OP2W_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op2w_types.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op2w_types.h
new file mode 100644
index 0000000..370f870
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_op2w_types.h
@@ -0,0 +1,53 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP_OP2W_TYPES_H_INCLUDED__
+#define __ISP_OP2W_TYPES_H_INCLUDED__
+
+/*
+ * This file is part of the Multi-precision vector operations exstension package.
+ */
+
+/*
+ * Double-precision vector operations
+ */
+
+/*
+ * Prerequisites:
+ *
+ */
+#include "mpmath.h"
+#include "isp_op1w_types.h"
+
+/*
+ * Single-precision data type specification
+ */
+
+
+typedef mpsdata_t       tvector2w;
+typedef mpsdata_t       tscalar2w;
+
+typedef struct {
+  tvector2w       d;
+  tflags        f;
+} tvector2w_tflags;
+
+#endif /* __ISP_OP2W_TYPES_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_public.h
new file mode 100644
index 0000000..f3877ae
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isp_public.h
@@ -0,0 +1,185 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP_PUBLIC_H_INCLUDED__
+#define __ISP_PUBLIC_H_INCLUDED__
+
+#include <type_support.h>
+#include "system_types.h"
+
+/*! Enable or disable the program complete irq signal of ISP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	cnd[in]				predicate
+
+ \return none, if(cnd) enable(ISP[ID].irq) else disable(ISP[ID].irq)
+ */
+extern void cnd_isp_irq_enable(
+	const isp_ID_t		ID,
+	const bool			cnd);
+
+/*! Read the state of cell ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	state[out]			isp state structure
+ \param	stall[out]			isp stall conditions
+
+ \return none, state = ISP[ID].state, stall = ISP[ID].stall
+ */
+extern void isp_get_state(
+	const isp_ID_t		ID,
+	isp_state_t			*state,
+	isp_stall_t			*stall);
+
+
+/*! Write to the status and control register of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, ISP[ID].sc[reg] = value
+ */
+STORAGE_CLASS_ISP_H void isp_ctrl_store(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+/*! Read from the status and control register of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return ISP[ID].sc[reg]
+ */
+STORAGE_CLASS_ISP_H hrt_data isp_ctrl_load(
+	const isp_ID_t		ID,
+	const unsigned int	reg);
+
+/*! Get the status of a bitfield in the control register of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be checked
+
+ \return  (ISP[ID].sc[reg] & (1<<bit)) != 0
+ */
+STORAGE_CLASS_ISP_H bool isp_ctrl_getbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit);
+
+/*! Set a bitfield in the control register of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be set
+
+ \return none, ISP[ID].sc[reg] |= (1<<bit)
+ */
+STORAGE_CLASS_ISP_H void isp_ctrl_setbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit);
+
+/*! Clear a bitfield in the control register of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be set
+
+ \return none, ISP[ID].sc[reg] &= ~(1<<bit)
+ */
+STORAGE_CLASS_ISP_H void isp_ctrl_clearbit(
+	const isp_ID_t		ID,
+	const unsigned int	reg,
+	const unsigned int	bit);
+
+/*! Write to the DMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, ISP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_ISP_H void isp_dmem_store(
+	const isp_ID_t		ID,
+	unsigned int		addr,
+	const void			*data,
+	const size_t		size);
+
+/*! Read from the DMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = ISP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_ISP_H void isp_dmem_load(
+	const isp_ID_t		ID,
+	const unsigned int	addr,
+	void				*data,
+	const size_t		size);
+
+/*! Write a 32-bit datum to the DMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, ISP[ID].dmem[addr] = data
+ */
+STORAGE_CLASS_ISP_H void isp_dmem_store_uint32(
+	const isp_ID_t		ID,
+	unsigned int		addr,
+	const uint32_t		data);
+
+/*! Load a 32-bit datum from the DMEM of ISP[ID]
+
+ \param	ID[in]				ISP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = ISP[ID].dmem[addr]
+ */
+STORAGE_CLASS_ISP_H uint32_t isp_dmem_load_uint32(
+	const isp_ID_t		ID,
+	const unsigned int	addr);
+
+/*! Concatenate the LSW and MSW into a double precision word
+
+ \param	x0[in]				Integer containing the LSW
+ \param	x1[in]				Integer containing the MSW
+
+ \return x0 | (x1 << bits_per_vector_element)
+ */
+STORAGE_CLASS_ISP_H uint32_t isp_2w_cat_1w(
+	const uint16_t		x0,
+	const uint16_t		x1);
+
+#endif /* __ISP_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isys_dma_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isys_dma_public.h
new file mode 100644
index 0000000..f2d4169
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isys_dma_public.h
@@ -0,0 +1,26 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISYS_DMA_PUBLIC_H_INCLUDED__
+#define __ISYS_DMA_PUBLIC_H_INCLUDED__
+
+
+#endif /* __ISYS_DMA_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isys_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isys_public.h
new file mode 100644
index 0000000..2fc4070
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isys_public.h
@@ -0,0 +1,44 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISYS_PUBLIC_H_INCLUDED__
+#define __ISYS_PUBLIC_H_INCLUDED__
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+/*! Read the state of INPUT_SYSTEM[ID]
+ \param ID[in]		INPUT_SYSTEM identifier
+ \param state[out]	pointer to input system state structure
+ \return none, state = INPUT_SYSTEM[ID].state
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H input_system_err_t input_system_get_state(
+	const input_system_ID_t	ID,
+	input_system_state_t *state);
+/*! Dump the state of INPUT_SYSTEM[ID]
+ \param ID[in]		INPUT_SYSTEM identifier
+ \param state[in]	pointer to input system state structure
+ \return none
+ \depends on host supplied print function as part of ia_css_init()
+ */
+STORAGE_CLASS_INPUT_SYSTEM_H void input_system_dump_state(
+	const input_system_ID_t	ID,
+	input_system_state_t *state);
+#endif /* USE_INPUT_SYSTEM_VERSION_2401 */
+#endif /* __ISYS_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isys_stream2mmio_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isys_stream2mmio_public.h
new file mode 100644
index 0000000..bd454b9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/isys_stream2mmio_public.h
@@ -0,0 +1,90 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISYS_STREAM2MMIO_PUBLIC_H_INCLUDED__
+#define __ISYS_STREAM2MMIO_PUBLIC_H_INCLUDED__
+
+/*****************************************************
+ *
+ * Native command interface (NCI).
+ *
+ *****************************************************/
+/**
+ * @brief Get the stream2mmio-controller state.
+ * Get the state of the stream2mmio-controller regiester-set.
+ *
+ * @param[in]	id		The global unique ID of the steeam2mmio controller.
+ * @param[out]	state	Point to the register-state.
+ */
+STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_state(
+		const stream2mmio_ID_t ID,
+		stream2mmio_state_t *state);
+
+/**
+ * @brief Get the state of the stream2mmio-controller sidess.
+ * Get the state of the register set per buf-controller sidess.
+ *
+ * @param[in]	id		The global unique ID of the steeam2mmio controller.
+ * @param[in]	sid_id		The sid ID.
+ * @param[out]	state		Point to the sid state.
+ */
+STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_sid_state(
+		const stream2mmio_ID_t ID,
+		const uint32_t sid_id,
+		stream2mmio_sid_state_t *state);
+/** end of NCI */
+
+/*****************************************************
+ *
+ * Device level interface (DLI).
+ *
+ *****************************************************/
+/**
+ * @brief Load the register value.
+ * Load the value of the register of the stream2mmio-controller.
+ *
+ * @param[in]	ID	The global unique ID for the stream2mmio-controller instance.
+ * @param[in]	sid_id	The SID in question.
+ * @param[in]	reg_idx	The offet address of the register.
+ *
+ * @return the value of the register.
+ */
+STORAGE_CLASS_STREAM2MMIO_H hrt_data stream2mmio_reg_load(
+	const stream2mmio_ID_t ID,
+	const uint32_t sid_id,
+	const uint32_t reg_idx);
+
+/**
+ * @brief Store a value to the register.
+ * Store a value to the registe of the stream2mmio-controller.
+ *
+ * @param[in]	ID		The global unique ID for the stream2mmio-controller instance.
+ * @param[in]	reg		The offet address of the register.
+ * @param[in]	value	The value to be stored.
+ *
+ */
+STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_reg_store(
+	const stream2mmio_ID_t ID,
+	const hrt_address reg,
+	const hrt_data value);
+/** end of DLI */
+
+#endif /* __ISYS_STREAM2MMIO_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/mmu_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/mmu_public.h
new file mode 100644
index 0000000..37d5ddc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/mmu_public.h
@@ -0,0 +1,89 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MMU_PUBLIC_H_INCLUDED__
+#define __MMU_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+/*! Set the page table base index of MMU[ID]
+
+ \param	ID[in]				MMU identifier
+ \param	base_index[in]		page table base index
+
+ \return none, MMU[ID].page_table_base_index = base_index
+ */
+STORAGE_CLASS_EXTERN void mmu_set_page_table_base_index(
+	const mmu_ID_t		ID,
+	const hrt_data		base_index);
+
+/*! Get the page table base index of MMU[ID]
+
+ \param	ID[in]				MMU identifier
+ \param	base_index[in]		page table base index
+
+ \return MMU[ID].page_table_base_index
+ */
+STORAGE_CLASS_EXTERN hrt_data mmu_get_page_table_base_index(
+	const mmu_ID_t		ID);
+
+/*! Invalidate the page table cache of MMU[ID]
+
+ \param	ID[in]				MMU identifier
+
+ \return none
+ */
+STORAGE_CLASS_EXTERN void mmu_invalidate_cache(
+	const mmu_ID_t		ID);
+
+
+/*! Invalidate the page table cache of all MMUs
+
+ \return none
+ */
+STORAGE_CLASS_EXTERN void mmu_invalidate_cache_all(void);
+
+/*! Write to a control register of MMU[ID]
+
+ \param	ID[in]				MMU identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, MMU[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_MMU_H void mmu_reg_store(
+	const mmu_ID_t		ID,
+	const unsigned int	reg,
+	const hrt_data		value);
+
+/*! Read from a control register of MMU[ID]
+
+ \param	ID[in]				MMU identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return MMU[ID].ctrl[reg]
+ */
+STORAGE_CLASS_MMU_H hrt_data mmu_reg_load(
+	const mmu_ID_t		ID,
+	const unsigned int	reg);
+
+#endif /* __MMU_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/pipeline_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/pipeline_public.h
new file mode 100644
index 0000000..3b26f06
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/pipeline_public.h
@@ -0,0 +1,25 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __PIPELINE_PUBLIC_H_INCLUDED__
+#define __PIPELINE_PUBLIC_H_INCLUDED__
+
+#endif /* __PIPELINE_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/pixelgen_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/pixelgen_public.h
new file mode 100644
index 0000000..2f0fabd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/pixelgen_public.h
@@ -0,0 +1,86 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __PIXELGEN_PUBLIC_H_INCLUDED__
+#define __PIXELGEN_PUBLIC_H_INCLUDED__
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+/*****************************************************
+ *
+ * Native command interface (NCI).
+ *
+ *****************************************************/
+/**
+ * @brief Get the pixelgen state.
+ * Get the state of the pixelgen regiester-set.
+ *
+ * @param[in]	id	The global unique ID of the pixelgen controller.
+ * @param[out]	state	Point to the register-state.
+ */
+STORAGE_CLASS_PIXELGEN_H void pixelgen_ctrl_get_state(
+		const pixelgen_ID_t ID,
+		pixelgen_ctrl_state_t *state);
+/**
+ * @brief Dump the pixelgen state.
+ * Dump the state of the pixelgen regiester-set.
+ *
+ * @param[in]	id	The global unique ID of the pixelgen controller.
+ * @param[in]	state	Point to the register-state.
+ */
+STORAGE_CLASS_PIXELGEN_H void pixelgen_ctrl_dump_state(
+		const pixelgen_ID_t ID,
+		pixelgen_ctrl_state_t *state);
+/** end of NCI */
+
+/*****************************************************
+ *
+ * Device level interface (DLI).
+ *
+ *****************************************************/
+/**
+ * @brief Load the register value.
+ * Load the value of the register of the pixelgen
+ *
+ * @param[in]	ID	The global unique ID for the pixelgen instance.
+ * @param[in]	reg	The offet address of the register.
+ *
+ * @return the value of the register.
+ */
+STORAGE_CLASS_PIXELGEN_H hrt_data pixelgen_ctrl_reg_load(
+	const pixelgen_ID_t ID,
+	const hrt_address reg);
+/**
+ * @brief Store a value to the register.
+ * Store a value to the registe of the pixelgen
+ *
+ * @param[in]	ID		The global unique ID for the pixelgen.
+ * @param[in]	reg		The offet address of the register.
+ * @param[in]	value	The value to be stored.
+ *
+ */
+STORAGE_CLASS_PIXELGEN_H void pixelgen_ctrl_reg_store(
+	const pixelgen_ID_t ID,
+	const hrt_address reg,
+	const hrt_data value);
+/** end of DLI */
+
+#endif /* USE_INPUT_SYSTEM_VERSION_2401 */
+#endif /* __PIXELGEN_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ref_vector_func.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ref_vector_func.h
new file mode 100644
index 0000000..6b5099a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ref_vector_func.h
@@ -0,0 +1,276 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2013 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+
+#ifndef _REF_VECTOR_FUNC_H_INCLUDED_
+#define _REF_VECTOR_FUNC_H_INCLUDED_
+
+#ifndef STORAGE_CLASS_REF_VECTOR_FUNC_C
+#define STORAGE_CLASS_REF_VECTOR_FUNC_C extern
+#endif
+
+#include "ref_vector_func_types.h"
+
+/** @brief Normalised FIR with coefficients [3,4,1]
+ *
+ * @param[in] m	1x3 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [3,4,1],
+ *-5dB at Fs/2, -90 degree phase shift (quarter pixel)
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir1x3m_5dB_m90_nrm (
+	const s_1w_1x3_matrix		m);
+
+/** @brief Normalised FIR with coefficients [1,4,3]
+ *
+ * @param[in] m	1x3 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [1,4,3],
+ *-5dB at Fs/2, +90 degree phase shift (quarter pixel)
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir1x3m_5dB_p90_nrm (
+	const s_1w_1x3_matrix		m);
+
+/** @brief Normalised FIR with coefficients [1,2,1]
+ *
+ * @param[in] m	1x3 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [1,2,1], -6dB at Fs/2
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir1x3m_6dB_nrm (
+	const s_1w_1x3_matrix		m);
+
+/** @brief Normalised FIR with coefficients [13,16,3]
+ *
+ * @param[in] m	1x3 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [13,16,3],
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir1x3m_6dB_nrm_ph0 (
+	const s_1w_1x3_matrix		m);
+
+/** @brief Normalised FIR with coefficients [9,16,7]
+ *
+ * @param[in] m	1x3 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [9,16,7],
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir1x3m_6dB_nrm_ph1 (
+	const s_1w_1x3_matrix		m);
+
+/** @brief Normalised FIR with coefficients [5,16,11]
+ *
+ * @param[in] m	1x3 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [5,16,11],
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir1x3m_6dB_nrm_ph2 (
+	const s_1w_1x3_matrix		m);
+
+/** @brief Normalised FIR with coefficients [1,16,15]
+ *
+ * @param[in] m	1x3 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [1,16,15],
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir1x3m_6dB_nrm_ph3 (
+	const s_1w_1x3_matrix		m);
+
+/** @brief Normalised FIR with programable phase shift
+ *
+ * @param[in] m	1x3 matrix with pixels
+ * @param[in] coeff	phase shift
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [8-coeff,16,8+coeff],
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir1x3m_6dB_nrm_calc_coeff (
+	const s_1w_1x3_matrix		m, tscalar1w_3bit coeff);
+
+/** @brief 3 tab FIR with coefficients [1,1,1]
+ *
+ * @param[in] m	1x3 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * FIR with coefficients [1,1,1], -9dB at Fs/2 normalized with factor 1/2
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir1x3m_9dB_nrm (
+	const s_1w_1x3_matrix		m);
+
+
+/** @brief Normalised 2D FIR with coefficients  [1;2;1] * [1,2,1]
+ *
+ * @param[in] m	3x3 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients  [1;2;1] * [1,2,1]
+ * Unity gain filter through repeated scaling and rounding
+ *	- 6 rotate operations per output
+ *	- 8 vector operations per output
+ * _______
+ *   14 total operations
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir3x3m_6dB_nrm (
+	const s_1w_3x3_matrix		m);
+
+/** @brief Normalised 2D FIR with coefficients  [1;1;1] * [1,1,1]
+ *
+ * @param[in] m	3x3 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [1;1;1] * [1,1,1]
+ *
+ * (near) Unity gain filter through repeated scaling and rounding
+ *	- 6 rotate operations per output
+ *	- 8 vector operations per output
+ * _______
+ *   14 operations
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir3x3m_9dB_nrm (
+	const s_1w_3x3_matrix		m);
+
+/** @brief Normalised dual output 2D FIR with coefficients  [1;2;1] * [1,2,1]
+ *
+ * @param[in] m	4x3 matrix with pixels
+ *
+ * @return		two filtered outputs (2x1 matrix)
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients  [1;2;1] * [1,2,1]
+ * and produce two outputs (vertical)
+ * Unity gain filter through repeated scaling and rounding
+ * compute two outputs per call to re-use common intermediates
+ *	- 4 rotate operations per output
+ *	- 6 vector operations per output (alternative possible, but in this
+ *	    form it's not obvious to re-use variables)
+ * _______
+ *   10 total operations
+ */
+ STORAGE_CLASS_REF_VECTOR_FUNC_C s_1w_2x1_matrix fir3x3m_6dB_out2x1_nrm (
+	const s_1w_4x3_matrix		m);
+
+/** @brief Normalised dual output 2D FIR with coefficients [1;1;1] * [1,1,1]
+ *
+ * @param[in] m	4x3 matrix with pixels
+ *
+ * @return		two filtered outputs (2x1 matrix)
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [1;1;1] * [1,1,1]
+ * and produce two outputs (vertical)
+ * (near) Unity gain filter through repeated scaling and rounding
+ * compute two outputs per call to re-use common intermediates
+ *	- 4 rotate operations per output
+ *	- 7 vector operations per output (alternative possible, but in this
+ *	    form it's not obvious to re-use variables)
+ * _______
+ *   11 total operations
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_C s_1w_2x1_matrix fir3x3m_9dB_out2x1_nrm (
+	const s_1w_4x3_matrix		m);
+
+/** @brief Normalised 2D FIR 5x5
+ *
+ * @param[in] m	5x5 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [1;1;1] * [1;2;1] * [1,2,1] * [1,1,1]
+ * and produce a filtered output
+ * (near) Unity gain filter through repeated scaling and rounding
+ *	- 20 rotate operations per output
+ *	- 28 vector operations per output
+ * _______
+ *   48 total operations
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir5x5m_15dB_nrm (
+	const s_1w_5x5_matrix	m);
+
+/** @brief Normalised FIR 1x5
+ *
+ * @param[in] m	1x5 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [1,2,1] * [1,1,1] = [1,4,6,4,1]
+ * and produce a filtered output
+ * (near) Unity gain filter through repeated scaling and rounding
+ *	- 4 rotate operations per output
+ *	- 5 vector operations per output
+ * _______
+ *   9 total operations
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir1x5m_12dB_nrm (
+	const s_1w_1x5_matrix m);
+
+/** @brief Normalised 2D FIR 5x5
+ *
+ * @param[in] m	5x5 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will calculate the
+ * Normalised FIR with coefficients [1;2;1] * [1;2;1] * [1,2,1] * [1,2,1]
+ * and produce a filtered output
+ * (near) Unity gain filter through repeated scaling and rounding
+ *	- 20 rotate operations per output
+ *	- 30 vector operations per output
+ * _______
+ *   50 total operations
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_C tvector1w fir5x5m_12dB_nrm (
+	const s_1w_5x5_matrix m);
+#endif /*_REF_VECTOR_FUNC_H_INCLUDED_*/
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ref_vector_func_types.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ref_vector_func_types.h
new file mode 100644
index 0000000..cc3ee66
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/ref_vector_func_types.h
@@ -0,0 +1,89 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2013 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+
+#ifndef __REF_VECTOR_FUNC_TYPES_H_INCLUDED__
+#define __REF_VECTOR_FUNC_TYPES_H_INCLUDED__
+
+
+/*
+ * Prerequisites:
+ *
+ */
+#include "mpmath.h"
+#include "isp_op1w_types.h"
+#include "isp_op2w_types.h"
+
+/*
+ * Struct type specification
+ */
+
+typedef unsigned short tscalar1w_3bit;
+typedef unsigned short tvector_5bit;
+typedef unsigned short tvector_4bit;
+typedef unsigned short tvector1w_unsigned;
+typedef unsigned int   tvector2w_unsigned;
+
+typedef struct {
+  tvector1w     v0  ;
+  tvector1w     v1 ;
+} s_1w_2x1_matrix;
+
+typedef struct {
+  tvector1w     v00  ;
+  tvector1w     v01 ;
+  tvector1w     v02 ;
+} s_1w_1x3_matrix;
+
+typedef struct {
+  tvector1w     v00  ; tvector1w     v01 ; tvector1w     v02  ;
+  tvector1w     v10  ; tvector1w     v11 ; tvector1w     v12  ;
+  tvector1w     v20  ; tvector1w     v21 ; tvector1w     v22  ;
+} s_1w_3x3_matrix;
+
+typedef struct {
+  tvector1w     v00  ; tvector1w     v01 ; tvector1w     v02  ;
+  tvector1w     v10  ; tvector1w     v11 ; tvector1w     v12  ;
+  tvector1w     v20  ; tvector1w     v21 ; tvector1w     v22  ;
+  tvector1w     v30  ; tvector1w     v31 ; tvector1w     v32  ;
+} s_1w_4x3_matrix;
+
+typedef struct {
+  tvector1w     v00 ;
+  tvector1w     v01 ;
+  tvector1w     v02 ;
+  tvector1w     v03 ;
+  tvector1w     v04 ;
+} s_1w_1x5_matrix;
+
+typedef struct {
+  tvector1w     v00  ; tvector1w     v01 ; tvector1w     v02  ; tvector1w     v03 ; tvector1w     v04  ;
+  tvector1w     v10  ; tvector1w     v11 ; tvector1w     v12  ; tvector1w     v13 ; tvector1w     v14  ;
+  tvector1w     v20  ; tvector1w     v21 ; tvector1w     v22  ; tvector1w     v23 ; tvector1w     v24  ;
+  tvector1w     v30  ; tvector1w     v31 ; tvector1w     v32  ; tvector1w     v33 ; tvector1w     v34  ;
+  tvector1w     v40  ; tvector1w     v41 ; tvector1w     v42  ; tvector1w     v43 ; tvector1w     v44  ;
+} s_1w_5x5_matrix;
+
+
+#endif /* __REF_VECTOR_FUNC_TYPES_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/sp_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/sp_public.h
new file mode 100644
index 0000000..99d9da3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/sp_public.h
@@ -0,0 +1,230 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SP_PUBLIC_H_INCLUDED__
+#define __SP_PUBLIC_H_INCLUDED__
+
+#include <type_support.h>
+#include "system_types.h"
+
+typedef struct sp_state_s		sp_state_t;
+typedef struct sp_stall_s		sp_stall_t;
+
+/*! Enable or disable the program complete irq signal of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	cnd[in]				predicate
+
+ \return none, if(cnd) enable(SP[ID].irq) else disable(SP[ID].irq)
+ */
+extern void cnd_sp_irq_enable(
+	const sp_ID_t		ID,
+	const bool			cnd);
+
+/*! Read the state of cell SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	state[out]			sp state structure
+ \param	stall[out]			isp stall conditions
+
+ \return none, state = SP[ID].state, stall = SP[ID].stall
+ */
+extern void sp_get_state(
+	const sp_ID_t		ID,
+	sp_state_t			*state,
+	sp_stall_t			*stall);
+
+/*! Write to the status and control register of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return none, SP[ID].sc[reg] = value
+ */
+STORAGE_CLASS_SP_H void sp_ctrl_store(
+	const sp_ID_t		ID,
+	const hrt_address	reg,
+	const hrt_data		value);
+
+/*! Read from the status and control register of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	reg[in]				register index
+ \param value[in]			The data to be written
+
+ \return SP[ID].sc[reg]
+ */
+STORAGE_CLASS_SP_H hrt_data sp_ctrl_load(
+	const sp_ID_t		ID,
+	const hrt_address	reg);
+
+/*! Get the status of a bitfield in the control register of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be checked
+
+ \return  (SP[ID].sc[reg] & (1<<bit)) != 0
+ */
+STORAGE_CLASS_SP_H bool sp_ctrl_getbit(
+	const sp_ID_t		ID,
+	const hrt_address	reg,
+	const unsigned int	bit);
+
+/*! Set a bitfield in the control register of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be set
+
+ \return none, SP[ID].sc[reg] |= (1<<bit)
+ */
+STORAGE_CLASS_SP_H void sp_ctrl_setbit(
+	const sp_ID_t		ID,
+	const hrt_address	reg,
+	const unsigned int	bit);
+
+/*! Clear a bitfield in the control register of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	reg[in]				register index
+ \param bit[in]				The bit index to be set
+
+ \return none, SP[ID].sc[reg] &= ~(1<<bit)
+ */
+STORAGE_CLASS_SP_H void sp_ctrl_clearbit(
+	const sp_ID_t		ID,
+	const hrt_address	reg,
+	const unsigned int	bit);
+
+/*! Write to the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, SP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_SP_H void sp_dmem_store(
+	const sp_ID_t		ID,
+	hrt_address		addr,
+	const void			*data,
+	const size_t		size);
+
+/*! Read from the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = SP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_SP_H void sp_dmem_load(
+	const sp_ID_t		ID,
+	const hrt_address	addr,
+	void			*data,
+	const size_t		size);
+
+/*! Write a 8-bit datum to the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, SP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_SP_H void sp_dmem_store_uint8(
+	const sp_ID_t		ID,
+	hrt_address		addr,
+	const uint8_t		data);
+
+/*! Write a 16-bit datum to the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, SP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_SP_H void sp_dmem_store_uint16(
+	const sp_ID_t		ID,
+	hrt_address		addr,
+	const uint16_t		data);
+
+/*! Write a 32-bit datum to the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be written
+ \param size[in]			The size(in bytes) of the data to be written
+
+ \return none, SP[ID].dmem[addr...addr+size-1] = data
+ */
+STORAGE_CLASS_SP_H void sp_dmem_store_uint32(
+	const sp_ID_t		ID,
+	hrt_address		addr,
+	const uint32_t		data);
+
+/*! Load a 8-bit datum from the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = SP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_SP_H uint8_t sp_dmem_load_uint8(
+	const sp_ID_t		ID,
+	const hrt_address	addr);
+
+/*! Load a 16-bit datum from the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = SP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_SP_H uint16_t sp_dmem_load_uint16(
+	const sp_ID_t		ID,
+	const hrt_address	addr);
+
+/*! Load a 32-bit datum from the DMEM of SP[ID]
+
+ \param	ID[in]				SP identifier
+ \param	addr[in]			the address in DMEM
+ \param data[in]			The data to be read
+ \param size[in]			The size(in bytes) of the data to be read
+
+ \return none, data = SP[ID].dmem[addr...addr+size-1]
+ */
+STORAGE_CLASS_SP_H uint32_t sp_dmem_load_uint32(
+	const sp_ID_t		ID,
+	const hrt_address	addr);
+
+#endif /* __SP_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/tag_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/tag_public.h
new file mode 100644
index 0000000..27b8d80
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/tag_public.h
@@ -0,0 +1,48 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TAG_PUBLIC_H_INCLUDED__
+#define __TAG_PUBLIC_H_INCLUDED__
+
+/**
+ * @brief	Creates the tag description from the given parameters.
+ * @param[in]	num_captures
+ * @param[in]	skip
+ * @param[in]	offset
+ * @param[out]	tag_descr
+ */
+void
+sh_css_create_tag_descr(int num_captures,
+			unsigned int skip,
+			int offset,
+			unsigned int exp_id,
+			struct sh_css_tag_descr *tag_descr);
+
+/**
+ * @brief	Encodes the members of tag description into a 32-bit value.
+ * @param[in]	tag		Pointer to the tag description
+ * @return	(unsigned int)	Encoded 32-bit tag-info
+ */
+unsigned int
+sh_css_encode_tag_descr(struct sh_css_tag_descr *tag);
+
+#endif /* __TAG_PUBLIC_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/timed_ctrl_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/timed_ctrl_public.h
new file mode 100644
index 0000000..726e770
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/timed_ctrl_public.h
@@ -0,0 +1,69 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TIMED_CTRL_PUBLIC_H_INCLUDED__
+#define __TIMED_CTRL_PUBLIC_H_INCLUDED__
+
+#include "system_types.h"
+
+/*! Write to a control register of TIMED_CTRL[ID]
+
+ \param	ID[in]				TIMED_CTRL identifier
+ \param	reg_addr[in]		register byte address
+ \param value[in]			The data to be written
+
+ \return none, TIMED_CTRL[ID].ctrl[reg] = value
+ */
+STORAGE_CLASS_TIMED_CTRL_H void timed_ctrl_reg_store(
+	const timed_ctrl_ID_t	ID,
+	const unsigned int		reg_addr,
+	const hrt_data			value);
+
+extern void timed_ctrl_snd_commnd(
+	const timed_ctrl_ID_t				ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	hrt_address				addr,
+	hrt_data				value);
+
+extern void timed_ctrl_snd_sp_commnd(
+	const timed_ctrl_ID_t				ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	const sp_ID_t			SP_ID,
+	hrt_address				offset,
+	hrt_data				value);
+
+#if !defined(HAS_NO_GPIO)
+extern void timed_ctrl_snd_gpio_commnd(
+	const timed_ctrl_ID_t				ID,
+	hrt_data				mask,
+	hrt_data				condition,
+	hrt_data				counter,
+	const gpio_ID_t			GPIO_ID,
+	hrt_address				offset,
+	hrt_data				value);
+#endif
+
+
+#endif /* __TIMED_CTRL_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/vamem_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/vamem_public.h
new file mode 100644
index 0000000..c56ed9c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/vamem_public.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VAMEM_PUBLIC_H_INCLUDED__
+#define __VAMEM_PUBLIC_H_INCLUDED__
+
+
+
+#endif /* __VAMEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/host/vmem_public.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/vmem_public.h
new file mode 100644
index 0000000..da65def
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/host/vmem_public.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VMEM_PUBLIC_H_INCLUDED__
+#define __VMEM_PUBLIC_H_INCLUDED__
+
+#include "isp.h" /* tmemvectoru */
+
+#endif /* __VMEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/ibuf_ctrl.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/ibuf_ctrl.h
new file mode 100644
index 0000000..c8d9841
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/ibuf_ctrl.h
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IBUF_CTRL_H_INCLUDED__
+#define __IBUF_CTRL_H_INCLUDED__
+
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ * - system and cell agnostic interfaces, constants and identifiers
+ * - public:  system agnostic, cell specific interfaces
+ * - private: system dependent, cell specific interfaces &
+ *   inline implementations
+ * - global:  system specific constants and identifiers
+ * - local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "ibuf_ctrl_local.h"
+
+#ifndef __INLINE_IBUF_CTRL__
+#define STORAGE_CLASS_IBUF_CTRL_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_IBUF_CTRL_C
+#include "ibuf_ctrl_public.h"
+#else  /* __INLINE_IBUF_CTRL__ */
+#define STORAGE_CLASS_IBUF_CTRL_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_IBUF_CTRL_C STORAGE_CLASS_INLINE
+#include "ibuf_ctrl_private.h"
+#endif /* __INLINE_IBUF_CTRL__ */
+
+#endif /* __IBUF_CTRL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/input_formatter.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/input_formatter.h
new file mode 100644
index 0000000..ee96f9a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/input_formatter.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __INPUT_FORMATTER_H_INCLUDED__
+#define __INPUT_FORMATTER_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "input_formatter_local.h"
+
+#ifndef __INLINE_INPUT_FORMATTER__
+#define STORAGE_CLASS_INPUT_FORMATTER_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_INPUT_FORMATTER_C
+#include "input_formatter_public.h"
+#else  /* __INLINE_INPUT_FORMATTER__ */
+#define STORAGE_CLASS_INPUT_FORMATTER_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_INPUT_FORMATTER_C STORAGE_CLASS_INLINE
+#include "input_formatter_private.h"
+#endif /* __INLINE_INPUT_FORMATTER__ */
+
+#endif /* __INPUT_FORMATTER_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/input_system.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/input_system.h
new file mode 100644
index 0000000..5db8ba8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/input_system.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __INPUT_SYSTEM_H_INCLUDED__
+#define __INPUT_SYSTEM_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "input_system_local.h"
+
+#ifndef __INLINE_INPUT_SYSTEM__
+#define STORAGE_CLASS_INPUT_SYSTEM_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_INPUT_SYSTEM_C
+#include "input_system_public.h"
+#else  /* __INLINE_INPUT_SYSTEM__ */
+#define STORAGE_CLASS_INPUT_SYSTEM_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_INPUT_SYSTEM_C STORAGE_CLASS_INLINE
+#include "input_system_private.h"
+#endif /* __INLINE_INPUT_SYSTEM__ */
+
+#endif /* __INPUT_SYSTEM_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/irq.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/irq.h
new file mode 100644
index 0000000..c87c0fc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/irq.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IRQ_H_INCLUDED__
+#define __IRQ_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the IRQ device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "irq_local.h"
+
+#ifndef __INLINE_IRQ__
+#define STORAGE_CLASS_IRQ_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_IRQ_C
+#include "irq_public.h"
+#else  /* __INLINE_IRQ__ */
+#define STORAGE_CLASS_IRQ_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_IRQ_C STORAGE_CLASS_INLINE
+#include "irq_private.h"
+#endif /* __INLINE_IRQ__ */
+
+#endif /* __IRQ_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/isp.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/isp.h
new file mode 100644
index 0000000..01a34db
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/isp.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISP_H_INCLUDED__
+#define __ISP_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the ISP cell. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "isp_local.h"
+
+#ifndef __INLINE_ISP__
+#define STORAGE_CLASS_ISP_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_ISP_C
+#include "isp_public.h"
+#else  /* __INLINE_iSP__ */
+#define STORAGE_CLASS_ISP_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_ISP_C STORAGE_CLASS_INLINE
+#include "isp_private.h"
+#endif /* __INLINE_ISP__ */
+
+#endif /* __ISP_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/isys_dma.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/isys_dma.h
new file mode 100644
index 0000000..5b633cb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/isys_dma.h
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISYS_DMA_H_INCLUDED__
+#define __ISYS_DMA_H_INCLUDED__
+
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ * - system and cell agnostic interfaces, constants and identifiers
+ * - public:  system agnostic, cell specific interfaces
+ * - private: system dependent, cell specific interfaces &
+ *   inline implementations
+ * - global:  system specific constants and identifiers
+ * - local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "isys_dma_local.h"
+
+#ifndef __INLINE_ISYS2401_DMA__
+#define STORAGE_CLASS_ISYS2401_DMA_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_ISYS2401_DMA_C
+#include "isys_dma_public.h"
+#else  /* __INLINE_ISYS2401_DMA__ */
+#define STORAGE_CLASS_ISYS2401_DMA_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_ISYS2401_DMA_C STORAGE_CLASS_INLINE
+#include "isys_dma_private.h"
+#endif /* __INLINE_ISYS2401_DMA__ */
+
+#endif /* __ISYS_DMA_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/isys_stream2mmio.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/isys_stream2mmio.h
new file mode 100644
index 0000000..363a641
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/isys_stream2mmio.h
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __ISYS_STREAM2MMIO_H_INCLUDED__
+#define __ISYS_STREAM2MMIO_H_INCLUDED__
+
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ * - system and cell agnostic interfaces, constants and identifiers
+ * - public:  system agnostic, cell specific interfaces
+ * - private: system dependent, cell specific interfaces &
+ *   inline implementations
+ * - global:  system specific constants and identifiers
+ * - local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "isys_stream2mmio_local.h"
+
+#ifndef __INLINE_STREAM2MMIO__
+#define STORAGE_CLASS_STREAM2MMIO_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_STREAM2MMIO_C
+#include "isys_stream2mmio_public.h"
+#else  /* __INLINE_STREAM2MMIO__ */
+#define STORAGE_CLASS_STREAM2MMIO_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_STREAM2MMIO_C STORAGE_CLASS_INLINE
+#include "isys_stream2mmio_private.h"
+#endif /* __INLINE_STREAM2MMIO__ */
+
+#endif /* __ISYS_STREAM2MMIO_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/math_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/math_support.h
new file mode 100644
index 0000000..8bf12ed
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/math_support.h
@@ -0,0 +1,405 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MATH_SUPPORT_H_INCLUDED__
+#define __MATH_SUPPORT_H_INCLUDED__
+
+/* ceil((real)a / b) */
+#define ceil_div(a,b) (((a)+(b)-1)/(b))
+#define IS_ODD(a) ((a) & 0x1)
+#define IS_EVEN(a) (!IS_ODD(a))
+
+/* force a value to a lower even value */
+#define EVEN_FLOOR(x)	(x & ~1)
+
+/* A => B */
+#define IMPLIES(a, b) (!(a) || (b))
+
+#if defined(_MSC_VER)
+
+/* MSC already provides min/max */
+/*#define min(a, b) ((a) < (b) ? (a) : (b)) */
+/*#define max(a, b) ((a) > (b) ? (a) : (b)) */
+#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
+#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
+
+#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
+#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
+#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
+#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
+#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
+#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
+#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
+#define OP_std_modadd(base, offset, size) ((base+offset)%(size))
+
+#ifndef SH_CSS_CEIL_INLINE
+#define MAX(a, b)	 	_MAX(a,b)
+#define CEIL_MUL(a, b)		_CEIL_MUL(a, b)
+#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
+#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
+#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
+
+#else /* SH_CSS_CEIL_INLINE */
+
+#define MAX(a, b)	 	_max(a,b)
+#define CEIL_MUL(a, b)		_ceil_mul(a, b)
+#define CEIL_DIV(a, b)   	_ceil_div(a, b)
+#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
+#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
+
+static __inline unsigned _max(unsigned a, unsigned b)
+{
+	return _MAX(a,b);
+}
+
+static __inline unsigned _min(unsigned a, unsigned b)
+{
+	return _MIN(a,b);
+}
+
+static __inline unsigned _ceil_div(unsigned a, unsigned b)
+{
+	return _CEIL_DIV(a,b);
+}
+
+static inline unsigned _ceil_mul(unsigned a, unsigned b)
+{
+	return _CEIL_MUL(a,b);
+}
+
+static __inline unsigned _ceil_shift(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT(a,b);
+}
+
+static __inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT_MUL(a,b);
+}
+
+static __inline unsigned _ceil_mul2(unsigned a, unsigned b)
+{
+	return _CEIL_MUL2(a,b);
+}
+
+#endif /* SH_CSS_CEIL_INLINE */
+
+#elif defined(__HIVECC)
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#define max(a, b) ((a) > (b) ? (a) : (b))
+#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
+/* the HIVE operator clip() is an assymetric bound() */
+#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
+
+#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
+#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
+#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
+#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
+#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
+#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
+#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
+
+#ifndef SH_CSS_CEIL_INLINE
+#define MAX(a, b)	 	_MAX(a,b)
+#define CEIL_MUL(a, b)		_CEIL_MUL(a, b)
+#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
+#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
+#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
+
+#else /* SH_CSS_CEIL_INLINE */
+
+#define MAX(a, b)	 	_max(a,b)
+#define CEIL_MUL(a, b)		_ceil_mul(a, b)
+#define CEIL_DIV(a, b)   	_ceil_div(a, b)
+#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
+#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
+
+static inline unsigned _max(unsigned a, unsigned b)
+{
+	return _MAX(a,b);
+}
+
+static inline unsigned _min(unsigned a, unsigned b)
+{
+	return _MIN(a,b);
+}
+
+static inline unsigned _ceil_div(unsigned a, unsigned b)
+{
+	return _CEIL_DIV(a,b);
+}
+
+static inline unsigned _ceil_mul(unsigned a, unsigned b)
+{
+	return _CEIL_MUL(a,b);
+}
+
+static inline unsigned _ceil_shift(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT(a,b);
+}
+
+static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT_MUL(a,b);
+}
+
+static inline unsigned _ceil_mul2(unsigned a, unsigned b)
+{
+	return _CEIL_MUL2(a,b);
+}
+
+#endif /* SH_CSS_CEIL_INLINE */
+
+#elif defined(__KERNEL__)
+
+#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
+#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
+#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
+#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
+#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
+#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
+#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
+#define OP_std_modadd(base, offset, size) ((base+offset)%(size))
+
+#ifndef SH_CSS_CEIL_INLINE
+#define MAX(a, b)	 	_MAX(a,b)
+#define CEIL_MUL(a, b)		_CEIL_MUL(a, b)
+#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
+#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
+#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
+
+#else /* SH_CSS_CEIL_INLINE */
+
+#define MAX(a, b)	 	_max(a,b)
+#define CEIL_MUL(a, b)		_ceil_mul(a, b)
+#define CEIL_DIV(a, b)   	_ceil_div(a, b)
+#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
+#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
+
+static inline unsigned _max(unsigned a, unsigned b)
+{
+	return _MAX(a,b);
+}
+
+static inline unsigned _min(unsigned a, unsigned b)
+{
+	return _MIN(a,b);
+}
+
+static inline unsigned _ceil_div(unsigned a, unsigned b)
+{
+	return _CEIL_DIV(a,b);
+}
+
+static inline unsigned _ceil_mul(unsigned a, unsigned b)
+{
+	return _CEIL_MUL(a,b);
+}
+
+static inline unsigned _ceil_shift(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT(a,b);
+}
+
+static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT_MUL(a,b);
+}
+
+static inline unsigned _ceil_mul2(unsigned a, unsigned b)
+{
+	return _CEIL_MUL2(a,b);
+}
+
+#endif /* SH_CSS_CEIL_INLINE */
+
+#elif defined(__FIST__)
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#define max(a, b) ((a) > (b) ? (a) : (b))
+#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
+#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
+
+#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
+#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
+#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
+#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
+#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
+#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
+#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
+
+#ifndef SH_CSS_CEIL_INLINE
+#define MAX(a, b)	 	_MAX(a,b)
+#define CEIL_MUL(a, b)		_CEIL_MUL(a, b)
+#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
+#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
+#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
+
+#else /* SH_CSS_CEIL_INLINE */
+
+#define MAX(a, b)	 	_max(a,b)
+#define CEIL_MUL(a, b)		_ceil_mul(a, b)
+#define CEIL_DIV(a, b)   	_ceil_div(a, b)
+#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
+#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
+
+static inline unsigned _max(unsigned a, unsigned b)
+{
+	return _MAX(a,b);
+}
+
+static inline unsigned _min(unsigned a, unsigned b)
+{
+	return _MIN(a,b);
+}
+
+static inline unsigned _ceil_div(unsigned a, unsigned b)
+{
+	return _CEIL_DIV(a,b);
+}
+
+static inline unsigned _ceil_mul(unsigned a, unsigned b)
+{
+	return _CEIL_MUL(a,b);
+}
+
+static inline unsigned _ceil_shift(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT(a,b);
+}
+
+static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT_MUL(a,b);
+}
+
+static inline unsigned _ceil_mul2(unsigned a, unsigned b)
+{
+	return _CEIL_MUL2(a,b);
+}
+
+#endif /* SH_CSS_CEIL_INLINE */
+
+#elif defined(__GNUC__)
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+#define max(a, b) ((a) > (b) ? (a) : (b))
+/*
+#define min(a, b) ({ \
+	__typeof__ (a) _a = (a); \
+	__typeof__ (b) _b = (b); \
+	_a < _b ? _a : _b; })
+
+#define max(a, b) ({ \
+	__typeof__ (a) _a = (a); \
+	__typeof__ (b) _b = (b); \
+	_a > _b ? _a : _b; })
+ */
+#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
+#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
+
+#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
+#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
+#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
+#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
+#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
+#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
+#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
+#if !defined(__ISP) && !defined(__SP)
+/*
+ * For SP and ISP, SDK provides the definition of OP_std_modadd.
+ * We need it only for host
+ */
+#define OP_std_modadd(base, offset, size) ((base+offset)%(size))
+#endif
+
+#ifndef SH_CSS_CEIL_INLINE
+#define MAX(a, b)	 	_MAX(a,b)
+#define CEIL_MUL(a, b)		_CEIL_MUL(a, b)
+#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
+#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
+#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
+#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
+
+#else /* SH_CSS_CEIL_INLINE */
+
+#define MAX(a, b)	 	_max(a,b)
+#define CEIL_MUL(a, b)		_ceil_mul(a, b)
+#define CEIL_DIV(a, b)   	_ceil_div(a, b)
+#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
+
+#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
+#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
+
+static inline unsigned _max(unsigned a, unsigned b)
+{
+	return _MAX(a,b);
+}
+
+static inline unsigned _min(unsigned a, unsigned b)
+{
+	return _MIN(a,b);
+}
+
+static inline unsigned _ceil_div(unsigned a, unsigned b)
+{
+	return _CEIL_DIV(a,b);
+}
+
+static inline unsigned _ceil_mul(unsigned a, unsigned b)
+{
+	return _CEIL_MUL(a,b);
+}
+
+static inline unsigned _ceil_shift(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT(a,b);
+}
+
+static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
+{
+	return _CEIL_SHIFT_MUL(a,b);
+}
+
+static inline unsigned _ceil_mul2(unsigned a, unsigned b)
+{
+	return _CEIL_MUL2(a,b);
+}
+
+#endif /* SH_CSS_CEIL_INLINE */
+
+#else /* default is for an unknown environment */
+
+/* already defined */
+
+#endif
+
+#endif /* __MATH_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/memory_access/memory_access.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/memory_access/memory_access.h
new file mode 100644
index 0000000..e70f7e3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/memory_access/memory_access.h
@@ -0,0 +1,287 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MEMORY_ACCESS_H_INCLUDED__
+#define __MEMORY_ACCESS_H_INCLUDED__
+
+/*!
+ * \brief
+ * Define the public interface for virtual memory
+ * access functions. Access types are limited to
+ * those defined in <stdint.h>
+ *
+ * The address representation is private to the system
+ * and represented as "hrt_vaddress" rather than a
+ * pointer, as the memory allocation cannot be accessed
+ * by dereferencing but reaquires load and store access
+ * functions
+ *
+ * The page table selection or virtual memory context;
+ * The page table base index; Is implicit. This page
+ * table base index must be set by the implementation
+ * of the access function
+ *
+ * "store" is a transfer to the system
+ * "load" is a transfer from the system
+ *
+ * Allocation properties can be specified by setting
+ * attributes (see below) in case of multiple physical
+ * memories the memory ID is encoded on the attribute
+ *
+ * Allocations in the same physical memory, but in a
+ * different (set of) page tables can be shared through
+ * a page table information mapping function
+ */
+
+#include <type_support.h>
+
+/*
+ * User provided file that defines the (sub)system address types:
+ *	- hrt_vaddress	a type that can hold the (sub)system virtual address range
+ */
+#include "system_types.h"
+
+/*
+ * The MMU base address is a physical address, thus the same type is used
+ * as for the device base address
+ */
+#include "device_access.h"
+
+/*!
+ * \brief
+ * Bit masks for specialised allocation functions
+ * the default is "uncached", "not contiguous",
+ * "not page aligned" and "not cleared"
+ *
+ * Forcing alignment (usually) returns a pointer
+ * at an alignment boundary that is offset from
+ * the allocated pointer. Without storing this
+ * pointer/offset, we cannot free it. The memory
+ * manager is responsible for the bookkeeping, e.g.
+ * the allocation function creates a sentinel
+ * within the allocation referencable from the
+ * returned pointer/address.
+ */
+#define MMGR_ATTRIBUTE_MASK			0x000f
+#define MMGR_ATTRIBUTE_CACHED		0x0001
+#define MMGR_ATTRIBUTE_CONTIGUOUS	0x0002
+#define MMGR_ATTRIBUTE_PAGEALIGN	0x0004
+#define MMGR_ATTRIBUTE_CLEARED		0x0008
+#define MMGR_ATTRIBUTE_UNUSED		0xfff0
+
+/* #define MMGR_ATTRIBUTE_DEFAULT	(MMGR_ATTRIBUTE_CACHED) */
+#define MMGR_ATTRIBUTE_DEFAULT	0
+
+extern const hrt_vaddress	mmgr_NULL;
+extern const hrt_vaddress	mmgr_EXCEPTION;
+
+/*! Set the (sub)system virtual memory page table base address
+
+ \param	base_addr[in]		The address where page table 0 is located
+
+ \Note: The base_addr is an absolute system address, thus it is not
+        relative to the DDR base address
+
+ \return none,
+ */
+extern void mmgr_set_base_address(
+	const sys_address		base_addr);
+
+/*! Get the (sub)system virtual memory page table base address
+
+ \return base_address,
+ */
+/* unused */
+extern sys_address mmgr_get_base_address(void);
+
+
+/*! Set the (sub)system virtual memory page table base index
+
+ \param	base_addr[in]		The index  where page table 0 is located
+
+ \Note: The base_index is the MSB section of an absolute system address,
+        the in-page address bits are discared. The base address is not
+		relative to the DDR base address
+
+ \return none,
+ */
+/* unused */
+extern void mmgr_set_base_index(
+	const hrt_data			base_index);
+
+/*! Get the (sub)system virtual memory page table base index
+
+ \return base_address,
+ */
+/* unused */
+extern hrt_data mmgr_get_base_index(void);
+
+/*! Return the address of an allocation in memory
+
+ \param	size[in]			Size in bytes of the allocation
+
+ \return vaddress
+ */
+extern hrt_vaddress mmgr_malloc(
+	const size_t			size);
+
+/*! Return the address of a zero initialised allocation in memory
+
+ \param	size[in]			Size in bytes of the allocation
+
+ \return vaddress
+ */
+extern hrt_vaddress mmgr_calloc(
+	const size_t			N,
+	const size_t			size);
+
+/*! Return the address of a reallocated allocation in memory
+
+ \param	vaddr[in]			Address of an allocation
+ \param	size[in]			Size in bytes of the allocation
+
+ \Note
+	All limitations and particularities of the C stdlib
+	realloc function apply
+
+ \return vaddress
+ */
+/* unused */
+extern hrt_vaddress mmgr_realloc(
+	hrt_vaddress			vaddr,
+	const size_t			size);
+
+/*! Free the memory allocation identified by the address
+
+ \param	vaddr[in]			Address of the allocation
+
+ \return vaddress
+ */
+extern void mmgr_free(
+	hrt_vaddress			vaddr);
+
+/*! Return the address of an allocation in memory
+
+ \param	size[in]			Size in bytes of the allocation
+ \param	attribute[in]		Bit vector specifying the properties
+							of the allocation including zero
+							initialisation
+
+ \return vaddress
+ */
+extern hrt_vaddress mmgr_alloc_attr(
+	const size_t			size,
+	const uint16_t			attribute);
+
+/*! Return the address of a reallocated allocation in memory
+
+ \param	vaddr[in]			Address of an allocation
+ \param	size[in]			Size in bytes of the allocation
+ \param	attribute[in]		Bit vector specifying the properties
+							of the allocation
+
+ \Note
+	All limitations and particularities of the C stdlib
+	realloc function apply
+
+ \return vaddress
+ */
+/* unused */
+extern hrt_vaddress mmgr_realloc_attr(
+	hrt_vaddress			vaddr,
+	const size_t			size,
+	const uint16_t			attribute);
+
+/*! Return the address of a mapped existing allocation in memory
+
+ \param	ptr[in]				Pointer to an allocation in a different
+					virtual memory page table, but the same
+					physical memory
+ \param size[in]			Size of the memory of the pointer
+ \param	attribute[in]			Bit vector specifying the properties
+					of the allocation
+ \param context				Pointer of a context provided by
+					client/driver for additonal parameters
+					needed by the implementation
+ \Note
+	This interface is tentative, limited to the desired function
+	the actual interface may require furhter parameters
+
+ \return vaddress
+ */
+extern hrt_vaddress mmgr_mmap(
+	const void *ptr,
+	const size_t size,
+	uint16_t attribute,
+	void *context);
+
+/*! Zero initialise an allocation in memory
+
+ \param	vaddr[in]			Address of an allocation
+ \param	size[in]			Size in bytes of the area to be cleared
+
+ \return none
+ */
+extern void mmgr_clear(
+	hrt_vaddress			vaddr,
+	const size_t			size);
+
+/*! Set an allocation in memory to a value
+
+ \param	vaddr[in]			Address of an allocation
+ \param	data[in]			Value to set
+ \param	size[in]			Size in bytes of the area to be set
+
+ \return none
+ */
+/* unused */
+extern void mmgr_set(
+	hrt_vaddress			vaddr,
+	const uint8_t			data,
+	const size_t			size);
+
+/*! Read an array of bytes from a virtual memory address
+
+ \param	vaddr[in]			Address of an allocation
+ \param	data[out]			pointer to the destination array
+ \param	size[in]			number of bytes to read
+
+ \return none
+ */
+extern void mmgr_load(
+	const hrt_vaddress		vaddr,
+	void					*data,
+	const size_t			size);
+
+/*! Write an array of bytes to device registers or memory in the device
+
+ \param	vaddr[in]			Address of an allocation
+ \param	data[in]			pointer to the source array
+ \param	size[in]			number of bytes to write
+
+ \return none
+ */
+extern void mmgr_store(
+	const hrt_vaddress		vaddr,
+	const void				*data,
+	const size_t			size);
+
+#endif /* __MEMORY_ACCESS_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/mmu_device.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/mmu_device.h
new file mode 100644
index 0000000..d4df4dc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/mmu_device.h
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MMU_DEVICE_H_INCLUDED__
+#define __MMU_DEVICE_H_INCLUDED__
+
+/* The file mmu.h already exists */
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the MMU device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "mmu_local.h"
+
+#ifndef __INLINE_MMU__
+#define STORAGE_CLASS_MMU_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_MMU_C
+#include "mmu_public.h"
+#else  /* __INLINE_MMU__ */
+#define STORAGE_CLASS_MMU_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_MMU_C STORAGE_CLASS_INLINE
+#include "mmu_private.h"
+#endif /* __INLINE_MMU__ */
+
+#endif /* __MMU_DEVICE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/mpmath.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/mpmath.h
new file mode 100644
index 0000000..d335708
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/mpmath.h
@@ -0,0 +1,298 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MPMATH_H_INCLUDED__
+#define __MPMATH_H_INCLUDED__
+
+#ifdef INLINE_MPMATH
+#if defined(MSVC)
+#define STORAGE_CLASS_MPMATH_FUNC_H static __inline
+#else
+#define STORAGE_CLASS_MPMATH_FUNC_H static inline
+#endif
+#define STORAGE_CLASS_MPMATH_DATA_H static const
+#else /* INLINE_MPMATH */
+#define STORAGE_CLASS_MPMATH_FUNC_H extern
+#define STORAGE_CLASS_MPMATH_DATA_H extern const
+#endif  /* INLINE_MPMATH */
+
+#include <stdint.h>
+#include <stdbool.h>
+
+/*
+ * Implementation limits
+ */
+#define MIN_BITDEPTH            1
+#define MAX_BITDEPTH            64
+
+#define ROUND_NEAREST_EVEN  0
+#define ROUND_NEAREST       1
+
+/*
+ * The MP types
+ *
+ * "vector lane data" is scalar. With "scalar data" for limited range shift and address values
+ */
+typedef unsigned long long      mpudata_t;   /* Type of reference MP scalar / vector lane data; unsigned */
+typedef long long               mpsdata_t;   /* Type of reference MP scalar / vector lane data; signed */
+typedef unsigned short          spudata_t;   /* Type of reference SP scalar / vector lane data; unsigned */
+typedef short                   spsdata_t;   /* Type of reference SP scalar / vector lane data; signed */
+typedef unsigned short          bitdepth_t;
+
+typedef enum {
+    mp_zero_ID,
+    mp_one_ID,
+    mp_mone_ID,
+    mp_smin_ID,
+    mp_smax_ID,
+    mp_umin_ID,
+    mp_umax_ID,
+    N_mp_const_ID
+} mp_const_ID_t;
+
+STORAGE_CLASS_MPMATH_FUNC_H bool isValidMpsdata(
+    const mpsdata_t             data,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H bool isValidMpudata(
+    const mpudata_t             data,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_castd (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_casth (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_scasth (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_qcastd (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_qcasth (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_qrcasth (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_abs (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_limit (
+    const mpsdata_t             bnd_low,
+    const mpsdata_t             in0,
+    const mpsdata_t             bnd_high,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_max (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_min (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_mux (
+    const spudata_t             sel,
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_rmux (
+    const spudata_t             sel,
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_add (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_sadd (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_sub (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_ssub (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_addasr1 (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_subasr1 (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_lsr (
+    const mpsdata_t             in0,
+    const spsdata_t             shft,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_asr (
+    const mpsdata_t             in0,
+    const spsdata_t             shft,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_rasr (
+    const mpsdata_t             in0,
+    const spsdata_t             shft,
+    const bitdepth_t            bitdepth);
+
+/* "mp_rasr_u()" is implemented by "mp_rasr()" */
+STORAGE_CLASS_MPMATH_FUNC_H mpudata_t mp_rasr_u (
+    const mpudata_t             in0,
+    const spsdata_t             shft,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_lsl (
+    const mpsdata_t             in0,
+    const spsdata_t             shft,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_asl (
+    const mpsdata_t             in0,
+    const spsdata_t             shft,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_muld (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_mul (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_qmul (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_and (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_compl (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_or (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_xor (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isEQ (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isNE (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isGT (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isGE (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isLT (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isLE (
+    const mpsdata_t             in0,
+    const mpsdata_t             in1,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isEQZ (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isNEZ (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isGTZ (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isGEZ (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isLTZ (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H spudata_t mp_isLEZ (
+    const mpsdata_t             in0,
+    const bitdepth_t            bitdepth);
+
+STORAGE_CLASS_MPMATH_FUNC_H mpsdata_t mp_const (
+    const mp_const_ID_t         ID,
+    const bitdepth_t            bitdepth);
+
+#ifndef INLINE_MPMATH
+#define STORAGE_CLASS_MPMATH_FUNC_C
+#define STORAGE_CLASS_MPMATH_DATA_C const
+#else /* INLINE_MPMATH */
+#define STORAGE_CLASS_MPMATH_FUNC_C STORAGE_CLASS_MPMATH_FUNC_H
+#define STORAGE_CLASS_MPMATH_DATA_C STORAGE_CLASS_MPMATH_DATA_H
+#include "mpmath.c"
+#define MPMATH_INLINED
+#endif  /* INLINE_MPMATH */
+
+#endif /* __MPMATH_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/pixelgen.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/pixelgen.h
new file mode 100644
index 0000000..0b314f1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/pixelgen.h
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __PIXELGEN_H_INCLUDED__
+#define __PIXELGEN_H_INCLUDED__
+
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ * - system and cell agnostic interfaces, constants and identifiers
+ * - public:  system agnostic, cell specific interfaces
+ * - private: system dependent, cell specific interfaces &
+ *   inline implementations
+ * - global:  system specific constants and identifiers
+ * - local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "pixelgen_local.h"
+
+#ifndef __INLINE_PIXELGEN__
+#define STORAGE_CLASS_PIXELGEN_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_PIXELGEN_C
+#include "pixelgen_public.h"
+#else  /* __INLINE_PIXELGEN__ */
+#define STORAGE_CLASS_PIXELGEN_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_PIXELGEN_C STORAGE_CLASS_INLINE
+#include "pixelgen_private.h"
+#endif /* __INLINE_PIXELGEN__ */
+
+#endif /* __PIXELGEN_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/platform_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/platform_support.h
new file mode 100644
index 0000000..5ea7938
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/platform_support.h
@@ -0,0 +1,101 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __PLATFORM_SUPPORT_H_INCLUDED__
+#define __PLATFORM_SUPPORT_H_INCLUDED__
+
+#if defined(_MSC_VER)
+/*
+ * Put here everything _MSC_VER specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+#include "hrt/defs.h"
+#include "storage_class.h"
+#include <stdio.h>
+#include <string.h>
+
+STORAGE_CLASS_INLINE void
+hrt_sleep(void)
+{
+	/* Empty for now. Polling is not used in many places */
+}
+
+/* Ignore warning 4505: Unreferenced local function has been removed */
+#pragma warning(disable: 4505)
+
+#define CSS_ALIGN(d, a) _declspec(align(a)) d
+#define inline      __inline
+#define __func__    __FUNCTION__
+
+#define snprintf(buffer, size, ...) \
+	_snprintf_s(buffer, size, size, __VA_ARGS__)
+
+#elif defined(__HIVECC)
+/*
+ * Put here everything __HIVECC specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+#include <string.h>
+#define CSS_ALIGN(d, a) d __attribute__((aligned(a)))
+
+#elif defined(__KERNEL__)
+#include "storage_class.h"
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/* For definition of hrt_sleep() */
+static inline void hrt_sleep(void)
+{
+	udelay(1);
+}
+
+#define UINT16_MAX USHRT_MAX
+#define UINT32_MAX UINT_MAX
+#define UCHAR_MAX  (255)
+
+#define CSS_ALIGN(d, a) d __attribute__((aligned(a)))
+
+/*
+ * Put here everything __KERNEL__ specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+
+#elif defined(__GNUC__)
+/*
+ * Put here everything __GNUC__ specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+#include "hrt/host.h"
+#include <string.h>
+#include <stdio.h>
+
+#define CSS_ALIGN(d, a) d __attribute__((aligned(a)))
+
+#else /* default is for the FIST environment */
+/*
+ * Put here everything FIST specific not covered in
+ * "assert_support.h", "math_support.h", etc
+ */
+#include <string.h>
+#endif
+
+#endif /* __PLATFORM_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/print_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/print_support.h
new file mode 100644
index 0000000..2888987
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/print_support.h
@@ -0,0 +1,38 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __PRINT_SUPPORT_H_INCLUDED__
+#define __PRINT_SUPPORT_H_INCLUDED__
+
+#include <stdarg.h> /* for va_start, va_list, va_end */
+
+extern int (*sh_css_printf) (const char *fmt, va_list args);
+/* depends on host supplied print function in ia_css_init() */
+static __inline void ia_css_print(const char *fmt, ...)
+{
+	va_list ap;
+	if (sh_css_printf) {
+		va_start(ap, fmt);
+		sh_css_printf(fmt, ap);
+		va_end(ap);
+	}
+}
+#endif /* __PRINT_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/queue.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/queue.h
new file mode 100644
index 0000000..db98b10
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/queue.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __QUEUE_H_INCLUDED__
+#define __QUEUE_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and is system agnostic
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - system and cell agnostic interfaces, constants and identifiers
+ *	- public:  cell specific interfaces
+ *	- private: cell specific inline implementations
+ *	- global:  inter cell constants and identifiers
+ *	- local:   cell specific constants and identifiers
+ *
+ */
+
+#include <storage_class.h>
+
+#include "queue_local.h"
+
+#ifndef __INLINE_QUEUE__
+#define STORAGE_CLASS_QUEUE_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_QUEUE_C
+/* #include "queue_public.h" */
+#include "ia_css_queue.h"
+#else  /* __INLINE_QUEUE__ */
+#define STORAGE_CLASS_QUEUE_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_QUEUE_C STORAGE_CLASS_INLINE
+#include "queue_private.h"
+#endif /* __INLINE_QUEUE__ */
+
+#endif /* __QUEUE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/resource.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/resource.h
new file mode 100644
index 0000000..4afb64c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/resource.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __RESOURCE_H_INCLUDED__
+#define __RESOURCE_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses a RESOURCE manager. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "resource_local.h"
+
+#ifndef __INLINE_RESOURCE__
+#define STORAGE_CLASS_RESOURCE_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_RESOURCE_C
+#include "resource_public.h"
+#else  /* __INLINE_RESOURCE__ */
+#define STORAGE_CLASS_RESOURCE_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_RESOURCE_C STORAGE_CLASS_INLINE
+#include "resource_private.h"
+#endif /* __INLINE_RESOURCE__ */
+
+#endif /* __RESOURCE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/socket.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/socket.h
new file mode 100644
index 0000000..859437b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/socket.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SOCKET_H_INCLUDED__
+#define __SOCKET_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the DMA device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "socket_local.h"
+
+#ifndef __INLINE_SOCKET__
+#define STORAGE_CLASS_SOCKET_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_SOCKET_C
+#include "socket_public.h"
+#else  /* __INLINE_SOCKET__ */
+#define STORAGE_CLASS_SOCKET_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_SOCKET_C STORAGE_CLASS_INLINE
+#include "socket_private.h"
+#endif /* __INLINE_SOCKET__ */
+
+#endif /* __SOCKET_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/sp.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/sp.h
new file mode 100644
index 0000000..105d2a2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/sp.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SP_H_INCLUDED__
+#define __SP_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the SP cell. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "sp_local.h"
+
+#ifndef __INLINE_SP__
+#define STORAGE_CLASS_SP_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_SP_C
+#include "sp_public.h"
+#else  /* __INLINE_SP__ */
+#define STORAGE_CLASS_SP_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_SP_C STORAGE_CLASS_INLINE
+#include "sp_private.h"
+#endif /* __INLINE_SP__ */
+
+#endif /* __SP_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/storage_class.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/storage_class.h
new file mode 100644
index 0000000..8f8f156
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/storage_class.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __STORAGE_CLASS_H_INCLUDED__
+#define __STORAGE_CLASS_H_INCLUDED__
+
+#define STORAGE_CLASS_EXTERN extern
+
+#if defined(_MSC_VER)
+#define STORAGE_CLASS_INLINE static __inline
+#elif defined(__HIVECC)
+#define STORAGE_CLASS_INLINE static inline
+#else
+#define STORAGE_CLASS_INLINE static inline
+#endif
+
+#endif /* __STORAGE_CLASS_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/stream_buffer.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/stream_buffer.h
new file mode 100644
index 0000000..d188b7f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/stream_buffer.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __STREAM_BUFFER_H_INCLUDED__
+#define __STREAM_BUFFER_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the DMA device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "stream_buffer_local.h"
+
+#ifndef __INLINE_STREAM_BUFFER__
+#define STORAGE_CLASS_STREAM_BUFFER_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_STREAM_BUFFER_C
+#include "stream_buffer_public.h"
+#else  /* __INLINE_STREAM_BUFFER__ */
+#define STORAGE_CLASS_STREAM_BUFFER_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_STREAM_BUFFER_C STORAGE_CLASS_INLINE
+#include "stream_buffer_private.h"
+#endif /* __INLINE_STREAM_BUFFER__ */
+
+#endif /* __STREAM_BUFFER_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/string_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/string_support.h
new file mode 100644
index 0000000..ba31f84
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/string_support.h
@@ -0,0 +1,174 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __STRING_SUPPORT_H_INCLUDED__
+#define __STRING_SUPPORT_H_INCLUDED__
+#include <platform_support.h>
+#include <type_support.h>
+#include <storage_class.h>
+
+#if !defined(_MSC_VER)
+/*
+ * For all non microsoft cases, we need the following functions
+ */
+
+
+/** @brief Copy from src_buf to dest_buf.
+ *
+ * @param[out] dest_buf. Destination buffer to copy to
+ * @param[in]  dest_size. The size of the destination buffer in bytes
+ * @param[in]  src_buf. The source buffer
+ * @param[in]  src_size. The size of the source buffer in bytes
+ * @return     0 on success, error code on failure
+ * @return     EINVAL on Invalid arguments
+ * @return     ERANGE on Destination size too small
+ */
+STORAGE_CLASS_INLINE int memcpy_s(
+	void* dest_buf,
+	size_t dest_size,
+	const void* src_buf,
+	size_t src_size)
+{
+	if ((src_buf == NULL) || (dest_buf == NULL)) {
+		/* Invalid arguments*/
+		return EINVAL;
+	}
+
+	if ((dest_size < src_size) || (src_size == 0)) {
+		/* Destination too small*/
+		return ERANGE;
+	}
+
+	memcpy(dest_buf, src_buf, src_size);
+	return 0;
+}
+
+/** @brief Get the length of the string, excluding the null terminator
+ *
+ * @param[in]  src_str. The source string
+ * @param[in]  max_len. Look only for max_len bytes in the string
+ * @return     Return the string length excluding null character
+ * @return     Return max_len if no null character in the first max_len bytes
+ * @return     Returns 0 if src_str is NULL
+ */
+static size_t strnlen_s(
+	const char* src_str,
+	size_t max_len)
+{
+	size_t ix;
+	if (src_str == NULL) {
+		/* Invalid arguments*/
+		return 0;
+	}
+
+	for (ix=0;
+		((src_str[ix] != '\0') && (ix< max_len));
+		++ix) /*Nothing else to do*/;
+
+	/* On Error, it will return src_size == max_len*/
+	return ix;
+}
+
+/** @brief Copy string from src_str to dest_str
+ *
+ * @param[out] dest_str. Destination buffer to copy to
+ * @param[in]  dest_size. The size of the destination buffer in bytes
+ * @param[in]  src_str. The source buffer
+ * @param[in]  src_size. The size of the source buffer in bytes
+ * @return     Returns 0 on success
+ * @return     Returns EINVAL on invalid arguments
+ * @return     Returns ERANGE on destination size too small
+ */
+STORAGE_CLASS_INLINE int strncpy_s(
+	char* dest_str,
+	size_t dest_size,
+	const char* src_str,
+	size_t src_size)
+{
+	size_t len;
+	if (dest_str == NULL) {
+		/* Invalid arguments*/
+		return EINVAL;
+	}
+
+	if ((src_str == NULL) || (dest_size == 0)) {
+		/* Invalid arguments*/
+		dest_str[0] = '\0';
+		return EINVAL;
+	}
+
+	len = strnlen_s(src_str, src_size);
+
+	if (len >= dest_size) {
+		/* Destination too small*/
+		dest_str[0] = '\0';
+		return ERANGE;
+	}
+
+	/* dest_str is big enough for the len */
+	strncpy(dest_str, src_str, len);
+	dest_str[len+1] = '\0';
+	return 0;
+}
+
+/** @brief Copy string from src_str to dest_str
+ *
+ * @param[out] dest_str. Destination buffer to copy to
+ * @param[in]  dest_size. The size of the destination buffer in bytes
+ * @param[in]  src_str. The source buffer
+ * @return     Returns 0 on success
+ * @return     Returns EINVAL on invalid arguments
+ * @return     Returns ERANGE on destination size too small
+ */
+STORAGE_CLASS_INLINE int strcpy_s(
+	char* dest_str,
+	size_t dest_size,
+	const char* src_str)
+{
+	size_t len;
+	if (dest_str == NULL) {
+		/* Invalid arguments*/
+		return EINVAL;
+	}
+
+	if ((src_str == NULL) || (dest_size == 0)) {
+		/* Invalid arguments*/
+		dest_str[0] = '\0';
+		return EINVAL;
+	}
+
+	len = strnlen_s(src_str, dest_size);
+
+	if (len >= dest_size) {
+		/* Destination too small*/
+		dest_str[0] = '\0';
+		return ERANGE;
+	}
+
+	/* dest_str is big enough for the len */
+	strncpy(dest_str, src_str, len);
+	dest_str[len+1] = '\0';
+	return 0;
+}
+
+#endif /*!defined(_MSC_VER)*/
+
+#endif /* __STRING_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/system_types.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/system_types.h
new file mode 100644
index 0000000..f9cbfe6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/system_types.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SYSTEM_TYPES_H_INCLUDED__
+#define __SYSTEM_TYPES_H_INCLUDED__
+
+#include "system_local.h"
+
+#endif /* __SYSTEM_TYPES_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/tag.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/tag.h
new file mode 100644
index 0000000..fe835f9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/tag.h
@@ -0,0 +1,53 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TAG_H_INCLUDED__
+#define __TAG_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and is system agnostic
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  cell specific interfaces
+ *	- private: cell specific inline implementations
+ *	- global:  inter cell constants and identifiers
+ *	- local:   cell specific constants and identifiers
+ *
+ */
+
+#include "storage_class.h"
+
+#include "tag_local.h"
+
+#ifndef __INLINE_TAG__
+#define STORAGE_CLASS_TAG_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_TAG_C
+#include "tag_public.h"
+#else  /* __INLINE_TAG__ */
+#define STORAGE_CLASS_TAG_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_TAG_C STORAGE_CLASS_INLINE
+#include "tag_private.h"
+#endif /* __INLINE_TAG__ */
+
+#endif /* __TAG_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/timed_ctrl.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/timed_ctrl.h
new file mode 100644
index 0000000..1e70d07
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/timed_ctrl.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TIMED_CTRL_H_INCLUDED__
+#define __TIMED_CTRL_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the input system device(s). It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "timed_ctrl_local.h"
+
+#ifndef __INLINE_TIMED_CTRL__
+#define STORAGE_CLASS_TIMED_CTRL_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_TIMED_CTRL_C
+#include "timed_ctrl_public.h"
+#else  /* __INLINE_TIMED_CTRL__ */
+#define STORAGE_CLASS_TIMED_CTRL_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_TIMED_CTRL_C STORAGE_CLASS_INLINE
+#include "timed_ctrl_private.h"
+#endif /* __INLINE_TIMED_CTRL__ */
+
+#endif /* __TIMED_CTRL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/type_support.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/type_support.h
new file mode 100644
index 0000000..d77be74
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/type_support.h
@@ -0,0 +1,73 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TYPE_SUPPORT_H_INCLUDED__
+#define __TYPE_SUPPORT_H_INCLUDED__
+
+/* Per the DLI spec, types are in "type_support.h" and
+ * "platform_support.h" is for unclassified/to be refactored
+ * platform specific definitions.
+ */
+
+#if defined(_MSC_VER)
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <limits.h>
+#include <errno.h>
+#if defined(_M_X64)
+#define HOST_ADDRESS(x) (unsigned long long)(x)
+#else
+#define HOST_ADDRESS(x) (unsigned long)(x)
+#endif
+
+#elif defined(__HIVECC)
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <limits.h>
+#define HOST_ADDRESS(x) (unsigned long)(x)
+
+#elif defined(__KERNEL__)
+#include <linux/types.h>
+#include <linux/limits.h>
+#include <linux/errno.h>
+#define HOST_ADDRESS(x) (unsigned long)(x)
+
+#elif defined(__GNUC__)
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <limits.h>
+#include <errno.h>
+#define HOST_ADDRESS(x) (unsigned long)(x)
+
+#else /* default is for the FIST environment */
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <limits.h>
+#include <errno.h>
+#define HOST_ADDRESS(x) (unsigned long)(x)
+
+#endif
+
+#endif /* __TYPE_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/vamem.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/vamem.h
new file mode 100644
index 0000000..93dfea5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/vamem.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VAMEM_H_INCLUDED__
+#define __VAMEM_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the VAMEM device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "vamem_local.h"
+
+#ifndef __INLINE_VAMEM__
+#define STORAGE_CLASS_VAMEM_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_VAMEM_C
+#include "vamem_public.h"
+#else  /* __INLINE_VAMEM__ */
+#define STORAGE_CLASS_VAMEM_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_VAMEM_C STORAGE_CLASS_INLINE
+#include "vamem_private.h"
+#endif /* __INLINE_VAMEM__ */
+
+#endif /* __VAMEM_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_func.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_func.h
new file mode 100644
index 0000000..de76876
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_func.h
@@ -0,0 +1,39 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VECTOR_FUNC_H_INCLUDED__
+#define __VECTOR_FUNC_H_INCLUDED__
+
+#include "storage_class.h"
+
+#include "vector_func_local.h"
+
+#ifndef __INLINE_VECTOR_FUNC__
+#define STORAGE_CLASS_VECTOR_FUNC_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_VECTOR_FUNC_C
+#include "vector_func_public.h"
+#else  /* __INLINE_VECTOR_FUNC__ */
+#define STORAGE_CLASS_VECTOR_FUNC_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_VECTOR_FUNC_C STORAGE_CLASS_INLINE
+#include "vector_func_private.h"
+#endif /* __INLINE_VECTOR_FUNC__ */
+
+#endif /* __VECTOR_FUNC_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_ops.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_ops.h
new file mode 100644
index 0000000..1437c88
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/vector_ops.h
@@ -0,0 +1,39 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VECTOR_OPS_H_INCLUDED__
+#define __VECTOR_OPS_H_INCLUDED__
+
+#include "storage_class.h"
+
+#include "vector_ops_local.h"
+
+#ifndef __INLINE_VECTOR_OPS__
+#define STORAGE_CLASS_VECTOR_OPS_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_VECTOR_OPS_C
+#include "vector_ops_public.h"
+#else  /* __INLINE_VECTOR_OPS__ */
+#define STORAGE_CLASS_VECTOR_OPS_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_VECTOR_OPS_C STORAGE_CLASS_INLINE
+#include "vector_ops_private.h"
+#endif /* __INLINE_VECTOR_OPS__ */
+
+#endif /* __VECTOR_OPS_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_include/vmem.h b/drivers/media/atomisp2/css2400/hive_isp_css_include/vmem.h
new file mode 100644
index 0000000..114c945
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_include/vmem.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __VMEM_H_INCLUDED__
+#define __VMEM_H_INCLUDED__
+
+/*
+ * This file is included on every cell {SP,ISP,host} and on every system
+ * that uses the VMEM device. It defines the API to DLI bridge
+ *
+ * System and cell specific interfaces and inline code are included
+ * conditionally through Makefile path settings.
+ *
+ *  - .        system and cell agnostic interfaces, constants and identifiers
+ *	- public:  system agnostic, cell specific interfaces
+ *	- private: system dependent, cell specific interfaces & inline implementations
+ *	- global:  system specific constants and identifiers
+ *	- local:   system and cell specific constants and identifiers
+ */
+
+#include "storage_class.h"
+
+#include "system_local.h"
+#include "vmem_local.h"
+
+#ifndef __INLINE_VMEM__
+#define STORAGE_CLASS_VMEM_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_VMEM_C
+#include "vmem_public.h"
+#else  /* __INLINE_VMEM__ */
+#define STORAGE_CLASS_VMEM_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_VMEM_C STORAGE_CLASS_INLINE
+#include "vmem_private.h"
+#endif /* __INLINE_VMEM__ */
+
+#endif /* __VMEM_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_local.h
new file mode 100644
index 0000000..95e21cb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_local.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __QUEUE_LOCAL_H_INCLUDED__
+#define __QUEUE_LOCAL_H_INCLUDED__
+
+#include "queue_global.h"
+
+#endif /* __QUEUE_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_private.h
new file mode 100644
index 0000000..96c7127
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/queue_private.h
@@ -0,0 +1,25 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __QUEUE_PRIVATE_H_INCLUDED__
+#define __QUEUE_PRIVATE_H_INCLUDED__
+
+#endif /* __QUEUE_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag.c b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag.c
new file mode 100644
index 0000000..83587b6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag.c
@@ -0,0 +1,102 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "tag.h"
+#include <platform_support.h>	/* NULL */
+#include <assert_support.h>
+#include "tag_local.h"
+
+/**
+ * @brief	Creates the tag description from the given parameters.
+ * @param[in]	num_captures
+ * @param[in]	skip
+ * @param[in]	offset
+ * @param[out]	tag_descr
+ */
+void
+sh_css_create_tag_descr(int num_captures,
+			unsigned int skip,
+			int offset,
+			unsigned int exp_id,
+			struct sh_css_tag_descr *tag_descr)
+{
+	assert(tag_descr != NULL);
+
+	tag_descr->num_captures = num_captures;
+	tag_descr->skip		= skip;
+	tag_descr->offset	= offset;
+	tag_descr->exp_id	= exp_id;
+}
+
+/**
+ * @brief	Encodes the members of tag description into a 32-bit value.
+ * @param[in]	tag		Pointer to the tag description
+ * @return	(unsigned int)	Encoded 32-bit tag-info
+ */
+unsigned int
+sh_css_encode_tag_descr(struct sh_css_tag_descr *tag)
+{
+	int num_captures;
+	unsigned int num_captures_sign;
+	unsigned int skip;
+	int offset;
+	unsigned int offset_sign;
+	unsigned int exp_id;
+	unsigned int encoded_tag;
+
+	assert(tag != NULL);
+
+	if (tag->num_captures < 0) {
+		num_captures = -tag->num_captures;
+		num_captures_sign = 1;
+	} else {
+		num_captures = tag->num_captures;
+		num_captures_sign = 0;
+	}
+	skip = tag->skip;
+	if (tag->offset < 0) {
+		offset = -tag->offset;
+		offset_sign = 1;
+	} else {
+		offset = tag->offset;
+		offset_sign = 0;
+	}
+	exp_id = tag->exp_id;
+
+	if (exp_id != 0)
+	{
+		/* we encode either an exp_id or capture data */
+		assert((num_captures == 0) && (skip == 0) && (offset == 0));
+
+		encoded_tag = TAG_EXP | (exp_id & 0xFF) << TAG_EXP_ID_SHIFT;
+	}
+	else
+	{
+		encoded_tag = TAG_CAP
+				| ((num_captures_sign & 0x00000001) << TAG_NUM_CAPTURES_SIGN_SHIFT)
+				| ((offset_sign       & 0x00000001) << TAG_OFFSET_SIGN_SHIFT)
+				| ((num_captures      & 0x000000FF) << TAG_NUM_CAPTURES_SHIFT)
+				| ((skip              & 0x000000FF) << TAG_OFFSET_SHIFT)
+				| ((offset            & 0x000000FF) << TAG_SKIP_SHIFT);
+
+	}
+	return encoded_tag;
+}
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_local.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_local.h
new file mode 100644
index 0000000..1bc114c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_local.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TAG_LOCAL_H_INCLUDED__
+#define __TAG_LOCAL_H_INCLUDED__
+
+#include "tag_global.h"
+
+#define SH_CSS_MINIMUM_TAG_ID (-1)
+
+#endif /* __TAG_LOCAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_private.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_private.h
new file mode 100644
index 0000000..6241024
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/host/tag_private.h
@@ -0,0 +1,25 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TAG_PRIVATE_H_INCLUDED__
+#define __TAG_PRIVATE_H_INCLUDED__
+
+#endif /* __TAG_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/queue_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/queue_global.h
new file mode 100644
index 0000000..6c00f08
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/queue_global.h
@@ -0,0 +1,26 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __QUEUE_GLOBAL_H_INCLUDED__
+#define __QUEUE_GLOBAL_H_INCLUDED__
+
+#endif /* __QUEUE_GLOBAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/socket_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/socket_global.h
new file mode 100644
index 0000000..feb8a33
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/socket_global.h
@@ -0,0 +1,60 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SOCKET_GLOBAL_H_INCLUDED__
+#define __SOCKET_GLOBAL_H_INCLUDED__
+
+#include "stream_buffer.h"
+
+/* define the socket port direction */
+typedef enum {
+	SOCKET_PORT_DIRECTION_NULL,
+	SOCKET_PORT_DIRECTION_IN,
+	SOCKET_PORT_DIRECTION_OUT
+} socket_port_direction_t;
+
+/* pointer to the port's callout function */
+typedef void (*socket_port_callout_fp)(void);
+typedef struct socket_port_s socket_port_t;
+typedef struct socket_s socket_t;
+
+/* data structure of the socket port */
+struct socket_port_s {
+	unsigned				channel;	/* the port entity */
+	socket_port_direction_t direction;	/* the port direction */
+	socket_port_callout_fp	callout;	/* the port callout function */
+
+	socket_t				*socket;	/* point to the socket */
+
+	struct {
+		unsigned data;
+	} buf;								/* the buffer at the port */
+};
+
+/* data structure of the socket */
+struct socket_s {
+	socket_port_t	*in;	/* the in-direction port */
+	socket_port_t	*out;	/* the out-direction port */
+	stream_buffer_t	buf;	/* the buffer between in-ports and out-ports */
+};
+
+#endif /* __SOCKET_GLOBAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/stream_buffer_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/stream_buffer_global.h
new file mode 100644
index 0000000..5aefcb2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/stream_buffer_global.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __STREAM_BUFFER_GLOBAL_H_INCLUDED__
+#define __STREAM_BUFFER_GLOBAL_H_INCLUDED__
+
+typedef struct stream_buffer_s stream_buffer_t;
+struct stream_buffer_s {
+	unsigned	base;
+	unsigned	limit;
+	unsigned	top;
+};
+
+#endif /* __STREAM_BUFFER_GLOBAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/sw_event_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/sw_event_global.h
new file mode 100644
index 0000000..dae7829
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/sw_event_global.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SW_EVENT_GLOBAL_H_INCLUDED__
+#define __SW_EVENT_GLOBAL_H_INCLUDED__
+
+#define MAX_NR_OF_PAYLOADS_PER_SW_EVENT 4
+
+#define SP_SW_EVENT_ID_0	0	/* for the error		*/
+#define SP_SW_EVENT_ID_1	1	/* for the host2sp_buffer_queue */
+#define SP_SW_EVENT_ID_2	2	/* for the sp2host_buffer_queue */
+#define SP_SW_EVENT_ID_3	3	/* for the sp2host_event_queue  */
+#define SP_SW_EVENT_ID_4	4	/* for the start stream cmd */
+#define SP_SW_EVENT_ID_5	5	/* for the stop stream cmd  */
+
+/*********************************************
+ *
+ * Hack for Baytrail.
+ *
+ * AUTHOR: zhengjie.lu@intel.com
+ * TIME: 2013-01-19, 14:38.
+ * LOCATION: Santa Clara, U.S.A.
+ * COMMENT:
+ * Define a new Host2SP event which indicates
+ * the Host has passed the pointers of the
+ * empty MIPI buffers to the SP.
+ *
+ ********************************************/
+#define SP_SW_EVENT_ID_6	6	/* for the completion of passing the
+					   pointers of the empty MIPI buffers
+					   from the Host to the SP
+					*/
+/** End of hack for Baytrail **/
+
+#endif /* __SW_EVENT_GLOBAL_H_INCLUDED__ */
+
diff --git a/drivers/media/atomisp2/css2400/hive_isp_css_shared/tag_global.h b/drivers/media/atomisp2/css2400/hive_isp_css_shared/tag_global.h
new file mode 100644
index 0000000..b340ffd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hive_isp_css_shared/tag_global.h
@@ -0,0 +1,63 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __TAG_GLOBAL_H_INCLUDED__
+#define __TAG_GLOBAL_H_INCLUDED__
+
+/* offsets for encoding/decoding the tag into an uint32_t */
+
+#define TAG_CAP	1
+#define TAG_EXP	2
+
+#define TAG_NUM_CAPTURES_SIGN_SHIFT	 6
+#define TAG_OFFSET_SIGN_SHIFT 		 7
+#define TAG_NUM_CAPTURES_SHIFT 		 8
+#define TAG_OFFSET_SHIFT 		16
+#define TAG_SKIP_SHIFT 			24
+
+#define TAG_EXP_ID_SHIFT 		 8
+
+/* Data structure containing the tagging information which is used in
+ * continuous mode to specify which frames should be captured.
+ * num_captures		The number of RAW frames to be processed to
+ *                      YUV. Setting this to -1 will make continuous
+ *                      capture run until it is stopped.
+ * skip			Skip N frames in between captures. This can be
+ *                      used to select a slower capture frame rate than
+ *                      the sensor output frame rate.
+ * offset		Start the RAW-to-YUV processing at RAW buffer
+ *                      with this offset. This allows the user to
+ *                      process RAW frames that were captured in the
+ *                      past or future.
+ * exp_id		Exposure id of the RAW frame to tag.
+ *
+ * NOTE: Either exp_id = 0 or all other fields are 0
+ *	 (so yeah, this could be a union)
+ */
+
+struct sh_css_tag_descr {
+	int num_captures;
+	unsigned int skip;
+	int offset;
+	unsigned int exp_id;
+};
+
+#endif /* __TAG_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/media/atomisp2/css2400/hrt/bits.h b/drivers/media/atomisp2/css2400/hrt/bits.h
new file mode 100644
index 0000000..7fae5d0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/bits.h
@@ -0,0 +1,111 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _HRT_BITS_H
+#define _HRT_BITS_H
+
+#include "defs.h"
+
+#define _hrt_ones(n) HRTCAT(_hrt_ones_, n)
+#define _hrt_ones_0x0  0x00000000U
+#define _hrt_ones_0x1  0x00000001U
+#define _hrt_ones_0x2  0x00000003U
+#define _hrt_ones_0x3  0x00000007U
+#define _hrt_ones_0x4  0x0000000FU
+#define _hrt_ones_0x5  0x0000001FU
+#define _hrt_ones_0x6  0x0000003FU
+#define _hrt_ones_0x7  0x0000007FU
+#define _hrt_ones_0x8  0x000000FFU
+#define _hrt_ones_0x9  0x000001FFU
+#define _hrt_ones_0xA  0x000003FFU
+#define _hrt_ones_0xB  0x000007FFU
+#define _hrt_ones_0xC  0x00000FFFU
+#define _hrt_ones_0xD  0x00001FFFU
+#define _hrt_ones_0xE  0x00003FFFU
+#define _hrt_ones_0xF  0x00007FFFU
+#define _hrt_ones_0x10 0x0000FFFFU
+#define _hrt_ones_0x11 0x0001FFFFU
+#define _hrt_ones_0x12 0x0003FFFFU
+#define _hrt_ones_0x13 0x0007FFFFU
+#define _hrt_ones_0x14 0x000FFFFFU
+#define _hrt_ones_0x15 0x001FFFFFU
+#define _hrt_ones_0x16 0x003FFFFFU
+#define _hrt_ones_0x17 0x007FFFFFU
+#define _hrt_ones_0x18 0x00FFFFFFU
+#define _hrt_ones_0x19 0x01FFFFFFU
+#define _hrt_ones_0x1A 0x03FFFFFFU
+#define _hrt_ones_0x1B 0x07FFFFFFU
+#define _hrt_ones_0x1C 0x0FFFFFFFU
+#define _hrt_ones_0x1D 0x1FFFFFFFU
+#define _hrt_ones_0x1E 0x3FFFFFFFU
+#define _hrt_ones_0x1F 0x7FFFFFFFU
+#define _hrt_ones_0x20 0xFFFFFFFFU
+
+#define _hrt_ones_0  _hrt_ones_0x0
+#define _hrt_ones_1  _hrt_ones_0x1
+#define _hrt_ones_2  _hrt_ones_0x2
+#define _hrt_ones_3  _hrt_ones_0x3
+#define _hrt_ones_4  _hrt_ones_0x4
+#define _hrt_ones_5  _hrt_ones_0x5
+#define _hrt_ones_6  _hrt_ones_0x6
+#define _hrt_ones_7  _hrt_ones_0x7
+#define _hrt_ones_8  _hrt_ones_0x8
+#define _hrt_ones_9  _hrt_ones_0x9
+#define _hrt_ones_10 _hrt_ones_0xA
+#define _hrt_ones_11 _hrt_ones_0xB
+#define _hrt_ones_12 _hrt_ones_0xC
+#define _hrt_ones_13 _hrt_ones_0xD
+#define _hrt_ones_14 _hrt_ones_0xE
+#define _hrt_ones_15 _hrt_ones_0xF
+#define _hrt_ones_16 _hrt_ones_0x10
+#define _hrt_ones_17 _hrt_ones_0x11
+#define _hrt_ones_18 _hrt_ones_0x12
+#define _hrt_ones_19 _hrt_ones_0x13
+#define _hrt_ones_20 _hrt_ones_0x14
+#define _hrt_ones_21 _hrt_ones_0x15
+#define _hrt_ones_22 _hrt_ones_0x16
+#define _hrt_ones_23 _hrt_ones_0x17
+#define _hrt_ones_24 _hrt_ones_0x18
+#define _hrt_ones_25 _hrt_ones_0x19
+#define _hrt_ones_26 _hrt_ones_0x1A
+#define _hrt_ones_27 _hrt_ones_0x1B
+#define _hrt_ones_28 _hrt_ones_0x1C
+#define _hrt_ones_29 _hrt_ones_0x1D
+#define _hrt_ones_30 _hrt_ones_0x1E
+#define _hrt_ones_31 _hrt_ones_0x1F
+#define _hrt_ones_32 _hrt_ones_0x20
+
+#define _hrt_mask(b, n) \
+  (_hrt_ones(n) << (b))
+#define _hrt_get_bits(w, b, n) \
+  (((w) >> (b)) & _hrt_ones(n))
+#define _hrt_set_bits(w, b, n, v) \
+  (((w) & ~_hrt_mask(b, n)) | (((v) & _hrt_ones(n)) << (b)))
+#define _hrt_get_bit(w, b) \
+  (((w) >> (b)) & 1)
+#define _hrt_set_bit(w, b, v) \
+  (((w) & (~(1 << (b)))) | (((v)&1) << (b)))
+#define _hrt_set_lower_half(w, v) \
+  _hrt_set_bits(w, 0, 16, v)
+#define _hrt_set_upper_half(w, v) \
+  _hrt_set_bits(w, 16, 16, v)
+
+#endif /* _HRT_BITS_H */
diff --git a/drivers/media/atomisp2/css2400/hrt/cell_params.h b/drivers/media/atomisp2/css2400/hrt/cell_params.h
new file mode 100644
index 0000000..2be3aa4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/cell_params.h
@@ -0,0 +1,49 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _cell_params_h
+#define _cell_params_h
+
+#define SP_PMEM_LOG_WIDTH_BITS           6  /*Width of PC, 64 bits, 8 bytes*/
+#define SP_ICACHE_TAG_BITS               4  /*size of tag*/
+#define SP_ICACHE_SET_BITS               8  /* 256 sets*/
+#define SP_ICACHE_BLOCKS_PER_SET_BITS    1  /* 2 way associative*/
+#define SP_ICACHE_BLOCK_ADDRESS_BITS     11 /* 2048 lines capacity*/
+
+#define SP_ICACHE_ADDRESS_BITS \
+	                    (SP_ICACHE_TAG_BITS+SP_ICACHE_BLOCK_ADDRESS_BITS)
+
+#define SP_PMEM_DEPTH        (1<<SP_ICACHE_ADDRESS_BITS)
+
+#define SP_FIFO_0_DEPTH      0
+#define SP_FIFO_1_DEPTH      0
+#define SP_FIFO_2_DEPTH      0
+#define SP_FIFO_3_DEPTH      0
+#define SP_FIFO_4_DEPTH      0
+#define SP_FIFO_5_DEPTH      0
+#define SP_FIFO_6_DEPTH      0
+#define SP_FIFO_7_DEPTH      0
+
+
+#define SP_SLV_BUS_MAXBURSTSIZE        1
+
+#endif /* _cell_params_h */
+
diff --git a/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_common_defs.h b/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_common_defs.h
new file mode 100644
index 0000000..5f8196f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_common_defs.h
@@ -0,0 +1,207 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _css_receiver_2400_common_defs_h_
+#define _css_receiver_2400_common_defs_h_
+#ifndef _mipi_backend_common_defs_h_
+#define _mipi_backend_common_defs_h_
+
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH     16
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH     2
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH  3
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_REAL_WIDTH (_HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH + _HRT_CSS_RECEIVER_2400_GEN_SHORT_CH_ID_WIDTH + _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_WIDTH      32 /* use 32 to be compatibel with streaming monitor !, MSB's of interface are tied to '0' */
+
+/* Definition of data format ID at the interface CSS_receiver capture/acquisition units */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8          24   /* 01 1000 YUV420 8-bit                                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10         25   /* 01 1001  YUV420 10-bit                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8L         26   /* 01 1010   YUV420 8-bit legacy                               */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_8          30   /* 01 1110   YUV422 8-bit                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV422_10         31   /* 01 1111   YUV422 10-bit                                     */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB444            32   /* 10 0000   RGB444                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB555            33   /* 10 0001   RGB555                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB565            34   /* 10 0010   RGB565                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB666            35   /* 10 0011   RGB666                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RGB888            36   /* 10 0100   RGB888                                            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW6              40   /* 10 1000   RAW6                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW7              41   /* 10 1001   RAW7                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW8              42   /* 10 1010   RAW8                                              */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW10             43   /* 10 1011   RAW10                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW12             44   /* 10 1100   RAW12                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW14             45   /* 10 1101   RAW14                                             */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_1         48   /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_2         49   /* 11 0001    User Defined 8-bit Data Type 2                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_3         50   /* 11 0010    User Defined 8-bit Data Type 3                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_4         51   /* 11 0011    User Defined 8-bit Data Type 4                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_5         52   /* 11 0100    User Defined 8-bit Data Type 5                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_6         53   /* 11 0101    User Defined 8-bit Data Type 6                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_7         54   /* 11 0110    User Defined 8-bit Data Type 7                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_USR_DEF_8         55   /* 11 0111    User Defined 8-bit Data Type 8                   */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_Emb               18   /* 01 0010    embedded eight bit non image data                */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOF                0   /* 00 0000    frame start                                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOF                1   /* 00 0001    frame end                                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_SOL                2   /* 00 0010    line start                                       */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_EOL                3   /* 00 0011    line end                                         */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH1            8   /* 00 1000  Generic Short Packet Code 1                        */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH2            9   /* 00 1001    Generic Short Packet Code 2                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH3           10   /* 00 1010    Generic Short Packet Code 3                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH4           11   /* 00 1011    Generic Short Packet Code 4                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH5           12   /* 00 1100    Generic Short Packet Code 5                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH6           13   /* 00 1101    Generic Short Packet Code 6                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH7           14   /* 00 1110    Generic Short Packet Code 7                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_GEN_SH8           15   /* 00 1111    Generic Short Packet Code 8                      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_8_CSPS     28   /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_YUV420_10_CSPS    29   /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
+/* used reseved mipi positions for these */
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW16             46
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18             47
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_2           37
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_RAW18_3           38
+
+#define _HRT_CSS_RECEIVER_2400_DATA_FORMAT_ID_WIDTH              6
+
+/* Definition of format_types at the interface CSS --> input_selector*/
+/* !! Changes here should be copied to systems/isp/isp_css/bin/conv_transmitter_cmd.tcl !! */
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB888           0  // 36 'h24
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB555           1  // 33 'h
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB444           2  // 32
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB565           3  // 34
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RGB666           4  // 35
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW8             5  // 42
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW10            6  // 43
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW6             7  // 40
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW7             8  // 41
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW12            9  // 43
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW14           10  // 45
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8        11  // 30
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10       12  // 25
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_8        13  // 30
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV422_10       14  // 31
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_1       15  // 48
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8L       16  // 26
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_Emb             17  // 18
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_2       18  // 49
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_3       19  // 50
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_4       20  // 51
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_5       21  // 52
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_6       22  // 53
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_7       23  // 54
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_USR_DEF_8       24  // 55
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_8_CSPS   25  // 28
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_YUV420_10_CSPS  26  // 29
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW16           27  // ?
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18           28  // ?
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_2         29  // ? Option 2 for depacketiser
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_RAW18_3         30  // ? Option 3 for depacketiser
+#define _HRT_CSS_RECEIVER_2400_FMT_TYPE_CUSTOM          31  // to signal custom decoding
+
+/* definition for state machine of data FIFO for decode different type of data */
+#define _HRT_CSS_RECEIVER_2400_YUV420_8_REPEAT_PTN                 1
+#define _HRT_CSS_RECEIVER_2400_YUV420_10_REPEAT_PTN                5
+#define _HRT_CSS_RECEIVER_2400_YUV420_8L_REPEAT_PTN                1
+#define _HRT_CSS_RECEIVER_2400_YUV422_8_REPEAT_PTN                 1
+#define _HRT_CSS_RECEIVER_2400_YUV422_10_REPEAT_PTN                5
+#define _HRT_CSS_RECEIVER_2400_RGB444_REPEAT_PTN                   2
+#define _HRT_CSS_RECEIVER_2400_RGB555_REPEAT_PTN                   2
+#define _HRT_CSS_RECEIVER_2400_RGB565_REPEAT_PTN                   2
+#define _HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN                   9
+#define _HRT_CSS_RECEIVER_2400_RGB888_REPEAT_PTN                   3
+#define _HRT_CSS_RECEIVER_2400_RAW6_REPEAT_PTN                     3
+#define _HRT_CSS_RECEIVER_2400_RAW7_REPEAT_PTN                     7
+#define _HRT_CSS_RECEIVER_2400_RAW8_REPEAT_PTN                     1
+#define _HRT_CSS_RECEIVER_2400_RAW10_REPEAT_PTN                    5
+#define _HRT_CSS_RECEIVER_2400_RAW12_REPEAT_PTN                    3
+#define _HRT_CSS_RECEIVER_2400_RAW14_REPEAT_PTN                    7
+
+#define _HRT_CSS_RECEIVER_2400_MAX_REPEAT_PTN                      _HRT_CSS_RECEIVER_2400_RGB666_REPEAT_PTN
+
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_IDX                     0
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FMT_WIDTH                   3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_IDX                    3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_PRED_WIDTH                  1
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_USD_BITS                    4  /* bits per USD type */
+
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_DATAID_IDX                 0
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_EN_IDX                     6
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_DATAID_IDX                 0
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_OPTION_IDX                 6
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_EN_IDX                     8
+
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_NO_COMP                     0
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_6_10                     1
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_7_10                     2
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_10_8_10                     3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_6_12                     4
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_7_12                     5
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_12_8_12                     6
+
+
+/* packet bit definition */
+#define _HRT_CSS_RECEIVER_2400_PKT_SOP_IDX                        32
+#define _HRT_CSS_RECEIVER_2400_PKT_SOP_BITS                        1
+#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_IDX                      22
+#define _HRT_CSS_RECEIVER_2400_PKT_CH_ID_BITS                      2
+#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_IDX                     16
+#define _HRT_CSS_RECEIVER_2400_PKT_FMT_ID_BITS                     6
+#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_IDX                   0
+#define _HRT_CSS_RECEIVER_2400_PH_DATA_FIELD_BITS                 16
+#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_IDX                     0
+#define _HRT_CSS_RECEIVER_2400_PKT_PAYLOAD_BITS                   32
+
+
+/*************************************************************************************************/
+/* Custom Decoding                                                                               */
+/* These Custom Defs are defined based on design-time config in "csi_be_pixel_formatter.chdl" !! */
+/*************************************************************************************************/
+#define BE_CUST_EN_IDX                     0     /* 2bits */
+#define BE_CUST_EN_DATAID_IDX              2     /* 6bits MIPI DATA ID */
+#define BE_CUST_EN_WIDTH                   8
+#define BE_CUST_MODE_ALL                   1     /* Enable Custom Decoding for all DATA IDs */
+#define BE_CUST_MODE_ONE                   3     /* Enable Custom Decoding for ONE DATA ID, programmed in CUST_EN_DATA_ID */
+
+/* Data State config = {get_bits(6bits), valid(1bit)}  */
+#define BE_CUST_DATA_STATE_S0_IDX          0     /* 7bits */
+#define BE_CUST_DATA_STATE_S1_IDX          7     /* 7bits */
+#define BE_CUST_DATA_STATE_S2_IDX          14    /* 7bits */
+#define BE_CUST_DATA_STATE_WIDTH           21
+#define BE_CUST_DATA_STATE_VALID_IDX       0     /* 1bits */
+#define BE_CUST_DATA_STATE_GETBITS_IDX     1     /* 6bits */
+
+/* Pixel Extractor config */
+#define BE_CUST_PIX_EXT_DATA_ALIGN_IDX     0     /* 5bits */
+#define BE_CUST_PIX_EXT_PIX_ALIGN_IDX      5     /* 5bits */
+#define BE_CUST_PIX_EXT_PIX_MASK_IDX       10    /* 18bits */
+#define BE_CUST_PIX_EXT_PIX_EN_IDX         28    /* 1bits */
+#define BE_CUST_PIX_EXT_WIDTH              29
+
+/* Pixel Valid & EoP config = {[eop,valid](especial), [eop,valid](normal)} */
+#define BE_CUST_PIX_VALID_EOP_P0_IDX        0    /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_P1_IDX        4    /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_P2_IDX        8    /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_P3_IDX        12   /* 4bits */
+#define BE_CUST_PIX_VALID_EOP_WIDTH         16
+#define BE_CUST_PIX_VALID_EOP_NOR_VALID_IDX 0    /* Normal (NO less get_bits case) Valid - 1bits */
+#define BE_CUST_PIX_VALID_EOP_NOR_EOP_IDX   1    /* Normal (NO less get_bits case) EoP - 1bits */
+#define BE_CUST_PIX_VALID_EOP_ESP_VALID_IDX 2    /* Especial (less get_bits case) Valid - 1bits */
+#define BE_CUST_PIX_VALID_EOP_ESP_EOP_IDX   3    /* Especial (less get_bits case) EoP - 1bits */
+
+#endif /* _mipi_backend_common_defs_h_ */
+#endif /* _css_receiver_2400_common_defs_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_defs.h b/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_defs.h
new file mode 100644
index 0000000..2695b83
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/css_receiver_2400_defs.h
@@ -0,0 +1,265 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _css_receiver_2400_defs_h_
+#define _css_receiver_2400_defs_h_
+
+#include "css_receiver_2400_common_defs.h"
+
+#define CSS_RECEIVER_DATA_WIDTH                8
+#define CSS_RECEIVER_RX_TRIG                   4
+#define CSS_RECEIVER_RF_WORD                  32
+#define CSS_RECEIVER_IMG_PROC_RF_ADDR         10
+#define CSS_RECEIVER_CSI_RF_ADDR               4
+#define CSS_RECEIVER_DATA_OUT                 12
+#define CSS_RECEIVER_CHN_NO                    2
+#define CSS_RECEIVER_DWORD_CNT                11
+#define CSS_RECEIVER_FORMAT_TYP                5
+#define CSS_RECEIVER_HRESPONSE                 2
+#define CSS_RECEIVER_STATE_WIDTH               3
+#define CSS_RECEIVER_FIFO_DAT                 32
+#define CSS_RECEIVER_CNT_VAL                   2
+#define CSS_RECEIVER_PRED10_VAL               10
+#define CSS_RECEIVER_PRED12_VAL               12
+#define CSS_RECEIVER_CNT_WIDTH                 8
+#define CSS_RECEIVER_WORD_CNT                 16
+#define CSS_RECEIVER_PIXEL_LEN                 6
+#define CSS_RECEIVER_PIXEL_CNT                 5
+#define CSS_RECEIVER_COMP_8_BIT                8
+#define CSS_RECEIVER_COMP_7_BIT                7
+#define CSS_RECEIVER_COMP_6_BIT                6
+
+#define CSI_CONFIG_WIDTH                       4
+
+/* division of gen_short data, ch_id and fmt_type over streaming data interface */
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_LSB     0
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_LSB     + _HRT_CSS_RECEIVER_2400_GEN_SHORT_DATA_WIDTH)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_LSB    (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB + _HRT_CSS_RECEIVER_2400_GEN_SHORT_FMT_TYPE_WIDTH)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_DATA_BIT_MSB     (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_LSB - 1)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_FMT_TYPE_BIT_MSB (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_LSB    - 1)
+#define _HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_CH_ID_BIT_MSB    (_HRT_CSS_RECEIVER_2400_GEN_SHORT_STR_REAL_WIDTH       - 1)
+
+#define _HRT_CSS_RECEIVER_2400_REG_ALIGN 4
+#define _HRT_CSS_RECEIVER_2400_BYTES_PER_PKT             4
+
+#define hrt_css_receiver_2400_4_lane_port_offset  0x100
+#define hrt_css_receiver_2400_1_lane_port_offset  0x200
+#define hrt_css_receiver_2400_2_lane_port_offset  0x300
+#define hrt_css_receiver_2400_backend_port_offset 0x100
+
+#define _HRT_CSS_RECEIVER_2400_DEVICE_READY_REG_IDX      0
+#define _HRT_CSS_RECEIVER_2400_IRQ_STATUS_REG_IDX        1
+#define _HRT_CSS_RECEIVER_2400_IRQ_ENABLE_REG_IDX        2
+#define _HRT_CSS_RECEIVER_2400_CSI2_FUNC_PROG_REG_IDX    3
+#define _HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX        4
+#define _HRT_CSS_RECEIVER_2400_FS_TO_LS_DELAY_REG_IDX    7
+#define _HRT_CSS_RECEIVER_2400_LS_TO_DATA_DELAY_REG_IDX  8
+#define _HRT_CSS_RECEIVER_2400_DATA_TO_LE_DELAY_REG_IDX  9
+#define _HRT_CSS_RECEIVER_2400_LE_TO_FE_DELAY_REG_IDX   10
+#define _HRT_CSS_RECEIVER_2400_FE_TO_FS_DELAY_REG_IDX   11
+#define _HRT_CSS_RECEIVER_2400_LE_TO_LS_DELAY_REG_IDX   12
+#define _HRT_CSS_RECEIVER_2400_TWO_PIXEL_EN_REG_IDX     13
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_REG_IDX  14
+#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX       15
+#define _HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX         16
+#define _HRT_CSS_RECEIVER_2400_BACKEND_RST_REG_IDX      17
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG0_IDX 18
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC0_REG1_IDX 19
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG0_IDX 20
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC1_REG1_IDX 21
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG0_IDX 22
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC2_REG1_IDX 23
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG0_IDX 24
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_VC3_REG1_IDX 25
+#define _HRT_CSS_RECEIVER_2400_RAW18_REG_IDX            26
+#define _HRT_CSS_RECEIVER_2400_FORCE_RAW8_REG_IDX       27
+#define _HRT_CSS_RECEIVER_2400_RAW16_REG_IDX            28
+
+/* Interrupt bits for IRQ_STATUS and IRQ_ENABLE registers */
+#define _HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_BIT                0
+#define _HRT_CSS_RECEIVER_2400_IRQ_RESERVED_BIT               1
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_BIT       2
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_BIT        3
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_BIT             4
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_BIT        5
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_BIT            6
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_BIT         7
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_BIT      8
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_BIT  9
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_BIT               10
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_BIT                11
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_BIT        12
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_BIT        13
+#define _HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_BIT          14
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_BIT            15
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_BIT         16
+
+#define _HRT_CSS_RECEIVER_2400_IRQ_OVERRUN_CAUSE_                  "Fifo Overrun"
+#define _HRT_CSS_RECEIVER_2400_IRQ_RESERVED_CAUSE_                 "Reserved"
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_ENTRY_CAUSE_         "Sleep mode entry"
+#define _HRT_CSS_RECEIVER_2400_IRQ_SLEEP_MODE_EXIT_CAUSE_          "Sleep mode exit"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_HS_CAUSE_               "Error high speed SOT"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_SOT_SYNC_HS_CAUSE_          "Error high speed sync SOT"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CONTROL_CAUSE_              "Error control"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_DOUBLE_CAUSE_           "Error correction double bit"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_CORRECTED_CAUSE_        "Error correction single bit"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ECC_NO_CORRECTION_CAUSE_    "No error"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_CRC_CAUSE_                  "Error cyclic redundancy check"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ID_CAUSE_                   "Error id"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_SYNC_CAUSE_           "Error frame sync"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_FRAME_DATA_CAUSE_           "Error frame data"
+#define _HRT_CSS_RECEIVER_2400_IRQ_DATA_TIMEOUT_CAUSE_             "Data time-out"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_ESCAPE_CAUSE_               "Error escape"
+#define _HRT_CSS_RECEIVER_2400_IRQ_ERR_LINE_SYNC_CAUSE_            "Error line sync"
+
+/* Bits for CSI2_DEVICE_READY register */
+#define _HRT_CSS_RECEIVER_2400_CSI2_DEVICE_READY_IDX                          0
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_INIT_TIME_OUT_ERR_IDX                2
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_OVER_RUN_ERR_IDX                     3
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_SOT_SYNC_ERR_IDX                     4
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_RECEIVE_DATA_TIME_OUT_ERR_IDX        5
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_ECC_TWO_BIT_ERR_IDX                  6
+#define _HRT_CSS_RECEIVER_2400_CSI2_MASK_DATA_ID_ERR_IDX                      7
+
+
+/* Bits for CSI2_FUNC_PROG register */
+#define _HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_IDX    0
+#define _HRT_CSS_RECEIVER_2400_CSI2_DATA_TIMEOUT_BITS   19
+
+/* Bits for INIT_COUNT register */
+#define _HRT_CSS_RECEIVER_2400_INIT_TIMER_IDX  0
+#define _HRT_CSS_RECEIVER_2400_INIT_TIMER_BITS 16
+
+/* Bits for COUNT registers */
+#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_IDX     0
+#define _HRT_CSS_RECEIVER_2400_SYNC_COUNT_BITS    8
+#define _HRT_CSS_RECEIVER_2400_RX_COUNT_IDX       0
+#define _HRT_CSS_RECEIVER_2400_RX_COUNT_BITS      8
+
+/* Bits for RAW116_18_DATAID register */
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW16_BITS_IDX   0
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW16_BITS_BITS  6
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW18_BITS_IDX   8
+#define _HRT_CSS_RECEIVER_2400_RAW16_18_DATAID_RAW18_BITS_BITS  6
+
+/* Bits for COMP_FORMAT register, this selects the compression data format */
+#define _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_IDX  0
+#define _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_BITS 8
+#define _HRT_CSS_RECEIVER_2400_COMP_NUM_BITS_IDX  (_HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_IDX + _HRT_CSS_RECEIVER_2400_COMP_RAW_BITS_BITS)
+#define _HRT_CSS_RECEIVER_2400_COMP_NUM_BITS_BITS 8
+
+/* Bits for COMP_PREDICT register, this selects the predictor algorithm */
+#define _HRT_CSS_RECEIVER_2400_PREDICT_NO_COMP 0
+#define _HRT_CSS_RECEIVER_2400_PREDICT_1       1
+#define _HRT_CSS_RECEIVER_2400_PREDICT_2       2
+
+/* Number of bits used for the delay registers */
+#define _HRT_CSS_RECEIVER_2400_DELAY_BITS 8
+
+/* Bits for COMP_SCHEME register, this  selects the compression scheme for a VC */
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD1_BITS_IDX  0
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD2_BITS_IDX  5
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD3_BITS_IDX  10
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD4_BITS_IDX  15
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD5_BITS_IDX  20
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD6_BITS_IDX  25
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD7_BITS_IDX  0
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD8_BITS_IDX  5
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_BITS_BITS  5
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_FMT_BITS_IDX   0
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_FMT_BITS_BITS  3
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_PRED_BITS_IDX  3
+#define _HRT_CSS_RECEIVER_2400_COMP_SCHEME_USD_PRED_BITS_BITS 2
+
+
+/* BITS for backend RAW16 and RAW 18 registers */
+
+#define _HRT_CSS_RECEIVER_2400_RAW18_DATAID_IDX    0
+#define _HRT_CSS_RECEIVER_2400_RAW18_DATAID_BITS   6
+#define _HRT_CSS_RECEIVER_2400_RAW18_OPTION_IDX    6
+#define _HRT_CSS_RECEIVER_2400_RAW18_OPTION_BITS   2
+#define _HRT_CSS_RECEIVER_2400_RAW18_EN_IDX        8
+#define _HRT_CSS_RECEIVER_2400_RAW18_EN_BITS       1
+
+#define _HRT_CSS_RECEIVER_2400_RAW16_DATAID_IDX    0
+#define _HRT_CSS_RECEIVER_2400_RAW16_DATAID_BITS   6
+#define _HRT_CSS_RECEIVER_2400_RAW16_OPTION_IDX    6
+#define _HRT_CSS_RECEIVER_2400_RAW16_OPTION_BITS   2
+#define _HRT_CSS_RECEIVER_2400_RAW16_EN_IDX        8
+#define _HRT_CSS_RECEIVER_2400_RAW16_EN_BITS       1
+
+/* These hsync and vsync values are for HSS simulation only */
+#define _HRT_CSS_RECEIVER_2400_HSYNC_VAL (1<<16)
+#define _HRT_CSS_RECEIVER_2400_VSYNC_VAL (1<<17)
+
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_WIDTH                 28
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_LSB              0
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_MSB             (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_LSB + CSS_RECEIVER_DATA_OUT - 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_VAL_BIT         (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_MSB + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_LSB             (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_A_VAL_BIT + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_MSB             (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_LSB + CSS_RECEIVER_DATA_OUT - 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_VAL_BIT         (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_MSB + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_SOP_BIT               (_HRT_CSS_RECEIVER_2400_BE_STREAMING_PIX_B_VAL_BIT + 1)
+#define _HRT_CSS_RECEIVER_2400_BE_STREAMING_EOP_BIT               (_HRT_CSS_RECEIVER_2400_BE_STREAMING_SOP_BIT + 1)
+
+// SH Backend Register IDs
+#define _HRT_CSS_RECEIVER_2400_BE_GSP_ACC_OVL_REG_IDX              0
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_REG_IDX                     1
+#define _HRT_CSS_RECEIVER_2400_BE_TWO_PPC_REG_IDX                  2
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG0_IDX             3
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG1_IDX             4
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG2_IDX             5
+#define _HRT_CSS_RECEIVER_2400_BE_COMP_FORMAT_REG3_IDX             6
+#define _HRT_CSS_RECEIVER_2400_BE_SEL_REG_IDX                      7
+#define _HRT_CSS_RECEIVER_2400_BE_RAW16_CONFIG_REG_IDX             8
+#define _HRT_CSS_RECEIVER_2400_BE_RAW18_CONFIG_REG_IDX             9
+#define _HRT_CSS_RECEIVER_2400_BE_FORCE_RAW8_REG_IDX              10
+#define _HRT_CSS_RECEIVER_2400_BE_IRQ_STATUS_REG_IDX              11
+#define _HRT_CSS_RECEIVER_2400_BE_IRQ_CLEAR_REG_IDX               12
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_EN_REG_IDX                 13
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_DATA_STATE_REG_IDX         14    /* Data State 0,1,2 config */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P0_REG_IDX       15    /* Pixel Extractor config for Data State 0 & Pix 0 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P1_REG_IDX       16    /* Pixel Extractor config for Data State 0 & Pix 1 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P2_REG_IDX       17    /* Pixel Extractor config for Data State 0 & Pix 2 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S0P3_REG_IDX       18    /* Pixel Extractor config for Data State 0 & Pix 3 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P0_REG_IDX       19    /* Pixel Extractor config for Data State 1 & Pix 0 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P1_REG_IDX       20    /* Pixel Extractor config for Data State 1 & Pix 1 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P2_REG_IDX       21    /* Pixel Extractor config for Data State 1 & Pix 2 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S1P3_REG_IDX       22    /* Pixel Extractor config for Data State 1 & Pix 3 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P0_REG_IDX       23    /* Pixel Extractor config for Data State 2 & Pix 0 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P1_REG_IDX       24    /* Pixel Extractor config for Data State 2 & Pix 1 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P2_REG_IDX       25    /* Pixel Extractor config for Data State 2 & Pix 2 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_EXT_S2P3_REG_IDX       26    /* Pixel Extractor config for Data State 2 & Pix 3 */
+#define _HRT_CSS_RECEIVER_2400_BE_CUST_PIX_VALID_EOP_REG_IDX      27    /* Pixel Valid & EoP config for Pix 0,1,2,3 */
+
+#define _HRT_CSS_RECEIVER_2400_BE_NOF_REGISTERS                   28
+
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_HE                          0
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_RCF                         1
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_PF                          2
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_SM                          3
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_PD                          4
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_SD                          5
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_OT                          6
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_BC                          7
+#define _HRT_CSS_RECEIVER_2400_BE_SRST_WIDTH                       8
+
+#endif /* _css_receiver_2400_defs_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/defs.h b/drivers/media/atomisp2/css2400/hrt/defs.h
new file mode 100644
index 0000000..4917c00
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/defs.h
@@ -0,0 +1,43 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _HRT_DEFS_H_
+#define _HRT_DEFS_H_
+
+#ifndef HRTCAT
+#define _HRTCAT(m, n)     m##n
+#define HRTCAT(m, n)      _HRTCAT(m, n)
+#endif
+
+#ifndef HRTSTR
+#define _HRTSTR(x)   #x
+#define HRTSTR(x)    _HRTSTR(x)
+#endif
+
+#ifndef HRTMIN
+#define HRTMIN(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+#ifndef HRTMAX
+#define HRTMAX(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+
+#endif /* _HRT_DEFS_H_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/dma_v2_defs.h b/drivers/media/atomisp2/css2400/hrt/dma_v2_defs.h
new file mode 100644
index 0000000..e359c3f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/dma_v2_defs.h
@@ -0,0 +1,206 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _dma_v2_defs_h
+#define _dma_v2_defs_h
+
+#define _DMA_V2_NUM_CHANNELS_ID               MaxNumChannels
+#define _DMA_V2_CONNECTIONS_ID                Connections
+#define _DMA_V2_DEV_ELEM_WIDTHS_ID            DevElemWidths
+#define _DMA_V2_DEV_FIFO_DEPTH_ID             DevFifoDepth
+#define _DMA_V2_DEV_FIFO_RD_LAT_ID            DevFifoRdLat
+#define _DMA_V2_DEV_FIFO_LAT_BYPASS_ID        DevFifoRdLatBypass
+#define _DMA_V2_DEV_NO_BURST_ID               DevNoBurst
+#define _DMA_V2_DEV_RD_ACCEPT_ID              DevRdAccept
+#define _DMA_V2_DEV_SRMD_ID                   DevSRMD
+#define _DMA_V2_DEV_HAS_CRUN_ID               CRunMasters
+#define _DMA_V2_CTRL_ACK_FIFO_DEPTH_ID        CtrlAckFifoDepth
+#define _DMA_V2_CMD_FIFO_DEPTH_ID             CommandFifoDepth
+#define _DMA_V2_CMD_FIFO_RD_LAT_ID            CommandFifoRdLat
+#define _DMA_V2_CMD_FIFO_LAT_BYPASS_ID        CommandFifoRdLatBypass
+#define _DMA_V2_NO_PACK_ID                    has_no_pack
+
+#define _DMA_V2_REG_ALIGN                4
+#define _DMA_V2_REG_ADDR_BITS            2
+
+/* Command word */
+#define _DMA_V2_CMD_IDX            0
+#define _DMA_V2_CMD_BITS           6
+#define _DMA_V2_CHANNEL_IDX        (_DMA_V2_CMD_IDX + _DMA_V2_CMD_BITS)
+#define _DMA_V2_CHANNEL_BITS       5
+
+/* The command to set a parameter contains the PARAM field next */
+#define _DMA_V2_PARAM_IDX          (_DMA_V2_CHANNEL_IDX + _DMA_V2_CHANNEL_BITS)
+#define _DMA_V2_PARAM_BITS         4
+
+/* Commands to read, write or init specific blocks contain these
+   three values */
+#define _DMA_V2_SPEC_DEV_A_XB_IDX  (_DMA_V2_CHANNEL_IDX + _DMA_V2_CHANNEL_BITS)
+#define _DMA_V2_SPEC_DEV_A_XB_BITS 8
+#define _DMA_V2_SPEC_DEV_B_XB_IDX  (_DMA_V2_SPEC_DEV_A_XB_IDX + _DMA_V2_SPEC_DEV_A_XB_BITS)
+#define _DMA_V2_SPEC_DEV_B_XB_BITS 8
+#define _DMA_V2_SPEC_YB_IDX        (_DMA_V2_SPEC_DEV_B_XB_IDX + _DMA_V2_SPEC_DEV_B_XB_BITS)
+#define _DMA_V2_SPEC_YB_BITS       (32-_DMA_V2_SPEC_DEV_B_XB_BITS-_DMA_V2_SPEC_DEV_A_XB_BITS-_DMA_V2_CMD_BITS-_DMA_V2_CHANNEL_BITS)
+
+/* */
+#define _DMA_V2_CMD_CTRL_IDX       4
+#define _DMA_V2_CMD_CTRL_BITS      4
+
+/* Packing setup word */
+#define _DMA_V2_CONNECTION_IDX     0
+#define _DMA_V2_CONNECTION_BITS    4
+#define _DMA_V2_EXTENSION_IDX      (_DMA_V2_CONNECTION_IDX + _DMA_V2_CONNECTION_BITS)
+#define _DMA_V2_EXTENSION_BITS     1
+
+/* Elements packing word */
+#define _DMA_V2_ELEMENTS_IDX        0
+#define _DMA_V2_ELEMENTS_BITS       8
+#define _DMA_V2_LEFT_CROPPING_IDX  (_DMA_V2_ELEMENTS_IDX + _DMA_V2_ELEMENTS_BITS)
+#define _DMA_V2_LEFT_CROPPING_BITS  8
+
+#define _DMA_V2_WIDTH_IDX           0
+#define _DMA_V2_WIDTH_BITS         16
+
+#define _DMA_V2_HEIGHT_IDX          0
+#define _DMA_V2_HEIGHT_BITS        16
+
+#define _DMA_V2_STRIDE_IDX          0
+#define _DMA_V2_STRIDE_BITS        32
+
+/* Command IDs */
+#define _DMA_V2_MOVE_B2A_COMMAND                             0
+#define _DMA_V2_MOVE_B2A_BLOCK_COMMAND                       1
+#define _DMA_V2_MOVE_B2A_NO_SYNC_CHK_COMMAND                 2
+#define _DMA_V2_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND           3
+#define _DMA_V2_MOVE_A2B_COMMAND                             4
+#define _DMA_V2_MOVE_A2B_BLOCK_COMMAND                       5
+#define _DMA_V2_MOVE_A2B_NO_SYNC_CHK_COMMAND                 6
+#define _DMA_V2_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND           7
+#define _DMA_V2_INIT_A_COMMAND                               8
+#define _DMA_V2_INIT_A_BLOCK_COMMAND                         9
+#define _DMA_V2_INIT_A_NO_SYNC_CHK_COMMAND                  10
+#define _DMA_V2_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND            11
+#define _DMA_V2_INIT_B_COMMAND                              12
+#define _DMA_V2_INIT_B_BLOCK_COMMAND                        13
+#define _DMA_V2_INIT_B_NO_SYNC_CHK_COMMAND                  14
+#define _DMA_V2_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND            15
+#define _DMA_V2_NO_ACK_MOVE_B2A_NO_SYNC_CHK_COMMAND         (_DMA_V2_MOVE_B2A_NO_SYNC_CHK_COMMAND       + 16)
+#define _DMA_V2_NO_ACK_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND   (_DMA_V2_MOVE_B2A_BLOCK_NO_SYNC_CHK_COMMAND + 16)
+#define _DMA_V2_NO_ACK_MOVE_A2B_NO_SYNC_CHK_COMMAND         (_DMA_V2_MOVE_A2B_NO_SYNC_CHK_COMMAND       + 16)
+#define _DMA_V2_NO_ACK_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND   (_DMA_V2_MOVE_A2B_BLOCK_NO_SYNC_CHK_COMMAND + 16)
+#define _DMA_V2_NO_ACK_INIT_A_NO_SYNC_CHK_COMMAND           (_DMA_V2_INIT_A_NO_SYNC_CHK_COMMAND         + 16)
+#define _DMA_V2_NO_ACK_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND     (_DMA_V2_INIT_A_BLOCK_NO_SYNC_CHK_COMMAND   + 16)
+#define _DMA_V2_NO_ACK_INIT_B_NO_SYNC_CHK_COMMAND           (_DMA_V2_INIT_B_NO_SYNC_CHK_COMMAND         + 16)
+#define _DMA_V2_NO_ACK_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND     (_DMA_V2_INIT_B_BLOCK_NO_SYNC_CHK_COMMAND   + 16)
+#define _DMA_V2_CONFIG_CHANNEL_COMMAND                      32
+#define _DMA_V2_SET_CHANNEL_PARAM_COMMAND                   33
+#define _DMA_V2_SET_CRUN_COMMAND                            62
+
+/* Channel Parameter IDs */
+#define _DMA_V2_PACKING_SETUP_PARAM                     0
+#define _DMA_V2_STRIDE_A_PARAM                          1
+#define _DMA_V2_ELEM_CROPPING_A_PARAM                   2
+#define _DMA_V2_WIDTH_A_PARAM                           3
+#define _DMA_V2_STRIDE_B_PARAM                          4
+#define _DMA_V2_ELEM_CROPPING_B_PARAM                   5
+#define _DMA_V2_WIDTH_B_PARAM                           6
+#define _DMA_V2_HEIGHT_PARAM                            7
+#define _DMA_V2_QUEUED_CMDS                             8
+
+/* Parameter Constants */
+#define _DMA_V2_ZERO_EXTEND                             0
+#define _DMA_V2_SIGN_EXTEND                             1
+
+  /* SLAVE address map */
+#define _DMA_V2_SEL_FSM_CMD                             0
+#define _DMA_V2_SEL_CH_REG                              1
+#define _DMA_V2_SEL_CONN_GROUP                          2
+#define _DMA_V2_SEL_DEV_INTERF                          3
+
+#define _DMA_V2_ADDR_SEL_COMP_IDX                      12
+#define _DMA_V2_ADDR_SEL_COMP_BITS                      4
+#define _DMA_V2_ADDR_SEL_CH_REG_IDX                     2
+#define _DMA_V2_ADDR_SEL_CH_REG_BITS                    6
+#define _DMA_V2_ADDR_SEL_PARAM_IDX                      (_DMA_V2_ADDR_SEL_CH_REG_BITS+_DMA_V2_ADDR_SEL_CH_REG_IDX)
+#define _DMA_V2_ADDR_SEL_PARAM_BITS                     4
+
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_IDX                 2
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_BITS                6
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_IDX            (_DMA_V2_ADDR_SEL_GROUP_COMP_BITS + _DMA_V2_ADDR_SEL_GROUP_COMP_IDX)
+#define _DMA_V2_ADDR_SEL_GROUP_COMP_INFO_BITS           4
+
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX             2
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS            6
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_IDX            (_DMA_V2_ADDR_SEL_DEV_INTERF_IDX_IDX+_DMA_V2_ADDR_SEL_DEV_INTERF_IDX_BITS)
+#define _DMA_V2_ADDR_SEL_DEV_INTERF_INFO_BITS           4
+
+#define _DMA_V2_FSM_GROUP_CMD_IDX                       0
+#define _DMA_V2_FSM_GROUP_ADDR_SRC_IDX                  1
+#define _DMA_V2_FSM_GROUP_ADDR_DEST_IDX                 2
+#define _DMA_V2_FSM_GROUP_CMD_CTRL_IDX                  3
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_IDX                  4
+#define _DMA_V2_FSM_GROUP_FSM_PACK_IDX                  5
+#define _DMA_V2_FSM_GROUP_FSM_REQ_IDX                   6
+#define _DMA_V2_FSM_GROUP_FSM_WR_IDX                    7
+
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_STATE_IDX            0
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX          1
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX         2
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX       3
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_XB_IDX           4
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_REQ_YB_IDX           5
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX     6
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX      7
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX          8
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX        9
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX     10
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX      11
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX      12
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX   13
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX    14
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX        15
+#define _DMA_V2_FSM_GROUP_FSM_CTRL_CMD_CTRL_IDX        15
+
+#define _DMA_V2_FSM_GROUP_FSM_PACK_STATE_IDX            0
+#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_YB_IDX           1
+#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX       2
+#define _DMA_V2_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX        3
+
+#define _DMA_V2_FSM_GROUP_FSM_REQ_STATE_IDX             0
+#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_YB_IDX            1
+#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_XB_IDX            2
+#define _DMA_V2_FSM_GROUP_FSM_REQ_XB_REMAINING_IDX      3
+#define _DMA_V2_FSM_GROUP_FSM_REQ_CNT_BURST_IDX         4
+
+#define _DMA_V2_FSM_GROUP_FSM_WR_STATE_IDX              0
+#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_YB_IDX             1
+#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_XB_IDX             2
+#define _DMA_V2_FSM_GROUP_FSM_WR_XB_REMAINING_IDX       3
+#define _DMA_V2_FSM_GROUP_FSM_WR_CNT_BURST_IDX          4
+
+#define _DMA_V2_DEV_INTERF_REQ_SIDE_STATUS_IDX          0
+#define _DMA_V2_DEV_INTERF_SEND_SIDE_STATUS_IDX         1
+#define _DMA_V2_DEV_INTERF_FIFO_STATUS_IDX              2
+#define _DMA_V2_DEV_INTERF_REQ_ONLY_COMPLETE_BURST_IDX  3
+#define _DMA_V2_DEV_INTERF_MAX_BURST_IDX                4
+#define _DMA_V2_DEV_INTERF_CHK_ADDR_ALIGN               5
+
+#endif /* _dma_v2_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/gdc_v2_defs.h b/drivers/media/atomisp2/css2400/hrt/gdc_v2_defs.h
new file mode 100644
index 0000000..5b4f7a5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/gdc_v2_defs.h
@@ -0,0 +1,177 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef HRT_GDC_v2_defs_h_
+#define HRT_GDC_v2_defs_h_
+
+#define HRT_GDC_IS_V2
+
+#define HRT_GDC_N                     1024 /* Top-level design constant, equal to the number of entries in the LUT      */
+#define HRT_GDC_FRAC_BITS               10 /* Number of fractional bits in the GDC block, driven by the size of the LUT */
+
+#define HRT_GDC_BLI_FRAC_BITS            4 /* Number of fractional bits for the bi-linear interpolation type            */
+#define HRT_GDC_BLI_COEF_ONE             (1 << HRT_GDC_BLI_FRAC_BITS)
+
+#define HRT_GDC_BCI_COEF_BITS           14 /* 14 bits per coefficient                                                   */
+#define HRT_GDC_BCI_COEF_ONE             (1 << (HRT_GDC_BCI_COEF_BITS-2))  /* We represent signed 10 bit coefficients.  */
+                                                                        /* The supported range is [-256, .., +256]      */
+                                                                        /* in 14-bit signed notation,                   */
+                                                                        /* We need all ten bits (MSB must be zero).     */
+                                                                        /* -s is inserted to solve this issue, and      */
+                                                                        /* therefore "1" is equal to +256.              */
+#define HRT_GDC_BCI_COEF_MASK            ((1 << HRT_GDC_BCI_COEF_BITS) - 1)
+
+#define HRT_GDC_LUT_BYTES                (HRT_GDC_N*4*2)                /* 1024 addresses, 4 coefficients per address,  */
+                                                                        /* 2 bytes per coefficient                      */
+
+#define _HRT_GDC_REG_ALIGN               4
+
+  //     31  30  29    25 24                     0
+  //  |-----|---|--------|------------------------|
+  //  | CMD | C | Reg_ID |        Value           |
+
+
+  // There are just two commands possible for the GDC block:
+  // 1 - Configure reg
+  // 0 - Data token
+
+  // C      - Reserved bit
+  //          Used in protocol to indicate whether it is C-run or other type of runs
+  //          In case of C-run, this bit has a value of 1, for all the other runs, it is 0.
+
+  // Reg_ID - Address of the register to be configured
+
+  // Value  - Value to store to the addressed register, maximum of 24 bits
+
+  // Configure reg command is not followed by any other token.
+  // The address of the register and the data to be filled in is contained in the same token
+
+  // When the first data token is received, it must be:
+  //   1. FRX and FRY (device configured in one of the  scaling modes) ***DEFAULT MODE***, or,
+  //   2. P0'X        (device configured in one of the tetragon modes)
+  // After the first data token is received, pre-defined number of tokens with the following meaning follow:
+  //   1. two  tokens: SRC address ; DST address
+  //   2. nine tokens: P0'Y, .., P3'Y ; SRC address ; DST address
+
+#define HRT_GDC_CONFIG_CMD             1
+#define HRT_GDC_DATA_CMD               0
+
+
+#define HRT_GDC_CMD_POS               31
+#define HRT_GDC_CMD_BITS               1
+#define HRT_GDC_CRUN_POS              30
+#define HRT_GDC_REG_ID_POS            25
+#define HRT_GDC_REG_ID_BITS            5
+#define HRT_GDC_DATA_POS               0
+#define HRT_GDC_DATA_BITS             25
+
+#define HRT_GDC_FRYIPXFRX_BITS        26
+#define HRT_GDC_P0X_BITS              23
+
+
+#define HRT_GDC_MAX_OXDIM           (8192-64)
+#define HRT_GDC_MAX_OYDIM           4095
+#define HRT_GDC_MAX_IXDIM           (8192-64)
+#define HRT_GDC_MAX_IYDIM           4095
+#define HRT_GDC_MAX_DS_FAC            16
+#define HRT_GDC_MAX_DX                 (HRT_GDC_MAX_DS_FAC*HRT_GDC_N - 1)
+#define HRT_GDC_MAX_DY                 HRT_GDC_MAX_DX
+
+
+/* GDC lookup tables entries are 10 bits values, but they're
+   stored 2 by 2 as 32 bit values, yielding 16 bits per entry.
+   A GDC lookup table contains 64 * 4 elements */
+
+#define HRT_GDC_PERF_1_1_pix          0
+#define HRT_GDC_PERF_2_1_pix          1
+#define HRT_GDC_PERF_1_2_pix          2
+#define HRT_GDC_PERF_2_2_pix          3
+
+#define HRT_GDC_NND_MODE              0
+#define HRT_GDC_BLI_MODE              1
+#define HRT_GDC_BCI_MODE              2
+#define HRT_GDC_LUT_MODE              3
+
+#define HRT_GDC_SCAN_STB              0
+#define HRT_GDC_SCAN_STR              1
+
+#define HRT_GDC_MODE_SCALING          0
+#define HRT_GDC_MODE_TETRAGON         1
+
+#define HRT_GDC_LUT_COEFF_OFFSET     16
+#define HRT_GDC_FRY_BIT_OFFSET       16
+// FRYIPXFRX is the only register where we store two values in one field,
+// to save one token in the scaling protocol.
+// Like this, we have three tokens in the scaling protocol,
+// Otherwise, we would have had four.
+// The register bit-map is:
+//   31  26 25      16 15  10 9        0
+//  |------|----------|------|----------|
+//  | XXXX |   FRY    |  IPX |   FRX    |
+
+
+#define HRT_GDC_CE_FSM0_POS           0
+#define HRT_GDC_CE_FSM0_LEN           2
+#define HRT_GDC_CE_OPY_POS            2
+#define HRT_GDC_CE_OPY_LEN           14
+#define HRT_GDC_CE_OPX_POS           16
+#define HRT_GDC_CE_OPX_LEN           16
+// CHK_ENGINE register bit-map:
+//   31            16 15        2 1  0
+//  |----------------|-----------|----|
+//  |      OPX       |    OPY    |FSM0|
+// However, for the time being at least,
+// this implementation is meaningless in hss model,
+// So, we just return 0
+
+
+#define HRT_GDC_CHK_ENGINE_IDX        0
+#define HRT_GDC_WOIX_IDX              1
+#define HRT_GDC_WOIY_IDX              2
+#define HRT_GDC_BPP_IDX               3
+#define HRT_GDC_FRYIPXFRX_IDX         4
+#define HRT_GDC_OXDIM_IDX             5
+#define HRT_GDC_OYDIM_IDX             6
+#define HRT_GDC_SRC_ADDR_IDX          7
+#define HRT_GDC_SRC_END_ADDR_IDX      8
+#define HRT_GDC_SRC_WRAP_ADDR_IDX     9
+#define HRT_GDC_SRC_STRIDE_IDX       10
+#define HRT_GDC_DST_ADDR_IDX         11
+#define HRT_GDC_DST_STRIDE_IDX       12
+#define HRT_GDC_DX_IDX               13
+#define HRT_GDC_DY_IDX               14
+#define HRT_GDC_P0X_IDX              15
+#define HRT_GDC_P0Y_IDX              16
+#define HRT_GDC_P1X_IDX              17
+#define HRT_GDC_P1Y_IDX              18
+#define HRT_GDC_P2X_IDX              19
+#define HRT_GDC_P2Y_IDX              20
+#define HRT_GDC_P3X_IDX              21
+#define HRT_GDC_P3Y_IDX              22
+#define HRT_GDC_PERF_POINT_IDX       23  // 1x1 ; 1x2 ; 2x1 ; 2x2 pixels per cc
+#define HRT_GDC_INTERP_TYPE_IDX      24  // NND ; BLI ; BCI ; LUT
+#define HRT_GDC_SCAN_IDX             25  // 0 = STB (Slide To Bottom) ; 1 = STR (Slide To Right)
+#define HRT_GDC_PROC_MODE_IDX        26  // 0 = Scaling ; 1 = Tetragon
+
+#define HRT_GDC_LUT_IDX              32
+
+
+#endif /* HRT_GDC_v2_defs_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/gp_regs_defs.h b/drivers/media/atomisp2/css2400/hrt/gp_regs_defs.h
new file mode 100644
index 0000000..0e10a65
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/gp_regs_defs.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _gp_regs_defs_h
+#define _gp_regs_defs_h
+
+#define _HRT_GP_REGS_IS_FWD_REG_IDX 0
+
+#define _HRT_GP_REGS_REG_ALIGN 4
+
+#endif /* _gp_regs_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/gpio_block_defs.h b/drivers/media/atomisp2/css2400/hrt/gpio_block_defs.h
new file mode 100644
index 0000000..f5b1c69
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/gpio_block_defs.h
@@ -0,0 +1,49 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _gpio_block_defs_h_
+#define _gpio_block_defs_h_
+
+#define _HRT_GPIO_BLOCK_REG_ALIGN 4
+
+/* R/W registers */
+#define _gpio_block_reg_do_e			         0
+#define _gpio_block_reg_do_select		       1
+#define _gpio_block_reg_do_0			         2
+#define _gpio_block_reg_do_1			         3
+#define _gpio_block_reg_do_pwm_cnt_0	     4
+#define _gpio_block_reg_do_pwm_cnt_1	     5
+#define _gpio_block_reg_do_pwm_cnt_2	     6
+#define _gpio_block_reg_do_pwm_cnt_3	     7
+#define _gpio_block_reg_do_pwm_main_cnt    8
+#define _gpio_block_reg_do_pwm_enable      9
+#define _gpio_block_reg_di_debounce_sel	  10
+#define _gpio_block_reg_di_debounce_cnt_0	11
+#define _gpio_block_reg_di_debounce_cnt_1	12
+#define _gpio_block_reg_di_debounce_cnt_2	13
+#define _gpio_block_reg_di_debounce_cnt_3	14
+#define _gpio_block_reg_di_active_level	  15
+
+
+/* read-only registers */
+#define _gpio_block_reg_di			          16
+
+#endif /* _gpio_block_defs_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/hive_isp_css_defs.h b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_defs.h
new file mode 100644
index 0000000..d866439
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_defs.h
@@ -0,0 +1,423 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _hive_isp_css_defs_h__
+#define _hive_isp_css_defs_h__
+
+#define HIVE_ISP_CSS_IS_2400B0_SYSTEM
+
+#define HIVE_ISP_CTRL_DATA_WIDTH     32
+#define HIVE_ISP_CTRL_ADDRESS_WIDTH  32
+#define HIVE_ISP_CTRL_MAX_BURST_SIZE  1
+#define HIVE_ISP_DDR_ADDRESS_WIDTH   36
+
+#define HIVE_ISP_HOST_MAX_BURST_SIZE  8 /* host supports bursts in order to prevent repeating DDRAM accesses */
+#define HIVE_ISP_NUM_GPIO_PINS       12
+
+/* This list of vector num_elems/elem_bits pairs is valid both in C as initializer
+   and in the DMA parameter list */
+#define HIVE_ISP_DDR_DMA_SPECS {{32,  8}, {16, 16}, {18, 14}, {25, 10}, {21, 12}}
+#define HIVE_ISP_DDR_WORD_BITS 256
+#define HIVE_ISP_DDR_WORD_BYTES  (HIVE_ISP_DDR_WORD_BITS/8)
+#define HIVE_ISP_DDR_BYTES       (512 * 1024 * 1024) /* hss only */
+#define HIVE_ISP_DDR_BYTES_RTL   (127 * 1024 * 1024) /* RTL only */
+#define HIVE_ISP_DDR_SMALL_BYTES (128 * 256 / 8)
+#define HIVE_ISP_PAGE_SHIFT    12
+#define HIVE_ISP_PAGE_SIZE     (1<<HIVE_ISP_PAGE_SHIFT)
+
+#define CSS_DDR_WORD_BITS        HIVE_ISP_DDR_WORD_BITS
+#define CSS_DDR_WORD_BYTES       HIVE_ISP_DDR_WORD_BYTES
+
+/* If HIVE_ISP_DDR_BASE_OFFSET is set to a non-zero value, the wide bus just before the DDRAM gets an extra dummy port where         */
+/* address range 0 .. HIVE_ISP_DDR_BASE_OFFSET-1 maps onto. This effectively creates an offset for the DDRAM from system perspective */
+#define HIVE_ISP_DDR_BASE_OFFSET 0x120000000 /* 0x200000 */
+
+#define HIVE_DMA_ISP_BUS_CONN 0
+#define HIVE_DMA_ISP_DDR_CONN 1
+#define HIVE_DMA_BUS_DDR_CONN 2
+#define HIVE_DMA_ISP_MASTER master_port0
+#define HIVE_DMA_BUS_MASTER master_port1
+#define HIVE_DMA_DDR_MASTER master_port2
+
+#define HIVE_DMA_NUM_CHANNELS       32 /* old value was  8 */
+#define HIVE_DMA_CMD_FIFO_DEPTH     24 /* old value was 12 */
+
+#define HIVE_IF_PIXEL_WIDTH 12
+
+#define HIVE_MMU_TLB_SETS           8
+#define HIVE_MMU_TLB_SET_BLOCKS     8
+#define HIVE_MMU_TLB_BLOCK_ELEMENTS 8
+#define HIVE_MMU_PAGE_TABLE_LEVELS  2
+#define HIVE_MMU_PAGE_BYTES         HIVE_ISP_PAGE_SIZE
+
+#define HIVE_ISP_CH_ID_BITS    2
+#define HIVE_ISP_FMT_TYPE_BITS 5
+#define HIVE_ISP_ISEL_SEL_BITS 2
+
+#define HIVE_GP_REGS_SDRAM_WAKEUP_IDX                           0
+#define HIVE_GP_REGS_IDLE_IDX                                   1
+#define HIVE_GP_REGS_IRQ_0_IDX                                  2
+#define HIVE_GP_REGS_IRQ_1_IDX                                  3
+#define HIVE_GP_REGS_SP_STREAM_STAT_IDX                         4
+#define HIVE_GP_REGS_SP_STREAM_STAT_B_IDX                       5
+#define HIVE_GP_REGS_ISP_STREAM_STAT_IDX                        6
+#define HIVE_GP_REGS_MOD_STREAM_STAT_IDX                        7
+#define HIVE_GP_REGS_SP_STREAM_STAT_IRQ_COND_IDX                8
+#define HIVE_GP_REGS_SP_STREAM_STAT_B_IRQ_COND_IDX              9
+#define HIVE_GP_REGS_ISP_STREAM_STAT_IRQ_COND_IDX              10
+#define HIVE_GP_REGS_MOD_STREAM_STAT_IRQ_COND_IDX              11
+#define HIVE_GP_REGS_SP_STREAM_STAT_IRQ_ENABLE_IDX             12
+#define HIVE_GP_REGS_SP_STREAM_STAT_B_IRQ_ENABLE_IDX           13
+#define HIVE_GP_REGS_ISP_STREAM_STAT_IRQ_ENABLE_IDX            14
+#define HIVE_GP_REGS_MOD_STREAM_STAT_IRQ_ENABLE_IDX            15
+#define HIVE_GP_REGS_SWITCH_PRIM_IF_IDX                        16
+#define HIVE_GP_REGS_SWITCH_GDC1_IDX                           17
+#define HIVE_GP_REGS_SWITCH_GDC2_IDX                           18
+#define HIVE_GP_REGS_SRST_IDX                                  19
+#define HIVE_GP_REGS_SLV_REG_SRST_IDX                          20
+#define HIVE_GP_REGS_VISA_REG_IDX                              21
+
+/* Bit numbers of the soft reset register */
+#define HIVE_GP_REGS_SRST_ISYS_CBUS                             0
+#define HIVE_GP_REGS_SRST_ISEL_CBUS                             1
+#define HIVE_GP_REGS_SRST_IFMT_CBUS                             2
+#define HIVE_GP_REGS_SRST_GPDEV_CBUS                            3
+#define HIVE_GP_REGS_SRST_GPIO                                  4
+#define HIVE_GP_REGS_SRST_TC                                    5
+#define HIVE_GP_REGS_SRST_GPTIMER                               6
+#define HIVE_GP_REGS_SRST_FACELLFIFOS                           7
+#define HIVE_GP_REGS_SRST_D_OSYS                                8
+#define HIVE_GP_REGS_SRST_IFT_SEC_PIPE                          9
+#define HIVE_GP_REGS_SRST_GDC1                                 10
+#define HIVE_GP_REGS_SRST_GDC2                                 11
+#define HIVE_GP_REGS_SRST_VEC_BUS                              12
+#define HIVE_GP_REGS_SRST_ISP                                  13
+#define HIVE_GP_REGS_SRST_SLV_GRP_BUS                          14
+#define HIVE_GP_REGS_SRST_DMA                                  15
+#define HIVE_GP_REGS_SRST_SF_ISP_SP                            16
+#define HIVE_GP_REGS_SRST_SF_PIF_CELLS                         17
+#define HIVE_GP_REGS_SRST_SF_SIF_SP                            18
+#define HIVE_GP_REGS_SRST_SF_MC_SP                             19
+#define HIVE_GP_REGS_SRST_SF_ISYS_SP                           20
+#define HIVE_GP_REGS_SRST_SF_DMA_CELLS                         21
+#define HIVE_GP_REGS_SRST_SF_GDC1_CELLS                        22
+#define HIVE_GP_REGS_SRST_SF_GDC2_CELLS                        23
+#define HIVE_GP_REGS_SRST_SP                                   24
+#define HIVE_GP_REGS_SRST_OCP2CIO                              25
+#define HIVE_GP_REGS_SRST_NBUS                                 26
+#define HIVE_GP_REGS_SRST_HOST12BUS                            27
+#define HIVE_GP_REGS_SRST_WBUS                                 28
+#define HIVE_GP_REGS_SRST_IC_OSYS                              29
+#define HIVE_GP_REGS_SRST_WBUS_IC                              30
+
+/* Bit numbers of the slave register soft reset register */
+#define HIVE_GP_REGS_SLV_REG_SRST_DMA                           0
+#define HIVE_GP_REGS_SLV_REG_SRST_GDC1                          1
+#define HIVE_GP_REGS_SLV_REG_SRST_GDC2                          2
+
+/* order of the input bits for the irq controller */
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID                       0
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID                       1
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID                       2
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID                       3
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID                       4
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID                       5
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID                       6
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID                       7
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID                       8
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID                       9
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID                     10
+#define HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID                     11
+#define HIVE_GP_DEV_IRQ_SP_BIT_ID                              12
+#define HIVE_GP_DEV_IRQ_ISP_BIT_ID                             13
+#define HIVE_GP_DEV_IRQ_ISYS_BIT_ID                            14
+#define HIVE_GP_DEV_IRQ_ISEL_BIT_ID                            15
+#define HIVE_GP_DEV_IRQ_IFMT_BIT_ID                            16
+#define HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID                   17
+#define HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID                  18
+#define HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID                  19
+#define HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID                  20
+#define HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID                 21
+#define HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID                  22
+#define HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID             23
+#define HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID                   24
+#define HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID             25
+#define HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID                      26
+#define HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID                      27
+#define HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID                        28
+#define HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID                        29
+#define HIVE_GP_DEV_IRQ_DMA_BIT_ID                             30
+#define HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID                 31
+
+#define HIVE_GP_REGS_NUM_SW_IRQ_REGS                            2
+
+/* order of the input bits for the timed controller */
+#define HIVE_GP_DEV_TC_GPIO_PIN_0_BIT_ID                       0
+#define HIVE_GP_DEV_TC_GPIO_PIN_1_BIT_ID                       1
+#define HIVE_GP_DEV_TC_GPIO_PIN_2_BIT_ID                       2
+#define HIVE_GP_DEV_TC_GPIO_PIN_3_BIT_ID                       3
+#define HIVE_GP_DEV_TC_GPIO_PIN_4_BIT_ID                       4
+#define HIVE_GP_DEV_TC_GPIO_PIN_5_BIT_ID                       5
+#define HIVE_GP_DEV_TC_GPIO_PIN_6_BIT_ID                       6
+#define HIVE_GP_DEV_TC_GPIO_PIN_7_BIT_ID                       7
+#define HIVE_GP_DEV_TC_GPIO_PIN_8_BIT_ID                       8
+#define HIVE_GP_DEV_TC_GPIO_PIN_9_BIT_ID                       9
+#define HIVE_GP_DEV_TC_GPIO_PIN_10_BIT_ID                     10
+#define HIVE_GP_DEV_TC_GPIO_PIN_11_BIT_ID                     11
+#define HIVE_GP_DEV_TC_SP_BIT_ID                              12
+#define HIVE_GP_DEV_TC_ISP_BIT_ID                             13
+#define HIVE_GP_DEV_TC_ISYS_BIT_ID                            14
+#define HIVE_GP_DEV_TC_ISEL_BIT_ID                            15
+#define HIVE_GP_DEV_TC_IFMT_BIT_ID                            16
+#define HIVE_GP_DEV_TC_GP_TIMER_0_BIT_ID                      17
+#define HIVE_GP_DEV_TC_GP_TIMER_1_BIT_ID                      18
+#define HIVE_GP_DEV_TC_MIPI_SOL_BIT_ID                        19
+#define HIVE_GP_DEV_TC_MIPI_EOL_BIT_ID                        20
+#define HIVE_GP_DEV_TC_MIPI_SOF_BIT_ID                        21
+#define HIVE_GP_DEV_TC_MIPI_EOF_BIT_ID                        22
+#define HIVE_GP_DEV_TC_INPSYS_SM                              23
+
+/* definitions for the gp_timer block */
+#define HIVE_GP_TIMER_0                                         0
+#define HIVE_GP_TIMER_1                                         1
+#define HIVE_GP_TIMER_2                                         2
+#define HIVE_GP_TIMER_3                                         3
+#define HIVE_GP_TIMER_4                                         4
+#define HIVE_GP_TIMER_5                                         5
+#define HIVE_GP_TIMER_6                                         6
+#define HIVE_GP_TIMER_7                                         7
+#define HIVE_GP_TIMER_NUM_COUNTERS                              8
+
+#define HIVE_GP_TIMER_IRQ_0                                     0
+#define HIVE_GP_TIMER_IRQ_1                                     1
+#define HIVE_GP_TIMER_NUM_IRQS                                  2
+
+#define HIVE_GP_TIMER_GPIO_0_BIT_ID                             0
+#define HIVE_GP_TIMER_GPIO_1_BIT_ID                             1
+#define HIVE_GP_TIMER_GPIO_2_BIT_ID                             2
+#define HIVE_GP_TIMER_GPIO_3_BIT_ID                             3
+#define HIVE_GP_TIMER_GPIO_4_BIT_ID                             4
+#define HIVE_GP_TIMER_GPIO_5_BIT_ID                             5
+#define HIVE_GP_TIMER_GPIO_6_BIT_ID                             6
+#define HIVE_GP_TIMER_GPIO_7_BIT_ID                             7
+#define HIVE_GP_TIMER_GPIO_8_BIT_ID                             8
+#define HIVE_GP_TIMER_GPIO_9_BIT_ID                             9
+#define HIVE_GP_TIMER_GPIO_10_BIT_ID                           10
+#define HIVE_GP_TIMER_GPIO_11_BIT_ID                           11
+#define HIVE_GP_TIMER_INP_SYS_IRQ                              12
+#define HIVE_GP_TIMER_ISEL_IRQ                                 13
+#define HIVE_GP_TIMER_IFMT_IRQ                                 14
+#define HIVE_GP_TIMER_SP_STRMON_IRQ                            15
+#define HIVE_GP_TIMER_SP_B_STRMON_IRQ                          16
+#define HIVE_GP_TIMER_ISP_STRMON_IRQ                           17
+#define HIVE_GP_TIMER_MOD_STRMON_IRQ                           18
+#define HIVE_GP_TIMER_ISP_PMEM_ERROR_IRQ                       19
+#define HIVE_GP_TIMER_ISP_BAMEM_ERROR_IRQ                      20
+#define HIVE_GP_TIMER_ISP_DMEM_ERROR_IRQ                       21
+#define HIVE_GP_TIMER_SP_ICACHE_MEM_ERROR_IRQ                  22
+#define HIVE_GP_TIMER_SP_DMEM_ERROR_IRQ                        23
+#define HIVE_GP_TIMER_SP_OUT_RUN_DP                            24
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I0         25
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I1         26
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I2         27
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I3         28
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I4         29
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I5         30
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I6         31
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I7         32
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I8         33
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I9         34
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I0_I10        35
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I1_I0         36
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I2_I0         37
+#define HIVE_GP_TIMER_SP_WIRE_DEBUG_LM_MSINK_RUN_I3_I0         38
+#define HIVE_GP_TIMER_ISP_OUT_RUN_DP                           39
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I0_I0        40
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I0_I1        41
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I1_I0        42
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I0        43
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I1        44
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I2        45
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I3        46
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I4        47
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I5        48
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I2_I6        49
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I3_I0        50
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I4_I0        51
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I5_I0        52
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I6_I0        53
+#define HIVE_GP_TIMER_ISP_WIRE_DEBUG_LM_MSINK_RUN_I7_I0        54
+#define HIVE_GP_TIMER_MIPI_SOL_BIT_ID                          55
+#define HIVE_GP_TIMER_MIPI_EOL_BIT_ID                          56
+#define HIVE_GP_TIMER_MIPI_SOF_BIT_ID                          57
+#define HIVE_GP_TIMER_MIPI_EOF_BIT_ID                          58
+#define HIVE_GP_TIMER_INPSYS_SM                                59
+
+/* port definitions for the streaming monitors */
+/* port definititions SP streaming monitor, monitors the status of streaming ports at the SP side of the streaming FIFO's */
+#define SP_STR_MON_PORT_SP2SIF            0
+#define SP_STR_MON_PORT_SIF2SP            1
+#define SP_STR_MON_PORT_SP2MC             2
+#define SP_STR_MON_PORT_MC2SP             3
+#define SP_STR_MON_PORT_SP2DMA            4
+#define SP_STR_MON_PORT_DMA2SP            5
+#define SP_STR_MON_PORT_SP2ISP            6
+#define SP_STR_MON_PORT_ISP2SP            7
+#define SP_STR_MON_PORT_SP2GPD            8
+#define SP_STR_MON_PORT_FA2SP             9
+#define SP_STR_MON_PORT_SP2ISYS          10
+#define SP_STR_MON_PORT_ISYS2SP          11
+#define SP_STR_MON_PORT_SP2PIFA          12
+#define SP_STR_MON_PORT_PIFA2SP          13
+#define SP_STR_MON_PORT_SP2PIFB          14
+#define SP_STR_MON_PORT_PIFB2SP          15
+
+#define SP_STR_MON_PORT_B_SP2GDC1         0
+#define SP_STR_MON_PORT_B_GDC12SP         1
+#define SP_STR_MON_PORT_B_SP2GDC2         2
+#define SP_STR_MON_PORT_B_GDC22SP         3
+
+/* previously used SP streaming monitor port identifiers, kept for backward compatibility */
+#define SP_STR_MON_PORT_SND_SIF           SP_STR_MON_PORT_SP2SIF
+#define SP_STR_MON_PORT_RCV_SIF           SP_STR_MON_PORT_SIF2SP
+#define SP_STR_MON_PORT_SND_MC            SP_STR_MON_PORT_SP2MC
+#define SP_STR_MON_PORT_RCV_MC            SP_STR_MON_PORT_MC2SP
+#define SP_STR_MON_PORT_SND_DMA           SP_STR_MON_PORT_SP2DMA
+#define SP_STR_MON_PORT_RCV_DMA           SP_STR_MON_PORT_DMA2SP
+#define SP_STR_MON_PORT_SND_ISP           SP_STR_MON_PORT_SP2ISP
+#define SP_STR_MON_PORT_RCV_ISP           SP_STR_MON_PORT_ISP2SP
+#define SP_STR_MON_PORT_SND_GPD           SP_STR_MON_PORT_SP2GPD
+#define SP_STR_MON_PORT_RCV_GPD           SP_STR_MON_PORT_FA2SP
+/* Deprecated */
+#define SP_STR_MON_PORT_SND_PIF           SP_STR_MON_PORT_SP2PIFA
+#define SP_STR_MON_PORT_RCV_PIF           SP_STR_MON_PORT_PIFA2SP
+#define SP_STR_MON_PORT_SND_PIFB          SP_STR_MON_PORT_SP2PIFB
+#define SP_STR_MON_PORT_RCV_PIFB          SP_STR_MON_PORT_PIFB2SP
+
+#define SP_STR_MON_PORT_SND_PIF_A         SP_STR_MON_PORT_SP2PIFA
+#define SP_STR_MON_PORT_RCV_PIF_A         SP_STR_MON_PORT_PIFA2SP
+#define SP_STR_MON_PORT_SND_PIF_B         SP_STR_MON_PORT_SP2PIFB
+#define SP_STR_MON_PORT_RCV_PIF_B         SP_STR_MON_PORT_PIFB2SP
+
+/* port definititions ISP streaming monitor, monitors the status of streaming ports at the ISP side of the streaming FIFO's */
+#define ISP_STR_MON_PORT_ISP2PIFA         0
+#define ISP_STR_MON_PORT_PIFA2ISP         1
+#define ISP_STR_MON_PORT_ISP2PIFB         2
+#define ISP_STR_MON_PORT_PIFB2ISP         3
+#define ISP_STR_MON_PORT_ISP2DMA          4
+#define ISP_STR_MON_PORT_DMA2ISP          5
+#define ISP_STR_MON_PORT_ISP2GDC1         6
+#define ISP_STR_MON_PORT_GDC12ISP         7
+#define ISP_STR_MON_PORT_ISP2GDC2         8
+#define ISP_STR_MON_PORT_GDC22ISP         9
+#define ISP_STR_MON_PORT_ISP2GPD         10
+#define ISP_STR_MON_PORT_FA2ISP          11
+#define ISP_STR_MON_PORT_ISP2SP          12
+#define ISP_STR_MON_PORT_SP2ISP          13
+
+/* previously used ISP streaming monitor port identifiers, kept for backward compatibility */
+#define ISP_STR_MON_PORT_SND_PIF_A       ISP_STR_MON_PORT_ISP2PIFA
+#define ISP_STR_MON_PORT_RCV_PIF_A       ISP_STR_MON_PORT_PIFA2ISP
+#define ISP_STR_MON_PORT_SND_PIF_B       ISP_STR_MON_PORT_ISP2PIFB
+#define ISP_STR_MON_PORT_RCV_PIF_B       ISP_STR_MON_PORT_PIFB2ISP
+#define ISP_STR_MON_PORT_SND_DMA         ISP_STR_MON_PORT_ISP2DMA
+#define ISP_STR_MON_PORT_RCV_DMA         ISP_STR_MON_PORT_DMA2ISP
+#define ISP_STR_MON_PORT_SND_GDC         ISP_STR_MON_PORT_ISP2GDC1
+#define ISP_STR_MON_PORT_RCV_GDC         ISP_STR_MON_PORT_GDC12ISP
+#define ISP_STR_MON_PORT_SND_GPD         ISP_STR_MON_PORT_ISP2GPD
+#define ISP_STR_MON_PORT_RCV_GPD         ISP_STR_MON_PORT_FA2ISP
+#define ISP_STR_MON_PORT_SND_SP          ISP_STR_MON_PORT_ISP2SP
+#define ISP_STR_MON_PORT_RCV_SP          ISP_STR_MON_PORT_SP2ISP
+
+/* port definititions MOD streaming monitor, monitors the status of streaming ports at the module side of the streaming FIFO's */
+
+#define MOD_STR_MON_PORT_PIFA2CELLS       0
+#define MOD_STR_MON_PORT_CELLS2PIFA       1
+#define MOD_STR_MON_PORT_PIFB2CELLS       2
+#define MOD_STR_MON_PORT_CELLS2PIFB       3
+#define MOD_STR_MON_PORT_SIF2SP           4
+#define MOD_STR_MON_PORT_SP2SIF           5
+#define MOD_STR_MON_PORT_MC2SP            6
+#define MOD_STR_MON_PORT_SP2MC            7
+#define MOD_STR_MON_PORT_DMA2ISP          8
+#define MOD_STR_MON_PORT_ISP2DMA          9
+#define MOD_STR_MON_PORT_DMA2SP          10
+#define MOD_STR_MON_PORT_SP2DMA          11
+#define MOD_STR_MON_PORT_GDC12CELLS      12
+#define MOD_STR_MON_PORT_CELLS2GDC1      13
+#define MOD_STR_MON_PORT_GDC22CELLS      14
+#define MOD_STR_MON_PORT_CELLS2GDC2      15
+
+#define MOD_STR_MON_PORT_SND_PIF_A        0
+#define MOD_STR_MON_PORT_RCV_PIF_A        1
+#define MOD_STR_MON_PORT_SND_PIF_B        2
+#define MOD_STR_MON_PORT_RCV_PIF_B        3
+#define MOD_STR_MON_PORT_SND_SIF          4
+#define MOD_STR_MON_PORT_RCV_SIF          5
+#define MOD_STR_MON_PORT_SND_MC           6
+#define MOD_STR_MON_PORT_RCV_MC           7
+#define MOD_STR_MON_PORT_SND_DMA2ISP      8
+#define MOD_STR_MON_PORT_RCV_DMA_FR_ISP   9
+#define MOD_STR_MON_PORT_SND_DMA2SP      10
+#define MOD_STR_MON_PORT_RCV_DMA_FR_SP   11
+#define MOD_STR_MON_PORT_SND_GDC         12
+#define MOD_STR_MON_PORT_RCV_GDC         13
+
+
+/* testbench signals:       */
+
+/* testbench GP adapter register ids  */
+#define HIVE_TESTBENCH_GPIO_DATA_OUT_REG_IDX                    0
+#define HIVE_TESTBENCH_GPIO_DIR_OUT_REG_IDX                     1
+#define HIVE_TESTBENCH_IRQ_REG_IDX                              2
+#define HIVE_TESTBENCH_SDRAM_WAKEUP_REG_IDX                     3
+#define HIVE_TESTBENCH_IDLE_REG_IDX                             4
+#define HIVE_TESTBENCH_GPIO_DATA_IN_REG_IDX                     5
+#define HIVE_TESTBENCH_MIPI_BFM_EN_REG_IDX                      6
+#define HIVE_TESTBENCH_CSI_CONFIG_REG_IDX                       7
+#define HIVE_TESTBENCH_DDR_STALL_EN_REG_IDX                     8
+
+#define HIVE_TESTBENCH_ISP_PMEM_ERROR_IRQ_REG_IDX               9
+#define HIVE_TESTBENCH_ISP_BAMEM_ERROR_IRQ_REG_IDX             10
+#define HIVE_TESTBENCH_ISP_DMEM_ERROR_IRQ_REG_IDX              11
+#define HIVE_TESTBENCH_SP_ICACHE_MEM_ERROR_IRQ_REG_IDX         12
+#define HIVE_TESTBENCH_SP_DMEM_ERROR_IRQ_REG_IDX               13
+
+/* Signal monitor input bit ids */
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_O_BIT_ID                0
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_1_BIT_ID                1
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_2_BIT_ID                2
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_3_BIT_ID                3
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_4_BIT_ID                4
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_5_BIT_ID                5
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_6_BIT_ID                6
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_7_BIT_ID                7
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_8_BIT_ID                8
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_9_BIT_ID                9
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_10_BIT_ID              10
+#define HIVE_TESTBENCH_SIG_MON_GPIO_PIN_11_BIT_ID              11
+#define HIVE_TESTBENCH_SIG_MON_IRQ_PIN_BIT_ID                  12
+#define HIVE_TESTBENCH_SIG_MON_SDRAM_WAKEUP_PIN_BIT_ID         13
+#define HIVE_TESTBENCH_SIG_MON_IDLE_PIN_BIT_ID                 14
+
+#define ISP2400_DEBUG_NETWORK    1
+
+#endif /* _hive_isp_css_defs_h__ */
diff --git a/drivers/media/atomisp2/css2400/hrt/hive_isp_css_host_ids_hrt.h b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_host_ids_hrt.h
new file mode 100644
index 0000000..6a1131d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_host_ids_hrt.h
@@ -0,0 +1,91 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _hive_isp_css_host_ids_hrt_h_
+#define _hive_isp_css_host_ids_hrt_h_
+
+/* ISP_CSS identifiers */
+#define INP_SYS       testbench_isp_inp_sys
+#define ISYS_GP_REGS  testbench_isp_inp_sys_gpreg
+#define ISYS_IRQ_CTRL testbench_isp_inp_sys_irq_ctrl
+#define ISYS_CAP_A    testbench_isp_inp_sys_capt_unit_a
+#define ISYS_CAP_B    testbench_isp_inp_sys_capt_unit_b
+#define ISYS_CAP_C    testbench_isp_inp_sys_capt_unit_c
+#define ISYS_INP_BUF  testbench_isp_inp_sys_input_buffer
+#define ISYS_INP_CTRL testbench_isp_inp_sys_inp_ctrl
+#define ISYS_ACQ      testbench_isp_inp_sys_acq_unit
+
+#define ISP           testbench_isp_isp
+#define SP            testbench_isp_scp
+
+#define IF_PRIM       testbench_isp_ifmt_ift_prim
+#define IF_PRIM_B     testbench_isp_ifmt_ift_prim_b
+#define IF_SEC        testbench_isp_ifmt_ift_sec
+#define IF_SEC_MASTER testbench_isp_ifmt_ift_sec_mt_out
+#define STR_TO_MEM    testbench_isp_ifmt_mem_cpy
+#define IFMT_GP_REGS  testbench_isp_ifmt_gp_reg
+#define IFMT_IRQ_CTRL testbench_isp_ifmt_irq_ctrl
+
+#define CSS_RECEIVER  testbench_isp_inp_sys_csi_receiver
+
+#define TC            testbench_isp_gpd_tc
+#define GPTIMER       testbench_isp_gpd_gptimer
+#define DMA           testbench_isp_isp_dma
+#define GDC           testbench_isp_gdc1
+#define GDC2          testbench_isp_gdc2
+#define IRQ_CTRL      testbench_isp_gpd_irq_ctrl
+#define GPIO          testbench_isp_gpd_c_gpio
+#define GP_REGS       testbench_isp_gpd_gp_reg
+#define ISEL_GP_REGS  testbench_isp_isel_gpr
+#define ISEL_IRQ_CTRL testbench_isp_isel_irq_ctrl
+#define DATA_MMU      testbench_isp_data_out_sys_c_mmu
+#define ICACHE_MMU    testbench_isp_icache_out_sys_c_mmu
+
+/* next is actually not FIFO but FIFO adapter, or slave to streaming adapter */
+#define ISP_SP_FIFO   testbench_isp_fa_sp_isp
+#define ISEL_FIFO     testbench_isp_isel_sf_fa_in
+
+#define FIFO_GPF_SP   testbench_isp_sf_fa2sp_in
+#define FIFO_GPF_ISP  testbench_isp_sf_fa2isp_in
+#define FIFO_SP_GPF   testbench_isp_sf_sp2fa_in
+#define FIFO_ISP_GPF  testbench_isp_sf_isp2fa_in
+
+#define DATA_OCP_MASTER    testbench_isp_data_out_sys_cio2ocp_wide_data_out_mt
+#define ICACHE_OCP_MASTER  testbench_isp_icache_out_sys_cio2ocp_wide_data_out_mt
+
+#define SP_IN_FIFO    testbench_isp_sf_fa2sp_in
+#define SP_OUT_FIFO   testbench_isp_sf_sp2fa_out
+#define ISP_IN_FIFO   testbench_isp_sf_fa2isp_in
+#define ISP_OUT_FIFO  testbench_isp_sf_isp2fa_out
+#define GEN_SHORT_PACK_PORT testbench_isp_inp_sys_csi_str_mon_fa_gensh_out
+#define ISYS_GP_REGS  testbench_isp_inp_sys_gpreg
+
+/* Testbench identifiers */
+#define DDR             testbench_ddram
+#define DDR_SMALL       testbench_ddram_small
+#define XMEM            DDR
+#define GPIO_ADAPTER    testbench_gp_adapter
+#define SIG_MONITOR     testbench_sig_mon
+#define DDR_SLAVE       testbench_ddram_ip0
+#define DDR_SMALL_SLAVE testbench_ddram_small_ip0
+#define HOST_MASTER     host_op0
+
+#endif /* _hive_isp_css_host_ids_hrt_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/hive_isp_css_irq_types_hrt.h b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_irq_types_hrt.h
new file mode 100644
index 0000000..2f86327
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_irq_types_hrt.h
@@ -0,0 +1,79 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _HIVE_ISP_CSS_IRQ_TYPES_HRT_H_
+#define _HIVE_ISP_CSS_IRQ_TYPES_HRT_H_
+
+/*
+ * These are the indices of each interrupt in the interrupt
+ * controller's registers. these can be used as the irq_id
+ * argument to the hrt functions irq_controller.h.
+ *
+ * The definitions are taken from <system>_defs.h
+ */
+typedef enum hrt_isp_css_irq {
+  hrt_isp_css_irq_gpio_pin_0           = HIVE_GP_DEV_IRQ_GPIO_PIN_0_BIT_ID          ,
+  hrt_isp_css_irq_gpio_pin_1           = HIVE_GP_DEV_IRQ_GPIO_PIN_1_BIT_ID          ,
+  hrt_isp_css_irq_gpio_pin_2           = HIVE_GP_DEV_IRQ_GPIO_PIN_2_BIT_ID          ,
+  hrt_isp_css_irq_gpio_pin_3           = HIVE_GP_DEV_IRQ_GPIO_PIN_3_BIT_ID          ,
+  hrt_isp_css_irq_gpio_pin_4           = HIVE_GP_DEV_IRQ_GPIO_PIN_4_BIT_ID          ,
+  hrt_isp_css_irq_gpio_pin_5           = HIVE_GP_DEV_IRQ_GPIO_PIN_5_BIT_ID          ,
+  hrt_isp_css_irq_gpio_pin_6           = HIVE_GP_DEV_IRQ_GPIO_PIN_6_BIT_ID          ,
+  hrt_isp_css_irq_gpio_pin_7           = HIVE_GP_DEV_IRQ_GPIO_PIN_7_BIT_ID          ,
+  hrt_isp_css_irq_gpio_pin_8           = HIVE_GP_DEV_IRQ_GPIO_PIN_8_BIT_ID          ,
+  hrt_isp_css_irq_gpio_pin_9           = HIVE_GP_DEV_IRQ_GPIO_PIN_9_BIT_ID          ,
+  hrt_isp_css_irq_gpio_pin_10          = HIVE_GP_DEV_IRQ_GPIO_PIN_10_BIT_ID         ,
+  hrt_isp_css_irq_gpio_pin_11          = HIVE_GP_DEV_IRQ_GPIO_PIN_11_BIT_ID         ,
+  hrt_isp_css_irq_sp                   = HIVE_GP_DEV_IRQ_SP_BIT_ID                  ,
+  hrt_isp_css_irq_isp                  = HIVE_GP_DEV_IRQ_ISP_BIT_ID                 ,
+  hrt_isp_css_irq_isys                 = HIVE_GP_DEV_IRQ_ISYS_BIT_ID                ,
+  hrt_isp_css_irq_isel                 = HIVE_GP_DEV_IRQ_ISEL_BIT_ID                ,
+  hrt_isp_css_irq_ifmt                 = HIVE_GP_DEV_IRQ_IFMT_BIT_ID                ,
+  hrt_isp_css_irq_sp_stream_mon        = HIVE_GP_DEV_IRQ_SP_STREAM_MON_BIT_ID       ,
+  hrt_isp_css_irq_isp_stream_mon       = HIVE_GP_DEV_IRQ_ISP_STREAM_MON_BIT_ID      ,
+  hrt_isp_css_irq_mod_stream_mon       = HIVE_GP_DEV_IRQ_MOD_STREAM_MON_BIT_ID      ,
+#ifdef _HIVE_ISP_CSS_2401_SYSTEM
+  hrt_isp_css_irq_is2401               = HIVE_GP_DEV_IRQ_IS2401_BIT_ID              ,
+#else
+  hrt_isp_css_irq_isp_pmem_error       = HIVE_GP_DEV_IRQ_ISP_PMEM_ERROR_BIT_ID      ,
+#endif
+  hrt_isp_css_irq_isp_bamem_error      = HIVE_GP_DEV_IRQ_ISP_BAMEM_ERROR_BIT_ID     ,
+  hrt_isp_css_irq_isp_dmem_error       = HIVE_GP_DEV_IRQ_ISP_DMEM_ERROR_BIT_ID      ,
+  hrt_isp_css_irq_sp_icache_mem_error  = HIVE_GP_DEV_IRQ_SP_ICACHE_MEM_ERROR_BIT_ID ,
+  hrt_isp_css_irq_sp_dmem_error        = HIVE_GP_DEV_IRQ_SP_DMEM_ERROR_BIT_ID       ,
+  hrt_isp_css_irq_mmu_cache_mem_error  = HIVE_GP_DEV_IRQ_MMU_CACHE_MEM_ERROR_BIT_ID ,
+  hrt_isp_css_irq_gp_timer_0           = HIVE_GP_DEV_IRQ_GP_TIMER_0_BIT_ID          ,
+  hrt_isp_css_irq_gp_timer_1           = HIVE_GP_DEV_IRQ_GP_TIMER_1_BIT_ID          ,
+  hrt_isp_css_irq_sw_pin_0             = HIVE_GP_DEV_IRQ_SW_PIN_0_BIT_ID            ,
+  hrt_isp_css_irq_sw_pin_1             = HIVE_GP_DEV_IRQ_SW_PIN_1_BIT_ID            ,
+  hrt_isp_css_irq_dma                  = HIVE_GP_DEV_IRQ_DMA_BIT_ID                 ,
+  hrt_isp_css_irq_sp_stream_mon_b      = HIVE_GP_DEV_IRQ_SP_STREAM_MON_B_BIT_ID     ,
+  /* this must (obviously) be the last on in the enum */
+  hrt_isp_css_irq_num_irqs
+} hrt_isp_css_irq_t;
+
+typedef enum hrt_isp_css_irq_status {
+  hrt_isp_css_irq_status_error,
+  hrt_isp_css_irq_status_more_irqs,
+  hrt_isp_css_irq_status_success
+} hrt_isp_css_irq_status_t;
+
+#endif /* _HIVE_ISP_CSS_IRQ_TYPES_HRT_H_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h
new file mode 100644
index 0000000..af00e23
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _hive_isp_css_streaming_to_mipi_types_hrt_h_
+#define _hive_isp_css_streaming_to_mipi_types_hrt_h_
+
+#include <streaming_to_mipi_defs.h>
+
+#define _HIVE_ISP_CH_ID_MASK    ((1U << HIVE_ISP_CH_ID_BITS)-1)
+#define _HIVE_ISP_FMT_TYPE_MASK ((1U << HIVE_ISP_FMT_TYPE_BITS)-1)
+
+#define _HIVE_STR_TO_MIPI_FMT_TYPE_LSB (HIVE_STR_TO_MIPI_CH_ID_LSB + HIVE_ISP_CH_ID_BITS)
+#define _HIVE_STR_TO_MIPI_DATA_B_LSB   (HIVE_STR_TO_MIPI_DATA_A_LSB + HIVE_IF_PIXEL_WIDTH)
+
+#endif /* _hive_isp_css_streaming_to_mipi_types_hrt_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/hive_types.h b/drivers/media/atomisp2/css2400/hrt/hive_types.h
new file mode 100644
index 0000000..6c7c86c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/hive_types.h
@@ -0,0 +1,135 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _HRT_HIVE_TYPES_H
+#define _HRT_HIVE_TYPES_H
+
+#include "version.h"
+#include "defs.h"
+
+#ifndef HRTCAT3
+#define _HRTCAT3(m,n,o)     m##n##o
+#define HRTCAT3(m,n,o)      _HRTCAT3(m,n,o)
+#endif
+
+#ifndef HRTCAT4
+#define _HRTCAT4(m,n,o,p)     m##n##o##p
+#define HRTCAT4(m,n,o,p)      _HRTCAT4(m,n,o,p)
+#endif
+
+#ifndef HRTMIN
+#define HRTMIN(a,b) (((a)<(b))?(a):(b))
+#endif
+
+#ifndef HRTMAX
+#define HRTMAX(a,b) (((a)>(b))?(a):(b))
+#endif
+
+/* boolean data type */
+typedef unsigned int hive_bool;
+#define hive_false 0
+#define hive_true  1
+
+typedef char                 hive_int8;
+typedef short                hive_int16;
+typedef int                  hive_int32;
+typedef long long            hive_int64;
+
+typedef unsigned char        hive_uint8;
+typedef unsigned short       hive_uint16;
+typedef unsigned int         hive_uint32;
+typedef unsigned long long   hive_uint64;
+
+/* by default assume 32 bit master port (both data and address) */
+#ifndef HRT_DATA_WIDTH
+#define HRT_DATA_WIDTH 32
+#endif
+#ifndef HRT_ADDRESS_WIDTH
+#define HRT_ADDRESS_WIDTH 32
+#endif
+
+#define HRT_DATA_BYTES    (HRT_DATA_WIDTH/8)
+#define HRT_ADDRESS_BYTES (HRT_ADDRESS_WIDTH/8)
+
+#if HRT_DATA_WIDTH == 64
+typedef hive_uint64 hrt_data;
+#elif HRT_DATA_WIDTH == 32
+typedef hive_uint32 hrt_data;
+#else
+#error data width not supported
+#endif
+
+#if HRT_ADDRESS_WIDTH == 64
+typedef hive_uint64 hrt_address;
+#elif HRT_ADDRESS_WIDTH == 32
+typedef hive_uint32 hrt_address;
+#else
+#error adddres width not supported
+#endif
+
+/* The SP side representation of an HMM virtual address */
+typedef hive_uint32 hrt_vaddress;
+
+/* use 64 bit addresses in simulation, where possible */
+typedef hive_uint64  hive_sim_address;
+
+/* below is for csim, not for hrt, rename and move this elsewhere */
+
+typedef unsigned int hive_uint;
+typedef hive_uint32  hive_address;
+typedef hive_address hive_slave_address;
+typedef hive_address hive_mem_address;
+
+/* MMIO devices */
+typedef hive_uint    hive_mmio_id;
+typedef hive_mmio_id hive_slave_id;
+typedef hive_mmio_id hive_port_id;
+typedef hive_mmio_id hive_master_id;
+typedef hive_mmio_id hive_mem_id;
+typedef hive_mmio_id hive_dev_id;
+typedef hive_mmio_id hive_fifo_id;
+
+typedef hive_uint      hive_hier_id;
+typedef hive_hier_id   hive_device_id;
+typedef hive_device_id hive_proc_id;
+typedef hive_device_id hive_cell_id;
+typedef hive_device_id hive_host_id;
+typedef hive_device_id hive_bus_id;
+typedef hive_device_id hive_bridge_id;
+typedef hive_device_id hive_fifo_adapter_id;
+typedef hive_device_id hive_custom_device_id;
+
+typedef hive_uint hive_slot_id;
+typedef hive_uint hive_fu_id;
+typedef hive_uint hive_reg_file_id;
+typedef hive_uint hive_reg_id;
+
+/* Streaming devices */
+typedef hive_uint hive_outport_id;
+typedef hive_uint hive_inport_id;
+
+typedef hive_uint hive_msink_id;
+
+/* HRT specific */
+typedef char* hive_program;
+typedef char* hive_function;
+
+#endif /* _HRT_HIVE_TYPES_H */
diff --git a/drivers/media/atomisp2/css2400/hrt/if_defs.h b/drivers/media/atomisp2/css2400/hrt/if_defs.h
new file mode 100644
index 0000000..ebcd130
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/if_defs.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IF_DEFS_H
+#define _IF_DEFS_H
+
+#define HIVE_IF_FRAME_REQUEST        0xA000
+#define HIVE_IF_LINES_REQUEST        0xB000
+#define HIVE_IF_VECTORS_REQUEST      0xC000
+
+#endif /* _IF_DEFS_H */
diff --git a/drivers/media/atomisp2/css2400/hrt/input_formatter_subsystem_defs.h b/drivers/media/atomisp2/css2400/hrt/input_formatter_subsystem_defs.h
new file mode 100644
index 0000000..d2a6244
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/input_formatter_subsystem_defs.h
@@ -0,0 +1,60 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _if_subsystem_defs_h
+#define _if_subsystem_defs_h__
+
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_0            0
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_1            1
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_2            2
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_3            3
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_4            4
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_5            5
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_6            6
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_7            7
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_FSYNC_LUT_REG        8
+#define HIVE_IFMT_GP_REGS_SRST_IDX                          9
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IDX                 10
+
+#define HIVE_IFMT_GP_REGS_CH_ID_FMT_TYPE_IDX               11
+
+#define HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_BASE         HIVE_IFMT_GP_REGS_INPUT_SWITCH_LUT_REG_0
+
+/* order of the input bits for the ifmt irq controller */
+#define HIVE_IFMT_IRQ_IFT_PRIM_BIT_ID                       0
+#define HIVE_IFMT_IRQ_IFT_PRIM_B_BIT_ID                     1
+#define HIVE_IFMT_IRQ_IFT_SEC_BIT_ID                        2
+#define HIVE_IFMT_IRQ_MEM_CPY_BIT_ID                        3
+#define HIVE_IFMT_IRQ_SIDEBAND_CHANGED_BIT_ID               4
+
+/* order of the input bits for the ifmt Soft reset register */
+#define HIVE_IFMT_GP_REGS_SRST_IFT_PRIM_BIT_IDX             0
+#define HIVE_IFMT_GP_REGS_SRST_IFT_PRIM_B_BIT_IDX           1
+#define HIVE_IFMT_GP_REGS_SRST_IFT_SEC_BIT_IDX              2
+#define HIVE_IFMT_GP_REGS_SRST_MEM_CPY_BIT_IDX              3
+
+/* order of the input bits for the ifmt Soft reset register */
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_PRIM_BIT_IDX     0
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_PRIM_B_BIT_IDX   1
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_IFT_SEC_BIT_IDX      2
+#define HIVE_IFMT_GP_REGS_SLV_REG_SRST_MEM_CPY_BIT_IDX      3
+
+#endif /* _if_subsystem_defs_h__ */
diff --git a/drivers/media/atomisp2/css2400/hrt/input_selector_defs.h b/drivers/media/atomisp2/css2400/hrt/input_selector_defs.h
new file mode 100644
index 0000000..666070b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/input_selector_defs.h
@@ -0,0 +1,96 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _input_selector_defs_h
+#define _input_selector_defs_h
+
+#ifndef HIVE_ISP_ISEL_SEL_BITS
+#define HIVE_ISP_ISEL_SEL_BITS                                  2
+#endif
+
+#ifndef HIVE_ISP_CH_ID_BITS
+#define HIVE_ISP_CH_ID_BITS                                     2
+#endif
+
+#ifndef HIVE_ISP_FMT_TYPE_BITS
+#define HIVE_ISP_FMT_TYPE_BITS                                  5
+#endif
+
+/* gp_register register id's -- Outputs */
+#define HIVE_ISEL_GP_REGS_SYNCGEN_ENABLE_IDX                    0
+#define HIVE_ISEL_GP_REGS_SYNCGEN_FREE_RUNNING_IDX              1
+#define HIVE_ISEL_GP_REGS_SYNCGEN_PAUSE_IDX                     2
+#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_FRAMES_IDX                 3
+#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_PIX_IDX                    4
+#define HIVE_ISEL_GP_REGS_SYNCGEN_NR_LINES_IDX                  5
+#define HIVE_ISEL_GP_REGS_SYNCGEN_HBLANK_CYCLES_IDX             6
+#define HIVE_ISEL_GP_REGS_SYNCGEN_VBLANK_CYCLES_IDX             7
+
+#define HIVE_ISEL_GP_REGS_SOF_IDX                               8
+#define HIVE_ISEL_GP_REGS_EOF_IDX                               9
+#define HIVE_ISEL_GP_REGS_SOL_IDX                              10
+#define HIVE_ISEL_GP_REGS_EOL_IDX                              11
+
+#define HIVE_ISEL_GP_REGS_PRBS_ENABLE                          12
+#define HIVE_ISEL_GP_REGS_PRBS_ENABLE_PORT_B                   13
+#define HIVE_ISEL_GP_REGS_PRBS_LFSR_RESET_VALUE                14
+
+#define HIVE_ISEL_GP_REGS_TPG_ENABLE                           15
+#define HIVE_ISEL_GP_REGS_TPG_ENABLE_PORT_B                    16
+#define HIVE_ISEL_GP_REGS_TPG_HOR_CNT_MASK_IDX                 17
+#define HIVE_ISEL_GP_REGS_TPG_VER_CNT_MASK_IDX                 18
+#define HIVE_ISEL_GP_REGS_TPG_XY_CNT_MASK_IDX                  19
+#define HIVE_ISEL_GP_REGS_TPG_HOR_CNT_DELTA_IDX                20
+#define HIVE_ISEL_GP_REGS_TPG_VER_CNT_DELTA_IDX                21
+#define HIVE_ISEL_GP_REGS_TPG_MODE_IDX                         22
+#define HIVE_ISEL_GP_REGS_TPG_R1_IDX                           23
+#define HIVE_ISEL_GP_REGS_TPG_G1_IDX                           24
+#define HIVE_ISEL_GP_REGS_TPG_B1_IDX                           25
+#define HIVE_ISEL_GP_REGS_TPG_R2_IDX                           26
+#define HIVE_ISEL_GP_REGS_TPG_G2_IDX                           27
+#define HIVE_ISEL_GP_REGS_TPG_B2_IDX                           28
+
+
+#define HIVE_ISEL_GP_REGS_CH_ID_IDX                            29
+#define HIVE_ISEL_GP_REGS_FMT_TYPE_IDX                         30
+#define HIVE_ISEL_GP_REGS_DATA_SEL_IDX                         31
+#define HIVE_ISEL_GP_REGS_SBAND_SEL_IDX                        32
+#define HIVE_ISEL_GP_REGS_SYNC_SEL_IDX                         33
+#define HIVE_ISEL_GP_REGS_SRST_IDX                             37
+
+#define HIVE_ISEL_GP_REGS_SRST_SYNCGEN_BIT                      0
+#define HIVE_ISEL_GP_REGS_SRST_PRBS_BIT                         1
+#define HIVE_ISEL_GP_REGS_SRST_TPG_BIT                          2
+#define HIVE_ISEL_GP_REGS_SRST_FIFO_BIT                         3
+
+/* gp_register register id's -- Inputs   */
+#define HIVE_ISEL_GP_REGS_SYNCGEN_HOR_CNT_IDX                  34
+#define HIVE_ISEL_GP_REGS_SYNCGEN_VER_CNT_IDX                  35
+#define HIVE_ISEL_GP_REGS_SYNCGEN_FRAMES_CNT_IDX               36
+
+/* irq sources isel irq controller */
+#define HIVE_ISEL_IRQ_SYNC_GEN_SOF_BIT_ID                       0
+#define HIVE_ISEL_IRQ_SYNC_GEN_EOF_BIT_ID                       1
+#define HIVE_ISEL_IRQ_SYNC_GEN_SOL_BIT_ID                       2
+#define HIVE_ISEL_IRQ_SYNC_GEN_EOL_BIT_ID                       3
+#define HIVE_ISEL_IRQ_NUM_IRQS                                  4
+
+#endif /* _input_selector_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/input_switch_2400_defs.h b/drivers/media/atomisp2/css2400/hrt/input_switch_2400_defs.h
new file mode 100644
index 0000000..4d199a4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/input_switch_2400_defs.h
@@ -0,0 +1,37 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _input_switch_2400_defs_h
+#define _input_switch_2400_defs_h
+
+#define _HIVE_INPUT_SWITCH_GET_LUT_REG_ID(ch_id, fmt_type) (((ch_id)*2) + ((fmt_type)>=16))
+#define _HIVE_INPUT_SWITCH_GET_LUT_REG_LSB(fmt_type)        (((fmt_type)%16) * 2)
+
+#define HIVE_INPUT_SWITCH_SELECT_NO_OUTPUT   0
+#define HIVE_INPUT_SWITCH_SELECT_IF_PRIM     1
+#define HIVE_INPUT_SWITCH_SELECT_IF_SEC      2
+#define HIVE_INPUT_SWITCH_SELECT_STR_TO_MEM  3
+#define HIVE_INPUT_SWITCH_VSELECT_NO_OUTPUT  0
+#define HIVE_INPUT_SWITCH_VSELECT_IF_PRIM    1
+#define HIVE_INPUT_SWITCH_VSELECT_IF_SEC     2
+#define HIVE_INPUT_SWITCH_VSELECT_STR_TO_MEM 4
+
+#endif /* _input_switch_2400_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/input_system_ctrl_defs.h b/drivers/media/atomisp2/css2400/hrt/input_system_ctrl_defs.h
new file mode 100644
index 0000000..130cba2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/input_system_ctrl_defs.h
@@ -0,0 +1,261 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _input_system_ctrl_defs_h
+#define _input_system_ctrl_defs_h
+
+#define _INPUT_SYSTEM_CTRL_REG_ALIGN                    4  /* assuming 32 bit control bus width */
+
+/* --------------------------------------------------*/
+
+/* --------------------------------------------------*/
+/* REGISTER INFO */
+/* --------------------------------------------------*/
+
+// Number of registers
+#define ISYS_CTRL_NOF_REGS                              23
+
+// Register id's of MMIO slave accesible registers
+#define ISYS_CTRL_CAPT_START_ADDR_A_REG_ID              0
+#define ISYS_CTRL_CAPT_START_ADDR_B_REG_ID              1
+#define ISYS_CTRL_CAPT_START_ADDR_C_REG_ID              2
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_ID         3
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_ID         4
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_ID         5
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_ID         6
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_ID         7
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_ID         8
+#define ISYS_CTRL_ACQ_START_ADDR_REG_ID                 9
+#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_ID            10
+#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_ID            11
+#define ISYS_CTRL_INIT_REG_ID                           12
+#define ISYS_CTRL_LAST_COMMAND_REG_ID                   13
+#define ISYS_CTRL_NEXT_COMMAND_REG_ID                   14
+#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_ID               15
+#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_ID               16
+#define ISYS_CTRL_FSM_STATE_INFO_REG_ID                 17
+#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_ID          18
+#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_ID          19
+#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_ID          20
+#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_ID             21
+#define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_ID    22
+
+
+/* register reset value */
+#define ISYS_CTRL_CAPT_START_ADDR_A_REG_RSTVAL           0
+#define ISYS_CTRL_CAPT_START_ADDR_B_REG_RSTVAL           0
+#define ISYS_CTRL_CAPT_START_ADDR_C_REG_RSTVAL           0
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_RSTVAL      128
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_RSTVAL      128
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_RSTVAL      128
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_RSTVAL      3
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_RSTVAL      3
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_RSTVAL      3
+#define ISYS_CTRL_ACQ_START_ADDR_REG_RSTVAL              0
+#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_RSTVAL         128
+#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_RSTVAL         3
+#define ISYS_CTRL_INIT_REG_RSTVAL                        0
+#define ISYS_CTRL_LAST_COMMAND_REG_RSTVAL                15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_NEXT_COMMAND_REG_RSTVAL                15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_RSTVAL            15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_RSTVAL            15    //0x0000_000F (to signal non-valid cmd/ack after reset/soft-reset)
+#define ISYS_CTRL_FSM_STATE_INFO_REG_RSTVAL              0
+#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_RSTVAL       0
+#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_RSTVAL       0
+#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_RSTVAL       0
+#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_RSTVAL          0
+#define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_RSTVAL 0
+
+/* register width value */
+#define ISYS_CTRL_CAPT_START_ADDR_A_REG_WIDTH            9
+#define ISYS_CTRL_CAPT_START_ADDR_B_REG_WIDTH            9
+#define ISYS_CTRL_CAPT_START_ADDR_C_REG_WIDTH            9
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_A_REG_WIDTH       9
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_B_REG_WIDTH       9
+#define ISYS_CTRL_CAPT_MEM_REGION_SIZE_C_REG_WIDTH       9
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_A_REG_WIDTH       9
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_B_REG_WIDTH       9
+#define ISYS_CTRL_CAPT_NUM_MEM_REGIONS_C_REG_WIDTH       9
+#define ISYS_CTRL_ACQ_START_ADDR_REG_WIDTH               9
+#define ISYS_CTRL_ACQ_MEM_REGION_SIZE_REG_WIDTH          9
+#define ISYS_CTRL_ACQ_NUM_MEM_REGIONS_REG_WIDTH          9
+#define ISYS_CTRL_INIT_REG_WIDTH                         3
+#define ISYS_CTRL_LAST_COMMAND_REG_WIDTH                 32    /* slave data width */
+#define ISYS_CTRL_NEXT_COMMAND_REG_WIDTH                 32
+#define ISYS_CTRL_LAST_ACKNOWLEDGE_REG_WIDTH             32
+#define ISYS_CTRL_NEXT_ACKNOWLEDGE_REG_WIDTH             32
+#define ISYS_CTRL_FSM_STATE_INFO_REG_WIDTH               32
+#define ISYS_CTRL_CAPT_A_FSM_STATE_INFO_REG_WIDTH        32
+#define ISYS_CTRL_CAPT_B_FSM_STATE_INFO_REG_WIDTH        32
+#define ISYS_CTRL_CAPT_C_FSM_STATE_INFO_REG_WIDTH        32
+#define ISYS_CTRL_ACQ_FSM_STATE_INFO_REG_WIDTH           32
+#define ISYS_CTRL_CAPT_RESERVE_ONE_MEM_REGION_REG_WIDTH  1
+
+/* bit definitions */
+
+/* --------------------------------------------------*/
+/* TOKEN INFO */
+/* --------------------------------------------------*/
+
+/*
+InpSysCaptFramesAcq  1/0  [3:0] - 'b0000
+[7:4] - CaptPortId,
+           CaptA-'b0000
+           CaptB-'b0001
+           CaptC-'b0010
+[31:16] - NOF_frames
+InpSysCaptFrameExt  2/0  [3:0] - 'b0001'
+[7:4] - CaptPortId,
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+
+  2/1  [31:0] - external capture address
+InpSysAcqFrame  2/0  [3:0] - 'b0010,
+[31:4] - NOF_ext_mem_words
+  2/1  [31:0] - external memory read start address
+InpSysOverruleON  1/0  [3:0] - 'b0011,
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+InpSysOverruleOFF  1/0  [3:0] - 'b0100,
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+InpSysOverruleCmd  2/0  [3:0] - 'b0101,
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+  2/1  [31:0] - command token value for port opid
+
+
+acknowledge tokens:
+
+InpSysAckCFA  1/0   [3:0] - 'b0000
+ [7:4] - CaptPortId,
+           CaptA-'b0000
+           CaptB- 'b0001
+           CaptC-'b0010
+ [31:16] - NOF_frames
+InpSysAckCFE  1/0  [3:0] - 'b0001'
+[7:4] - CaptPortId,
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+
+InpSysAckAF  1/0  [3:0] - 'b0010
+InpSysAckOverruleON  1/0  [3:0] - 'b0011,
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+InpSysAckOverruleOFF  1/0  [3:0] - 'b0100,
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+InpSysAckOverrule  2/0  [3:0] - 'b0101,
+[7:4] - overrule port id (opid)
+           'b0000 - CaptA
+           'b0001 - CaptB
+           'b0010 - CaptC
+           'b0011 - Acq
+           'b0100 - DMA
+
+
+  2/1  [31:0] - acknowledge token value from port opid
+
+
+
+*/
+
+
+/* Command and acknowledge tokens IDs */
+#define ISYS_CTRL_CAPT_FRAMES_ACQ_TOKEN_ID        0 /* 0000b */
+#define ISYS_CTRL_CAPT_FRAME_EXT_TOKEN_ID         1 /* 0001b */
+#define ISYS_CTRL_ACQ_FRAME_TOKEN_ID              2 /* 0010b */
+#define ISYS_CTRL_OVERRULE_ON_TOKEN_ID            3 /* 0011b */
+#define ISYS_CTRL_OVERRULE_OFF_TOKEN_ID           4 /* 0100b */
+#define ISYS_CTRL_OVERRULE_TOKEN_ID               5 /* 0101b */
+
+#define ISYS_CTRL_ACK_CFA_TOKEN_ID                0
+#define ISYS_CTRL_ACK_CFE_TOKEN_ID                1
+#define ISYS_CTRL_ACK_AF_TOKEN_ID                 2
+#define ISYS_CTRL_ACK_OVERRULE_ON_TOKEN_ID        3
+#define ISYS_CTRL_ACK_OVERRULE_OFF_TOKEN_ID       4
+#define ISYS_CTRL_ACK_OVERRULE_TOKEN_ID           5
+#define ISYS_CTRL_ACK_DEVICE_ERROR_TOKEN_ID       6
+
+#define ISYS_CTRL_TOKEN_ID_MSB                    3
+#define ISYS_CTRL_TOKEN_ID_LSB                    0
+#define ISYS_CTRL_PORT_ID_TOKEN_MSB               7
+#define ISYS_CTRL_PORT_ID_TOKEN_LSB               4
+#define ISYS_CTRL_NOF_CAPT_TOKEN_MSB              31
+#define ISYS_CTRL_NOF_CAPT_TOKEN_LSB              16
+#define ISYS_CTRL_NOF_EXT_TOKEN_MSB               31
+#define ISYS_CTRL_NOF_EXT_TOKEN_LSB               8
+
+#define ISYS_CTRL_TOKEN_ID_IDX                    0
+#define ISYS_CTRL_TOKEN_ID_BITS                   (ISYS_CTRL_TOKEN_ID_MSB - ISYS_CTRL_TOKEN_ID_LSB + 1)
+#define ISYS_CTRL_PORT_ID_IDX                     (ISYS_CTRL_TOKEN_ID_IDX + ISYS_CTRL_TOKEN_ID_BITS)
+#define ISYS_CTRL_PORT_ID_BITS                    (ISYS_CTRL_PORT_ID_TOKEN_MSB - ISYS_CTRL_PORT_ID_TOKEN_LSB +1)
+#define ISYS_CTRL_NOF_CAPT_IDX                    ISYS_CTRL_NOF_CAPT_TOKEN_LSB
+#define ISYS_CTRL_NOF_CAPT_BITS                   (ISYS_CTRL_NOF_CAPT_TOKEN_MSB - ISYS_CTRL_NOF_CAPT_TOKEN_LSB + 1)
+#define ISYS_CTRL_NOF_EXT_IDX                     ISYS_CTRL_NOF_EXT_TOKEN_LSB
+#define ISYS_CTRL_NOF_EXT_BITS                    (ISYS_CTRL_NOF_EXT_TOKEN_MSB - ISYS_CTRL_NOF_EXT_TOKEN_LSB + 1)
+
+#define ISYS_CTRL_PORT_ID_CAPT_A                  0 /* device ID for capture unit A      */
+#define ISYS_CTRL_PORT_ID_CAPT_B                  1 /* device ID for capture unit B      */
+#define ISYS_CTRL_PORT_ID_CAPT_C                  2 /* device ID for capture unit C      */
+#define ISYS_CTRL_PORT_ID_ACQUISITION             3 /* device ID for acquistion unit     */
+#define ISYS_CTRL_PORT_ID_DMA_CAPT_A              4 /* device ID for dma unit            */
+#define ISYS_CTRL_PORT_ID_DMA_CAPT_B              5 /* device ID for dma unit            */
+#define ISYS_CTRL_PORT_ID_DMA_CAPT_C              6 /* device ID for dma unit            */
+#define ISYS_CTRL_PORT_ID_DMA_ACQ                 7 /* device ID for dma unit            */
+
+#define ISYS_CTRL_NO_ACQ_ACK                      16 /* no ack from acquisition unit */
+#define ISYS_CTRL_NO_DMA_ACK                      0
+#define ISYS_CTRL_NO_CAPT_ACK                     16
+
+#endif /* _input_system_ctrl_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/input_system_defs.h b/drivers/media/atomisp2/css2400/hrt/input_system_defs.h
new file mode 100644
index 0000000..e7789fc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/input_system_defs.h
@@ -0,0 +1,133 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _input_system_defs_h
+#define _input_system_defs_h
+
+/* csi controller modes */
+#define HIVE_CSI_CONFIG_MAIN                   0
+#define HIVE_CSI_CONFIG_STEREO1                4
+#define HIVE_CSI_CONFIG_STEREO2                8
+
+/* general purpose register IDs */
+
+/* Stream Multicast select modes */
+#define HIVE_ISYS_GPREG_MULTICAST_A_IDX           0
+#define HIVE_ISYS_GPREG_MULTICAST_B_IDX           1
+#define HIVE_ISYS_GPREG_MULTICAST_C_IDX           2
+
+/* Stream Mux select modes */
+#define HIVE_ISYS_GPREG_MUX_IDX                   3
+
+/* streaming monitor status and control */
+#define HIVE_ISYS_GPREG_STRMON_STAT_IDX           4
+#define HIVE_ISYS_GPREG_STRMON_COND_IDX           5
+#define HIVE_ISYS_GPREG_STRMON_IRQ_EN_IDX         6
+#define HIVE_ISYS_GPREG_SRST_IDX                  7
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_IDX          8
+#define HIVE_ISYS_GPREG_REG_PORT_A_IDX            9
+#define HIVE_ISYS_GPREG_REG_PORT_B_IDX            10
+
+/* Bit numbers of the soft reset register */
+#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_A_BIT      0
+#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_B_BIT      1
+#define HIVE_ISYS_GPREG_SRST_CAPT_FIFO_C_BIT      2
+#define HIVE_ISYS_GPREG_SRST_MULTICAST_A_BIT      3
+#define HIVE_ISYS_GPREG_SRST_MULTICAST_B_BIT      4
+#define HIVE_ISYS_GPREG_SRST_MULTICAST_C_BIT      5
+#define HIVE_ISYS_GPREG_SRST_CAPT_A_BIT           6
+#define HIVE_ISYS_GPREG_SRST_CAPT_B_BIT           7
+#define HIVE_ISYS_GPREG_SRST_CAPT_C_BIT           8
+#define HIVE_ISYS_GPREG_SRST_ACQ_BIT              9
+/* For ISYS_CTRL 5bits are defined to allow soft-reset per sub-controller and top-ctrl */
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_BIT        10  /*LSB for 5bit vector */
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_CAPT_A_BIT 10
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_CAPT_B_BIT 11
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_CAPT_C_BIT 12
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_ACQ_BIT    13
+#define HIVE_ISYS_GPREG_SRST_ISYS_CTRL_TOP_BIT    14
+/* -- */
+#define HIVE_ISYS_GPREG_SRST_STR_MUX_BIT          15
+#define HIVE_ISYS_GPREG_SRST_CIO2AHB_BIT          16
+#define HIVE_ISYS_GPREG_SRST_GEN_SHORT_FIFO_BIT   17
+#define HIVE_ISYS_GPREG_SRST_WIDE_BUS_BIT         18 // includes CIO conv
+#define HIVE_ISYS_GPREG_SRST_DMA_BIT              19
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_A_BIT   20
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_B_BIT   21
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_CAPT_C_BIT   22
+#define HIVE_ISYS_GPREG_SRST_SF_CTRL_ACQ_BIT      23
+#define HIVE_ISYS_GPREG_SRST_CSI_BE_OUT_BIT       24
+
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_A_BIT    0
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_B_BIT    1
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_CAPT_C_BIT    2
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_ACQ_BIT       3
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_DMA_BIT        4
+#define HIVE_ISYS_GPREG_SLV_REG_SRST_ISYS_CTRL_BIT  5
+
+/* streaming monitor port id's */
+#define HIVE_ISYS_STR_MON_PORT_CAPA            0
+#define HIVE_ISYS_STR_MON_PORT_CAPB            1
+#define HIVE_ISYS_STR_MON_PORT_CAPC            2
+#define HIVE_ISYS_STR_MON_PORT_ACQ             3
+#define HIVE_ISYS_STR_MON_PORT_CSS_GENSH       4
+#define HIVE_ISYS_STR_MON_PORT_SF_GENSH        5
+#define HIVE_ISYS_STR_MON_PORT_SP2ISYS         6
+#define HIVE_ISYS_STR_MON_PORT_ISYS2SP         7
+#define HIVE_ISYS_STR_MON_PORT_PIXA            8
+#define HIVE_ISYS_STR_MON_PORT_PIXB            9
+
+/* interrupt bit ID's        */
+#define HIVE_ISYS_IRQ_CSI_SOF_BIT_ID           0
+#define HIVE_ISYS_IRQ_CSI_EOF_BIT_ID           1
+#define HIVE_ISYS_IRQ_CSI_SOL_BIT_ID           2
+#define HIVE_ISYS_IRQ_CSI_EOL_BIT_ID           3
+#define HIVE_ISYS_IRQ_CSI_RECEIVER_BIT_ID      4
+#define HIVE_ISYS_IRQ_CSI_RECEIVER_BE_BIT_ID   5
+#define HIVE_ISYS_IRQ_CAP_UNIT_A_NO_SOP        6
+#define HIVE_ISYS_IRQ_CAP_UNIT_A_LATE_SOP      7
+/*#define HIVE_ISYS_IRQ_CAP_UNIT_A_UNDEF_PH      7*/
+#define HIVE_ISYS_IRQ_CAP_UNIT_B_NO_SOP        8
+#define HIVE_ISYS_IRQ_CAP_UNIT_B_LATE_SOP      9
+/*#define HIVE_ISYS_IRQ_CAP_UNIT_B_UNDEF_PH     10*/
+#define HIVE_ISYS_IRQ_CAP_UNIT_C_NO_SOP       10
+#define HIVE_ISYS_IRQ_CAP_UNIT_C_LATE_SOP     11
+/*#define HIVE_ISYS_IRQ_CAP_UNIT_C_UNDEF_PH     13*/
+#define HIVE_ISYS_IRQ_ACQ_UNIT_SOP_MISMATCH   12
+/*#define HIVE_ISYS_IRQ_ACQ_UNIT_UNDEF_PH       15*/
+#define HIVE_ISYS_IRQ_INP_CTRL_CAPA           13
+#define HIVE_ISYS_IRQ_INP_CTRL_CAPB           14
+#define HIVE_ISYS_IRQ_INP_CTRL_CAPC           15
+#define HIVE_ISYS_IRQ_CIO2AHB                 16
+#define HIVE_ISYS_IRQ_DMA_BIT_ID              17
+#define HIVE_ISYS_IRQ_STREAM_MON_BIT_ID       18
+#define HIVE_ISYS_IRQ_NUM_BITS                19
+
+/* DMA */
+#define HIVE_ISYS_DMA_CHANNEL                  0
+#define HIVE_ISYS_DMA_IBUF_DDR_CONN            0
+#define HIVE_ISYS_DMA_HEIGHT                   1
+#define HIVE_ISYS_DMA_ELEMS                    1 /* both master buses of same width */
+#define HIVE_ISYS_DMA_STRIDE                   0 /* no stride required as height is fixed to 1 */
+#define HIVE_ISYS_DMA_CROP                     0 /* no cropping */
+#define HIVE_ISYS_DMA_EXTENSION                0 /* no extension as elem width is same on both side */
+
+#endif /* _input_system_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/irq_controller_defs.h b/drivers/media/atomisp2/css2400/hrt/irq_controller_defs.h
new file mode 100644
index 0000000..2ace68e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/irq_controller_defs.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _irq_controller_defs_h
+#define _irq_controller_defs_h
+
+#define _HRT_IRQ_CONTROLLER_EDGE_REG_IDX           0
+#define _HRT_IRQ_CONTROLLER_MASK_REG_IDX           1
+#define _HRT_IRQ_CONTROLLER_STATUS_REG_IDX         2
+#define _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX          3
+#define _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX         4
+#define _HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX 5
+#define _HRT_IRQ_CONTROLLER_STR_OUT_ENABLE_REG_IDX 6
+
+#define _HRT_IRQ_CONTROLLER_REG_ALIGN 4
+
+#endif /* _irq_controller_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/isp2400_mamoiada_params.h b/drivers/media/atomisp2/css2400/hrt/isp2400_mamoiada_params.h
new file mode 100644
index 0000000..c20224c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/isp2400_mamoiada_params.h
@@ -0,0 +1,265 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/* Version */
+#define RTL_VERSION
+
+/* Cell name  */
+#define ISP_CELL_TYPE                          isp2400_mamoiada
+#define ISP_VMEM                               simd_vmem
+#define _HRT_ISP_VMEM                          isp2400_mamoiada_simd_vmem
+
+/* instruction pipeline depth */
+#define ISP_BRANCHDELAY                        5
+
+/* bus */
+#define ISP_BUS_WIDTH                          32
+#define ISP_BUS_ADDR_WIDTH                     32
+#define ISP_BUS_BURST_SIZE                     1
+
+/* data-path */
+#define ISP_SCALAR_WIDTH                       32
+#define ISP_SLICE_NELEMS                       4
+#define ISP_VEC_NELEMS                         64
+#define ISP_VEC_ELEMBITS                       14
+#define ISP_VEC_ELEM8BITS                      16
+#define ISP_CLONE_DATAPATH_IS_16               1
+
+/* memories */
+#define ISP_DMEM_DEPTH                         4096
+#define ISP_DMEM_BSEL_DOWNSAMPLE               8
+#define ISP_VMEM_DEPTH                         3072
+#define ISP_VMEM_BSEL_DOWNSAMPLE               8
+#define ISP_VMEM_ELEMBITS                      14
+#define ISP_VMEM_ELEM_PRECISION                14
+#define ISP_VMEM_IS_BAMEM                      1
+#if ISP_VMEM_IS_BAMEM
+  #define ISP_VMEM_BAMEM_MAX_BOI_HEIGHT        8
+  #define ISP_VMEM_BAMEM_LATENCY               5
+  #define ISP_VMEM_BAMEM_BANK_NARROWING_FACTOR 2
+  #define ISP_VMEM_BAMEM_NR_DATA_PLANES        8
+  #define ISP_VMEM_BAMEM_NR_CFG_REGISTERS      16
+  #define ISP_VMEM_BAMEM_LININT                0
+  #define ISP_VMEM_BAMEM_DAP_BITS              3
+  #define ISP_VMEM_BAMEM_LININT_FRAC_BITS      0
+  #define ISP_VMEM_BAMEM_PID_BITS              3
+  #define ISP_VMEM_BAMEM_OFFSET_BITS           19
+  #define ISP_VMEM_BAMEM_ADDRESS_BITS          25
+  #define ISP_VMEM_BAMEM_RID_BITS              4
+  #define ISP_VMEM_BAMEM_TRANSPOSITION         1
+  #define ISP_VMEM_BAMEM_VEC_PLUS_SLICE        1
+  #define ISP_VMEM_BAMEM_ARB_SERVICE_CYCLE_BITS 1
+  #define ISP_VMEM_BAMEM_LUT_ELEMS             16
+  #define ISP_VMEM_BAMEM_LUT_ADDR_WIDTH        14
+  #define ISP_VMEM_BAMEM_HALF_BLOCK_WRITE      1
+  #define ISP_VMEM_BAMEM_SMART_FETCH           1
+  #define ISP_VMEM_BAMEM_BIG_ENDIANNESS        0
+#endif /* ISP_VMEM_IS_BAMEM */
+#define ISP_PMEM_DEPTH                         2048
+#define ISP_PMEM_WIDTH                         640
+#define ISP_VAMEM_ADDRESS_BITS                 12
+#define ISP_VAMEM_ELEMBITS                     12
+#define ISP_VAMEM_DEPTH                        2048
+#define ISP_VAMEM_ALIGNMENT                    2
+#define ISP_VA_ADDRESS_WIDTH                   896
+#define ISP_VEC_VALSU_LATENCY                  ISP_VEC_NELEMS
+#define ISP_HIST_ADDRESS_BITS                  12
+#define ISP_HIST_ALIGNMENT                     4
+#define ISP_HIST_COMP_IN_PREC                  12
+#define ISP_HIST_DEPTH                         1024
+#define ISP_HIST_WIDTH                         24
+#define ISP_HIST_COMPONENTS                    4
+
+/* program counter */
+#define ISP_PC_WIDTH                           13
+
+/* Template switches */
+#define ISP_SHIELD_INPUT_DMEM                  0
+#define ISP_SHIELD_OUTPUT_DMEM                 1
+#define ISP_SHIELD_INPUT_VMEM                  0
+#define ISP_SHIELD_OUTPUT_VMEM                 0
+#define ISP_SHIELD_INPUT_PMEM                  1
+#define ISP_SHIELD_OUTPUT_PMEM                 1
+#define ISP_SHIELD_INPUT_HIST                  1
+#define ISP_SHIELD_OUTPUT_HIST                 1
+/* When LUT is select the shielding is always on */
+#define ISP_SHIELD_INPUT_VAMEM                 1
+#define ISP_SHIELD_OUTPUT_VAMEM                1
+
+#define ISP_HAS_IRQ                            1
+#define ISP_HAS_SOFT_RESET                     1
+#define ISP_HAS_VEC_DIV                        0
+#define ISP_HAS_VFU_W_2O                       1
+#define ISP_HAS_DEINT3                         1
+#define ISP_HAS_LUT                            1
+#define ISP_HAS_HIST                           1
+#define ISP_HAS_VALSU                          1
+#define ISP_HAS_3rdVALSU                       1
+#define ISP_VRF1_HAS_2P                        1
+
+#define ISP_SRU_GUARDING                       1
+#define ISP_VLSU_GUARDING                      1
+
+#define ISP_VRF_RAM     	                     1
+#define ISP_SRF_RAM     	                     1
+
+#define ISP_SPLIT_VMUL_VADD_IS                 0
+#define ISP_RFSPLIT_FPGA                       0
+
+/* RSN or Bus pipelining */
+#define ISP_RSN_PIPE                           1
+#define ISP_VSF_BUS_PIPE                       0
+
+/* extra slave port to vmem */
+#define ISP_IF_VMEM                            0
+#define ISP_GDC_VMEM                           0
+
+/* Streaming ports */
+#define ISP_IF                                 1
+#define ISP_IF_B                               1
+#define ISP_GDC                                1
+#define ISP_SCL                                1
+#define ISP_GPFIFO                             1
+#define ISP_SP                                 1
+
+/* Removing Issue Slot(s) */
+#define ISP_HAS_NOT_SIMD_IS2                   0
+#define ISP_HAS_NOT_SIMD_IS3                   0
+#define ISP_HAS_NOT_SIMD_IS4                   0
+#define ISP_HAS_NOT_SIMD_IS4_VADD              0
+#define ISP_HAS_NOT_SIMD_IS5                   0
+#define ISP_HAS_NOT_SIMD_IS6                   0
+#define ISP_HAS_NOT_SIMD_IS7                   0
+#define ISP_HAS_NOT_SIMD_IS8                   0
+
+/* ICache  */
+#define ISP_ICACHE                             1
+#define ISP_ICACHE_ONLY                        0
+#define ISP_ICACHE_PREFETCH                    1
+#define ISP_ICACHE_INDEX_BITS                  8
+#define ISP_ICACHE_SET_BITS                    5
+#define ISP_ICACHE_BLOCKS_PER_SET_BITS         1
+
+/* Experimental Flags */
+#define ISP_EXP_1                              0
+#define ISP_EXP_2                              0
+#define ISP_EXP_3                              0
+#define ISP_EXP_4                              0
+#define ISP_EXP_5                              0
+#define ISP_EXP_6                              0
+
+/* Derived values */
+#define ISP_LOG2_PMEM_WIDTH                    10
+#define ISP_VEC_WIDTH                          896
+#define ISP_SLICE_WIDTH                        56
+#define ISP_VMEM_WIDTH                         896
+#define ISP_VMEM_ALIGN                         128
+#if ISP_VMEM_IS_BAMEM
+  #define ISP_VMEM_ALIGN_ELEM                  2
+#endif /* ISP_VMEM_IS_BAMEM */
+#define ISP_SIMDLSU                            1
+#define ISP_LSU_IMM_BITS                       12
+
+/* convenient shortcuts for software*/
+#define ISP_NWAY                               ISP_VEC_NELEMS
+#define NBITS                                  ISP_VEC_ELEMBITS
+
+#define _isp_ceil_div(a,b)                     (((a)+(b)-1)/(b))
+
+#ifdef C_RUN
+#define ISP_VEC_ALIGN                          (_isp_ceil_div(ISP_VEC_WIDTH, 64)*8)
+#else
+#define ISP_VEC_ALIGN                          ISP_VMEM_ALIGN
+#endif
+
+/* HRT specific vector support */
+#define isp2400_mamoiada_vector_alignment         ISP_VEC_ALIGN
+#define isp2400_mamoiada_vector_elem_bits         ISP_VMEM_ELEMBITS
+#define isp2400_mamoiada_vector_elem_precision    ISP_VMEM_ELEM_PRECISION
+#define isp2400_mamoiada_vector_num_elems         ISP_VEC_NELEMS
+
+/* register file sizes */
+#define ISP_RF0_SIZE        64
+#define ISP_RF1_SIZE        16
+#define ISP_RF2_SIZE        64
+#define ISP_RF3_SIZE        4
+#define ISP_RF4_SIZE        64
+#define ISP_RF5_SIZE        16
+#define ISP_RF6_SIZE        16
+#define ISP_RF7_SIZE        16
+#define ISP_RF8_SIZE        16
+#define ISP_RF9_SIZE        16
+#define ISP_RF10_SIZE       16
+#define ISP_RF11_SIZE       16
+#define ISP_VRF1_SIZE       24
+#define ISP_VRF2_SIZE       24
+#define ISP_VRF3_SIZE       24
+#define ISP_VRF4_SIZE       24
+#define ISP_VRF5_SIZE       24
+#define ISP_VRF6_SIZE       24
+#define ISP_VRF7_SIZE       24
+#define ISP_VRF8_SIZE       24
+#define ISP_SRF1_SIZE       4
+#define ISP_SRF2_SIZE       64
+#define ISP_SRF3_SIZE       64
+#define ISP_SRF4_SIZE       32
+#define ISP_SRF5_SIZE       64
+#define ISP_FRF0_SIZE       16
+#define ISP_FRF1_SIZE       4
+#define ISP_FRF2_SIZE       16
+#define ISP_FRF3_SIZE       4
+#define ISP_FRF4_SIZE       4
+#define ISP_FRF5_SIZE       8
+#define ISP_FRF6_SIZE       4
+/* register file read latency */
+#define ISP_VRF1_READ_LAT       1
+#define ISP_VRF2_READ_LAT       1
+#define ISP_VRF3_READ_LAT       1
+#define ISP_VRF4_READ_LAT       1
+#define ISP_VRF5_READ_LAT       1
+#define ISP_VRF6_READ_LAT       1
+#define ISP_VRF7_READ_LAT       1
+#define ISP_VRF8_READ_LAT       1
+#define ISP_SRF1_READ_LAT       1
+#define ISP_SRF2_READ_LAT       1
+#define ISP_SRF3_READ_LAT       1
+#define ISP_SRF4_READ_LAT       1
+#define ISP_SRF5_READ_LAT       1
+#define ISP_SRF5_READ_LAT       1
+/* immediate sizes */
+#define ISP_IS1_IMM_BITS        14
+#define ISP_IS2_IMM_BITS        13
+#define ISP_IS3_IMM_BITS        14
+#define ISP_IS4_IMM_BITS        14
+#define ISP_IS5_IMM_BITS        9
+#define ISP_IS6_IMM_BITS        16
+#define ISP_IS7_IMM_BITS        9
+#define ISP_IS8_IMM_BITS        16
+#define ISP_IS9_IMM_BITS        11
+/* fifo depths */
+#define ISP_IF_FIFO_DEPTH         0
+#define ISP_IF_B_FIFO_DEPTH       0
+#define ISP_DMA_FIFO_DEPTH        0
+#define ISP_OF_FIFO_DEPTH         0
+#define ISP_GDC_FIFO_DEPTH        0
+#define ISP_SCL_FIFO_DEPTH        0
+#define ISP_GPFIFO_FIFO_DEPTH     0
+#define ISP_SP_FIFO_DEPTH         0
diff --git a/drivers/media/atomisp2/css2400/hrt/isp2400_support.h b/drivers/media/atomisp2/css2400/hrt/isp2400_support.h
new file mode 100644
index 0000000..b6c67e7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/isp2400_support.h
@@ -0,0 +1,45 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _isp2400_support_h
+#define _isp2400_support_h
+
+#ifndef ISP2400_VECTOR_TYPES
+/* This typedef is to be able to include hive header files
+   in the host code which is useful in crun */
+typedef char *tmemvectors, *tmemvectoru, *tvector;
+#endif
+
+#define hrt_isp_vamem1_store_16(cell, addr, val) hrt_mem_store_16(cell, HRT_PROC_TYPE_PROP(cell, _simd_vamem1), addr, val)
+#define hrt_isp_vamem2_store_16(cell, addr, val) hrt_mem_store_16(cell, HRT_PROC_TYPE_PROP(cell, _simd_vamem2), addr, val)
+
+#define hrt_isp_dmem(cell) HRT_PROC_TYPE_PROP(cell, _base_dmem)
+#define hrt_isp_vmem(cell) HRT_PROC_TYPE_PROP(cell, _simd_vmem)
+
+#define hrt_isp_dmem_master_port_address(cell) hrt_mem_master_port_address(cell, hrt_isp_dmem(cell))
+#define hrt_isp_vmem_master_port_address(cell) hrt_mem_master_port_address(cell, hrt_isp_vmem(cell))
+
+#if ISP_HAS_HIST
+  #define hrt_isp_hist(cell) HRT_PROC_TYPE_PROP(cell, _simd_histogram)
+  #define hrt_isp_hist_master_port_address(cell) hrt_mem_master_port_address(cell, hrt_isp_hist(cell))
+#endif
+
+#endif /* _isp2400_support_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/isp_acquisition_defs.h b/drivers/media/atomisp2/css2400/hrt/isp_acquisition_defs.h
new file mode 100644
index 0000000..a3b8537
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/isp_acquisition_defs.h
@@ -0,0 +1,241 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _isp_acquisition_defs_h
+#define _isp_acquisition_defs_h
+
+#define _ISP_ACQUISITION_REG_ALIGN                4  /* assuming 32 bit control bus width */
+#define _ISP_ACQUISITION_BYTES_PER_ELEM           4
+
+/* --------------------------------------------------*/
+
+#define NOF_ACQ_IRQS                              1
+
+/* --------------------------------------------------*/
+/* FSM */
+/* --------------------------------------------------*/
+#define MEM2STREAM_FSM_STATE_BITS                 2
+#define ACQ_SYNCHRONIZER_FSM_STATE_BITS           2
+
+/* --------------------------------------------------*/
+/* REGISTER INFO */
+/* --------------------------------------------------*/
+
+#define NOF_ACQ_REGS                              12
+
+// Register id's of MMIO slave accesible registers
+#define ACQ_START_ADDR_REG_ID                     0
+#define ACQ_MEM_REGION_SIZE_REG_ID                1
+#define ACQ_NUM_MEM_REGIONS_REG_ID                2
+#define ACQ_INIT_REG_ID                           3
+#define ACQ_RECEIVED_SHORT_PACKETS_REG_ID         4
+#define ACQ_RECEIVED_LONG_PACKETS_REG_ID          5
+#define ACQ_LAST_COMMAND_REG_ID                   6
+#define ACQ_NEXT_COMMAND_REG_ID                   7
+#define ACQ_LAST_ACKNOWLEDGE_REG_ID               8
+#define ACQ_NEXT_ACKNOWLEDGE_REG_ID               9
+#define ACQ_FSM_STATE_INFO_REG_ID                 10
+#define ACQ_INT_CNTR_INFO_REG_ID                  11
+
+// Register width
+#define ACQ_START_ADDR_REG_WIDTH                  9
+#define ACQ_MEM_REGION_SIZE_REG_WIDTH             9
+#define ACQ_NUM_MEM_REGIONS_REG_WIDTH             9
+#define ACQ_INIT_REG_WIDTH                        3
+#define ACQ_RECEIVED_SHORT_PACKETS_REG_WIDTH      32
+#define ACQ_RECEIVED_LONG_PACKETS_REG_WIDTH       32
+#define ACQ_LAST_COMMAND_REG_WIDTH                32
+#define ACQ_NEXT_COMMAND_REG_WIDTH                32
+#define ACQ_LAST_ACKNOWLEDGE_REG_WIDTH            32
+#define ACQ_NEXT_ACKNOWLEDGE_REG_WIDTH            32
+#define ACQ_FSM_STATE_INFO_REG_WIDTH              ((MEM2STREAM_FSM_STATE_BITS * 3) + (ACQ_SYNCHRONIZER_FSM_STATE_BITS *3))
+#define ACQ_INT_CNTR_INFO_REG_WIDTH               32
+
+/* register reset value */
+#define ACQ_START_ADDR_REG_RSTVAL                 0
+#define ACQ_MEM_REGION_SIZE_REG_RSTVAL            128
+#define ACQ_NUM_MEM_REGIONS_REG_RSTVAL            3
+#define ACQ_INIT_REG_RSTVAL                       0
+#define ACQ_RECEIVED_SHORT_PACKETS_REG_RSTVAL     0
+#define ACQ_RECEIVED_LONG_PACKETS_REG_RSTVAL      0
+#define ACQ_LAST_COMMAND_REG_RSTVAL               0
+#define ACQ_NEXT_COMMAND_REG_RSTVAL               0
+#define ACQ_LAST_ACKNOWLEDGE_REG_RSTVAL           0
+#define ACQ_NEXT_ACKNOWLEDGE_REG_RSTVAL           0
+#define ACQ_FSM_STATE_INFO_REG_RSTVAL             0
+#define ACQ_INT_CNTR_INFO_REG_RSTVAL              0
+
+/* bit definitions */
+#define ACQ_INIT_RST_REG_BIT                      0
+#define ACQ_INIT_RESYNC_BIT                       2
+#define ACQ_INIT_RST_IDX                          ACQ_INIT_RST_REG_BIT
+#define ACQ_INIT_RST_BITS                         1
+#define ACQ_INIT_RESYNC_IDX                       ACQ_INIT_RESYNC_BIT
+#define ACQ_INIT_RESYNC_BITS                      1
+
+/* --------------------------------------------------*/
+/* TOKEN INFO */
+/* --------------------------------------------------*/
+#define ACQ_TOKEN_ID_LSB                          0
+#define ACQ_TOKEN_ID_MSB                          3
+#define ACQ_TOKEN_WIDTH                           (ACQ_TOKEN_ID_MSB - ACQ_TOKEN_ID_LSB  + 1) // 4
+#define ACQ_TOKEN_ID_IDX                          0
+#define ACQ_TOKEN_ID_BITS                         ACQ_TOKEN_WIDTH
+#define ACQ_INIT_CMD_INIT_IDX                     4
+#define ACQ_INIT_CMD_INIT_BITS                    3
+#define ACQ_CMD_START_ADDR_IDX                    4
+#define ACQ_CMD_START_ADDR_BITS                   9
+#define ACQ_CMD_NOFWORDS_IDX                      13
+#define ACQ_CMD_NOFWORDS_BITS                     9
+#define ACQ_MEM_REGION_ID_IDX                     22
+#define ACQ_MEM_REGION_ID_BITS                    9
+#define ACQ_PACKET_LENGTH_TOKEN_MSB               21
+#define ACQ_PACKET_LENGTH_TOKEN_LSB               13
+#define ACQ_PACKET_DATA_FORMAT_ID_TOKEN_MSB       9
+#define ACQ_PACKET_DATA_FORMAT_ID_TOKEN_LSB       4
+#define ACQ_PACKET_CH_ID_TOKEN_MSB                11
+#define ACQ_PACKET_CH_ID_TOKEN_LSB                10
+#define ACQ_PACKET_MEM_REGION_ID_TOKEN_MSB        12		/* only for capt_end_of_packet_written */
+#define ACQ_PACKET_MEM_REGION_ID_TOKEN_LSB        4		/* only for capt_end_of_packet_written */
+
+
+/* Command tokens IDs */
+#define ACQ_READ_REGION_AUTO_INCR_TOKEN_ID        0 //0000b
+#define ACQ_READ_REGION_TOKEN_ID                  1 //0001b
+#define ACQ_READ_REGION_SOP_TOKEN_ID              2 //0010b
+#define ACQ_INIT_TOKEN_ID                         8 //1000b
+
+/* Acknowledge token IDs */
+#define ACQ_READ_REGION_ACK_TOKEN_ID              0 //0000b
+#define ACQ_END_OF_PACKET_TOKEN_ID                4 //0100b
+#define ACQ_END_OF_REGION_TOKEN_ID                5 //0101b
+#define ACQ_SOP_MISMATCH_TOKEN_ID                 6 //0110b
+#define ACQ_UNDEF_PH_TOKEN_ID                     7 //0111b
+
+#define ACQ_TOKEN_MEMREGIONID_MSB                 30
+#define ACQ_TOKEN_MEMREGIONID_LSB                 22
+#define ACQ_TOKEN_NOFWORDS_MSB                    21
+#define ACQ_TOKEN_NOFWORDS_LSB                    13
+#define ACQ_TOKEN_STARTADDR_MSB                   12
+#define ACQ_TOKEN_STARTADDR_LSB                   4
+
+
+/* --------------------------------------------------*/
+/* MIPI */
+/* --------------------------------------------------*/
+
+#define WORD_COUNT_WIDTH                          16
+#define PKT_CODE_WIDTH                            6
+#define CHN_NO_WIDTH                              2
+#define ERROR_INFO_WIDTH                          8
+
+#define LONG_PKTCODE_MAX                          63
+#define LONG_PKTCODE_MIN                          16
+#define SHORT_PKTCODE_MAX                         15
+
+#define EOF_CODE                                  1
+
+/* --------------------------------------------------*/
+/* Packet Info */
+/* --------------------------------------------------*/
+#define ACQ_START_OF_FRAME                        0
+#define ACQ_END_OF_FRAME                          1
+#define ACQ_START_OF_LINE                         2
+#define ACQ_END_OF_LINE                           3
+#define ACQ_LINE_PAYLOAD                          4
+#define ACQ_GEN_SH_PKT                            5
+
+
+/* bit definition */
+#define ACQ_PKT_TYPE_IDX                          16
+#define ACQ_PKT_TYPE_BITS                         6
+#define ACQ_PKT_SOP_IDX                           32
+#define ACQ_WORD_CNT_IDX                          0
+#define ACQ_WORD_CNT_BITS                         16
+#define ACQ_PKT_INFO_IDX                          16
+#define ACQ_PKT_INFO_BITS                         8
+#define ACQ_HEADER_DATA_IDX                       0
+#define ACQ_HEADER_DATA_BITS                      16
+#define ACQ_ACK_TOKEN_ID_IDX                      ACQ_TOKEN_ID_IDX
+#define ACQ_ACK_TOKEN_ID_BITS                     ACQ_TOKEN_ID_BITS
+#define ACQ_ACK_NOFWORDS_IDX                      13
+#define ACQ_ACK_NOFWORDS_BITS                     9
+#define ACQ_ACK_PKT_LEN_IDX                       4
+#define ACQ_ACK_PKT_LEN_BITS                      16
+
+
+/* --------------------------------------------------*/
+/* Packet Data Type */
+/* --------------------------------------------------*/
+
+
+#define ACQ_YUV420_8_DATA                       24   /* 01 1000 YUV420 8-bit                                        */
+#define ACQ_YUV420_10_DATA                      25   /* 01 1001  YUV420 10-bit                                      */
+#define ACQ_YUV420_8L_DATA                      26   /* 01 1010   YUV420 8-bit legacy                               */
+#define ACQ_YUV422_8_DATA                       30   /* 01 1110   YUV422 8-bit                                      */
+#define ACQ_YUV422_10_DATA                      31   /* 01 1111   YUV422 10-bit                                     */
+#define ACQ_RGB444_DATA                         32   /* 10 0000   RGB444                                            */
+#define ACQ_RGB555_DATA              					 33   /* 10 0001   RGB555                                            */
+#define ACQ_RGB565_DATA              					 34   /* 10 0010   RGB565                                            */
+#define ACQ_RGB666_DATA              					 35   /* 10 0011   RGB666                                            */
+#define ACQ_RGB888_DATA              					 36   /* 10 0100   RGB888                                            */
+#define ACQ_RAW6_DATA                					 40   /* 10 1000   RAW6                                              */
+#define ACQ_RAW7_DATA                					 41   /* 10 1001   RAW7                                              */
+#define ACQ_RAW8_DATA                					 42   /* 10 1010   RAW8                                              */
+#define ACQ_RAW10_DATA               					 43   /* 10 1011   RAW10                                             */
+#define ACQ_RAW12_DATA               					 44   /* 10 1100   RAW12                                             */
+#define ACQ_RAW14_DATA               					 45   /* 10 1101   RAW14                                             */
+#define ACQ_USR_DEF_1_DATA           					 48   /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
+#define ACQ_USR_DEF_2_DATA           					 49   /* 11 0001    User Defined 8-bit Data Type 2                   */
+#define ACQ_USR_DEF_3_DATA           					 50   /* 11 0010    User Defined 8-bit Data Type 3                   */
+#define ACQ_USR_DEF_4_DATA           					 51   /* 11 0011    User Defined 8-bit Data Type 4                   */
+#define ACQ_USR_DEF_5_DATA           					 52   /* 11 0100    User Defined 8-bit Data Type 5                   */
+#define ACQ_USR_DEF_6_DATA           					 53   /* 11 0101    User Defined 8-bit Data Type 6                   */
+#define ACQ_USR_DEF_7_DATA           					 54   /* 11 0110    User Defined 8-bit Data Type 7                   */
+#define ACQ_USR_DEF_8_DATA           					 55   /* 11 0111    User Defined 8-bit Data Type 8                   */
+#define ACQ_Emb_DATA                 					 18   /* 01 0010    embedded eight bit non image data                */
+#define ACQ_SOF_DATA                 					 0   /* 00 0000    frame start                                      */
+#define ACQ_EOF_DATA                 					 1   /* 00 0001    frame end                                        */
+#define ACQ_SOL_DATA                 					 2   /* 00 0010    line start                                       */
+#define ACQ_EOL_DATA                 					 3   /* 00 0011    line end                                         */
+#define ACQ_GEN_SH1_DATA             					 8   /* 00 1000  Generic Short Packet Code 1                        */
+#define ACQ_GEN_SH2_DATA             					 9   /* 00 1001    Generic Short Packet Code 2                      */
+#define ACQ_GEN_SH3_DATA             					 10   /* 00 1010    Generic Short Packet Code 3                      */
+#define ACQ_GEN_SH4_DATA             					 11   /* 00 1011    Generic Short Packet Code 4                      */
+#define ACQ_GEN_SH5_DATA             					 12   /* 00 1100    Generic Short Packet Code 5                      */
+#define ACQ_GEN_SH6_DATA             					 13   /* 00 1101    Generic Short Packet Code 6                      */
+#define ACQ_GEN_SH7_DATA             					 14   /* 00 1110    Generic Short Packet Code 7                      */
+#define ACQ_GEN_SH8_DATA             					 15   /* 00 1111    Generic Short Packet Code 8                      */
+#define ACQ_YUV420_8_CSPS_DATA       					 28   /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
+#define ACQ_YUV420_10_CSPS_DATA      					 29   /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
+#define ACQ_RESERVED_DATA_TYPE_MIN              56
+#define ACQ_RESERVED_DATA_TYPE_MAX              63
+#define ACQ_GEN_LONG_RESERVED_DATA_TYPE_MIN     19
+#define ACQ_GEN_LONG_RESERVED_DATA_TYPE_MAX     23
+#define ACQ_YUV_RESERVED_DATA_TYPE              27
+#define ACQ_RGB_RESERVED_DATA_TYPE_MIN          37
+#define ACQ_RGB_RESERVED_DATA_TYPE_MAX          39
+#define ACQ_RAW_RESERVED_DATA_TYPE_MIN          46
+#define ACQ_RAW_RESERVED_DATA_TYPE_MAX          47
+
+/* --------------------------------------------------*/
+
+#endif /* _isp_acquisition_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/isp_capture_defs.h b/drivers/media/atomisp2/css2400/hrt/isp_capture_defs.h
new file mode 100644
index 0000000..601a8a5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/isp_capture_defs.h
@@ -0,0 +1,317 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _isp_capture_defs_h
+#define _isp_capture_defs_h
+
+#define _ISP_CAPTURE_REG_ALIGN                    4  /* assuming 32 bit control bus width */
+#define _ISP_CAPTURE_BITS_PER_ELEM                32  /* only for data, not SOP */
+#define _ISP_CAPTURE_BYTES_PER_ELEM               (_ISP_CAPTURE_BITS_PER_ELEM/8	)
+#define _ISP_CAPTURE_BYTES_PER_WORD               32		/* 256/8 */
+#define _ISP_CAPTURE_ELEM_PER_WORD                _ISP_CAPTURE_BYTES_PER_WORD / _ISP_CAPTURE_BYTES_PER_ELEM
+
+//#define CAPT_RCV_ACK                              1
+//#define CAPT_WRT_ACK                              2
+//#define CAPT_IRQ_ACK                              3
+
+/* --------------------------------------------------*/
+
+#define NOF_IRQS                                  2
+
+/* --------------------------------------------------*/
+/* REGISTER INFO */
+/* --------------------------------------------------*/
+
+// Number of registers
+#define CAPT_NOF_REGS                             16
+
+// Register id's of MMIO slave accesible registers
+#define CAPT_START_MODE_REG_ID                    0
+#define CAPT_START_ADDR_REG_ID                    1
+#define CAPT_MEM_REGION_SIZE_REG_ID               2
+#define CAPT_NUM_MEM_REGIONS_REG_ID               3
+#define CAPT_INIT_REG_ID                          4
+#define CAPT_START_REG_ID                         5
+#define CAPT_STOP_REG_ID                          6
+
+#define CAPT_PACKET_LENGTH_REG_ID                 7
+#define CAPT_RECEIVED_LENGTH_REG_ID               8
+#define CAPT_RECEIVED_SHORT_PACKETS_REG_ID        9
+#define CAPT_RECEIVED_LONG_PACKETS_REG_ID         10
+#define CAPT_LAST_COMMAND_REG_ID                  11
+#define CAPT_NEXT_COMMAND_REG_ID                  12
+#define CAPT_LAST_ACKNOWLEDGE_REG_ID              13
+#define CAPT_NEXT_ACKNOWLEDGE_REG_ID              14
+#define CAPT_FSM_STATE_INFO_REG_ID                15
+
+// Register width
+#define CAPT_START_MODE_REG_WIDTH                 1
+#define CAPT_START_ADDR_REG_WIDTH                 9
+#define CAPT_MEM_REGION_SIZE_REG_WIDTH            9
+#define CAPT_NUM_MEM_REGIONS_REG_WIDTH            9
+#define CAPT_INIT_REG_WIDTH                       (18 + 4)
+
+#define CAPT_START_REG_WIDTH                      1
+#define CAPT_STOP_REG_WIDTH                       1
+
+/* --------------------------------------------------*/
+/* FSM */
+/* --------------------------------------------------*/
+#define CAPT_WRITE2MEM_FSM_STATE_BITS             2
+#define CAPT_SYNCHRONIZER_FSM_STATE_BITS          3
+
+
+#define CAPT_PACKET_LENGTH_REG_WIDTH              17
+#define CAPT_RECEIVED_LENGTH_REG_WIDTH            17
+#define CAPT_RECEIVED_SHORT_PACKETS_REG_WIDTH     32
+#define CAPT_RECEIVED_LONG_PACKETS_REG_WIDTH      32
+#define CAPT_LAST_COMMAND_REG_WIDTH               32
+/* #define CAPT_NEXT_COMMAND_REG_WIDTH               32 */
+#define CAPT_LAST_ACKNOWLEDGE_REG_WIDTH           32
+#define CAPT_NEXT_ACKNOWLEDGE_REG_WIDTH           32
+#define CAPT_FSM_STATE_INFO_REG_WIDTH             ((CAPT_WRITE2MEM_FSM_STATE_BITS * 3) + (CAPT_SYNCHRONIZER_FSM_STATE_BITS * 3))
+
+#define CAPT_INIT_RESTART_MEM_ADDR_WIDTH          9
+#define CAPT_INIT_RESTART_MEM_REGION_WIDTH        9
+
+/* register reset value */
+#define CAPT_START_MODE_REG_RSTVAL                0
+#define CAPT_START_ADDR_REG_RSTVAL                0
+#define CAPT_MEM_REGION_SIZE_REG_RSTVAL           128
+#define CAPT_NUM_MEM_REGIONS_REG_RSTVAL           3
+#define CAPT_INIT_REG_RSTVAL                      0
+
+#define CAPT_START_REG_RSTVAL                     0
+#define CAPT_STOP_REG_RSTVAL                      0
+
+#define CAPT_PACKET_LENGTH_REG_RSTVAL             0
+#define CAPT_RECEIVED_LENGTH_REG_RSTVAL           0
+#define CAPT_RECEIVED_SHORT_PACKETS_REG_RSTVAL    0
+#define CAPT_RECEIVED_LONG_PACKETS_REG_RSTVAL     0
+#define CAPT_LAST_COMMAND_REG_RSTVAL              0
+#define CAPT_NEXT_COMMAND_REG_RSTVAL              0
+#define CAPT_LAST_ACKNOWLEDGE_REG_RSTVAL          0
+#define CAPT_NEXT_ACKNOWLEDGE_REG_RSTVAL          0
+#define CAPT_FSM_STATE_INFO_REG_RSTVAL            0
+
+/* bit definitions */
+#define CAPT_INIT_RST_REG_BIT                     0
+#define CAPT_INIT_FLUSH_BIT                       1
+#define CAPT_INIT_RESYNC_BIT                      2
+#define CAPT_INIT_RESTART_BIT                     3
+#define CAPT_INIT_RESTART_MEM_ADDR_LSB            4
+#define CAPT_INIT_RESTART_MEM_ADDR_MSB            12
+#define CAPT_INIT_RESTART_MEM_REGION_LSB          13
+#define CAPT_INIT_RESTART_MEM_REGION_MSB          21
+
+
+#define CAPT_INIT_RST_REG_IDX                     CAPT_INIT_RST_REG_BIT
+#define CAPT_INIT_RST_REG_BITS                    1
+#define CAPT_INIT_FLUSH_IDX                       CAPT_INIT_FLUSH_BIT
+#define CAPT_INIT_FLUSH_BITS                      1
+#define CAPT_INIT_RESYNC_IDX                      CAPT_INIT_RESYNC_BIT
+#define CAPT_INIT_RESYNC_BITS                     1
+#define CAPT_INIT_RESTART_IDX                     CAPT_INIT_RESTART_BIT
+#define CAPT_INIT_RESTART_BITS					  				1
+#define CAPT_INIT_RESTART_MEM_ADDR_IDX            CAPT_INIT_RESTART_MEM_ADDR_LSB
+#define CAPT_INIT_RESTART_MEM_ADDR_BITS           (CAPT_INIT_RESTART_MEM_ADDR_MSB - CAPT_INIT_RESTART_MEM_ADDR_LSB + 1)
+#define CAPT_INIT_RESTART_MEM_REGION_IDX          CAPT_INIT_RESTART_MEM_REGION_LSB
+#define CAPT_INIT_RESTART_MEM_REGION_BITS         (CAPT_INIT_RESTART_MEM_REGION_MSB - CAPT_INIT_RESTART_MEM_REGION_LSB + 1)
+
+
+
+/* --------------------------------------------------*/
+/* TOKEN INFO */
+/* --------------------------------------------------*/
+#define CAPT_TOKEN_ID_LSB                         0
+#define CAPT_TOKEN_ID_MSB                         3
+#define CAPT_TOKEN_WIDTH                         (CAPT_TOKEN_ID_MSB - CAPT_TOKEN_ID_LSB  + 1) /* 4 */
+
+/* Command tokens IDs */
+#define CAPT_START_TOKEN_ID                       0 /* 0000b */
+#define CAPT_STOP_TOKEN_ID                        1 /* 0001b */
+#define CAPT_FREEZE_TOKEN_ID                      2 /* 0010b */
+#define CAPT_RESUME_TOKEN_ID                      3 /* 0011b */
+#define CAPT_INIT_TOKEN_ID                        8 /* 1000b */
+
+#define CAPT_START_TOKEN_BIT                      0
+#define CAPT_STOP_TOKEN_BIT                       0
+#define CAPT_FREEZE_TOKEN_BIT                     0
+#define CAPT_RESUME_TOKEN_BIT                     0
+#define CAPT_INIT_TOKEN_BIT                       0
+
+/* Acknowledge token IDs */
+#define CAPT_END_OF_PACKET_RECEIVED_TOKEN_ID      0 /* 0000b */
+#define CAPT_END_OF_PACKET_WRITTEN_TOKEN_ID       1 /* 0001b */
+#define CAPT_END_OF_REGION_WRITTEN_TOKEN_ID       2 /* 0010b */
+#define CAPT_FLUSH_DONE_TOKEN_ID                  3 /* 0011b */
+#define CAPT_PREMATURE_SOP_TOKEN_ID               4 /* 0100b */
+#define CAPT_MISSING_SOP_TOKEN_ID                 5 /* 0101b */
+#define CAPT_UNDEF_PH_TOKEN_ID                    6 /* 0110b */
+#define CAPT_STOP_ACK_TOKEN_ID                    7 /* 0111b */
+
+#define CAPT_PACKET_LENGTH_TOKEN_MSB             19
+#define CAPT_PACKET_LENGTH_TOKEN_LSB              4
+#define CAPT_SUPER_PACKET_LENGTH_TOKEN_MSB       20
+#define CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB        4
+#define CAPT_PACKET_DATA_FORMAT_ID_TOKEN_MSB     25
+#define CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB     20
+#define CAPT_PACKET_CH_ID_TOKEN_MSB              27
+#define CAPT_PACKET_CH_ID_TOKEN_LSB              26
+#define CAPT_PACKET_MEM_REGION_ID_TOKEN_MSB      29
+#define CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB      21
+
+/*  bit definition */
+#define CAPT_CMD_IDX                              CAPT_TOKEN_ID_LSB
+#define	CAPT_CMD_BITS                             (CAPT_TOKEN_ID_MSB - CAPT_TOKEN_ID_LSB + 1)
+#define CAPT_SOP_IDX                              32
+#define CAPT_SOP_BITS                             1
+#define CAPT_PKT_INFO_IDX                         16
+#define CAPT_PKT_INFO_BITS                        8
+#define CAPT_PKT_TYPE_IDX                         0
+#define CAPT_PKT_TYPE_BITS                        6
+#define CAPT_HEADER_DATA_IDX                      0
+#define CAPT_HEADER_DATA_BITS                     16
+#define CAPT_PKT_DATA_IDX                         0
+#define CAPT_PKT_DATA_BITS                        32
+#define CAPT_WORD_CNT_IDX                         0
+#define CAPT_WORD_CNT_BITS                        16
+#define CAPT_ACK_TOKEN_ID_IDX                     0
+#define CAPT_ACK_TOKEN_ID_BITS                    4
+//#define CAPT_ACK_PKT_LEN_IDX                      CAPT_PACKET_LENGTH_TOKEN_LSB
+//#define CAPT_ACK_PKT_LEN_BITS                     (CAPT_PACKET_LENGTH_TOKEN_MSB - CAPT_PACKET_LENGTH_TOKEN_LSB + 1)
+//#define CAPT_ACK_PKT_INFO_IDX                     20
+//#define CAPT_ACK_PKT_INFO_BITS                    8
+//#define CAPT_ACK_MEM_REG_ID1_IDX                  20			/* for capt_end_of_packet_written */
+//#define CAPT_ACK_MEM_REG_ID2_IDX                  4       /* for capt_end_of_region_written */
+#define CAPT_ACK_PKT_LEN_IDX                      CAPT_PACKET_LENGTH_TOKEN_LSB
+#define CAPT_ACK_PKT_LEN_BITS                     (CAPT_PACKET_LENGTH_TOKEN_MSB - CAPT_PACKET_LENGTH_TOKEN_LSB + 1)
+#define CAPT_ACK_SUPER_PKT_LEN_IDX                CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB
+#define CAPT_ACK_SUPER_PKT_LEN_BITS               (CAPT_SUPER_PACKET_LENGTH_TOKEN_MSB - CAPT_SUPER_PACKET_LENGTH_TOKEN_LSB + 1)
+#define CAPT_ACK_PKT_INFO_IDX                     CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB
+#define CAPT_ACK_PKT_INFO_BITS                    (CAPT_PACKET_CH_ID_TOKEN_MSB - CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB + 1)
+#define CAPT_ACK_MEM_REGION_ID_IDX                CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB
+#define CAPT_ACK_MEM_REGION_ID_BITS               (CAPT_PACKET_MEM_REGION_ID_TOKEN_MSB - CAPT_PACKET_MEM_REGION_ID_TOKEN_LSB + 1)
+#define CAPT_ACK_PKT_TYPE_IDX                     CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB
+#define CAPT_ACK_PKT_TYPE_BITS                    (CAPT_PACKET_DATA_FORMAT_ID_TOKEN_MSB - CAPT_PACKET_DATA_FORMAT_ID_TOKEN_LSB + 1)
+#define CAPT_INIT_TOKEN_INIT_IDX                  4
+#define CAPT_INIT_TOKEN_INIT_BITS                 22
+
+
+/* --------------------------------------------------*/
+/* MIPI */
+/* --------------------------------------------------*/
+
+#define CAPT_WORD_COUNT_WIDTH                     16
+#define CAPT_PKT_CODE_WIDTH                       6
+#define CAPT_CHN_NO_WIDTH                         2
+#define CAPT_ERROR_INFO_WIDTH                     8
+
+#define LONG_PKTCODE_MAX                          63
+#define LONG_PKTCODE_MIN                          16
+#define SHORT_PKTCODE_MAX                         15
+
+
+/* --------------------------------------------------*/
+/* Packet Info */
+/* --------------------------------------------------*/
+#define CAPT_START_OF_FRAME                       0
+#define CAPT_END_OF_FRAME                         1
+#define CAPT_START_OF_LINE                        2
+#define CAPT_END_OF_LINE                          3
+#define CAPT_LINE_PAYLOAD                         4
+#define CAPT_GEN_SH_PKT                           5
+
+
+/* --------------------------------------------------*/
+/* Packet Data Type */
+/* --------------------------------------------------*/
+
+#define CAPT_YUV420_8_DATA                       24   /* 01 1000 YUV420 8-bit                                        */
+#define CAPT_YUV420_10_DATA                      25   /* 01 1001  YUV420 10-bit                                      */
+#define CAPT_YUV420_8L_DATA                      26   /* 01 1010   YUV420 8-bit legacy                               */
+#define CAPT_YUV422_8_DATA                       30   /* 01 1110   YUV422 8-bit                                      */
+#define CAPT_YUV422_10_DATA                      31   /* 01 1111   YUV422 10-bit                                     */
+#define CAPT_RGB444_DATA                         32   /* 10 0000   RGB444                                            */
+#define CAPT_RGB555_DATA              					 33   /* 10 0001   RGB555                                            */
+#define CAPT_RGB565_DATA              					 34   /* 10 0010   RGB565                                            */
+#define CAPT_RGB666_DATA              					 35   /* 10 0011   RGB666                                            */
+#define CAPT_RGB888_DATA              					 36   /* 10 0100   RGB888                                            */
+#define CAPT_RAW6_DATA                					 40   /* 10 1000   RAW6                                              */
+#define CAPT_RAW7_DATA                					 41   /* 10 1001   RAW7                                              */
+#define CAPT_RAW8_DATA                					 42   /* 10 1010   RAW8                                              */
+#define CAPT_RAW10_DATA               					 43   /* 10 1011   RAW10                                             */
+#define CAPT_RAW12_DATA               					 44   /* 10 1100   RAW12                                             */
+#define CAPT_RAW14_DATA               					 45   /* 10 1101   RAW14                                             */
+#define CAPT_USR_DEF_1_DATA           					 48   /* 11 0000    JPEG [User Defined 8-bit Data Type 1]            */
+#define CAPT_USR_DEF_2_DATA           					 49   /* 11 0001    User Defined 8-bit Data Type 2                   */
+#define CAPT_USR_DEF_3_DATA           					 50   /* 11 0010    User Defined 8-bit Data Type 3                   */
+#define CAPT_USR_DEF_4_DATA           					 51   /* 11 0011    User Defined 8-bit Data Type 4                   */
+#define CAPT_USR_DEF_5_DATA           					 52   /* 11 0100    User Defined 8-bit Data Type 5                   */
+#define CAPT_USR_DEF_6_DATA           					 53   /* 11 0101    User Defined 8-bit Data Type 6                   */
+#define CAPT_USR_DEF_7_DATA           					 54   /* 11 0110    User Defined 8-bit Data Type 7                   */
+#define CAPT_USR_DEF_8_DATA           					 55   /* 11 0111    User Defined 8-bit Data Type 8                   */
+#define CAPT_Emb_DATA                 					 18   /* 01 0010    embedded eight bit non image data                */
+#define CAPT_SOF_DATA                 					 0   /* 00 0000    frame start                                      */
+#define CAPT_EOF_DATA                 					 1   /* 00 0001    frame end                                        */
+#define CAPT_SOL_DATA                 					 2   /* 00 0010    line start                                       */
+#define CAPT_EOL_DATA                 					 3   /* 00 0011    line end                                         */
+#define CAPT_GEN_SH1_DATA             					 8   /* 00 1000  Generic Short Packet Code 1                        */
+#define CAPT_GEN_SH2_DATA             					 9   /* 00 1001    Generic Short Packet Code 2                      */
+#define CAPT_GEN_SH3_DATA             					 10   /* 00 1010    Generic Short Packet Code 3                      */
+#define CAPT_GEN_SH4_DATA             					 11   /* 00 1011    Generic Short Packet Code 4                      */
+#define CAPT_GEN_SH5_DATA             					 12   /* 00 1100    Generic Short Packet Code 5                      */
+#define CAPT_GEN_SH6_DATA             					 13   /* 00 1101    Generic Short Packet Code 6                      */
+#define CAPT_GEN_SH7_DATA             					 14   /* 00 1110    Generic Short Packet Code 7                      */
+#define CAPT_GEN_SH8_DATA             					 15   /* 00 1111    Generic Short Packet Code 8                      */
+#define CAPT_YUV420_8_CSPS_DATA       					 28   /* 01 1100   YUV420 8-bit (Chroma Shifted Pixel Sampling)      */
+#define CAPT_YUV420_10_CSPS_DATA      					 29   /* 01 1101   YUV420 10-bit (Chroma Shifted Pixel Sampling)     */
+#define CAPT_RESERVED_DATA_TYPE_MIN              56
+#define CAPT_RESERVED_DATA_TYPE_MAX              63
+#define CAPT_GEN_LONG_RESERVED_DATA_TYPE_MIN     19
+#define CAPT_GEN_LONG_RESERVED_DATA_TYPE_MAX     23
+#define CAPT_YUV_RESERVED_DATA_TYPE              27
+#define CAPT_RGB_RESERVED_DATA_TYPE_MIN          37
+#define CAPT_RGB_RESERVED_DATA_TYPE_MAX          39
+#define CAPT_RAW_RESERVED_DATA_TYPE_MIN          46
+#define CAPT_RAW_RESERVED_DATA_TYPE_MAX          47
+
+
+/* --------------------------------------------------*/
+/* Capture Unit State */
+/* --------------------------------------------------*/
+#define CAPT_FREE_RUN                             0
+#define CAPT_NO_SYNC                              1
+#define CAPT_SYNC_SWP                             2
+#define CAPT_SYNC_MWP                             3
+#define CAPT_SYNC_WAIT                            4
+#define CAPT_FREEZE                               5
+#define CAPT_RUN                                  6
+
+
+/* --------------------------------------------------*/
+
+#endif /* _isp_capture_defs_h */
+
+
+
+
+
diff --git a/drivers/media/atomisp2/css2400/hrt/mmu_defs.h b/drivers/media/atomisp2/css2400/hrt/mmu_defs.h
new file mode 100644
index 0000000..64fadd3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/mmu_defs.h
@@ -0,0 +1,30 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _mmu_defs_h
+#define _mmu_defs_h
+
+#define _HRT_MMU_INVALIDATE_TLB_REG_IDX          0
+#define _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX 1
+
+#define _HRT_MMU_REG_ALIGN 4
+
+#endif /* _mmu_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/scalar_processor_2400_params.h b/drivers/media/atomisp2/css2400/hrt/scalar_processor_2400_params.h
new file mode 100644
index 0000000..b0f56d7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/scalar_processor_2400_params.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _scalar_processor_2400_params_h
+#define _scalar_processor_2400_params_h
+
+#include "cell_params.h"
+
+#endif /* _scalar_processor_2400_params_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/sp_hrt.h b/drivers/media/atomisp2/css2400/hrt/sp_hrt.h
new file mode 100644
index 0000000..f3b8f25
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/sp_hrt.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _sp_hrt_h_
+#define _sp_hrt_h_
+
+#define hrt_sp_dmem(cell) HRT_PROC_TYPE_PROP(cell, _dmem)
+
+#define hrt_sp_dmem_master_port_address(cell) hrt_mem_master_port_address(cell, hrt_sp_dmem(cell))
+
+#endif /* _sp_hrt_h_ */
diff --git a/drivers/media/atomisp2/css2400/hrt/str2mem_defs.h b/drivers/media/atomisp2/css2400/hrt/str2mem_defs.h
new file mode 100644
index 0000000..75298fd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/str2mem_defs.h
@@ -0,0 +1,46 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _ST2MEM_DEFS_H
+#define _ST2MEM_DEFS_H
+
+#define _STR2MEM_CRUN_BIT               0x100000
+#define _STR2MEM_CMD_BITS               0x0F0000
+#define _STR2MEM_COUNT_BITS             0x00FFFF
+
+#define _STR2MEM_BLOCKS_CMD             0xA0000
+#define _STR2MEM_PACKETS_CMD            0xB0000
+#define _STR2MEM_BYTES_CMD              0xC0000
+#define _STR2MEM_BYTES_FROM_PACKET_CMD  0xD0000
+
+#define _STR2MEM_SOFT_RESET_REG_ID                   0
+#define _STR2MEM_INPUT_ENDIANNESS_REG_ID             1
+#define _STR2MEM_OUTPUT_ENDIANNESS_REG_ID            2
+#define _STR2MEM_BIT_SWAPPING_REG_ID                 3
+#define _STR2MEM_BLOCK_SYNC_LEVEL_REG_ID             4
+#define _STR2MEM_PACKET_SYNC_LEVEL_REG_ID            5
+#define _STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ID  6
+#define _STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ID     7
+#define _STR2MEM_EN_STAT_UPDATE_ID                   8
+
+#define _STR2MEM_REG_ALIGN      4
+
+#endif /* _ST2MEM_DEFS_H */
diff --git a/drivers/media/atomisp2/css2400/hrt/streaming_to_mipi_defs.h b/drivers/media/atomisp2/css2400/hrt/streaming_to_mipi_defs.h
new file mode 100644
index 0000000..b5ec5a7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/streaming_to_mipi_defs.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _streaming_to_mipi_defs_h
+#define _streaming_to_mipi_defs_h
+
+#define HIVE_STR_TO_MIPI_VALID_A_BIT 0
+#define HIVE_STR_TO_MIPI_VALID_B_BIT 1
+#define HIVE_STR_TO_MIPI_SOL_BIT     2
+#define HIVE_STR_TO_MIPI_EOL_BIT     3
+#define HIVE_STR_TO_MIPI_SOF_BIT     4
+#define HIVE_STR_TO_MIPI_EOF_BIT     5
+#define HIVE_STR_TO_MIPI_CH_ID_LSB   6
+
+#define HIVE_STR_TO_MIPI_DATA_A_LSB  (HIVE_STR_TO_MIPI_VALID_B_BIT + 1)
+
+#endif /* _streaming_to_mipi_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/timed_controller_defs.h b/drivers/media/atomisp2/css2400/hrt/timed_controller_defs.h
new file mode 100644
index 0000000..0029db7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/timed_controller_defs.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _timed_controller_defs_h
+#define _timed_controller_defs_h
+
+#define _HRT_TIMED_CONTROLLER_CMD_REG_IDX 0
+
+#define _HRT_TIMED_CONTROLLER_REG_ALIGN 4
+
+#endif /* _timed_controller_defs_h */
diff --git a/drivers/media/atomisp2/css2400/hrt/var.h b/drivers/media/atomisp2/css2400/hrt/var.h
new file mode 100644
index 0000000..c5c048a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/var.h
@@ -0,0 +1,104 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _HRT_VAR_H
+#define _HRT_VAR_H
+
+#include "version.h"
+#include "system_api.h"
+#include "hive_types.h"
+
+#define hrt_int_type_of_char   char
+#define hrt_int_type_of_uchar  unsigned char
+#define hrt_int_type_of_short  short
+#define hrt_int_type_of_ushort unsigned short
+#define hrt_int_type_of_int    int
+#define hrt_int_type_of_uint   unsigned int
+#define hrt_int_type_of_long   long
+#define hrt_int_type_of_ulong  unsigned long
+#define hrt_int_type_of_ptr    unsigned int
+
+#define hrt_host_type_of_char   char
+#define hrt_host_type_of_uchar  unsigned char
+#define hrt_host_type_of_short  short
+#define hrt_host_type_of_ushort unsigned short
+#define hrt_host_type_of_int    int
+#define hrt_host_type_of_uint   unsigned int
+#define hrt_host_type_of_long   long
+#define hrt_host_type_of_ulong  unsigned long
+#define hrt_host_type_of_ptr    void*
+
+#define HRT_TYPE_BYTES(cell, type) (HRT_TYPE_BITS(cell, type)/8)
+#define HRT_HOST_TYPE(cell_type)   HRTCAT(hrt_host_type_of_, cell_type)
+#define HRT_INT_TYPE(type)         HRTCAT(hrt_int_type_of_, type)
+
+#ifdef C_RUN
+
+#ifdef C_RUN_DYNAMIC_LINK_PROGRAMS
+extern void *csim_processor_get_crun_symbol(hive_proc_id p, const char *sym);
+#define _hrt_cell_get_crun_symbol(cell,sym)          csim_processor_get_crun_symbol(cell,HRTSTR(sym))
+#define _hrt_cell_get_crun_indexed_symbol(cell,sym)  csim_processor_get_crun_symbol(cell,HRTSTR(sym))
+#else
+#define _hrt_cell_get_crun_symbol(cell,sym)         (&sym)
+#define _hrt_cell_get_crun_indexed_symbol(cell,sym) (sym)
+#endif //  C_RUN_DYNAMIC_LINK_PROGRAMS
+
+#define hrt_scalar_store(cell, type, var, data) \
+	((*(HRT_HOST_TYPE(type)*)_hrt_cell_get_crun_symbol(cell,var)) = (data))
+#define hrt_scalar_load(cell, type, var) \
+	((*(HRT_HOST_TYPE(type)*)_hrt_cell_get_crun_symbol(cell,var)))
+
+#define hrt_indexed_store(cell, type, array, index, data) \
+	((((HRT_HOST_TYPE(type)*)_hrt_cell_get_crun_indexed_symbol(cell,array))[index]) = (data))
+#define hrt_indexed_load(cell, type, array, index) \
+	(((HRT_HOST_TYPE(type)*)_hrt_cell_get_crun_indexed_symbol(cell,array))[index])
+
+#else /* C_RUN */
+
+#define hrt_scalar_store(cell, type, var, data) \
+  HRTCAT(hrt_mem_store_,HRT_TYPE_BITS(cell, type))(\
+	       cell, \
+	       HRTCAT(HIVE_MEM_,var), \
+	       HRTCAT(HIVE_ADDR_,var), \
+	       (HRT_INT_TYPE(type))(data))
+
+#define hrt_scalar_load(cell, type, var) \
+  (HRT_HOST_TYPE(type))(HRTCAT4(_hrt_mem_load_,HRT_PROC_TYPE(cell),_,type) ( \
+	       cell, \
+	       HRTCAT(HIVE_MEM_,var), \
+	       HRTCAT(HIVE_ADDR_,var)))
+
+#define hrt_indexed_store(cell, type, array, index, data) \
+  HRTCAT(hrt_mem_store_,HRT_TYPE_BITS(cell, type))(\
+	       cell, \
+	       HRTCAT(HIVE_MEM_,array), \
+	       (HRTCAT(HIVE_ADDR_,array))+((index)*HRT_TYPE_BYTES(cell, type)), \
+	       (HRT_INT_TYPE(type))(data))
+
+#define hrt_indexed_load(cell, type, array, index) \
+  (HRT_HOST_TYPE(type))(HRTCAT4(_hrt_mem_load_,HRT_PROC_TYPE(cell),_,type) ( \
+         cell, \
+	       HRTCAT(HIVE_MEM_,array), \
+	       (HRTCAT(HIVE_ADDR_,array))+((index)*HRT_TYPE_BYTES(cell, type))))
+
+#endif /* C_RUN */
+
+#endif /* _HRT_VAR_H */
diff --git a/drivers/media/atomisp2/css2400/hrt/version.h b/drivers/media/atomisp2/css2400/hrt/version.h
new file mode 100644
index 0000000..f3b5038
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/hrt/version.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef HRT_VERSION_H
+#define HRT_VERSION_H
+#define HRT_VERSION_MAJOR 1
+#define HRT_VERSION_MINOR 4
+#define HRT_VERSION 1_4
+#endif
diff --git a/drivers/media/atomisp2/css2400/ia_css.h b/drivers/media/atomisp2/css2400/ia_css.h
new file mode 100644
index 0000000..49663ee
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css.h
@@ -0,0 +1,63 @@
+/* Release Version: 140311_1735 */
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/*! \file */
+
+#ifndef _IA_CSS_H_
+#define _IA_CSS_H_
+
+#include <type_support.h>
+#include <stdarg.h> /* va_list */
+#include "ia_css_types.h"
+#include "ia_css_3a.h"
+#include "ia_css_acc_types.h"
+#include "ia_css_buffer.h"
+#include "ia_css_control.h"
+#include "ia_css_dvs.h"
+#include "ia_css_env.h"
+#include "ia_css_err.h"
+#include "ia_css_event_public.h"
+#include "ia_css_firmware.h"
+#include "ia_css_frame_public.h"
+#include "ia_css_input_port.h"
+#include "ia_css_irq.h"
+#include "ia_css_metadata.h"
+#include "ia_css_mipi.h"
+#include "ia_css_pipe_public.h"
+#include "ia_css_prbs.h"
+#include "ia_css_properties.h"
+#include "ia_css_stream_format.h"
+#include "ia_css_stream_public.h"
+#include "ia_css_tpg.h"
+#include "ia_css_lace_stat.h"
+#include "ia_css_version.h"
+#include "ia_css_mmu.h"
+#include "ia_css_morph.h"
+#include "ia_css_shading.h"
+
+/*
+   Please do not add code to this file. Public functionality is to be
+   exposed in a function/data type specific header file.
+   Please add to the appropriate header file or create a new one.
+ */
+
+#endif /* _IA_CSS_H_ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_3a.h b/drivers/media/atomisp2/css2400/ia_css_3a.h
new file mode 100644
index 0000000..ba2a884
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_3a.h
@@ -0,0 +1,126 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_3A_H
+#define __IA_CSS_3A_H
+
+#include <type_support.h>
+#include "ia_css_types.h"
+#include "system_global.h"
+
+enum ia_css_3a_tables {
+	IA_CSS_S3A_TBL_HI,
+	IA_CSS_S3A_TBL_LO,
+	IA_CSS_RGBY_TBL,
+	IA_CSS_NUM_3A_TABLES
+};
+
+/** Structure that holds 3A statistics in the ISP internal
+ * format. Use ia_css_get_3a_statistics() to translate
+ * this to the format used on the host (3A library).
+ * */
+struct ia_css_isp_3a_statistics {
+	union {
+		struct {
+			ia_css_ptr s3a_tbl;
+		} dmem;
+		struct {
+			ia_css_ptr s3a_tbl_hi;
+			ia_css_ptr s3a_tbl_lo;
+		} vmem;
+	} data;
+	struct {
+		ia_css_ptr rgby_tbl;
+	} data_hmem;
+	uint32_t exp_id;
+};
+#define SIZE_OF_DMEM_STRUCT						\
+	(SIZE_OF_IA_CSS_PTR)
+
+#define SIZE_OF_VMEM_STRUCT						\
+	(2 * SIZE_OF_IA_CSS_PTR)
+
+#define SIZE_OF_DATA_UNION						\
+	(MAX(SIZE_OF_DMEM_STRUCT, SIZE_OF_VMEM_STRUCT))
+
+#define SIZE_OF_DATA_HMEM_STRUCT					\
+	(SIZE_OF_IA_CSS_PTR)
+
+#define SIZE_OF_IA_CSS_ISP_3A_STATISTICS_STRUCT				\
+	(SIZE_OF_DATA_UNION +						\
+	SIZE_OF_DATA_HMEM_STRUCT +					\
+	sizeof(uint32_t))
+
+#if defined(IS_ISP_2500_SYSTEM)
+/** @brief Copy 4A statistics from an ISP/ACC buffer to a host buffer.
+ * @param[in]	host_stats Host buffer.
+ * @param[in]	isp_stats ISP buffer.
+ * @return		None
+ */
+struct ia_css_4a_statistics;
+void ia_css_get_4a_statistics(struct ia_css_4a_statistics           *host_stats,
+		const struct ia_css_isp_3a_statistics *isp_stats);
+#endif
+
+/** @brief Copy 3A statistics from an ISP/ACC buffer to a host buffer.
+ * @param[in]	host_stats Host buffer.
+ * @param[in]	isp_stats ISP buffer.
+ * @return		None
+ *
+ * This may include a translation step as well depending
+ * on the ISP version.
+ * Always use this function, never copy the buffer directly.
+ */
+void
+ia_css_get_3a_statistics(struct ia_css_3a_statistics           *host_stats,
+			 const struct ia_css_isp_3a_statistics *isp_stats);
+
+/* Convenience functions for alloc/free of certain datatypes */
+
+/** @brief Allocate memory for the 3a statistics on the ISP
+ * @param[in]	grid The grid.
+ * @return		Pointer to the allocated 3a statistics buffer on the ISP
+*/
+struct ia_css_isp_3a_statistics *
+ia_css_isp_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid);
+
+/** @brief Free the 3a statistics memory on the isp
+ * @param[in]	me Pointer to the 3a statistics buffer on the ISP.
+ * @return		None
+*/
+void
+ia_css_isp_3a_statistics_free(struct ia_css_isp_3a_statistics *me);
+
+/** @brief Allocate memory for the 3a statistics on the host
+ * @param[in]	grid The grid.
+ * @return		Pointer to the allocated 3a statistics buffer on the host
+*/
+struct ia_css_3a_statistics *
+ia_css_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid);
+
+/** @brief Free the 3a statistics memory on the host
+ * @param[in]	me Pointer to the 3a statistics buffer on the host.
+ * @return		None
+ */
+void
+ia_css_3a_statistics_free(struct ia_css_3a_statistics *me);
+
+#endif /* __IA_CSS_3A_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_acc_types.h b/drivers/media/atomisp2/css2400/ia_css_acc_types.h
new file mode 100644
index 0000000..78c32a2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_acc_types.h
@@ -0,0 +1,424 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_ACC_TYPES_H_
+#define _IA_CSS_ACC_TYPES_H_
+
+/*! \file */
+
+/** @file ia_css_types.h
+ * This file contains types used for the ia_css parameters.
+ * These types are in a separate file because they are expected
+ * to be used in software layers that do not access the CSS API
+ * directly but still need to forward parameters for it.
+ */
+
+#include <system_types.h>	/* HAS_IRQ_MAP_VERSION_# */
+#include <type_support.h>
+#include <platform_support.h>
+#include <debug_global.h>
+
+#include "ia_css_types.h"
+#include "ia_css_frame_public.h"
+
+/* Types for the acceleration API.
+ * These should be moved to sh_css_internal.h once the old acceleration
+ * argument handling has been completed.
+ * After that, interpretation of these structures is no longer needed
+ * in the kernel and HAL.
+*/
+
+/** Type of acceleration.
+ */
+enum ia_css_acc_type {
+	IA_CSS_ACC_NONE,	/**< Normal binary */
+	IA_CSS_ACC_OUTPUT,	/**< Accelerator stage on output frame */
+	IA_CSS_ACC_VIEWFINDER,	/**< Accelerator stage on viewfinder frame */
+	IA_CSS_ACC_STANDALONE,	/**< Stand-alone acceleration */
+};
+
+/** Firmware types.
+ */
+enum ia_css_fw_type {
+	ia_css_sp_firmware,		/**< Firmware for the SP */
+#if defined(IS_ISP_2500_SYSTEM)
+	ia_css_sp1_firmware,	/**< Firmware for the SP1 */
+#endif
+	ia_css_isp_firmware,	/**< Firmware for the ISP */
+	ia_css_acc_firmware		/**< Firmware for accelrations */
+};
+
+/* Should be included without the path.
+   However, that requires adding the path to numerous makefiles
+   that have nothing to do with isp parameters.
+ */
+#include "runtime/isp_param/interface/ia_css_isp_param_types.h"
+
+struct ia_css_blob_descr;
+
+/** Blob descriptor.
+ * This structure describes an SP or ISP blob.
+ * It describes the test, data and bss sections as well as position in a
+ * firmware file.
+ * For convenience, it contains dynamic data after loading.
+ */
+struct ia_css_blob_info {
+	/**< Static blob data */
+	uint32_t offset;		/**< Blob offset in fw file */
+	struct ia_css_isp_param_memory_offsets memory_offsets;  /**< offset wrt hdr in bytes */
+	uint32_t prog_name_offset;  /**< offset wrt hdr in bytes */
+	uint32_t size;			/**< Size of blob */
+	uint32_t padding_size;	/**< total cummulative of bytes added due to section alignment */
+	uint32_t icache_source;	/**< Position of icache in blob */
+	uint32_t icache_size;	/**< Size of icache section */
+	uint32_t icache_padding;/**< bytes added due to icache section alignment */
+	uint32_t text_source;	/**< Position of text in blob */
+	uint32_t text_size;		/**< Size of text section */
+	uint32_t text_padding;	/**< bytes added due to text section alignment */
+	uint32_t data_source;	/**< Position of data in blob */
+	uint32_t data_target;	/**< Start of data in SP dmem */
+	uint32_t data_size;		/**< Size of text section */
+	uint32_t data_padding;	/**< bytes added due to data section alignment */
+	uint32_t bss_target;	/**< Start position of bss in SP dmem */
+	uint32_t bss_size;		/**< Size of bss section */
+	/**< Dynamic data filled by loader */
+	CSS_ALIGN(const void  *code, 8);		/**< Code section absolute pointer within fw, code = icache + text */
+	CSS_ALIGN(const void  *data, 8);		/**< Data section absolute pointer within fw, data = data + bss */
+};
+
+/** Structure describing an ISP binary.
+ * It describes the capabilities of a binary, like the maximum resolution,
+ * support features, dma channels, uds features, etc.
+ * This part is to be used by the SP.
+ * Future refactoring should move binary properties to ia_css_binary_xinfo,
+ * thereby making the SP code more binary independent.
+ */
+struct ia_css_binary_info {
+	CSS_ALIGN(uint32_t	id, 8); /* IA_CSS_BINARY_ID_* */
+	uint32_t		mode;
+	uint32_t		supported_bds_factors;
+	uint32_t		min_input_width;
+	uint32_t		min_input_height;
+	uint32_t		max_input_width;
+	uint32_t		max_input_height;
+	uint32_t		min_output_width;
+	uint32_t		min_output_height;
+	uint32_t		max_output_width;
+	uint32_t		max_output_height;
+	uint32_t		max_internal_width;
+	uint32_t		max_internal_height;
+	uint32_t		max_dvs_envelope_width;
+	uint32_t		max_dvs_envelope_height;
+	uint32_t		variable_resolution;
+	uint32_t		variable_output_format;
+	uint32_t		variable_vf_veceven;
+	uint32_t		max_vf_log_downscale;
+	uint32_t		top_cropping;
+	uint32_t		left_cropping;
+	uint32_t		s3atbl_use_dmem;
+	int32_t			input;
+	uint32_t		c_subsampling;
+	uint32_t		output_num_chunks;
+	uint32_t		num_stripes;
+	uint32_t		row_stripes_height;
+	uint32_t		row_stripes_overlap_lines;
+	uint32_t		pipelining;
+	uint32_t		fixed_s3a_deci_log;
+	uint32_t		isp_addresses;	/* Address in ISP dmem */
+	uint32_t		main_entry;	/* Address of entry fct */
+	uint32_t		in_frame;	/* Address in ISP dmem */
+	uint32_t		out_frame;	/* Address in ISP dmem */
+	uint32_t		in_data;	/* Address in ISP dmem */
+	uint32_t		out_data;	/* Address in ISP dmem */
+	uint32_t		block_width;
+	uint32_t		block_height;
+	uint32_t		output_block_height;
+	uint32_t		dvs_in_block_width;
+	uint32_t		dvs_in_block_height;
+	struct ia_css_isp_param_isp_segments mem_initializers;
+	uint32_t		sh_dma_cmd_ptr;     /* In ISP dmem */
+	uint32_t		isp_pipe_version;
+/* MW: Packing (related) bools in an integer ?? */
+	struct {
+#if defined(IS_ISP_2500_SYSTEM)
+		uint8_t	input_feeder;
+		uint8_t	obgrid;
+		uint8_t	lin;
+		uint8_t	dpc_acc;
+		uint8_t	bds_acc;
+		uint8_t	shd_acc;
+		uint8_t	shd_ff;
+		uint8_t	stats_3a_raw_buffer;
+		uint8_t	acc_bayer_denoise;
+		uint8_t	bnr_ff;
+		uint8_t	awb_acc;
+		uint8_t	awb_fr_acc;
+		uint8_t	anr_acc;
+		uint8_t	rgbpp_acc;
+		uint8_t	rgbpp_ff;
+		uint8_t	demosaic_acc;
+		uint8_t	dvs_stats;
+		uint8_t	lace_stats;
+		uint8_t	yuvp1_acc;
+		uint8_t	yuvp2_acc;
+		uint8_t	ae;
+		uint8_t	af;
+		uint8_t	dergb;
+		uint8_t	rgb2yuv;
+		uint8_t	high_quality;
+		uint8_t	kerneltest;
+		uint8_t	routing_bnr_to_anr;
+		uint8_t routing_anr_to_de;
+#endif
+		uint8_t	reduced_pipe;
+		uint8_t	vf_veceven;
+		uint8_t	dis;
+		uint8_t	dvs_envelope;
+		uint8_t	uds;
+		uint8_t	dvs_6axis;
+		uint8_t	block_output;
+		uint8_t	streaming_dma;
+		uint8_t	ds;
+		uint8_t	bayer_fir_6db;
+		uint8_t	raw_binning;
+		uint8_t	continuous;
+		uint8_t	s3a;
+		uint8_t	fpnr;
+		uint8_t	sc;
+		uint8_t	macc;
+		uint8_t	output;
+		uint8_t	ref_frame;
+		uint8_t	tnr;
+		uint8_t	xnr;
+		uint8_t	params;
+		uint8_t	ca_gdc;
+		uint8_t	isp_addresses;
+		uint8_t	in_frame;
+		uint8_t	out_frame;
+		uint8_t	high_speed;
+		uint8_t padding[2];
+	} enable;
+	struct {
+/* DMA channel ID: [0,...,HIVE_ISP_NUM_DMA_CHANNELS> */
+		uint8_t	ref_y_channel;
+		uint8_t	ref_c_channel;
+		uint8_t	tnr_channel;
+		uint8_t	tnr_out_channel;
+		uint8_t	dvs_coords_channel;
+		uint8_t	output_channel;
+		uint8_t	c_channel;
+		uint8_t	vfout_channel;
+		uint8_t	vfout_c_channel;
+		uint8_t	vfdec_bits_per_pixel;
+		uint8_t	claimed_by_isp;
+		uint8_t padding[2];
+	} dma;
+	struct {
+		uint16_t	bpp;
+		uint16_t	use_bci;
+		uint16_t	use_str;
+		uint16_t	woix;
+		uint16_t	woiy;
+		uint16_t	extra_out_vecs;
+		uint16_t	vectors_per_line_in;
+		uint16_t	vectors_per_line_out;
+		uint16_t	vectors_c_per_line_in;
+		uint16_t	vectors_c_per_line_out;
+		uint16_t	vmem_gdc_in_block_height_y;
+		uint16_t	vmem_gdc_in_block_height_c;
+		/* uint16_t padding; */
+	} uds;
+};
+
+/** Structure describing an ISP binary.
+ * It describes the capabilities of a binary, like the maximum resolution,
+ * support features, dma channels, uds features, etc.
+ */
+struct ia_css_binary_xinfo {
+	/* Part that is of interest to the SP. */
+	struct ia_css_binary_info    sp;
+
+	/* Rest of the binary info, only interesting to the host. */
+	enum ia_css_acc_type	     type;
+	CSS_ALIGN(int32_t	     num_output_formats, 8);
+	enum ia_css_frame_format     output_formats[IA_CSS_FRAME_FORMAT_NUM];
+	uint8_t			     num_output_pins;
+	ia_css_ptr		     xmem_addr;
+	CSS_ALIGN(const struct ia_css_blob_descr *blob, 8);
+	CSS_ALIGN(uint32_t blob_index, 8);
+	CSS_ALIGN(union ia_css_all_memory_offsets mem_offsets, 8);
+	CSS_ALIGN(struct ia_css_binary_xinfo *next, 8);
+};
+
+/** Structure describing the SP binary.
+ * It contains several address, either in ddr, sp_dmem or
+ * the entry function in pmem.
+ */
+struct ia_css_sp_info {
+	uint32_t init_dmem_data; /**< data sect config, stored to dmem */
+	uint32_t per_frame_data; /**< Per frame data, stored to dmem */
+	uint32_t group;		/**< Per pipeline data, loaded by dma */
+	uint32_t output;		/**< SP output data, loaded by dmem */
+	uint32_t host_sp_queue;	/**< Host <-> SP queues */
+	uint32_t host_sp_com;/**< Host <-> SP commands */
+	uint32_t isp_started;	/**< Polled from sensor thread, csim only */
+	uint32_t sw_state;	/**< Polled from css */
+	uint32_t host_sp_queues_initialized; /**< Polled from the SP */
+	uint32_t sleep_mode;  /**< different mode to halt SP */
+	uint32_t invalidate_tlb;		/**< inform SP to invalidate mmu TLB */
+	uint32_t stop_copy_preview;	/**< suspend copy and preview pipe when capture */
+	uint32_t debug_buffer_ddr_address;	/**< inform SP the address
+	of DDR debug queue */
+	uint32_t perf_counter_input_system_error; /**< input system perf
+	counter array */
+#ifdef HAS_WATCHDOG_SP_THREAD_DEBUG
+	uint32_t debug_wait; /**< thread/pipe post mortem debug */
+	uint32_t debug_stage; /**< thread/pipe post mortem debug */
+	uint32_t debug_stripe; /**< thread/pipe post mortem debug */
+#endif
+	uint32_t curr_binary_id;        /**< current binary id */
+	uint32_t raw_copy_line_count;   /**< raw copy line counter */
+	uint32_t ddr_parameter_address; /**< acc param ddrptr, sp dmem */
+	uint32_t ddr_parameter_size;    /**< acc param size, sp dmem */
+	/* Entry functions */
+	uint32_t sp_entry;	/**< The SP entry function */
+};
+
+/** Accelerator firmware information.
+ */
+struct ia_css_acc_info {
+	uint32_t per_frame_data; /**< Dummy for now */
+};
+
+/** Firmware information.
+ */
+union ia_css_fw_union {
+	struct ia_css_binary_xinfo	isp; /**< ISP info */
+	struct ia_css_sp_info		sp;  /**< SP info */
+#if defined(IS_ISP_2500_SYSTEM)
+	struct ia_css_sp_info		sp1;  /**< SP1 info */
+#endif
+	struct ia_css_acc_info		acc; /**< Accelerator info */
+};
+
+/** Firmware information.
+ */
+struct ia_css_fw_info {
+	size_t			 header_size; /**< size of fw header */
+	CSS_ALIGN(uint32_t type, 8);
+	union ia_css_fw_union	 info; /**< Binary info */
+	struct ia_css_blob_info  blob; /**< Blob info */
+	/* Dynamic part */
+	struct ia_css_fw_info   *next;
+	CSS_ALIGN(uint32_t       loaded, 8);	/**< Firmware has been loaded */
+	CSS_ALIGN(const uint8_t *isp_code, 8);  /**< ISP pointer to code */
+	/**< Firmware handle between user space and kernel */
+	CSS_ALIGN(uint32_t	handle, 8);
+	/**< Sections to copy from/to ISP */
+	struct ia_css_isp_param_css_segments mem_initializers;
+	/**< Initializer for local ISP memories */
+};
+
+struct ia_css_blob_descr {
+	const unsigned char  *blob;
+	struct ia_css_fw_info header;
+	const char	     *name;
+	union ia_css_all_memory_offsets mem_offsets;
+};
+
+struct ia_css_acc_fw;
+
+/** Structure describing the SP binary of a stand-alone accelerator.
+ */
+ struct ia_css_acc_sp {
+	void (*init) (struct ia_css_acc_fw *); /**< init for crun */
+	uint32_t      sp_prog_name_offset; /**< program name offset wrt hdr
+						in bytes */
+	uint32_t      sp_blob_offset;	   /**< blob offset wrt hdr in bytes */
+	void	     *entry;		   /**< Address of sp entry point */
+	uint32_t *css_abort;	   /**< SP dmem abort flag */
+	void	     *isp_code;		   /**< SP dmem address holding xmem
+						address of isp code */
+	struct ia_css_fw_info fw;	   /**< SP fw descriptor */
+	const uint8_t *code;	   /**< ISP pointer of allocated
+						SP code */
+};
+
+/** Acceleration firmware descriptor.
+  * This descriptor descibes either SP code (stand-alone), or
+  * ISP code (a separate pipeline stage).
+  */
+struct ia_css_acc_fw_hdr {
+	enum ia_css_acc_type type;	/**< Type of accelerator */
+	uint32_t	isp_prog_name_offset; /**< program name offset wrt
+						   header in bytes */
+	uint32_t	isp_blob_offset;      /**< blob offset wrt header
+						   in bytes */
+	uint32_t	isp_size;	      /**< Size of isp blob */
+	const uint8_t  *isp_code;	      /**< ISP pointer to code */
+	struct ia_css_acc_sp  sp;  /**< Standalone sp code */
+	/**< Firmware handle between user space and kernel */
+	uint32_t	handle;
+	struct ia_css_data parameters; /**< Current SP parameters */
+};
+
+/** Firmware structure.
+  * This contains the header and actual blobs.
+  * For standalone, it contains SP and ISP blob.
+  * For a pipeline stage accelerator, it contains ISP code only.
+  * Since its members are variable size, their offsets are described in the
+  * header and computed using the access macros below.
+  */
+struct ia_css_acc_fw {
+	struct ia_css_acc_fw_hdr header; /**< firmware header */
+	/*
+	int8_t   isp_progname[];	  **< ISP program name
+	int8_t   sp_progname[];	  **< SP program name, stand-alone only
+	uint8_t sp_code[];  **< SP blob, stand-alone only
+	uint8_t isp_code[]; **< ISP blob
+	*/
+};
+
+/* Access macros for firmware */
+#define IA_CSS_ACC_OFFSET(t, f, n) ((t)((uint8_t *)(f)+(f->header.n)))
+#define IA_CSS_ACC_SP_PROG_NAME(f) IA_CSS_ACC_OFFSET(const char *, f, \
+						 sp.sp_prog_name_offset)
+#define IA_CSS_ACC_ISP_PROG_NAME(f) IA_CSS_ACC_OFFSET(const char *, f, \
+						 isp_prog_name_offset)
+#define IA_CSS_ACC_SP_CODE(f)      IA_CSS_ACC_OFFSET(uint8_t *, f, \
+						 sp.sp_blob_offset)
+#define IA_CSS_ACC_SP_DATA(f)      (IA_CSS_ACC_SP_CODE(f) + \
+					(f)->header.sp.fw.blob.data_source)
+#define IA_CSS_ACC_ISP_CODE(f)     IA_CSS_ACC_OFFSET(uint8_t*, f,\
+						 isp_blob_offset)
+#define IA_CSS_ACC_ISP_SIZE(f)     ((f)->header.isp_size)
+
+/* Binary name follows header immediately */
+#define IA_CSS_EXT_ISP_PROG_NAME(f)   ((const char *)(f)+(f)->blob.prog_name_offset)
+#define IA_CSS_EXT_ISP_MEM_OFFSETS(f) \
+	((const struct ia_css_memory_offsets *)((const char *)(f)+(f)->blob.mem_offsets))
+
+enum ia_css_sp_sleep_mode {
+	SP_DISABLE_SLEEP_MODE = 0,
+	SP_SLEEP_AFTER_FRAME = 1 << 0,
+	SP_SLEEP_AFTER_IRQ = 1 << 1
+};
+#endif /* _IA_CSS_TYPES_H_ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_buffer.h b/drivers/media/atomisp2/css2400/ia_css_buffer.h
new file mode 100644
index 0000000..8c55110
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_buffer.h
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BUFFER_H
+#define __IA_CSS_BUFFER_H
+
+#include <type_support.h>
+#include "ia_css_types.h"
+
+/** Buffer structure. This is a container structure that enables content
+ *  independent buffer queues and access functions.
+ */
+struct ia_css_buffer {
+	enum ia_css_buffer_type type; /**< Buffer type. */
+	unsigned int exp_id; /**< exposure id for this buffer; 0 = not available; currently only implemented for buffered sensor mode */
+	union {
+		struct ia_css_isp_3a_statistics  *stats_3a;    /**< 3A statistics & optionally RGBY statistics. */
+		struct ia_css_isp_dvs_statistics *stats_dvs;   /**< DVS statistics. */
+		ia_css_ptr                        stats_acc_dvs;  /**< ACC DVS statistics. */
+		ia_css_ptr                        stats_acc_lace; /**< LACE statistics. */
+		struct ia_css_frame              *frame;       /**< Frame buffer. */
+		struct ia_css_acc_param          *custom_data; /**< Custom buffer. */
+		struct ia_css_metadata           *metadata;    /**< Sensor metadata. */
+	} data; /**< Buffer data pointer. */
+	uint64_t driver_cookie; /**< cookie for the driver */
+};
+
+/** @brief Dequeue param buffers from sp2host_queue
+ *
+ * @return                                       None
+ *
+ * This function must be called at every driver interrupt handler to prevent
+ * overflow of sp2host_queue.
+ */
+void
+ia_css_dequeue_param_buffers(void);
+
+#endif /* __IA_CSS_BUFFER_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_control.h b/drivers/media/atomisp2/css2400/ia_css_control.h
new file mode 100644
index 0000000..651f2fe
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_control.h
@@ -0,0 +1,169 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CONTROL_H
+#define __IA_CSS_CONTROL_H
+
+#include <type_support.h>
+#include <ia_css_env.h>
+#include <ia_css_firmware.h>
+#include <ia_css_irq.h>
+
+/** @brief Initialize the CSS API.
+ * @param[in]	env		Environment, provides functions to access the
+ *				environment in which the CSS code runs. This is
+ *				used for host side memory access and message
+ *				printing. May not be NULL.
+ * @param[in]	fw		Firmware package containing the firmware for all
+ *				predefined ISP binaries.
+ *				if fw is NULL the firmware must be loaded before
+ *				through a call of ia_css_load_firmware
+ * @param[in]	l1_base         Base index (isp2400)
+ *                              of the L1 page table. This is a physical
+ *                              address or index.
+ * @param[in]	irq_type	The type of interrupt to be used (edge or level)
+ * @return				Returns IA_CSS_ERR_INTERNAL_ERROR in case of any
+ *				errors and IA_CSS_SUCCESS otherwise.
+ *
+ * This function initializes the API which includes allocating and initializing
+ * internal data structures. This also interprets the firmware package. All
+ * contents of this firmware package are copied into local data structures, so
+ * the fw pointer could be freed after this function completes.
+ */
+enum ia_css_err ia_css_init(
+	const struct ia_css_env *env,
+	const struct ia_css_fw  *fw,
+	uint32_t                 l1_base,
+	enum ia_css_irq_type     irq_type);
+
+/** @brief Un-initialize the CSS API.
+ * @return	None
+ *
+ * This function deallocates all memory that has been allocated by the CSS API
+ * Exception: if you explicitly loaded firmware through ia_css_load_firmware
+ * you need to call ia_css_unload_firmware to deallocate the memory reserved
+ * for the firmware.
+ * After this function is called, no other CSS functions should be called
+ * with the exception of ia_css_init which will re-initialize the CSS code,
+ * ia_css_unload_firmware to unload the firmware or ia_css_load_firmware
+ * to load new firmware
+ */
+void
+ia_css_uninit(void);
+
+/** @brief Suspend CSS API for power down
+ * @return	success or faulure code
+ *
+ * suspend shuts down the system by:
+ *  unloading all the streams
+ *  stopping SP
+ *  performing uninit
+ *
+ *  Currently stream memory is deallocated because of rmmgr issues.
+ *  Need to come up with a bypass that will leave the streams intact.
+ */
+enum ia_css_err
+ia_css_suspend(void);
+
+/** @brief Resume CSS API from power down
+ * @return	success or failure code
+ *
+ * After a power cycle, this function will bring the CSS API back into
+ * a state where it can be started.
+ * This will re-initialize the hardware and all the streams.
+ * Call this function only after ia_css_suspend() has been called.
+ */
+enum ia_css_err
+ia_css_resume(void);
+
+/** @brief Test whether the ISP has started.
+ *
+ * @return	Boolean flag true if the ISP has started or false otherwise.
+ *
+ * Temporary function to poll whether the ISP has been started. Once it has,
+ * the sensor can also be started. */
+bool
+ia_css_isp_has_started(void);
+
+/** @brief Test whether the SP has initialized.
+ *
+ * @return	Boolean flag true if the SP has initialized or false otherwise.
+ *
+ * Temporary function to poll whether the SP has been initialized. Once it has,
+ * we can enqueue buffers. */
+bool
+ia_css_sp_has_initialized(void);
+
+/** @brief Test whether the SP has terminated.
+ *
+ * @return	Boolean flag true if the SP has terminated or false otherwise.
+ *
+ * Temporary function to poll whether the SP has been terminated. Once it has,
+ * we can switch mode. */
+bool
+ia_css_sp_has_terminated(void);
+
+#if defined(IS_ISP_2500_SYSTEM)
+/** @brief start SP1 hardware
+ *
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * It will boot the SP hardware and start multi-threading infrastructure.
+ * All threads will be started and blocked by semaphore. This function should
+ * be called before any ia_css_stream_start().
+ */
+void
+ia_css_start_sp1(void);
+#endif
+
+/** @brief start SP hardware
+ *
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * It will boot the SP hardware and start multi-threading infrastructure.
+ * All threads will be started and blocked by semaphore. This function should
+ * be called before any ia_css_stream_start().
+ */
+enum ia_css_err
+ia_css_start_sp(void);
+
+#if defined(IS_ISP_2500_SYSTEM)
+/** @brief stop SP1 hardware
+ *
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * This function will shut down SP1.
+ */
+enum ia_css_err
+ia_css_stop_sp1(void);
+#endif
+
+/** @brief stop SP hardware
+ *
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * This function will terminate all threads and shut down SP. It should be
+ * called after all ia_css_stream_stop().
+ */
+enum ia_css_err
+ia_css_stop_sp(void);
+
+#endif /* __IA_CSS_CONTROL_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_device_access.c b/drivers/media/atomisp2/css2400/ia_css_device_access.c
new file mode 100644
index 0000000..f3cb33f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_device_access.c
@@ -0,0 +1,102 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_device_access.h"
+#include <type_support.h>
+#include <assert_support.h>
+#include <device_access.h>
+#include <ia_css_env.h>
+
+static struct ia_css_hw_access_env my_env;
+
+void
+ia_css_device_access_init(const struct ia_css_hw_access_env *env)
+{
+	assert(env != NULL);
+
+	my_env = *env;
+}
+
+uint8_t
+ia_css_device_load_uint8(const hrt_address addr)
+{
+	return my_env.load_8(addr);
+}
+
+uint16_t
+ia_css_device_load_uint16(const hrt_address addr)
+{
+	return my_env.load_16(addr);
+}
+
+uint32_t
+ia_css_device_load_uint32(const hrt_address addr)
+{
+	return my_env.load_32(addr);
+}
+
+uint64_t
+ia_css_device_load_uint64(const hrt_address addr)
+{
+	assert(0);
+
+	(void)addr;
+	return 0;
+}
+
+void
+ia_css_device_store_uint8(const hrt_address addr, const uint8_t data)
+{
+	my_env.store_8(addr, data);
+}
+
+void
+ia_css_device_store_uint16(const hrt_address addr, const uint16_t data)
+{
+	my_env.store_16(addr, data);
+}
+
+void
+ia_css_device_store_uint32(const hrt_address addr, const uint32_t data)
+{
+	my_env.store_32(addr, data);
+}
+
+void
+ia_css_device_store_uint64(const hrt_address addr, const uint64_t data)
+{
+	assert(0);
+
+	(void)addr;
+	(void)data;
+}
+
+void
+ia_css_device_load(const hrt_address addr, void *data, const size_t size)
+{
+	my_env.load(addr, data, size);
+}
+
+void
+ia_css_device_store(const hrt_address addr, const void *data, const size_t size)
+{
+	my_env.store(addr, data, size);
+}
diff --git a/drivers/media/atomisp2/css2400/ia_css_device_access.h b/drivers/media/atomisp2/css2400/ia_css_device_access.h
new file mode 100644
index 0000000..d80a43c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_device_access.h
@@ -0,0 +1,30 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_DEVICE_ACCESS_H_
+#define _IA_CSS_DEVICE_ACCESS_H_
+
+#include <ia_css_env.h>
+
+void
+ia_css_device_access_init(const struct ia_css_hw_access_env *env);
+
+#endif /* _IA_CSS_DEVICE_ACCESS_H_ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_dvs.h b/drivers/media/atomisp2/css2400/ia_css_dvs.h
new file mode 100644
index 0000000..ee6e6ad
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_dvs.h
@@ -0,0 +1,166 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DVS_H
+#define __IA_CSS_DVS_H
+
+#include <type_support.h>
+#include "ia_css_types.h"
+#include "ia_css_stream_public.h"
+
+/** Structure that holds DVS statistics in the ISP internal
+ * format. Use ia_css_get_dvs_statistics() to translate
+ * this to the format used on the host (DVS engine).
+ * */
+struct ia_css_isp_dvs_statistics {
+	ia_css_ptr hor_proj;
+	ia_css_ptr ver_proj;
+	uint32_t   hor_size;
+	uint32_t   ver_size;
+	uint32_t   exp_id;
+};
+#define SIZE_OF_IA_CSS_ISP_DVS_STATISTICS_STRUCT			\
+	((2 * SIZE_OF_IA_CSS_PTR) +					\
+	(3 * sizeof(uint32_t)))
+
+/** @brief Copy DVS statistics from an ISP buffer to a host buffer.
+ * @param[in]	host_stats Host buffer
+ * @param[in]	isp_stats ISP buffer
+ * @return		None
+ * This may include a translation step as well depending
+ * on the ISP version.
+ * Always use this function, never copy the buffer directly.
+ */
+void
+ia_css_get_dvs_statistics(struct ia_css_dvs_statistics           *host_stats,
+			  const struct ia_css_isp_dvs_statistics *isp_stats);
+
+/** @brief Copy DVS 2.0 statistics from an ISP buffer to a host buffer.
+ * @param[in]	host_stats Host buffer
+ * @param[in]	isp_stats ISP buffer
+ * @return		None
+ * This may include a translation step as well depending
+ * on the ISP version.
+ * Always use this function, never copy the buffer directly.
+ */
+void
+ia_css_get_dvs2_statistics(struct ia_css_dvs2_statistics           *host_stats,
+			  const struct ia_css_isp_dvs_statistics *isp_stats);
+
+/** @brief Allocate the DVS statistics memory on the ISP
+ * @param[in]	grid The grid.
+ * @return		Pointer to the allocated DVS statistics buffer on the ISP
+*/
+struct ia_css_isp_dvs_statistics *
+ia_css_isp_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
+
+/** @brief Free the DVS statistics memory on the ISP
+ * @param[in]	me Pointer to the DVS statistics buffer on the ISP.
+ * @return		None
+*/
+void
+ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me);
+
+/** @brief Allocate the DVS 2.0 statistics memory
+ * @param[in]	grid The grid.
+ * @return		Pointer to the allocated DVS statistics buffer on the ISP
+*/
+struct ia_css_isp_dvs_statistics *
+ia_css_isp_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
+
+/** @brief Free the DVS 2.0 statistics memory
+ * @param[in]	me Pointer to the DVS statistics buffer on the ISP.
+ * @return		None
+*/
+void
+ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me);
+
+/** @brief Allocate the DVS statistics memory on the host
+ * @param[in]	grid The grid.
+ * @return		Pointer to the allocated DVS statistics buffer on the host
+*/
+struct ia_css_dvs_statistics *
+ia_css_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
+
+/** @brief Free the DVS statistics memory on the host
+ * @param[in]	me Pointer to the DVS statistics buffer on the host.
+ * @return		None
+*/
+void
+ia_css_dvs_statistics_free(struct ia_css_dvs_statistics *me);
+
+/** @brief Allocate the DVS coefficients memory
+ * @param[in]	grid The grid.
+ * @return		Pointer to the allocated DVS coefficients buffer
+*/
+struct ia_css_dvs_coefficients *
+ia_css_dvs_coefficients_allocate(const struct ia_css_dvs_grid_info *grid);
+
+/** @brief Free the DVS coefficients memory
+ * @param[in]	me Pointer to the DVS coefficients buffer.
+ * @return		None
+ */
+void
+ia_css_dvs_coefficients_free(struct ia_css_dvs_coefficients *me);
+
+/** @brief Allocate the DVS 2.0 statistics memory on the host
+ * @param[in]	grid The grid.
+ * @return		Pointer to the allocated DVS 2.0 statistics buffer on the host
+ */
+struct ia_css_dvs2_statistics *
+ia_css_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid);
+
+/** @brief Free the DVS 2.0 statistics memory
+ * @param[in]	me Pointer to the DVS 2.0 statistics buffer on the host.
+ * @return		None
+*/
+void
+ia_css_dvs2_statistics_free(struct ia_css_dvs2_statistics *me);
+
+/** @brief Allocate the DVS 2.0 coefficients memory
+ * @param[in]	grid The grid.
+ * @return		Pointer to the allocated DVS 2.0 coefficients buffer
+*/
+struct ia_css_dvs2_coefficients *
+ia_css_dvs2_coefficients_allocate(const struct ia_css_dvs_grid_info *grid);
+
+/** @brief Free the DVS 2.0 coefficients memory
+ * @param[in]	me Pointer to the DVS 2.0 coefficients buffer.
+ * @return		None
+*/
+void
+ia_css_dvs2_coefficients_free(struct ia_css_dvs2_coefficients *me);
+
+/** @brief Allocate the DVS 2.0 6-axis config memory
+ * @param[in]	stream The stream.
+ * @return		Pointer to the allocated DVS 6axis configuration buffer
+*/
+struct ia_css_dvs_6axis_config *
+ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream);
+
+/** @brief Free the DVS 2.0 6-axis config memory
+ * @param[in]	dvs_6axis_config Pointer to the DVS 6axis configuration buffer
+ * @return		None
+ */
+void
+ia_css_dvs2_6axis_config_free(struct ia_css_dvs_6axis_config *dvs_6axis_config);
+
+#endif /* __IA_CSS_DVS_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_env.h b/drivers/media/atomisp2/css2400/ia_css_env.h
new file mode 100644
index 0000000..bc6e1ee
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_env.h
@@ -0,0 +1,137 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ENV_H
+#define __IA_CSS_ENV_H
+
+#include <type_support.h>
+#include <stdarg.h> /* va_list */
+#include "ia_css_types.h"
+#include "ia_css_acc_types.h"
+
+/** Memory allocation attributes, for use in ia_css_css_mem_env. */
+enum ia_css_mem_attr {
+	IA_CSS_MEM_ATTR_CACHED = 1 << 0,
+	IA_CSS_MEM_ATTR_ZEROED = 1 << 1,
+	IA_CSS_MEM_ATTR_PAGEALIGN = 1 << 2,
+	IA_CSS_MEM_ATTR_CONTIGUOUS = 1 << 3,
+};
+
+/** Environment with function pointers for local IA memory allocation.
+ *  This provides the CSS code with environment specific functionality
+ *  for memory allocation of small local buffers such as local data structures.
+ *  This is never expected to allocate more than one page of memory (4K bytes).
+ */
+struct ia_css_cpu_mem_env {
+	void *(*alloc)(size_t bytes, bool zero_mem);
+	/**< Allocation function with boolean argument to indicate whether
+	     the allocated memory should be zeroed out or not, true (or 1)
+	     meaning the memory given to CSS must be zeroed */
+	void (*free)(void *ptr);
+	/**< Corresponding free function. The function must also accept
+	     a NULL argument, similar to C89 free(). */
+	void (*flush) (struct ia_css_acc_fw *fw);
+	/**< Flush function to flush the cache for given accelerator. */
+};
+
+/** Environment with function pointers for allocation of memory for the CSS.
+ *  The CSS uses its own MMU which has its own set of page tables. These
+ *  functions are expected to use and/or update those page tables.
+ *  This type of memory allocation is expected to be used for large buffers
+ *  for images and statistics.
+ *  ISP pointers are always 32 bits whereas IA pointer widths will depend
+ *  on the platform.
+ *  Attributes can be a combination (OR'ed) of ia_css_mem_attr values.
+ */
+struct ia_css_css_mem_env {
+	ia_css_ptr (*alloc)(size_t bytes, uint32_t attributes);
+	/**< Allocate memory, cached or uncached, zeroed out or not. */
+	void     (*free)(ia_css_ptr ptr);
+	/**< Free ISP shared memory. The function must also accept
+	     a NULL argument, similar to C89 free(). */
+	int      (*load)(ia_css_ptr ptr, void *data, size_t bytes);
+	/**< Load from ISP shared memory. This function is necessary because
+	     the IA MMU does not share page tables with the ISP MMU. This means
+	     that the IA needs to do the virtual-to-physical address
+	     translation in software. This function performs this translation.*/
+	int      (*store)(ia_css_ptr ptr, const void *data, size_t bytes);
+	/**< Same as the above load function but then to write data into ISP
+	     shared memory. */
+	int      (*set)(ia_css_ptr ptr, int c, size_t bytes);
+	/**< Set an ISP shared memory region to a particular value. Each byte
+	     in this region will be set to this value. In most cases this is
+	     used to zero-out memory sections in which case the argument c
+	     would have the value zero. */
+	ia_css_ptr (*mmap)(const void *ptr, const size_t size,
+			   uint16_t attribute, void *context);
+	/**< Map an pre-allocated memory region to an address. */
+};
+
+/** Environment with function pointers to access the CSS hardware. This includes
+ *  registers and local memories.
+ */
+struct ia_css_hw_access_env {
+	void     (*store_8)(hrt_address addr, uint8_t data);
+	/**< Store an 8 bit value into an address in the CSS HW address space.
+	     The address must be an 8 bit aligned address. */
+	void     (*store_16)(hrt_address addr, uint16_t data);
+	/**< Store a 16 bit value into an address in the CSS HW address space.
+	     The address must be a 16 bit aligned address. */
+	void     (*store_32)(hrt_address addr, uint32_t data);
+	/**< Store a 32 bit value into an address in the CSS HW address space.
+	     The address must be a 32 bit aligned address. */
+	uint8_t (*load_8)(hrt_address addr);
+	/**< Load an 8 bit value from an address in the CSS HW address
+	     space. The address must be an 8 bit aligned address. */
+	uint16_t (*load_16)(hrt_address addr);
+	/**< Load a 16 bit value from an address in the CSS HW address
+	     space. The address must be a 16 bit aligned address. */
+	uint32_t (*load_32)(hrt_address addr);
+	/**< Load a 32 bit value from an address in the CSS HW address
+	     space. The address must be a 32 bit aligned address. */
+	void     (*store)(hrt_address addr, const void *data, uint32_t bytes);
+	/**< Store a number of bytes into a byte-aligned address in the CSS HW address space. */
+	void     (*load)(hrt_address addr, void *data, uint32_t bytes);
+	/**< Load a number of bytes from a byte-aligned address in the CSS HW address space. */
+};
+
+/** Environment with function pointers to print error and debug messages.
+ */
+struct ia_css_print_env {
+	int (*debug_print)(const char *fmt, va_list args);
+	/**< Print a debug message. */
+	int (*error_print)(const char *fmt, va_list args);
+	/**< Print an error message.*/
+};
+
+/** Environment structure. This includes function pointers to access several
+ *  features provided by the environment in which the CSS API is used.
+ *  This is used to run the camera IP in multiple platforms such as Linux,
+ *  Windows and several simulation environments.
+ */
+struct ia_css_env {
+	struct ia_css_cpu_mem_env   cpu_mem_env;   /**< local malloc and free. */
+	struct ia_css_css_mem_env   css_mem_env;   /**< CSS/ISP buffer alloc/free */
+	struct ia_css_hw_access_env hw_access_env; /**< CSS HW access functions */
+	struct ia_css_print_env     print_env;     /**< Message printing env. */
+};
+
+#endif /* __IA_CSS_ENV_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_err.h b/drivers/media/atomisp2/css2400/ia_css_err.h
new file mode 100644
index 0000000..49e1b0f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_err.h
@@ -0,0 +1,45 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ERR_H
+#define __IA_CSS_ERR_H
+
+/** Errors, these values are used as the return value for most
+ *  functions in this API.
+ */
+enum ia_css_err {
+	IA_CSS_SUCCESS,
+	IA_CSS_ERR_INTERNAL_ERROR,
+	IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY,
+	IA_CSS_ERR_INVALID_ARGUMENTS,
+	IA_CSS_ERR_SYSTEM_NOT_IDLE,
+	IA_CSS_ERR_MODE_HAS_NO_VIEWFINDER,
+	IA_CSS_ERR_QUEUE_IS_FULL,
+	IA_CSS_ERR_QUEUE_IS_EMPTY,
+	IA_CSS_ERR_RESOURCE_NOT_AVAILABLE,
+	IA_CSS_ERR_RESOURCE_LIST_TO_SMALL,
+	IA_CSS_ERR_RESOURCE_ITEMS_STILL_ALLOCATED,
+	IA_CSS_ERR_RESOURCE_EXHAUSTED,
+	IA_CSS_ERR_RESOURCE_ALREADY_ALLOCATED,
+	IA_CSS_ERR_VERSION_MISMATCH
+};
+
+#endif /* __IA_CSS_ERR_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_event_public.h b/drivers/media/atomisp2/css2400/ia_css_event_public.h
new file mode 100644
index 0000000..e7ce583
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_event_public.h
@@ -0,0 +1,94 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_EVENT_PUBLIC_H
+#define __IA_CSS_EVENT_PUBLIC_H
+
+#include <type_support.h>
+
+struct ia_css_pipe;
+
+/** The event type, distinguishes the kind of events that
+ * can are generated by the CSS system.
+ */
+/**
+ * !IMPORTANT! KEEP THE FOLLOWING 3 ENUMS IN SYNC:
+ * 1) "enum ia_css_event_type event_id_2_event_mask" (file event.sp.c)
+ * 2) "enum ia_css_event_type convert_event_sp_to_host_domain" (file sh_css.c)
+ * 3) "enum sh_css_sp_event_type" (file sh_css_internal.h)
+ */
+enum ia_css_event_type {
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE	= 1 << 0, /**< Output frame ready. */
+	IA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE	= 1 << 1, /**< Second output frame ready. */
+	IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE	= 1 << 2, /**< Viewfinder Output frame ready. */
+	IA_CSS_EVENT_TYPE_SECOND_VF_OUTPUT_FRAME_DONE	= 1 << 3, /**< Second viewfinder Output frame ready. */
+	IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE	= 1 << 4, /**< Indication that 3A statistics are available. */
+	IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE	= 1 << 5, /**< Indication that DIS statistics are available. */
+	IA_CSS_EVENT_TYPE_PIPELINE_DONE		= 1 << 6, /**< Pipeline Done event, sent after last pipeline stage. */
+	IA_CSS_EVENT_TYPE_FRAME_TAGGED		= 1 << 7, /**< Frame tagged. */
+	IA_CSS_EVENT_TYPE_INPUT_FRAME_DONE	= 1 << 8, /**< Input frame ready. */
+	IA_CSS_EVENT_TYPE_METADATA_DONE		= 1 << 9, /**< Metadata ready. */
+	IA_CSS_EVENT_TYPE_LACE_STATISTICS_DONE	= 1 << 10, /**< Indication that LACE statistics are available. */
+	/* NOTE: Add new enums before IA_CSS_EVENT_TYPE_PORT_EOF MUST, see comment below */
+	IA_CSS_EVENT_TYPE_PORT_EOF		= 1 << 11, /**< End Of Frame event, sent when in buffered sensor mode. This enum MUST be last */
+};
+
+#define IA_CSS_EVENT_TYPE_NONE 0
+/* IA_CSS_EVENT_TYPE_ALL is a mask for alle events _EXCEPT_ IA_CSS_EVENT_TYPE_PORT_EOF
+ * For this reason IA_CSS_EVENT_TYPE_PORT_EOF must be last in the enum above.
+ * we create it by sbutracting 1 from IA_CSS_EVENT_TYPE_PORT_EOF
+ * alternate implementation could be or-ing of all the events.
+ * (IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE | IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE | ... | IA_CSS_EVENT_TYPE_INPUT_FRAME_DONE)
+ */
+#define IA_CSS_EVENT_TYPE_ALL  (IA_CSS_EVENT_TYPE_PORT_EOF - 1)
+
+/** The event struct, container for the event type and its related values.
+ * Depending on the event type, either pipe or port will be filled.
+ * Pipeline related events (like buffer/frame events) will return a valid and filled pipe handle.
+ * For non pipeline related events (but i.e. stream specific, like EOF event), the port will be
+ * filled.
+ */
+struct ia_css_event {
+	struct ia_css_pipe    *pipe;   /**< Pipe handle on which event happened, NULL for non pipe related events. */
+	enum ia_css_event_type type;   /**< Type of Event, always valid/filled. */
+	uint8_t                port;   /**< Port number for EOF event (not valid for other events). */
+	uint8_t                exp_id; /**< Exposure id for EOF/TAGGED_FRAME event (not valid for other events). */
+};
+
+/** @brief Dequeue an event from the CSS system. An event consists of pipe
+ * and event_id.
+ *
+ * @param[out]	event   Pointer to the event struct which will be filled by
+ *                      this function if an event is available.
+ * @return		IA_CSS_ERR_QUEUE_IS_EMPTY if no events are
+ *			available or
+ *			IA_CSS_SUCCESS otherwise.
+ *
+ * This function dequeues an event from an event queue. The queue is inbetween
+ * the Host (i.e. the Atom processor) and the CSS system. This function can be
+ * called after an interrupt has been generated that signalled that a new event
+ * was available and can be used in a polling-like situation where the NO_EVENT
+ * return value is used to determine whether an event was available or not.
+ */
+enum ia_css_err
+ia_css_dequeue_event(struct ia_css_event *event);
+
+#endif /* __IA_CSS_EVENT_PUBLIC_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_firmware.h b/drivers/media/atomisp2/css2400/ia_css_firmware.h
new file mode 100644
index 0000000..39dfb07
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_firmware.h
@@ -0,0 +1,67 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FIRMWARE_H
+#define __IA_CSS_FIRMWARE_H
+
+#include "ia_css_err.h"
+#include "ia_css_env.h"
+
+/** CSS firmware package structure.
+ */
+struct ia_css_fw {
+	void	    *data;  /**< pointer to the firmware data */
+	unsigned int bytes; /**< length in bytes of firmware data */
+};
+
+/** @brief Loads the firmware
+ * @param[in]	env		Environment, provides functions to access the
+ *				environment in which the CSS code runs. This is
+ *				used for host side memory access and message
+ *				printing.
+ * @param[in]	fw		Firmware package containing the firmware for all
+ *				predefined ISP binaries.
+ * @return			Returns IA_CSS_ERR_INTERNAL_ERROR in case of any
+ *				errors and IA_CSS_SUCCESS otherwise.
+ *
+ * This function interprets the firmware package. All
+ * contents of this firmware package are copied into local data structures, so
+ * the fw pointer could be freed after this function completes.
+ *
+ * Rationale for this function is that it can be called before ia_css_init, and thus
+ * speeds up ia_css_init (ia_css_init is called each time a stream is created but the
+ * firmware only needs to be loaded once).
+ */
+enum ia_css_err
+ia_css_load_firmware(const struct ia_css_env *env,
+	    const struct ia_css_fw  *fw);
+
+/** @brief Unloads the firmware
+ * @return	None
+ *
+ * This function unloads the firmware loaded by ia_css_load_firmware.
+ * It is pointless to call this function if no firmware is loaded,
+ * but it won't harm. Use this to deallocate all memory associated with the firmware.
+ */
+void
+ia_css_unload_firmware(bool forced);
+
+#endif /* __IA_CSS_FIRMWARE_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_frac.h b/drivers/media/atomisp2/css2400/ia_css_frac.h
new file mode 100644
index 0000000..c087a77
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_frac.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_FRAC_H_
+#define _IA_CSS_FRAC_H_
+
+#include <type_support.h>
+
+/* Fixed point types.
+ * NOTE: the 16 bit fixed point types actually occupy 32 bits
+ * to save on extension operations in the ISP code.
+ */
+/** Unsigned fixed point value, 0 integer bits, 16 fractional bits */
+typedef uint32_t ia_css_u0_16;
+/** Unsigned fixed point value, 5 integer bits, 11 fractional bits */
+typedef uint32_t ia_css_u5_11;
+/** Unsigned fixed point value, 8 integer bits, 8 fractional bits */
+typedef uint32_t ia_css_u8_8;
+/** Signed fixed point value, 0 integer bits, 15 fractional bits */
+typedef int32_t ia_css_s0_15;
+
+#endif /* _IA_CSS_FRAC_H_ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_frame_format.h b/drivers/media/atomisp2/css2400/ia_css_frame_format.h
new file mode 100644
index 0000000..88e0288
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_frame_format.h
@@ -0,0 +1,79 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FRAME_FORMAT_H
+#define __IA_CSS_FRAME_FORMAT_H
+
+/** Frame formats, some of these come from fourcc.org, others are
+   better explained by video4linux2. The NV11 seems to be described only
+   on MSDN pages, but even those seem to be gone now.
+   Frames can come in many forms, the main categories are RAW, RGB and YUV
+   (or YCbCr). The YUV frames come in 4 flavors, determined by how the U and V
+   values are subsampled:
+   1. YUV420: hor = 2, ver = 2
+   2. YUV411: hor = 4, ver = 1
+   3. YUV422: hor = 2, ver = 1
+   4. YUV444: hor = 1, ver = 1
+ */
+enum ia_css_frame_format {
+	IA_CSS_FRAME_FORMAT_NV11=0,     /**< 12 bit YUV 411, Y, UV plane */
+	IA_CSS_FRAME_FORMAT_NV12,       /**< 12 bit YUV 420, Y, UV plane */
+	IA_CSS_FRAME_FORMAT_NV16,       /**< 16 bit YUV 422, Y, UV plane */
+	IA_CSS_FRAME_FORMAT_NV21,       /**< 12 bit YUV 420, Y, VU plane */
+	IA_CSS_FRAME_FORMAT_NV61,       /**< 16 bit YUV 422, Y, VU plane */
+	IA_CSS_FRAME_FORMAT_YV12,       /**< 12 bit YUV 420, Y, V, U plane */
+	IA_CSS_FRAME_FORMAT_YV16,       /**< 16 bit YUV 422, Y, V, U plane */
+	IA_CSS_FRAME_FORMAT_YUV420,     /**< 12 bit YUV 420, Y, U, V plane */
+	IA_CSS_FRAME_FORMAT_YUV420_16,  /**< yuv420, 16 bits per subpixel */
+	IA_CSS_FRAME_FORMAT_YUV422,     /**< 16 bit YUV 422, Y, U, V plane */
+	IA_CSS_FRAME_FORMAT_YUV422_16,  /**< yuv422, 16 bits per subpixel */
+	IA_CSS_FRAME_FORMAT_UYVY,       /**< 16 bit YUV 422, UYVY interleaved */
+	IA_CSS_FRAME_FORMAT_YUYV,       /**< 16 bit YUV 422, YUYV interleaved */
+	IA_CSS_FRAME_FORMAT_YUV444,     /**< 24 bit YUV 444, Y, U, V plane */
+	IA_CSS_FRAME_FORMAT_YUV_LINE,   /**< Internal format, 2 y lines followed
+					     by a uvinterleaved line */
+	IA_CSS_FRAME_FORMAT_RAW,	/**< RAW, 1 plane */
+	IA_CSS_FRAME_FORMAT_RGB565,     /**< 16 bit RGB, 1 plane. Each 3 sub
+					     pixels are packed into one 16 bit
+					     value, 5 bits for R, 6 bits for G
+					     and 5 bits for B. */
+	IA_CSS_FRAME_FORMAT_PLANAR_RGB888, /**< 24 bit RGB, 3 planes */
+	IA_CSS_FRAME_FORMAT_RGBA888,	/**< 32 bit RGBA, 1 plane, A=Alpha
+					     (alpha is unused) */
+	IA_CSS_FRAME_FORMAT_QPLANE6, /**< Internal, for advanced ISP */
+	IA_CSS_FRAME_FORMAT_BINARY_8,	/**< byte stream, used for jpeg. For
+					     frames of this type, we set the
+					     height to 1 and the width to the
+					     number of allocated bytes. */
+	IA_CSS_FRAME_FORMAT_MIPI,	/**< MIPI frame, 1 plane */
+	IA_CSS_FRAME_FORMAT_RAW_PACKED, /**< RAW, 1 plane, packed */
+	IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8,	      /**< 8 bit per Y/U/V.
+							   Y odd line; UYVY
+							   interleaved even line */
+	IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8, /**< Legacy YUV420. UY odd
+							   line; VY even line */
+	IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_10,       /**< 10 bit per Y/U/V. Y odd
+							   line; UYVY interleaved
+							   even line */
+};
+#define IA_CSS_FRAME_FORMAT_NUM (IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_10 + 1)
+
+#endif /* __IA_CSS_FRAME_FORMAT_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_frame_public.h b/drivers/media/atomisp2/css2400/ia_css_frame_public.h
new file mode 100644
index 0000000..1712bee
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_frame_public.h
@@ -0,0 +1,354 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FRAME_PUBLIC_H
+#define __IA_CSS_FRAME_PUBLIC_H
+
+#include <type_support.h>
+#include "ia_css_err.h"
+#include "ia_css_types.h"
+#include "ia_css_frame_format.h"
+#include "runtime/bufq/interface/ia_css_bufq.h"
+
+/** For RAW input, the bayer order needs to be specified separately. There
+ *  are 4 possible orders. The name is constructed by taking the first two
+ *  colors on the first line and the first two colors from the second line.
+ */
+enum ia_css_bayer_order {
+	IA_CSS_BAYER_ORDER_GRBG, /**< GRGRGRGRGR .. BGBGBGBGBG */
+	IA_CSS_BAYER_ORDER_RGGB, /**< RGRGRGRGRG .. GBGBGBGBGB */
+	IA_CSS_BAYER_ORDER_BGGR, /**< BGBGBGBGBG .. GRGRGRGRGR */
+	IA_CSS_BAYER_ORDER_GBRG, /**< GBGBGBGBGB .. RGRGRGRGRG */
+};
+#define IA_CSS_BAYER_ORDER_NUM (IA_CSS_BAYER_ORDER_GBRG + 1)
+
+/** Frame plane structure. This describes one plane in an image
+ *  frame buffer.
+ */
+struct ia_css_frame_plane {
+	unsigned int height; /**< height of a plane in lines */
+	unsigned int width;  /**< width of a line, in DMA elements, note that
+				  for RGB565 the three subpixels are stored in
+				  one element. For all other formats this is
+				  the number of subpixels per line. */
+	unsigned int stride; /**< stride of a line in bytes */
+	unsigned int offset; /**< offset in bytes to start of frame data.
+				  offset is wrt data field in ia_css_frame */
+};
+
+/** Binary "plane". This is used to story binary streams such as jpeg
+ *  images. This is not actually a real plane.
+ */
+struct ia_css_frame_binary_plane {
+	unsigned int		  size; /**< number of bytes in the stream */
+	struct ia_css_frame_plane data; /**< plane */
+};
+
+/** Container for planar YUV frames. This contains 3 planes.
+ */
+struct ia_css_frame_yuv_planes {
+	struct ia_css_frame_plane y; /**< Y plane */
+	struct ia_css_frame_plane u; /**< U plane */
+	struct ia_css_frame_plane v; /**< V plane */
+};
+
+/** Container for semi-planar YUV frames.
+  */
+struct ia_css_frame_nv_planes {
+	struct ia_css_frame_plane y;  /**< Y plane */
+	struct ia_css_frame_plane uv; /**< UV plane */
+};
+
+/** Container for planar RGB frames. Each color has its own plane.
+ */
+struct ia_css_frame_rgb_planes {
+	struct ia_css_frame_plane r; /**< Red plane */
+	struct ia_css_frame_plane g; /**< Green plane */
+	struct ia_css_frame_plane b; /**< Blue plane */
+};
+
+/** Container for 6-plane frames. These frames are used internally
+ *  in the advanced ISP only.
+ */
+struct ia_css_frame_plane6_planes {
+	struct ia_css_frame_plane r;	  /**< Red plane */
+	struct ia_css_frame_plane r_at_b; /**< Red at blue plane */
+	struct ia_css_frame_plane gr;	  /**< Red-green plane */
+	struct ia_css_frame_plane gb;	  /**< Blue-green plane */
+	struct ia_css_frame_plane b;	  /**< Blue plane */
+	struct ia_css_frame_plane b_at_r; /**< Blue at red plane */
+};
+
+/** Frame info struct. This describes the contents of an image frame buffer.
+  */
+struct ia_css_frame_info {
+	struct ia_css_resolution res; /**< Frame resolution (valid data) */
+	unsigned int padded_width; /**< stride of line in memory (in pixels) */
+	enum ia_css_frame_format format; /**< format of the frame data */
+	unsigned int raw_bit_depth; /**< number of valid bits per pixel,
+					 only valid for RAW bayer frames */
+	enum ia_css_bayer_order raw_bayer_order; /**< bayer order, only valid
+						      for RAW bayer frames */
+};
+
+#define IA_CSS_BINARY_DEFAULT_FRAME_INFO \
+{ \
+	{0,                      /* width */ \
+	 0},                     /* height */ \
+	0,                       /* padded_width */ \
+	IA_CSS_FRAME_FORMAT_NUM, /* format */ \
+	0,                       /* raw_bit_depth */ \
+	IA_CSS_BAYER_ORDER_NUM   /* raw_bayer_order */ \
+}
+
+/**
+ *  Specifies the DVS loop delay in "frame periods"
+ */
+enum ia_css_frame_delay {
+	IA_CSS_FRAME_DELAY_0, /**< Frame delay = 0 */
+	IA_CSS_FRAME_DELAY_1, /**< Frame delay = 1 */
+	IA_CSS_FRAME_DELAY_2  /**< Frame delay = 2 */
+};
+
+enum ia_css_frame_flash_state {
+	IA_CSS_FRAME_FLASH_STATE_NONE,
+	IA_CSS_FRAME_FLASH_STATE_PARTIAL,
+	IA_CSS_FRAME_FLASH_STATE_FULL
+};
+
+/** Frame structure. This structure describes an image buffer or frame.
+ *  This is the main structure used for all input and output images.
+ */
+struct ia_css_frame {
+	struct ia_css_frame_info info; /**< info struct describing the frame */
+	ia_css_ptr   data;	       /**< pointer to start of image data */
+	unsigned int data_bytes;       /**< size of image data in bytes */
+	/* LA: move this to ia_css_buffer */
+	/*
+	 * -1 if data address is static during life time of pipeline
+	 * >=0 if data address can change per pipeline/frame iteration
+	 *     index to dynamic data: ia_css_frame_in, ia_css_frame_out
+	 *                            ia_css_frame_out_vf
+	 *     index to host-sp queue id: queue_0, queue_1 etc.
+	 */
+	int dynamic_data_index;
+	/*
+	 * if it is dynamic frame, buf_type indicates which buffer type it
+	 * should use for event generation. we have this because in vf_pp
+	 * binary, we use output port, but we expect VF_OUTPUT_DONE event
+	 */
+	enum ia_css_buffer_type buf_type;
+	enum ia_css_frame_flash_state flash_state;
+	unsigned int exp_id; /**< exposure id, only valid for continuous
+				capture cases */
+	unsigned int frame_nr;  /* frame number for detecting interlacing stream */
+	uint32_t isp_config_id; /**< Unique ID to track which config was actually applied to a particular frame */
+	bool valid; /**< First video output frame is not valid */
+	bool contiguous; /**< memory is allocated physically contiguously */
+	union {
+		unsigned int	_initialisation_dummy;
+		struct ia_css_frame_plane raw;
+		struct ia_css_frame_plane rgb;
+		struct ia_css_frame_rgb_planes planar_rgb;
+		struct ia_css_frame_plane yuyv;
+		struct ia_css_frame_yuv_planes yuv;
+		struct ia_css_frame_nv_planes nv;
+		struct ia_css_frame_plane6_planes plane6;
+		struct ia_css_frame_binary_plane binary;
+	} planes; /**< frame planes, select the right one based on
+		       info.format */
+};
+
+#define DEFAULT_FRAME \
+{ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* info */ \
+	0,					/* data */ \
+	0,					/* data_bytes */ \
+	SH_CSS_INVALID_QUEUE_ID,		/* dynamic_data_index */ \
+	IA_CSS_BUFFER_TYPE_INVALID,			/* buf_type */ \
+	IA_CSS_FRAME_FLASH_STATE_NONE,		/* flash_state */ \
+	0,					/* exp_id */ \
+	0,                             /* frame_nr */ \
+	0,					/* isp_config_id */ \
+	false,					/* valid */ \
+	false,					/* contiguous  */ \
+	{ 0 }					/* planes */ \
+}
+
+/** @brief Fill a frame with zeros
+ *
+ * @param	frame		The frame.
+ * @return	None
+ *
+ * Fill a frame with pixel values of zero
+ */
+void ia_css_frame_zero(struct ia_css_frame *frame);
+
+/** @brief Allocate a CSS frame structure
+ *
+ * @param	frame		The allocated frame.
+ * @param	width		The width (in pixels) of the frame.
+ * @param	height		The height (in lines) of the frame.
+ * @param	format		The frame format.
+ * @param	stride		The padded stride, in pixels.
+ * @param	raw_bit_depth	The raw bit depth, in bits.
+ * @return			The error code.
+ *
+ * Allocate a CSS frame structure. The memory for the frame data will be
+ * allocated in the CSS address space.
+ */
+enum ia_css_err
+ia_css_frame_allocate(struct ia_css_frame **frame,
+		      unsigned int width,
+		      unsigned int height,
+		      enum ia_css_frame_format format,
+		      unsigned int stride,
+		      unsigned int raw_bit_depth);
+
+/** @brief Allocate a CSS frame structure using a frame info structure.
+ *
+ * @param	frame	The allocated frame.
+ * @param[in]	info	The frame info structure.
+ * @return		The error code.
+ *
+ * Allocate a frame using the resolution and format from a frame info struct.
+ * This is a convenience function, implemented on top of
+ * ia_css_frame_allocate().
+ */
+enum ia_css_err
+ia_css_frame_allocate_from_info(struct ia_css_frame **frame,
+				const struct ia_css_frame_info *info);
+/** @brief Free a CSS frame structure.
+ *
+ * @param[in]	frame	Pointer to the frame.
+ * @return	None
+ *
+ * Free a CSS frame structure. This will free both the frame structure
+ * and the pixel data pointer contained within the frame structure.
+ */
+void
+ia_css_frame_free(struct ia_css_frame *frame);
+
+/** @brief Allocate a contiguous CSS frame structure
+ *
+ * @param	frame		The allocated frame.
+ * @param	width		The width (in pixels) of the frame.
+ * @param	height		The height (in lines) of the frame.
+ * @param	format		The frame format.
+ * @param	stride		The padded stride, in pixels.
+ * @param	raw_bit_depth	The raw bit depth, in bits.
+ * @return			The error code.
+ *
+ * Contiguous frame allocation, only for FPGA display driver which needs
+ * physically contiguous memory.
+ * Deprecated.
+ */
+enum ia_css_err
+ia_css_frame_allocate_contiguous(struct ia_css_frame **frame,
+				 unsigned int width,
+				 unsigned int height,
+				 enum ia_css_frame_format format,
+				 unsigned int stride,
+				 unsigned int raw_bit_depth);
+
+/** @brief Allocate a contiguous CSS frame from a frame info structure.
+ *
+ * @param	frame	The allocated frame.
+ * @param[in]	info	The frame info structure.
+ * @return		The error code.
+ *
+ * Allocate a frame using the resolution and format from a frame info struct.
+ * This is a convenience function, implemented on top of
+ * ia_css_frame_allocate_contiguous().
+ * Only for FPGA display driver which needs physically contiguous memory.
+ * Deprecated.
+ */
+enum ia_css_err
+ia_css_frame_allocate_contiguous_from_info(struct ia_css_frame **frame,
+					  const struct ia_css_frame_info *info);
+
+/** @brief Allocate a CSS frame structure using a frame info structure.
+ *
+ * @param	frame	The allocated frame.
+ * @param[in]	info	The frame info structure.
+ * @return		The error code.
+ *
+ * Allocate an empty CSS frame with no data buffer using the parameters
+ * in the frame info.
+ */
+enum ia_css_err
+ia_css_frame_create_from_info(struct ia_css_frame **frame,
+	const struct ia_css_frame_info *info);
+
+/** @brief Set a mapped data buffer to a CSS frame
+ *
+ * @param[in]	frame       Valid CSS frame pointer
+ * @param[in]	mapped_data  Mapped data buffer to be assigned to the CSS frame
+ * @param[in]	data_size_bytes  Size of the mapped_data in bytes
+ * @return      The error code.
+ *
+ * Sets a mapped data buffer to this frame. This function can be called multiple
+ * times with different buffers or NULL to reset the data pointer. This API
+ * would not try free the mapped_data and its the callers responsiblity to
+ * free the mapped_data buffer. However if ia_css_frame_free() is called and
+ * the frame had a valid data buffer, it would be freed along with the frame.
+ */
+enum ia_css_err
+ia_css_frame_set_data(struct ia_css_frame *frame,
+	const ia_css_ptr   mapped_data,
+	size_t data_size_bytes);
+
+/** @brief Map an existing frame data pointer to a CSS frame.
+ *
+ * @param	frame		Pointer to the frame to be initialized
+ * @param[in]	info		The frame info.
+ * @param[in]	data		Pointer to the allocated frame data.
+ * @param[in]	attribute	Attributes to be passed to mmgr_mmap.
+ * @param[in]	context		Pointer to the a context to be passed to mmgr_mmap.
+ * @return			The allocated frame structure.
+ *
+ * This function maps a pre-allocated pointer into a CSS frame. This can be
+ * used when an upper software layer is responsible for allocating the frame
+ * data and it wants to share that frame pointer with the CSS code.
+ * This function will fill the CSS frame structure just like
+ * ia_css_frame_allocate() does, but instead of allocating the memory, it will
+ * map the pre-allocated memory into the CSS address space.
+ */
+enum ia_css_err
+ia_css_frame_map(struct ia_css_frame **frame,
+		 const struct ia_css_frame_info *info,
+		 const void *data,
+		 uint16_t attribute,
+		 void *context);
+
+/** @brief Unmap a CSS frame structure.
+ *
+ * @param[in]	frame	Pointer to the CSS frame.
+ * @return	None
+ *
+ * This function unmaps the frame data pointer within a CSS frame and
+ * then frees the CSS frame structure. Use this for frame pointers created
+ * using ia_css_frame_map().
+ */
+void
+ia_css_frame_unmap(struct ia_css_frame *frame);
+
+#endif /* __IA_CSS_FRAME_PUBLIC_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_input_port.h b/drivers/media/atomisp2/css2400/ia_css_input_port.h
new file mode 100644
index 0000000..262ba19
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_input_port.h
@@ -0,0 +1,69 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_INPUT_PORT_H
+#define __IA_CSS_INPUT_PORT_H
+
+/** Enumeration of the physical input ports on the CSS hardware.
+ *  There are 3 MIPI CSI-2 ports.
+ */
+enum ia_css_csi2_port {
+	IA_CSS_CSI2_PORT0, /* Implicitly map to MIPI_PORT0_ID */
+	IA_CSS_CSI2_PORT1, /* Implicitly map to MIPI_PORT1_ID */
+	IA_CSS_CSI2_PORT2  /* Implicitly map to MIPI_PORT2_ID */
+};
+
+/** Backward compatible for CSS API 2.0 only
+ *  TO BE REMOVED when all drivers move to CSS	API 2.1
+ */
+#define	IA_CSS_CSI2_PORT_4LANE IA_CSS_CSI2_PORT0
+#define	IA_CSS_CSI2_PORT_1LANE IA_CSS_CSI2_PORT1
+#define	IA_CSS_CSI2_PORT_2LANE IA_CSS_CSI2_PORT2
+
+/** The CSI2 interface supports 2 types of compression or can
+ *  be run without compression.
+ */
+enum ia_css_csi2_compression_type {
+	IA_CSS_CSI2_COMPRESSION_TYPE_NONE, /**< No compression */
+	IA_CSS_CSI2_COMPRESSION_TYPE_1,    /**< Compression scheme 1 */
+	IA_CSS_CSI2_COMPRESSION_TYPE_2     /**< Compression scheme 2 */
+};
+
+struct ia_css_csi2_compression {
+	enum ia_css_csi2_compression_type type;
+	/**< Compression used */
+	unsigned int                      compressed_bits_per_pixel;
+	/**< Compressed bits per pixel (only when compression is enabled) */
+	unsigned int                      uncompressed_bits_per_pixel;
+	/**< Uncompressed bits per pixel (only when compression is enabled) */
+};
+
+/** Input port structure.
+ */
+struct ia_css_input_port {
+	enum ia_css_csi2_port port; /**< Physical CSI-2 port */
+	unsigned int num_lanes; /**< Number of lanes used (4-lane port only) */
+	unsigned int timeout;   /**< Timeout value */
+	unsigned int rxcount;   /**< Register value, should include all lanes */
+	struct ia_css_csi2_compression compression; /**< Compression used */
+};
+
+#endif /* __IA_CSS_INPUT_PORT_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_irq.h b/drivers/media/atomisp2/css2400/ia_css_irq.h
new file mode 100644
index 0000000..9252af8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_irq.h
@@ -0,0 +1,195 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_IRQ_H
+#define __IA_CSS_IRQ_H
+
+#include "ia_css_err.h"
+#include "ia_css_pipe_public.h"
+
+/** Interrupt types, these enumerate all supported interrupt types.
+ */
+enum ia_css_irq_type {
+	IA_CSS_IRQ_TYPE_EDGE,  /**< Edge (level) sensitive interrupt */
+	IA_CSS_IRQ_TYPE_PULSE  /**< Pulse-shaped interrupt */
+};
+
+/** Interrupt request type.
+ *  When the CSS hardware generates an interrupt, a function in this API
+ *  needs to be called to retrieve information about the interrupt.
+ *  This interrupt type is part of this information and indicates what
+ *  type of information the interrupt signals.
+ *
+ *  Note that one interrupt can carry multiple interrupt types. For
+ *  example: the online video ISP will generate only 2 interrupts, one to
+ *  signal that the statistics (3a and DIS) are ready and one to signal
+ *  that all output frames are done (output and viewfinder).
+ *
+ * DEPRECATED, this interface is not portable it should only define user
+ * (SW) interrupts
+ */
+enum ia_css_irq_info {
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR            = 1 << 0,
+	/**< the css receiver has encountered an error */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW    = 1 << 1,
+	/**< the FIFO in the csi receiver has overflown */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF              = 1 << 2,
+	/**< the css receiver received the start of frame */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF              = 1 << 3,
+	/**< the css receiver received the end of frame */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_SOL              = 1 << 4,
+	/**< the css receiver received the start of line */
+	IA_CSS_IRQ_INFO_EVENTS_READY                  = 1 << 5,
+	/**< One or more events are available in the event queue */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_EOL              = 1 << 6,
+	/**< the css receiver received the end of line */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_SIDEBAND_CHANGED = 1 << 7,
+	/**< the css receiver received a change in side band signals */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0      = 1 << 8,
+	/**< generic short packets (0) */
+	IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1      = 1 << 9,
+	/**< generic short packets (1) */
+	IA_CSS_IRQ_INFO_IF_PRIM_ERROR                 = 1 << 10,
+	/**< the primary input formatter (A) has encountered an error */
+	IA_CSS_IRQ_INFO_IF_PRIM_B_ERROR               = 1 << 11,
+	/**< the primary input formatter (B) has encountered an error */
+	IA_CSS_IRQ_INFO_IF_SEC_ERROR                  = 1 << 12,
+	/**< the secondary input formatter has encountered an error */
+	IA_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR           = 1 << 13,
+	/**< the stream-to-memory device has encountered an error */
+	IA_CSS_IRQ_INFO_SW_0                          = 1 << 14,
+	/**< software interrupt 0 */
+	IA_CSS_IRQ_INFO_SW_1                          = 1 << 15,
+	/**< software interrupt 1 */
+	IA_CSS_IRQ_INFO_SW_2                          = 1 << 16,
+	/**< software interrupt 2 */
+	IA_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY   = 1 << 17,
+	/**< ISP binary statistics are ready */
+	IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR            = 1 << 18,
+	/**< the input system in in error */
+	IA_CSS_IRQ_INFO_IF_ERROR                      = 1 << 19,
+	/**< the input formatter in in error */
+	IA_CSS_IRQ_INFO_DMA_ERROR                     = 1 << 20,
+	/**< the dma in in error */
+};
+
+/** CSS receiver error types. Whenever the CSS receiver has encountered
+ *  an error, this enumeration is used to indicate which errors have occurred.
+ *
+ *  Note that multiple error flags can be enabled at once and that this is in
+ *  fact common (whenever an error occurs, it usually results in multiple
+ *  errors).
+ *
+ * DEPRECATED: This interface is not portable, different systems have
+ * different receiver types, or possibly none in case of tests systems.
+ */
+enum ia_css_rx_irq_info {
+	IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN   = 1U << 0, /**< buffer overrun */
+	IA_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE = 1U << 1, /**< entering sleep mode */
+	IA_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE  = 1U << 2, /**< exited sleep mode */
+	IA_CSS_RX_IRQ_INFO_ECC_CORRECTED    = 1U << 3, /**< ECC corrected */
+	IA_CSS_RX_IRQ_INFO_ERR_SOT          = 1U << 4,
+						/**< Start of transmission */
+	IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC     = 1U << 5, /**< SOT sync (??) */
+	IA_CSS_RX_IRQ_INFO_ERR_CONTROL      = 1U << 6, /**< Control (??) */
+	IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE   = 1U << 7, /**< Double ECC */
+	IA_CSS_RX_IRQ_INFO_ERR_CRC          = 1U << 8, /**< CRC error */
+	IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID   = 1U << 9, /**< Unknown ID */
+	IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC   = 1U << 10,/**< Frame sync error */
+	IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA   = 1U << 11,/**< Frame data error */
+	IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT = 1U << 12,/**< Timeout occurred */
+	IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC  = 1U << 13,/**< Unknown escape seq. */
+	IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC    = 1U << 14,/**< Line Sync error */
+	IA_CSS_RX_IRQ_INFO_INIT_TIMEOUT     = 1U << 15,
+};
+
+/** Interrupt info structure. This structure contains information about an
+ *  interrupt. This needs to be used after an interrupt is received on the IA
+ *  to perform the correct action.
+ */
+struct ia_css_irq {
+	enum ia_css_irq_info type; /**< Interrupt type. */
+	unsigned int sw_irq_0_val; /**< In case of SW interrupt 0, value. */
+	unsigned int sw_irq_1_val; /**< In case of SW interrupt 1, value. */
+	unsigned int sw_irq_2_val; /**< In case of SW interrupt 2, value. */
+	struct ia_css_pipe *pipe;
+	/**< The image pipe that generated the interrupt. */
+};
+
+/** @brief Obtain interrupt information.
+ *
+ * @param[out] info	Pointer to the interrupt info. The interrupt
+ *			information wil be written to this info.
+ * @return		If an error is encountered during the interrupt info
+ *			and no interrupt could be translated successfully, this
+ *			will return IA_CSS_INTERNAL_ERROR. Otherwise
+ *			IA_CSS_SUCCESS.
+ *
+ * This function is expected to be executed after an interrupt has been sent
+ * to the IA from the CSS. This function returns information about the interrupt
+ * which is needed by the IA code to properly handle the interrupt. This
+ * information includes the image pipe, buffer type etc.
+ */
+enum ia_css_err
+ia_css_irq_translate(unsigned int *info);
+
+/** @brief Get CSI receiver error info.
+ *
+ * @param[out] irq_bits	Pointer to the interrupt bits. The interrupt
+ *			bits will be written this info.
+ *			This will be the error bits that are enabled in the CSI
+ *			receiver error register.
+ * @return	None
+ *
+ * This function should be used whenever a CSI receiver error interrupt is
+ * generated. It provides the detailed information (bits) on the exact error
+ * that occurred.
+ */
+void
+ia_css_rx_get_irq_info(unsigned int *irq_bits);
+
+/** @brief Clear CSI receiver error info.
+ *
+ * @param[in] irq_bits	The bits that should be cleared from the CSI receiver
+ *			interrupt bits register.
+ * @return	None
+ *
+ * This function should be called after ia_css_rx_get_irq_info has been called
+ * and the error bits have been interpreted. It is advised to use the return
+ * value of that function as the argument to this function to make sure no new
+ * error bits get overwritten.
+ */
+void
+ia_css_rx_clear_irq_info(unsigned int irq_bits);
+
+/** @brief Enable or disable specific interrupts.
+ *
+ * @param[in] type	The interrupt type that will be enabled/disabled.
+ * @param[in] enable	enable or disable.
+ * @return		Returns IA_CSS_INTERNAL_ERROR if this interrupt
+ *			type cannot be enabled/disabled which is true for
+ *			CSS internal interrupts. Otherwise returns
+ *			IA_CSS_SUCCESS.
+ */
+enum ia_css_err
+ia_css_irq_enable(enum ia_css_irq_info type, bool enable);
+
+#endif /* __IA_CSS_IRQ_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_lace_stat.h b/drivers/media/atomisp2/css2400/ia_css_lace_stat.h
new file mode 100644
index 0000000..5bad282
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_lace_stat.h
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_LACE_STAT_H
+#define __IA_CSS_LACE_STAT_H
+
+#include <type_support.h>
+#include "ia_css_types.h"
+#if defined(IS_ISP_2500_SYSTEM)
+#include <components/acc_cluster/acc_lace_stat/lace_stat_public.h>
+#endif
+
+#if defined(IS_ISP_2500_SYSTEM)
+/** @brief Copy LACE statistics from an ACC buffer to a host
+ *         buffer.
+ * @param[in]	host_stats Host buffer.
+ * @param[in] 	isp_stats ISP buffer.
+ * @return		None
+ */
+void ia_css_get_lace_statistics(struct ia_css_lace_statistics *host_stats,
+				    const ia_css_ptr isp_stats);
+#endif
+
+/** @brief Allocate mem for the LACE statistics on the ISP
+ * @param[in]	none
+ * @return	Pointer to the allocated LACE statistics
+ *         buffer on the ISP
+*/
+ia_css_ptr ia_css_lace_statistics_allocate(void);
+
+/** @brief Free the ACC LACE statistics memory on the isp
+ * @param[in]	me Pointer to the LACE statistics buffer on the
+ *       ISP.
+ * @return		None
+*/
+void ia_css_lace_statistics_free(ia_css_ptr me);
+
+#endif /*  __IA_CSS_LACE_STAT_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_memory_access.c b/drivers/media/atomisp2/css2400/ia_css_memory_access.c
new file mode 100644
index 0000000..a1aa8bb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_memory_access.c
@@ -0,0 +1,103 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_memory_access.h"
+#include <type_support.h>
+#include <system_types.h>
+#include <assert_support.h>
+#include <memory_access.h>
+#include <ia_css_env.h>
+
+const hrt_vaddress mmgr_NULL = (hrt_vaddress)0;
+const hrt_vaddress mmgr_EXCEPTION = (hrt_vaddress)-1;
+
+static struct ia_css_css_mem_env my_env;
+
+void
+ia_css_memory_access_init(const struct ia_css_css_mem_env *env)
+{
+	assert(env != NULL);
+
+	my_env = *env;
+}
+
+hrt_vaddress
+mmgr_malloc(const size_t size)
+{
+	return mmgr_alloc_attr(size, 0);
+}
+
+hrt_vaddress mmgr_alloc_attr(const size_t size, const uint16_t attrs)
+{
+	uint32_t my_attrs = 0;
+	uint16_t masked_attrs = attrs & MMGR_ATTRIBUTE_MASK;
+	hrt_vaddress ptr;
+
+	if (masked_attrs & MMGR_ATTRIBUTE_CACHED)
+		my_attrs |= IA_CSS_MEM_ATTR_CACHED;
+	if (masked_attrs & MMGR_ATTRIBUTE_CLEARED)
+		my_attrs |= IA_CSS_MEM_ATTR_ZEROED;
+	if (masked_attrs & MMGR_ATTRIBUTE_CONTIGUOUS)
+		my_attrs |= IA_CSS_MEM_ATTR_CONTIGUOUS;
+	if (masked_attrs & MMGR_ATTRIBUTE_PAGEALIGN)
+		my_attrs |= IA_CSS_MEM_ATTR_PAGEALIGN;
+
+	ptr = my_env.alloc(size, my_attrs);
+	assert(ptr != 0);
+	return ptr;
+}
+
+hrt_vaddress
+mmgr_calloc(const size_t N, const size_t size)
+{
+	return mmgr_alloc_attr(size * N, MMGR_ATTRIBUTE_CLEARED);
+}
+
+void
+mmgr_free(hrt_vaddress vaddr)
+{
+	my_env.free(vaddr);
+}
+
+void
+mmgr_clear(hrt_vaddress vaddr, const size_t size)
+{
+	my_env.set(vaddr, 0, size);
+}
+
+void
+mmgr_load(const hrt_vaddress vaddr, void *data, const size_t size)
+{
+	my_env.load(vaddr, data, size);
+}
+
+void
+mmgr_store(const hrt_vaddress vaddr, const void *data, const size_t size)
+{
+	my_env.store(vaddr, data, size);
+}
+
+hrt_vaddress
+mmgr_mmap(const void *ptr, const size_t size,
+	  uint16_t attribute, void *context)
+{
+	return my_env.mmap(ptr, size, attribute, context);
+}
diff --git a/drivers/media/atomisp2/css2400/ia_css_memory_access.h b/drivers/media/atomisp2/css2400/ia_css_memory_access.h
new file mode 100644
index 0000000..c2f569c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_memory_access.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_MEMORY_ACCESS_H_
+#define _IA_CSS_MEMORY_ACCESS_H_
+
+#include "ia_css_env.h"
+
+void
+ia_css_memory_access_init(const struct ia_css_css_mem_env *env);
+
+#endif /* _IA_CSS_MEMORY_ACCESS_H_ */
+
diff --git a/drivers/media/atomisp2/css2400/ia_css_metadata.h b/drivers/media/atomisp2/css2400/ia_css_metadata.h
new file mode 100644
index 0000000..43e5869
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_metadata.h
@@ -0,0 +1,73 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_METADATA_H
+#define __IA_CSS_METADATA_H
+
+#include <type_support.h>
+#include "ia_css_types.h"
+#include "ia_css_stream_format.h"
+
+/** Metadata configuration. This data structure contains necessary info
+ *  to process sensor metadata.
+ */
+struct ia_css_metadata_config {
+	enum ia_css_stream_format data_type; /**< Data type of CSI-2 embedded
+			data. The default value is IA_CSS_STREAM_FORMAT_EMBEDDED. For
+			certain sensors, user can choose non-default data type for embedded
+			data. */
+	struct ia_css_resolution  resolution; /**< Resolution */
+};
+
+struct ia_css_metadata_info {
+	struct ia_css_resolution resolution; /**< Resolution */
+	uint32_t                 stride;     /**< Stride in bytes */
+	uint32_t                 size;       /**< Total size in bytes */
+};
+
+struct ia_css_metadata {
+	struct ia_css_metadata_info info;    /**< Layout info */
+	ia_css_ptr	            address; /**< CSS virtual address */
+	uint32_t	            exp_id;  /**< Exposure ID */
+};
+#define SIZE_OF_IA_CSS_METADATA_STRUCT sizeof(struct ia_css_metadata)
+
+/** @brief Allocate a metadata buffer.
+ * @param[in]   metadata_info Metadata info struct, contains details on metadata buffers.
+ * @return      Pointer of metadata buffer or NULL (if error)
+ *
+ * This function allocates a metadata buffer according to the properties
+ * specified in the metadata_info struct.
+ */
+struct ia_css_metadata *
+ia_css_metadata_allocate(const struct ia_css_metadata_info *metadata_info);
+
+/** @brief Free a metadata buffer.
+ *
+ * @param[in]	metadata	Pointer of metadata buffer.
+ * @return	None
+ *
+ * This function frees a metadata buffer.
+ */
+void
+ia_css_metadata_free(struct ia_css_metadata *metadata);
+
+#endif /* __IA_CSS_METADATA_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_mipi.h b/drivers/media/atomisp2/css2400/ia_css_mipi.h
new file mode 100644
index 0000000..7f4024d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_mipi.h
@@ -0,0 +1,83 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_MIPI_H
+#define __IA_CSS_MIPI_H
+
+#include <type_support.h>
+#include "ia_css_err.h"
+#include "ia_css_stream_format.h"
+#include "ia_css_input_port.h"
+
+/** Backward compatible for CSS API 2.0 only
+ * TO BE REMOVED when all drivers move to CSS API 2.1.
+ */
+/** @brief Specify a CSS MIPI frame buffer.
+ *
+ * @param[in]	size_mem_words	The frame size in memory words (32B).
+ * @param[in]	contiguous	Allocate memory physically contiguously or not.
+ * @return		The error code.
+ *
+ * Specifies a CSS MIPI frame buffer: size in memory words (32B).
+ */
+enum ia_css_err
+ia_css_mipi_frame_specify(const unsigned int	size_mem_words,
+				const bool contiguous);
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+/** @brief Register size of a CSS MIPI frame for check during capturing.
+ *
+ * @param[in]	port	CSI-2 port this check is registered.
+ * @param[in]	size_mem_words	The frame size in memory words (32B).
+ * @return		Return the error in case of failure. E.g. MAX_NOF_ENTRIES REACHED
+ *
+ * Register size of a CSS MIPI frame to check during capturing. Up to
+ *		IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES entries per port allowed. Entries are reset
+ *		when stream is stopped.
+ *
+ *
+ */
+enum ia_css_err
+ia_css_mipi_frame_enable_check_on_size(const enum ia_css_csi2_port port,
+				const unsigned int	size_mem_words);
+#endif
+
+/** @brief Calculate the size of a mipi frame.
+ *
+ * @param[in]	width		The width (in pixels) of the frame.
+ * @param[in]	height		The height (in lines) of the frame.
+ * @param[in]	format		The frame (MIPI) format.
+ * @param[in]	hasSOLandEOL	Whether frame (MIPI) contains (optional) SOL and EOF packets.
+ * @param[in]	embedded_data_size_words		Embedded data size in memory words.
+ * @param		size_mem_words					The mipi frame size in memory words (32B).
+ * @return		The error code.
+ *
+ * Calculate the size of a mipi frame, based on the resolution and format.
+ */
+enum ia_css_err
+ia_css_mipi_frame_calculate_size(const unsigned int width,
+				const unsigned int height,
+				const enum ia_css_stream_format format,
+				const bool hasSOLandEOL,
+				const unsigned int embedded_data_size_words,
+				unsigned int *size_mem_words);
+
+#endif /* __IA_CSS_MIPI_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_mmu.h b/drivers/media/atomisp2/css2400/ia_css_mmu.h
new file mode 100644
index 0000000..f039181
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_mmu.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_MMU_H
+#define __IA_CSS_MMU_H
+
+/** @brief Invalidate the MMU internal cache.
+ * @return	None
+ *
+ * This function triggers an invalidation of the translate-look-aside
+ * buffer (TLB) that's inside the CSS MMU. This function should be called
+ * every time the page tables used by the MMU change.
+ */
+void
+ia_css_mmu_invalidate_cache(void);
+
+#endif /* __IA_CSS_MMU_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_morph.h b/drivers/media/atomisp2/css2400/ia_css_morph.h
new file mode 100644
index 0000000..aec6591
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_morph.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_MORPH_H
+#define __IA_CSS_MORPH_H
+
+#include <ia_css_types.h>
+
+/** @brief Morphing table
+ * @param[in]	width Width of the morphing table.
+ * @param[in]	height Height of the morphing table.
+ * @return		Pointer to the morphing table
+*/
+struct ia_css_morph_table *
+ia_css_morph_table_allocate(unsigned int width, unsigned int height);
+
+/** @brief Free the morph table
+ * @param[in]	me Pointer to the morph table.
+ * @return		None
+*/
+void
+ia_css_morph_table_free(struct ia_css_morph_table *me);
+
+#endif /* __IA_CSS_MORPH_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_pipe.h b/drivers/media/atomisp2/css2400/ia_css_pipe.h
new file mode 100644
index 0000000..d366314
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_pipe.h
@@ -0,0 +1,190 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_PIPE_H__
+#define __IA_CSS_PIPE_H__
+
+#include <type_support.h>
+#include "ia_css.h"
+#include "ia_css_stream.h"
+#include "ia_css_frame.h"
+#include "ia_css_pipeline.h"
+#include "ia_css_binary.h"
+#include "sh_css_legacy.h"
+#include "sh_css_internal.h"
+
+struct ia_css_preview_settings {
+	struct ia_css_binary copy_binary;
+	struct ia_css_binary preview_binary;
+	struct ia_css_binary vf_pp_binary;
+	struct ia_css_pipe *copy_pipe;
+	struct ia_css_pipe *capture_pipe;
+};
+
+#define DEFAULT_PREVIEW_SETTINGS \
+{ \
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* copy_binary */\
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* preview_binary */\
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* vf_pp_binary */\
+	NULL,				/* copy_pipe */\
+	NULL,				/* capture_pipe */\
+}
+
+struct ia_css_capture_settings {
+	struct ia_css_binary copy_binary;
+	struct ia_css_binary primary_binary;
+	struct ia_css_binary pre_isp_binary;
+	struct ia_css_binary anr_gdc_binary;
+	struct ia_css_binary post_isp_binary;
+	struct ia_css_binary capture_pp_binary;
+	struct ia_css_binary vf_pp_binary;
+};
+
+#define DEFAULT_CAPTURE_SETTINGS \
+{ \
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* copy_binary */\
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* primary_binary */\
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* pre_isp_binary */\
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* anr_gdc_binary */\
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* post_isp_binary */\
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* capture_pp_binary */\
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* vf_pp_binary */\
+}
+
+struct ia_css_video_settings {
+	struct ia_css_binary copy_binary;
+	struct ia_css_binary video_binary;
+	struct ia_css_binary vf_pp_binary;
+	struct ia_css_frame *delay_frames[NUM_VIDEO_DELAY_FRAMES];
+	struct ia_css_frame *tnr_frames[NUM_VIDEO_TNR_FRAMES];
+	struct ia_css_frame *vf_pp_in_frame;
+	struct ia_css_pipe *copy_pipe;
+	struct ia_css_pipe *capture_pipe;
+};
+
+#define DEFAULT_VIDEO_SETTINGS \
+{ \
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* copy_binary */ \
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* video_binary */ \
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* vf_pp_binary */ \
+	{ NULL },			/* delay_frames */ \
+	{ NULL },			/* tnr_frames */ \
+	NULL,				/* vf_pp_in_frame */ \
+	NULL,				/* copy_pipe */ \
+	NULL,				/* capture_pipe */ \
+}
+
+struct ia_css_yuvpp_settings {
+	struct ia_css_binary copy_binary;
+	struct ia_css_binary *yuv_scaler_binary;
+	struct ia_css_binary *vf_pp_binary;
+	bool *is_output_stage;
+	unsigned int num_yuv_scaler;
+	unsigned int num_vf_pp;
+	unsigned int num_output;
+};
+
+#define DEFAULT_YUVPP_SETTINGS \
+{ \
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* copy_binary */ \
+	NULL,							/* yuv_scaler_binary */ \
+	NULL,							/* vf_pp_binary */ \
+	NULL,							/* is_output_stage */ \
+	0,								/* num_yuv_scaler */ \
+	0,								/* num_vf_pp */ \
+	0,								/* num_output */ \
+}
+
+struct ia_css_pipe {
+	/* TODO: Remove stop_requested and use stop_requested in the pipeline */
+	bool                            stop_requested;
+	struct ia_css_pipe_config       config;
+	struct ia_css_pipe_extra_config extra_config;
+	struct ia_css_pipe_info         info;
+	enum ia_css_pipe_id		mode;
+	struct ia_css_shading_table	*shading_table;
+	struct ia_css_pipeline		pipeline;
+	struct ia_css_frame_info	output_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_frame_info	bds_output_info;
+	struct ia_css_frame_info	vf_output_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_frame_info	out_yuv_ds_input_info;
+	struct ia_css_frame_info	vf_yuv_ds_input_info;
+	struct ia_css_fw_info		*output_stage;	/* extra output stage */
+	struct ia_css_fw_info		*vf_stage;	/* extra vf_stage */
+	unsigned int				required_bds_factor;
+	enum ia_css_frame_delay		dvs_frame_delay;
+	int				num_invalid_frames;
+	bool				enable_viewfinder;
+	bool				enable_second_viewfinder;
+	struct ia_css_stream		*stream;
+	struct ia_css_frame		in_frame_struct;
+	struct ia_css_frame		out_frame_struct;
+	struct ia_css_frame		vf_frame_struct;
+	struct ia_css_frame		*continuous_frames[NUM_CONTINUOUS_FRAMES];
+	struct ia_css_metadata	*cont_md_buffers[NUM_CONTINUOUS_FRAMES];
+	union {
+		struct ia_css_preview_settings preview;
+		struct ia_css_video_settings   video;
+		struct ia_css_capture_settings capture;
+		struct ia_css_yuvpp_settings yuvpp;
+	} pipe_settings;
+
+	/* This number is unique per pipe each instance of css. This number is
+	 * reused as pipeline number also. There is a 1-1 mapping between pipe_num
+	 * and sp thread id. Current logic limits pipe_num to
+	 * SH_CSS_MAX_SP_THREADS */
+	unsigned int pipe_num;
+};
+
+#define DEFAULT_PIPE \
+{ \
+	false,					/* stop_requested */ \
+	DEFAULT_PIPE_CONFIG,			/* config */ \
+	DEFAULT_PIPE_EXTRA_CONFIG,		/* extra_config */ \
+	DEFAULT_PIPE_INFO,			/* info */ \
+	IA_CSS_PIPE_ID_ACC,			/* mode (pipe_id) */ \
+	NULL,					/* shading_table */ \
+	DEFAULT_PIPELINE,			/* pipeline */ \
+	{IA_CSS_BINARY_DEFAULT_FRAME_INFO},	/* output_info */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* bds_output_info */ \
+	{IA_CSS_BINARY_DEFAULT_FRAME_INFO},	/* vf_output_info */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* out_yuv_ds_input_info */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* vf_yuv_ds_input_info */ \
+	NULL,					/* output_stage */ \
+	NULL,					/* vf_stage */ \
+	SH_CSS_BDS_FACTOR_1_00,			/* required_bds_factor */ \
+	IA_CSS_FRAME_DELAY_1,			/* dvs_frame_delay */ \
+	0,					/* num_invalid_frames */ \
+	true,					/* enable_viewfinder */ \
+	true,					/* enable_second_viewfinder */ \
+	NULL,					/* stream */ \
+	DEFAULT_FRAME,				/* in_frame_struct */ \
+	DEFAULT_FRAME,				/* out_frame_struct */ \
+	DEFAULT_FRAME,				/* vf_frame_struct */ \
+	{ NULL },				/* continuous_frames */ \
+	{ NULL },				/* cont_md_buffers */ \
+	{ DEFAULT_PREVIEW_SETTINGS },		/* pipe_settings */ \
+	PIPE_ENTRY_EMPTY_TOKEN,				/* pipe_num */\
+}
+
+void ia_css_pipe_map_queue(struct ia_css_pipe *pipe, bool map);
+
+#endif /* __IA_CSS_PIPE_H__ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_pipe_public.h b/drivers/media/atomisp2/css2400/ia_css_pipe_public.h
new file mode 100644
index 0000000..4151b67
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_pipe_public.h
@@ -0,0 +1,370 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CCS_PIPE_PUBLIC_H
+#define __IA_CCS_PIPE_PUBLIC_H
+
+#include <type_support.h>
+#include "ia_css_types.h"
+#include "ia_css_frame_public.h"
+#include "ia_css_buffer.h"
+
+
+#define IA_CSS_PIPE_MAX_OUTPUT_STAGE 2
+
+/** Enumeration of pipe modes. This mode can be used to create
+ *  an image pipe for this mode. These pipes can be combined
+ *  to configure and run streams on the ISP.
+ *
+ *  For example, one can create a preview and capture pipe to
+ *  create a continuous capture stream.
+ */
+enum ia_css_pipe_mode {
+	IA_CSS_PIPE_MODE_PREVIEW,	/**< Preview pipe */
+	IA_CSS_PIPE_MODE_VIDEO,		/**< Video pipe */
+	IA_CSS_PIPE_MODE_CAPTURE,	/**< Still capture pipe */
+	IA_CSS_PIPE_MODE_ACC,		/**< Accelerated pipe */
+	IA_CSS_PIPE_MODE_COPY,		/**< Copy pipe, only used for embedded/image data copying */
+	IA_CSS_PIPE_MODE_YUVPP,		/**< YUV post processing pipe, used for all use cases with YUV input,
+									for SoC sensor and external ISP */
+};
+/* Temporary define  */
+#define IA_CSS_PIPE_MODE_NUM (IA_CSS_PIPE_MODE_COPY + 1)
+
+struct ia_css_pipe;
+
+/* Temporary hack, hivecc fails to properly compile if this struct is
+ * included. */
+#ifndef __HIVECC__
+
+/**
+ * Pipe configuration structure.
+ */
+struct ia_css_pipe_config {
+	enum ia_css_pipe_mode mode;
+	/**< mode, indicates which mode the pipe should use. */
+	unsigned int isp_pipe_version;
+	/**< pipe version, indicates which imaging pipeline the pipe should use. */
+	struct ia_css_resolution bayer_ds_out_res;
+	/**< bayer down scaling */
+	struct ia_css_resolution capt_pp_in_res;
+	/**< bayer down scaling */
+	struct ia_css_resolution vf_pp_in_res;
+	/**< bayer down scaling */
+	struct ia_css_resolution dvs_crop_out_res;
+	/**< dvs crop, video only, not in use yet. Use dvs_envelope below. */
+	struct ia_css_frame_info output_info;
+	/**< output of YUV scaling */
+	struct ia_css_frame_info second_output_info;
+	/**< second output of the pipe if applicable */
+	struct ia_css_frame_info vf_output_info;
+	/**< output of VF YUV scaling */
+	struct ia_css_frame_info second_vf_output_info;
+	/**< second vf output of the pipe if applicable */
+	struct ia_css_fw_info *acc_extension;
+	/**< Pipeline extension accelerator */
+	struct ia_css_fw_info **acc_stages;
+	/**< Standalone accelerator stages */
+	uint32_t num_acc_stages;
+	/**< Number of standalone accelerator stages */
+	struct ia_css_capture_config default_capture_config;
+	/**< Default capture config for initial capture pipe configuration. */
+	struct ia_css_resolution dvs_envelope; /**< temporary */
+	enum ia_css_frame_delay dvs_frame_delay;
+	/**< indicates the DVS loop delay in frame periods */
+	int acc_num_execs;
+	/**< For acceleration pipes only: determine how many times the pipe
+	     should be run. Setting this to -1 means it will run until
+	     stopped. */
+	bool enable_dz;
+	/**< Disabling digital zoom for a pipeline, if this is set to false,
+	     then setting a zoom factor will have no effect.
+	     In some use cases this provides better performance. */
+};
+#else
+struct ia_css_pipe_config;
+#endif
+
+#define DEFAULT_PIPE_CONFIG \
+{ \
+	IA_CSS_PIPE_MODE_PREVIEW,		/* mode */ \
+	1,					/* isp_pipe_version */ \
+	{ 0, 0 },				/* bayer_ds_out_res */ \
+	{ 0, 0 },				/* vf_pp_in_res */ \
+	{ 0, 0 },				/* capt_pp_in_res */ \
+	{ 0, 0 },				/* dvs_crop_out_res */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* output_info */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* second_output_info */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* vf_output_info */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* second_vf_output_info */ \
+	NULL,					/* acc_extension */ \
+	NULL,					/* acc_stages */ \
+	0,					/* num_acc_stages */ \
+	DEFAULT_CAPTURE_CONFIG,			/* default_capture_config */ \
+	{ 0, 0 },				/* dvs_envelope */ \
+	IA_CSS_FRAME_DELAY_1,			/* dvs_frame_delay */ \
+	-1,					/* acc_num_execs */ \
+	true					/* enable_dz */ \
+}
+
+/** Pipe info, this struct describes properties of a pipe after it's stream has
+ * been created.
+ */
+struct ia_css_pipe_info {
+	struct ia_css_frame_info output_info;
+	struct ia_css_frame_info second_output_info;
+	/**< Info about output resolution. This contains the stride which
+	     should be used for memory allocation. */
+	struct ia_css_frame_info vf_output_info;
+	struct ia_css_frame_info second_vf_output_info;
+	/**< Info about viewfinder output resolution (optional). This contains
+	     the stride that should be used for memory allocation. */
+	struct ia_css_frame_info raw_output_info;
+	/**< Raw output resolution. This indicates the resolution of the
+	     RAW bayer output for pipes that support this. Currently, only the
+	     still capture pipes support this feature. When this resolution is
+	     smaller than the input resolution, cropping will be performed by
+	     the ISP. The first cropping that will be performed is on the upper
+	     left corner where we crop 8 lines and 8 columns to remove the
+	     pixels normally used to initialize the ISP filters.
+	     This is why the raw output resolution should normally be set to
+	     the input resolution - 8x8. */
+	struct ia_css_grid_info  grid_info;
+	/**< After register an image pipe, this field will contain the grid
+	     info for 3A and DVS. */
+};
+
+#define DEFAULT_PIPE_INFO \
+{ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* output_info */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* second_output_info */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* vf_output_info */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* second_vf_output_info */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO,	/* raw_output_info */ \
+	DEFAULT_GRID_INFO			/* grid_info */ \
+}
+
+/** @brief Load default pipe configuration
+ * @param[out]	pipe_config The pipe configuration.
+ * @return	None
+ *
+ * This function will load the default pipe configuration:
+@code
+	struct ia_css_pipe_config def_config = {
+		IA_CSS_PIPE_MODE_PREVIEW,  //mode
+		1,      // isp_pipe_version
+		{0, 0}, // bayer_ds_out_res
+		{0, 0}, // capt_pp_in_res
+		{0, 0}, // vf_pp_in_res
+		{0, 0}, // dvs_crop_out_res
+		{{0, 0}, 0, 0, 0, 0}, // output_info
+		{{0, 0}, 0, 0, 0, 0}, // second_output_info
+		{{0, 0}, 0, 0, 0, 0}, // vf_output_info
+		{{0, 0}, 0, 0, 0, 0}, // second_vf_output_info
+		NULL,   // acc_extension
+		NULL,   // acc_stages
+		0,      // num_acc_stages
+		{
+			IA_CSS_CAPTURE_MODE_RAW, // mode
+			false, // enable_xnr
+			false  // enable_raw_output
+		},      // default_capture_config
+		{0, 0}, // dvs_envelope
+		1,      // dvs_frame_delay
+		-1,     // acc_num_execs
+		true,   // enable_dz
+	};
+@endcode
+ */
+void ia_css_pipe_config_defaults(struct ia_css_pipe_config *pipe_config);
+
+/** @brief Create a pipe
+ * @param[in]	config The pipe configuration.
+ * @param[out]	pipe The pipe.
+ * @return	IA_CSS_SUCCESS or the error code.
+ *
+ * This function will create a pipe with the given configuration.
+ */
+enum ia_css_err
+ia_css_pipe_create(const struct ia_css_pipe_config *config,
+		   struct ia_css_pipe **pipe);
+
+/** @brief Destroy a pipe
+ * @param[in]	pipe The pipe.
+ * @return	IA_CSS_SUCCESS or the error code.
+ *
+ * This function will destroy a given pipe.
+ */
+enum ia_css_err
+ia_css_pipe_destroy(struct ia_css_pipe *pipe);
+
+/** @brief Provides information about a pipe
+ * @param[in]	pipe The pipe.
+ * @param[out]	pipe_info The pipe information.
+ * @return	IA_CSS_SUCCESS or IA_CSS_ERR_INVALID_ARGUMENTS.
+ *
+ * This function will provide information about a given pipe.
+ */
+enum ia_css_err
+ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
+		     struct ia_css_pipe_info *pipe_info);
+
+/** @brief Controls when the Event generator raises an IRQ to the Host.
+ *
+ * @param[in]	pipe	The pipe.
+ * @param[in]	or_mask	Binary or of enum ia_css_event_irq_mask_type. Each pipe
+			related event that is part of this mask will directly
+			raise an IRQ to	the Host when the event occurs in the
+			CSS.
+ * @param[in]	and_mask Binary or of enum ia_css_event_irq_mask_type. An event
+			IRQ for the Host is only raised after all pipe related
+			events have occurred at least once for all the active
+			pipes. Events are remembered and don't need to occure
+			at the same moment in time. There is no control over
+			the order of these events. Once an IRQ has been raised
+			all remembered events are reset.
+ * @return		IA_CSS_SUCCESS.
+ *
+ Controls when the Event generator in the CSS raises an IRQ to the Host.
+ The main purpose of this function is to reduce the amount of interrupts
+ between the CSS and the Host. This will help saving power as it wakes up the
+ Host less often. In case both or_mask and and_mask are
+ IA_CSS_EVENT_TYPE_NONE for all pipes, no event IRQ's will be raised. An
+ exception holds for IA_CSS_EVENT_TYPE_PORT_EOF, for this event an IRQ is always
+ raised.
+ Note that events are still queued and the Host can poll for them. The
+ or_mask and and_mask may be be active at the same time\n
+ \n
+ Default values, for all pipe id's, after ia_css_init:\n
+ or_mask = IA_CSS_EVENT_TYPE_ALL\n
+ and_mask = IA_CSS_EVENT_TYPE_NONE\n
+ \n
+ Examples\n
+ \code
+ ia_css_pipe_set_irq_mask(h_pipe,
+ IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE |
+ IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE ,
+ IA_CSS_EVENT_TYPE_NONE);
+ \endcode
+ The event generator will only raise an interrupt to the Host when there are
+ 3A or DIS statistics available from the preview pipe. It will not generate
+ an interrupt for any other event of the preview pipe e.g when there is an
+ output frame available.
+
+ \code
+ ia_css_pipe_set_irq_mask(h_pipe_preview,
+	IA_CSS_EVENT_TYPE_NONE,
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE |
+	IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE );
+
+ ia_css_pipe_set_irq_mask(h_pipe_capture,
+	IA_CSS_EVENT_TYPE_NONE,
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE );
+ \endcode
+ The event generator will only raise an interrupt to the Host when there is
+ both a frame done and 3A event available from the preview pipe AND when there
+ is a frame done available from the capture pipe. Note that these events
+ may occur at different moments in time. Also the order of the events is not
+ relevant.
+
+ \code
+ ia_css_pipe_set_irq_mask(h_pipe_preview,
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE,
+	IA_CSS_EVENT_TYPE_ALL );
+
+ ia_css_pipe_set_irq_mask(h_pipe_capture,
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE,
+	IA_CSS_EVENT_TYPE_ALL );
+ \endcode
+ The event generator will only raise an interrupt to the Host when there is an
+ output frame from the preview pipe OR an output frame from the capture pipe.
+ All other events (3A, VF output, pipeline done) will not raise an interrupt
+ to the Host. These events are not lost but always stored in the event queue.
+ */
+enum ia_css_err
+ia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe,
+			 unsigned int or_mask,
+			 unsigned int and_mask);
+
+/** @brief Reads the current event IRQ mask from the CSS.
+ *
+ * @param[in]	pipe The pipe.
+ * @param[out]	or_mask	Current or_mask. The bits in this mask are a binary or
+		of enum ia_css_event_irq_mask_type. Pointer may be NULL.
+ * @param[out]	and_mask Current and_mask.The bits in this mask are a binary or
+		of enum ia_css_event_irq_mask_type. Pointer may be NULL.
+ * @return	IA_CSS_SUCCESS.
+ *
+ Reads the current event IRQ mask from the CSS. Reading returns the actual
+ values as used by the SP and not any mirrored values stored at the Host.\n
+\n
+Precondition:\n
+SP must be running.\n
+
+*/
+enum ia_css_err
+ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
+			  unsigned int *or_mask,
+			  unsigned int *and_mask);
+
+/** @brief Queue a buffer for an image pipe.
+ *
+ * @param[in] pipe	The pipe that will own the buffer.
+ * @param[in] buffer	Pointer to the buffer.
+ *			Note that the caller remains owner of the buffer
+ *			structure. Only the data pointer within it will
+ *			be passed into the internal queues.
+ * @return		IA_CSS_INTERNAL_ERROR in case of unexpected errors,
+ *			IA_CSS_SUCCESS otherwise.
+ *
+ * This function adds a buffer (which has a certain buffer type) to the queue
+ * for this type. This queue is owned by the image pipe. After this function
+ * completes successfully, the buffer is now owned by the image pipe and should
+ * no longer be accessed by any other code until it gets dequeued. The image
+ * pipe will dequeue buffers from this queue, use them and return them to the
+ * host code via an interrupt. Buffers will be consumed in the same order they
+ * get queued, but may be returned to the host out of order.
+ */
+enum ia_css_err
+ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
+			   const struct ia_css_buffer *buffer);
+
+/** @brief Dequeue a buffer from an image pipe.
+ *
+ * @param[in]    pipe	 The pipeline that the buffer queue belongs to.
+ * @param[in,out] buffer The buffer is used to lookup the type which determines
+ *			 which internal queue to use.
+ *			 The resulting buffer pointer is written into the dta
+ *			 field.
+ * @return		 IA_CSS_ERR_NO_BUFFER if the queue is empty or
+ *			 IA_CSS_SUCCESS otherwise.
+ *
+ * This function dequeues a buffer from a buffer queue. The queue is indicated
+ * by the buffer type argument. This function can be called after an interrupt
+ * has been generated that signalled that a new buffer was available and can
+ * be used in a polling-like situation where the NO_BUFFER return value is used
+ * to determine whether a buffer was available or not.
+ */
+enum ia_css_err
+ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
+			   struct ia_css_buffer *buffer);
+
+#endif /* __IA_CCS_PIPE_PUBLIC_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_prbs.h b/drivers/media/atomisp2/css2400/ia_css_prbs.h
new file mode 100644
index 0000000..863c661
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_prbs.h
@@ -0,0 +1,48 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_PRBS_H
+#define __IA_CSS_PRBS_H
+
+/** Enumerate the PRBS IDs.
+ */
+enum ia_css_prbs_id {
+	IA_CSS_PRBS_ID0,
+	IA_CSS_PRBS_ID1,
+	IA_CSS_PRBS_ID2
+};
+
+/**
+ * PRBS configuration structure.
+ *
+ * Seed the for the Pseudo Random Bit Sequence.
+ *
+ * This interface is deprecated, it is not portable -> move to input system API
+ */
+struct ia_css_prbs_config {
+	enum ia_css_prbs_id	id;
+	unsigned int		h_blank;	/**< horizontal blank */
+	unsigned int		v_blank;	/**< vertical blank */
+	int			seed;	/**< random seed for the 1st 2-pixel-components/clock */
+	int			seed1;	/**< random seed for the 2nd 2-pixel-components/clock */
+};
+
+#endif /* __IA_CSS_PRBS_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_properties.h b/drivers/media/atomisp2/css2400/ia_css_properties.h
new file mode 100644
index 0000000..c285fc8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_properties.h
@@ -0,0 +1,44 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_PROPERTIES_H
+#define __IA_CSS_PROPERTIES_H
+
+#include <type_support.h> /* bool */
+#include <ia_css_types.h> /* ia_css_vamem_type */
+
+struct ia_css_properties {
+	int  gdc_coord_one;
+	bool l1_base_is_index; /**< Indicate whether the L1 page base
+				    is a page index or a byte address. */
+	enum ia_css_vamem_type vamem_type;
+};
+
+/** @brief Get hardware properties
+ * @param[in,out]	properties The hardware properties
+ * @return	None
+ *
+ * This function returns a number of hardware properties.
+ */
+void
+ia_css_get_properties(struct ia_css_properties *properties);
+
+#endif /* __IA_CSS_PROPERTIES_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_shading.h b/drivers/media/atomisp2/css2400/ia_css_shading.h
new file mode 100644
index 0000000..05329e6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_shading.h
@@ -0,0 +1,43 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_SHADING_H
+#define __IA_CSS_SHADING_H
+
+#include <ia_css_types.h>
+
+/** @brief Shading table
+ * @param[in]	width Width of the shading table.
+ * @param[in]	height Height of the shading table.
+ * @return		Pointer to the shading table
+*/
+struct ia_css_shading_table *
+ia_css_shading_table_alloc(unsigned int width,
+			   unsigned int height);
+
+/** @brief Free shading table
+ * @param[in]	table Pointer to the shading table.
+ * @return		None
+*/
+void
+ia_css_shading_table_free(struct ia_css_shading_table *table);
+
+#endif /* __IA_CSS_SHADING_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_stream.h b/drivers/media/atomisp2/css2400/ia_css_stream.h
new file mode 100644
index 0000000..0b5cb9d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_stream.h
@@ -0,0 +1,96 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_STREAM_H_
+#define _IA_CSS_STREAM_H_
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include <input_system.h>
+#endif
+#include "ia_css.h"
+
+/**
+ * structure to hold all internal stream related information
+ */
+struct ia_css_stream {
+	struct ia_css_stream_config    config;
+	struct ia_css_stream_info      info;
+#if !defined(HAS_NO_INPUT_SYSTEM) && !defined(USE_INPUT_SYSTEM_VERSION_2401)
+	rx_cfg_t                       csi_rx_config;
+#endif
+	bool                           reconfigure_css_rx;
+	struct ia_css_pipe            *last_pipe;
+	int                            num_pipes;
+	struct ia_css_pipe           **pipes;
+	struct ia_css_pipe            *continuous_pipe;
+	struct ia_css_isp_parameters  *isp_params_configs;
+	bool                           cont_capt;
+	bool						   started;
+};
+
+struct ia_css_binary *
+ia_css_stream_get_dvs_binary(const struct ia_css_stream *stream);
+
+struct ia_css_binary *
+ia_css_stream_get_3a_binary(const struct ia_css_stream *stream);
+
+unsigned int
+ia_css_stream_input_format_bits_per_pixel(struct ia_css_stream *stream);
+
+bool
+sh_css_params_set_binning_factor(struct ia_css_stream *stream, unsigned int sensor_binning);
+
+enum ia_css_err
+sh_css_param_update_isp_params(struct ia_css_stream *stream, bool commit, struct ia_css_pipe *pipe);
+
+void
+sh_css_invalidate_params(struct ia_css_stream *stream);
+
+/* The following functions are used for testing purposes only */
+const struct ia_css_fpn_table *
+ia_css_get_fpn_table(struct ia_css_stream *stream);
+
+struct ia_css_shading_table *
+ia_css_get_shading_table(struct ia_css_stream *stream);
+
+void
+ia_css_get_isp_dis_coefficients(struct ia_css_stream *stream,
+				short *horizontal_coefficients,
+				short *vertical_coefficients);
+
+void
+ia_css_get_isp_dvs2_coefficients(struct ia_css_stream *stream,
+	short *hor_coefs_odd_real,
+	short *hor_coefs_odd_imag,
+	short *hor_coefs_even_real,
+	short *hor_coefs_even_imag,
+	short *ver_coefs_odd_real,
+	short *ver_coefs_odd_imag,
+	short *ver_coefs_even_real,
+	short *ver_coefs_even_imag);
+
+enum ia_css_err
+ia_css_stream_isp_parameters_init(struct ia_css_stream *stream);
+
+void
+ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream);
+
+#endif /*_IA_CSS_STREAM_H_*/
diff --git a/drivers/media/atomisp2/css2400/ia_css_stream_format.h b/drivers/media/atomisp2/css2400/ia_css_stream_format.h
new file mode 100644
index 0000000..b2d0e22
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_stream_format.h
@@ -0,0 +1,86 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_STREAM_FORMAT_H
+#define __IA_CSS_STREAM_FORMAT_H
+
+/** The ISP streaming input interface supports the following formats.
+ *  These match the corresponding MIPI formats.
+ */
+enum ia_css_stream_format {
+	IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY,    /**< 8 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_YUV420_8,  /**< 8 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_YUV420_10, /**< 10 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_YUV422_8,  /**< UYVY..UVYV, 8 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_YUV422_10, /**< UYVY..UVYV, 10 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_RGB_444,  /**< BGR..BGR, 4 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_RGB_555,  /**< BGR..BGR, 5 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_RGB_565,  /**< BGR..BGR, 5 bits B and R, 6 bits G */
+	IA_CSS_STREAM_FORMAT_RGB_666,  /**< BGR..BGR, 6 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_RGB_888,  /**< BGR..BGR, 8 bits per subpixel */
+	IA_CSS_STREAM_FORMAT_RAW_6,    /**< RAW data, 6 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_7,    /**< RAW data, 7 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_8,    /**< RAW data, 8 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_10,   /**< RAW data, 10 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_12,   /**< RAW data, 12 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_14,   /**< RAW data, 14 bits per pixel */
+	IA_CSS_STREAM_FORMAT_RAW_16,   /**< RAW data, 16 bits per pixel, which is
+					    not specified in CSI-MIPI standard*/
+	IA_CSS_STREAM_FORMAT_BINARY_8, /**< Binary byte stream, which is target at
+					    JPEG. */
+
+	/** CSI2-MIPI specific format: Generic short packet data. It is used to
+	 *  keep the timing information for the opening/closing of shutters,
+	 *  triggering of flashes and etc.
+	 */
+	IA_CSS_STREAM_FORMAT_GENERIC_SHORT1,  /**< Generic Short Packet Code 1 */
+	IA_CSS_STREAM_FORMAT_GENERIC_SHORT2,  /**< Generic Short Packet Code 2 */
+	IA_CSS_STREAM_FORMAT_GENERIC_SHORT3,  /**< Generic Short Packet Code 3 */
+	IA_CSS_STREAM_FORMAT_GENERIC_SHORT4,  /**< Generic Short Packet Code 4 */
+	IA_CSS_STREAM_FORMAT_GENERIC_SHORT5,  /**< Generic Short Packet Code 5 */
+	IA_CSS_STREAM_FORMAT_GENERIC_SHORT6,  /**< Generic Short Packet Code 6 */
+	IA_CSS_STREAM_FORMAT_GENERIC_SHORT7,  /**< Generic Short Packet Code 7 */
+	IA_CSS_STREAM_FORMAT_GENERIC_SHORT8,  /**< Generic Short Packet Code 8 */
+
+	/** CSI2-MIPI specific format: YUV data.
+	 */
+	IA_CSS_STREAM_FORMAT_YUV420_8_SHIFT,  /**< YUV420 8-bit (Chroma Shifted Pixel Sampling) */
+	IA_CSS_STREAM_FORMAT_YUV420_10_SHIFT, /**< YUV420 8-bit (Chroma Shifted Pixel Sampling) */
+
+	/** CSI2-MIPI specific format: Generic long packet data
+	 */
+	IA_CSS_STREAM_FORMAT_EMBEDDED, /**< Embedded 8-bit non Image Data */
+
+	/** CSI2-MIPI specific format: User defined byte-based data. For example,
+	 *  the data transmitter (e.g. the SoC sensor) can keep the JPEG data as
+	 *  the User Defined Data Type 4 and the MPEG data as the
+	 *  User Defined Data Type 7.
+	 */
+	IA_CSS_STREAM_FORMAT_USER_DEF1,  /**< User defined 8-bit data type 1 */
+	IA_CSS_STREAM_FORMAT_USER_DEF2,  /**< User defined 8-bit data type 2 */
+	IA_CSS_STREAM_FORMAT_USER_DEF3,  /**< User defined 8-bit data type 3 */
+	IA_CSS_STREAM_FORMAT_USER_DEF4,  /**< User defined 8-bit data type 4 */
+	IA_CSS_STREAM_FORMAT_USER_DEF5,  /**< User defined 8-bit data type 5 */
+	IA_CSS_STREAM_FORMAT_USER_DEF6,  /**< User defined 8-bit data type 6 */
+	IA_CSS_STREAM_FORMAT_USER_DEF7,  /**< User defined 8-bit data type 7 */
+	IA_CSS_STREAM_FORMAT_USER_DEF8,  /**< User defined 8-bit data type 8 */
+};
+#endif /* __IA_CSS_STREAM_FORMAT_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_stream_public.h b/drivers/media/atomisp2/css2400/ia_css_stream_public.h
new file mode 100644
index 0000000..8ce15dc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_stream_public.h
@@ -0,0 +1,517 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CCS_STREAM_PUBLIC_H
+#define __IA_CCS_STREAM_PUBLIC_H
+
+#include <type_support.h>
+#include "ia_css_types.h"
+#include "ia_css_pipe_public.h"
+#include "ia_css_metadata.h"
+#include "ia_css_tpg.h"
+#include "ia_css_prbs.h"
+#include "ia_css_input_port.h"
+
+/** Input modes, these enumerate all supported input modes.
+ *  Note that not all ISP modes support all input modes.
+ */
+enum ia_css_input_mode {
+	IA_CSS_INPUT_MODE_SENSOR, /**< data from sensor */
+	IA_CSS_INPUT_MODE_FIFO,   /**< data from input-fifo */
+	IA_CSS_INPUT_MODE_TPG,    /**< data from test-pattern generator */
+	IA_CSS_INPUT_MODE_PRBS,   /**< data from pseudo-random bit stream */
+	IA_CSS_INPUT_MODE_MEMORY, /**< data from a frame in memory */
+	IA_CSS_INPUT_MODE_BUFFERED_SENSOR /**< data is sent through mipi buffer */
+};
+
+/** Structure of the MIPI buffer configuration
+ */
+struct ia_css_mipi_buffer_config {
+	unsigned int size_mem_words; /**< The frame size in the system memory
+					  words (32B) */
+	bool contiguous;	     /**< Allocated memory physically
+					  contiguously or not */
+};
+
+/** Input stream description. This describes how input will flow into the
+ *  CSS. This is used to program the CSS hardware.
+ */
+struct ia_css_stream_config {
+	enum ia_css_input_mode    mode; /**< Input mode */
+	union {
+		struct ia_css_input_port  port; /**< Port, for sensor only. */
+		struct ia_css_tpg_config  tpg;  /**< TPG configuration */
+		struct ia_css_prbs_config prbs; /**< PRBS configuration */
+	} source; /**< Source of input data */
+	unsigned int	      channel_id; /**< Channel on which input data
+						   will arrive. Use this field
+						   to specify virtual channel id.
+						   Valid values are: 0, 1, 2, 3 */
+	struct ia_css_resolution  input_res; /**< Resolution of input data */
+	struct ia_css_resolution  effective_res; /**< Resolution of input data */
+	enum ia_css_stream_format format; /**< Format of input stream. This data
+					       format will be mapped to MIPI data
+					       type internally. */
+	enum ia_css_bayer_order bayer_order; /**< Bayer order for RAW streams */
+	unsigned int sensor_binning_factor; /**< Binning factor used by sensor
+						 to produce image data. This is
+						 used for shading correction. */
+	/** The next field is only for backward compatibility for CSS API 2.0
+	 *  TO BE REMOVED when all drivers move to CSS API 2.1
+	 *  Effectively below two lines are implemented internally:
+	 *  if ( pixels_per_clock == 0 )
+	 *	pixels_per_clock = two_pixels_per_clock ? 2 : 1;
+	 */
+	bool two_pixels_per_clock; /**< Enable/disable 2 pixels per clock */
+	unsigned int pixels_per_clock; /**< Number of pixels per clock, which can be
+					    1, 2 or 4. 0 is used as legacy support. */
+	bool online; /**< offline will activate RAW copy on SP, use this for
+			  continuous capture. */
+	unsigned init_num_cont_raw_buf; /**< initial number of raw buffers to
+					     allocate */
+	unsigned target_num_cont_raw_buf; /**< total number of raw buffers to
+					     allocate */
+	bool pack_raw_pixels; /**< Pack pixels in the raw buffers */
+	bool continuous; /**< Use SP copy feature to continuously capture frames
+			      to system memory and run pipes in offline mode */
+	int32_t flash_gpio_pin; /**< pin on which the flash is connected, -1 for no flash */
+	int left_padding; /** The number of input-formatter left-paddings, */
+			  /* -1 for default from binary.*/
+	struct ia_css_mipi_buffer_config mipi_buffer_config; /**< mipi buffer configuration */
+	struct ia_css_metadata_config	metadata_config;     /**< Metadata configuration. */
+};
+
+struct ia_css_stream;
+
+/** Stream info, this struct describes properties of a stream after it has been
+ *  created.
+ */
+struct ia_css_stream_info {
+	struct ia_css_resolution raw_info;
+	/**< Info about raw buffer resolution. Mainly for continuous capture */
+	struct ia_css_resolution effective_info;
+	/**< Info about effective input buffer resolution. */
+	struct ia_css_metadata_info metadata_info;
+	/**< Info about the metadata layout, this contains the stride. */
+};
+
+/** @brief Load default stream configuration
+ * @param[in,out]	stream_config The stream configuration.
+ * @return	None
+ *
+ * This function will reset the stream configuration to the default state:
+@code
+	memset(stream_config, 0, sizeof(*stream_config));
+	stream_config->online = true;
+	stream_config->left_padding = -1;
+@endcode
+ */
+void ia_css_stream_config_defaults(struct ia_css_stream_config *stream_config);
+
+/*
+ * create the internal structures and fill in the configuration data and pipes
+ */
+
+ /** @brief Creates a stream
+ * @param[in]	stream_config The stream configuration.
+ * @param[in]	num_pipes The number of pipes to incorporate in the stream.
+ * @param[in]	pipes The pipes.
+ * @param[out]	stream The stream.
+ * @return	IA_CSS_SUCCESS or the error code.
+ *
+ * This function will create a stream with a given configuration and given pipes.
+ */
+enum ia_css_err
+ia_css_stream_create(const struct ia_css_stream_config *stream_config,
+					 int num_pipes,
+					 struct ia_css_pipe *pipes[],
+					 struct ia_css_stream **stream);
+
+/** @brief Destroys a stream
+ * @param[in]	stream The stream.
+ * @return	IA_CSS_SUCCESS or the error code.
+ *
+ * This function will destroy a given stream.
+ */
+enum ia_css_err
+ia_css_stream_destroy(struct ia_css_stream *stream);
+
+/** @brief Provides information about a stream
+ * @param[in]	stream The stream.
+ * @param[out]	stream_info The information about the stream.
+ * @return	IA_CSS_SUCCESS or the error code.
+ *
+ * This function will destroy a given stream.
+ */
+enum ia_css_err
+ia_css_stream_get_info(const struct ia_css_stream *stream,
+		       struct ia_css_stream_info *stream_info);
+
+/** @brief load (rebuild) a stream that was unloaded.
+ * @param[in]	stream The stream
+ * @return		IA_CSS_SUCCESS or the error code
+ *
+ * Rebuild a stream, including allocating structs, setting configuration and
+ * building the required pipes.
+ */
+enum ia_css_err
+ia_css_stream_load(struct ia_css_stream *stream);
+
+/** @brief Starts the stream.
+ * @param[in]	stream The stream.
+ * @return IA_CSS_SUCCESS or the error code.
+ *
+ * The dynamic data in
+ * the buffers are not used and need to be queued with a separate call
+ * to ia_css_pipe_enqueue_buffer.
+ * NOTE: this function will only send start event to corresponding
+ * thread and will not start SP any more.
+ */
+enum ia_css_err
+ia_css_stream_start(struct ia_css_stream *stream);
+
+/** @brief Stop the stream.
+ * @param[in]	stream The stream.
+ * @return	IA_CSS_SUCCESS or the error code.
+ *
+ * NOTE: this function will send stop event to pipes belong to this
+ * stream but will not terminate threads.
+ */
+enum ia_css_err
+ia_css_stream_stop(struct ia_css_stream *stream);
+
+/** @brief Check if a stream has stopped
+ * @param[in]	stream The stream.
+ * @return	boolean flag
+ *
+ * This function will check if the stream has stopped and return the correspondent boolean flag.
+ */
+bool
+ia_css_stream_has_stopped(struct ia_css_stream *stream);
+
+/** @brief	destroy a stream according to the stream seed previosly saved in the seed array.
+ * @param[in]	stream The stream.
+ * @return	IA_CSS_SUCCESS (no other errors are generated now)
+ *
+ * Destroy the stream and all the pipes related to it.
+ */
+enum ia_css_err
+ia_css_stream_unload(struct ia_css_stream *stream);
+
+/** @brief Returns stream format
+ * @param[in]	stream The stream.
+ * @return	format of the string
+ *
+ * This function will return the stream format.
+ */
+ enum ia_css_stream_format
+ia_css_stream_get_format(const struct ia_css_stream *stream);
+
+/** @brief Check if the stream is configured for 2 pixels per clock
+ * @param[in]	stream The stream.
+ * @return	boolean flag
+ *
+ * This function will check if the stream is configured for 2 pixels per clock and return the correspondent boolean flag.
+ */
+bool
+ia_css_stream_get_two_pixels_per_clock(const struct ia_css_stream *stream);
+
+/** @brief Sets the output frame stride (at the last pipe)
+ * @param[in]	output_padded_width - the output buffer stride.
+ * @return	ia_css_err
+ *
+ * This function will Set the output frame stride (at the last pipe)
+ */
+enum ia_css_err
+ia_css_stream_set_output_padded_width(struct ia_css_stream *stream, unsigned int output_padded_width);
+
+/** @brief Return max number of continuous RAW frames.
+ * @param[in]	stream The Stream.
+ * @param[out]	buffer_depth The maximum number of continuous RAW frames.
+ * @return	IA_CSS_SUCCESS or IA_CSS_ERR_INVALID_ARGUMENTS
+ *
+ * This function will return the maximum number of continuous RAW frames
+ * the system can support.
+ */
+enum ia_css_err
+ia_css_stream_get_max_buffer_depth(struct ia_css_stream *stream, int *buffer_depth);
+
+/** @brief Set nr of continuous RAW frames to use.
+ *
+ * @param[in]	stream The stream.
+ * @param[in]	buffer_depth	Number of frames to set.
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+ * Set the number of continuous frames to use during continuous modes.
+ */
+enum ia_css_err
+ia_css_stream_set_buffer_depth(struct ia_css_stream *stream, int buffer_depth);
+
+/** @brief Get number of continuous RAW frames to use.
+ * @param[in]	stream The stream.
+ * @param[out]	buffer_depth The number of frames to use
+ * @return	IA_CSS_SUCCESS or IA_CSS_ERR_INVALID_ARGUMENTS
+ *
+ * Get the currently set number of continuous frames
+ * to use during continuous modes.
+ */
+enum ia_css_err
+ia_css_stream_get_buffer_depth(struct ia_css_stream *stream, int *buffer_depth);
+
+/* ===== CAPTURE ===== */
+
+/** @brief Configure the continuous capture
+ *
+ * @param[in]	stream		The stream.
+ * @param[in]	num_captures	The number of RAW frames to be processed to
+ *				YUV. Setting this to -1 will make continuous
+ *				capture run until it is stopped.
+ *				This number will also be used to allocate RAW
+ *				buffers. To allow the viewfinder to also
+ *				keep operating, 2 extra buffers will always be
+ *				allocated.
+ *				If the offset is negative and the skip setting
+ *				is greater than 0, additional buffers may be
+ *				needed.
+ * @param[in]	skip		Skip N frames in between captures. This can be
+ *				used to select a slower capture frame rate than
+ *				the sensor output frame rate.
+ * @param[in]	offset		Start the RAW-to-YUV processing at RAW buffer
+ *				with this offset. This allows the user to
+ *				process RAW frames that were captured in the
+ *				past or future.
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ *  For example, to capture the current frame plus the 2 previous
+ *  frames and 2 subsequent frames, you would call
+ *  ia_css_stream_capture(5, 0, -2).
+ */
+enum ia_css_err
+ia_css_stream_capture(struct ia_css_stream *stream,
+			int num_captures,
+			unsigned int skip,
+			int offset);
+
+/** @brief Specify which raw frame to tag based on exp_id found in frame info
+ *
+ * @param[in]	stream The stream.
+ * @param[in]	exp_id	The exposure id of the raw frame to tag.
+ *
+ * @return			IA_CSS_SUCCESS or error code upon error.
+ *
+ * This function allows the user to tag a raw frame based on the exposure id
+ * found in the viewfinder frames' frame info.
+ */
+enum ia_css_err
+ia_css_stream_capture_frame(struct ia_css_stream *stream,
+			unsigned int exp_id);
+
+/* ===== VIDEO ===== */
+
+/** @brief Send streaming data into the css input FIFO
+ *
+ * @param[in]	stream	The stream.
+ * @param[in]	data	Pointer to the pixels to be send.
+ * @param[in]	width	Width of the input frame.
+ * @param[in]	height	Height of the input frame.
+ * @return	None
+ *
+ * Send streaming data into the css input FIFO. This is for testing purposes
+ * only. This uses the channel ID and input format as set by the user with
+ * the regular functions for this.
+ * This function blocks until the entire frame has been written into the
+ * input FIFO.
+ *
+ * Note:
+ * For higher flexibility the ia_css_stream_send_input_frame is replaced by
+ * three separate functions:
+ * 1) ia_css_stream_start_input_frame
+ * 2) ia_css_stream_send_input_line
+ * 3) ia_css_stream_end_input_frame
+ * In this way it is possible to stream multiple frames on different
+ * channel ID's on a line basis. It will be possible to simulate
+ * line-interleaved Stereo 3D muxed on 1 mipi port.
+ * These 3 functions are for testing purpose only and can be used in
+ * conjunction with ia_css_stream_send_input_frame
+ */
+void
+ia_css_stream_send_input_frame(const struct ia_css_stream *stream,
+			       const unsigned short *data,
+			       unsigned int width,
+			       unsigned int height);
+
+/** @brief Start an input frame on the CSS input FIFO.
+ *
+ * @param[in]	stream The stream.
+ * @return	None
+ *
+ * Starts the streaming to mipi frame by sending SoF for channel channel_id.
+ * It will use the input_format and two_pixels_per_clock as provided by
+ * the user.
+ * For the "correct" use-case, input_format and two_pixels_per_clock must match
+ * with the values as set by the user with the regular functions.
+ * To simulate an error, the user can provide "incorrect" values for
+ * input_format and/or two_pixels_per_clock.
+ */
+void
+ia_css_stream_start_input_frame(const struct ia_css_stream *stream);
+
+/** @brief Send a line of input data into the CSS input FIFO.
+ *
+ * @param[in]	stream		The stream.
+ * @param[in]	data	Array of the first line of image data.
+ * @param	width	The width (in pixels) of the first line.
+ * @param[in]	data2	Array of the second line of image data.
+ * @param	width2	The width (in pixels) of the second line.
+ * @return	None
+ *
+ * Sends 1 frame line. Start with SoL followed by width bytes of data, followed
+ * by width2 bytes of data2 and followed by and EoL
+ * It will use the input_format and two_pixels_per_clock settings as provided
+ * with the ia_css_stream_start_input_frame function call.
+ *
+ * This function blocks until the entire line has been written into the
+ * input FIFO.
+ */
+void
+ia_css_stream_send_input_line(const struct ia_css_stream *stream,
+			      const unsigned short *data,
+			      unsigned int width,
+			      const unsigned short *data2,
+			      unsigned int width2);
+
+/** @brief Send a line of input embedded data into the CSS input FIFO.
+ *
+ * @param[in]	stream     Pointer of the stream.
+ * @param[in]	format     Format of the embedded data.
+ * @param[in]	data       Pointer of the embedded data line.
+ * @param[in]	width      The width (in pixels) of the line.
+ * @return		None
+ *
+ * Sends one embedded data line to input fifo. Start with SoL followed by
+ * width bytes of data, and followed by and EoL.
+ * It will use the two_pixels_per_clock settings as provided with the
+ * ia_css_stream_start_input_frame function call.
+ *
+ * This function blocks until the entire line has been written into the
+ * input FIFO.
+ */
+void
+ia_css_stream_send_input_embedded_line(const struct ia_css_stream *stream,
+			      enum ia_css_stream_format format,
+			      const unsigned short *data,
+			      unsigned int width);
+
+/** @brief End an input frame on the CSS input FIFO.
+ *
+ * @param[in]	stream	The stream.
+ * @return	None
+ *
+ * Send the end-of-frame signal into the CSS input FIFO.
+ */
+void
+ia_css_stream_end_input_frame(const struct ia_css_stream *stream);
+
+/** @brief send a request flash command to SP
+ *
+ * @param[in]	stream The stream.
+ * @return	None
+ *
+ * Driver needs to call this function to send a flash request command
+ * to SP, SP will be responsible for switching on/off the flash at proper
+ * time. Due to the SP multi-threading environment, this request may have
+ * one-frame delay, the driver needs to check the flashed flag in frame info
+ * to determine which frame is being flashed.
+ */
+void
+ia_css_stream_request_flash(struct ia_css_stream *stream);
+
+/** @brief Configure a stream with filter coefficients.
+ *
+ * @param[in]	stream The stream.
+ * @param[in]	config	The set of filter coefficients.
+ * @param[in]   pipe Pipe to be updated when set isp config, NULL means to
+ *		   update all pipes in the stream.
+ * @return		IA_CSS_SUCCESS or error code upon error.
+ *
+ * This function configures the filter coefficients for an image
+ * stream. For image pipes that do not execute any ISP filters, this
+ * function will have no effect.
+ * It is safe to call this function while the image stream is running,
+ * in fact this is the expected behavior most of the time. Proper
+ * resource locking and double buffering is in place to allow for this.
+ */
+enum ia_css_err
+ia_css_stream_set_isp_config_on_pipe(struct ia_css_stream *stream,
+			     const struct ia_css_isp_config *config,
+			     struct ia_css_pipe *pipe);
+
+/** @brief Configure a stream with filter coefficients.
+ * @param[in]	stream	The stream.
+ * @param[in]	config	The set of filter coefficients.
+ * @return		IA_CSS_SUCCESS or error code upon error.
+ *
+ * This function configures the filter coefficients for an image
+ * stream. For image pipes that do not execute any ISP filters, this
+ * function will have no effect. All pipes of a stream will be updated.
+ * See ::ia_css_stream_set_isp_config_on_pipe() for the per-pipe alternative.
+ * It is safe to call this function while the image stream is running,
+ * in fact this is the expected behaviour most of the time. Proper
+ * resource locking and double buffering is in place to allow for this.
+ */
+enum ia_css_err
+ia_css_stream_set_isp_config(
+	struct ia_css_stream *stream,
+	const struct ia_css_isp_config *config);
+
+/** @brief Get selected configuration settings
+ * @param[in]	stream	The stream.
+ * @param[out]	config	Configuration settings.
+ * @return		None
+ */
+void
+ia_css_stream_get_isp_config(const struct ia_css_stream *stream,
+			     struct ia_css_isp_config *config);
+
+/** @brief allocate continuous raw frames for continuous capture
+ * @param[in]	stream The stream.
+ * @return IA_CSS_SUCCESS or error code.
+ *
+ *  because this allocation takes a long time (around 120ms per frame),
+ *  we separate the allocation part and update part to let driver call
+ *  this function without locking. This function is the allocation part
+ *  and next one is update part
+ */
+enum ia_css_err
+ia_css_alloc_continuous_frame_remain(struct ia_css_stream *stream);
+
+/** @brief allocate continuous raw frames for continuous capture
+ * @param[in]	stream The stream.
+ * @return	IA_CSS_SUCCESS or error code.
+ *
+ *  because this allocation takes a long time (around 120ms per frame),
+ *  we separate the allocation part and update part to let driver call
+ *  this function without locking. This function is the update part
+ */
+enum ia_css_err
+ia_css_update_continuous_frames(struct ia_css_stream *stream);
+
+#endif /* __IA_CCS_STREAM_PUBLIC_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_tpg.h b/drivers/media/atomisp2/css2400/ia_css_tpg.h
new file mode 100644
index 0000000..876f5fa
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_tpg.h
@@ -0,0 +1,73 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_TPG_H
+#define __IA_CSS_TPG_H
+
+/** Enumerate the TPG IDs.
+ */
+enum ia_css_tpg_id {
+	IA_CSS_TPG_ID0,
+	IA_CSS_TPG_ID1,
+	IA_CSS_TPG_ID2
+};
+
+/** Enumerate the TPG modes.
+ */
+enum ia_css_tpg_mode {
+	IA_CSS_TPG_MODE_RAMP,
+	IA_CSS_TPG_MODE_CHECKERBOARD,
+	IA_CSS_TPG_MODE_FRAME_BASED_COLOR,
+	IA_CSS_TPG_MODE_MONO
+};
+
+/** @brief Configure the test pattern generator.
+ *
+ * Configure the Test Pattern Generator, the way these values are used to
+ * generate the pattern can be seen in the HRT extension for the test pattern
+ * generator:
+ * devices/test_pat_gen/hrt/include/test_pat_gen.h: hrt_calc_tpg_data().
+ *
+ * This interface is deprecated, it is not portable -> move to input system API
+ *
+@code
+unsigned int test_pattern_value(unsigned int x, unsigned int y)
+{
+ unsigned int x_val, y_val;
+ if (x_delta > 0) (x_val = (x << x_delta) & x_mask;
+ else (x_val = (x >> -x_delta) & x_mask;
+ if (y_delta > 0) (y_val = (y << y_delta) & y_mask;
+ else (y_val = (y >> -y_delta) & x_mask;
+ return (x_val + y_val) & xy_mask;
+}
+@endcode
+ */
+struct ia_css_tpg_config {
+	enum ia_css_tpg_id   id;
+	enum ia_css_tpg_mode mode;
+	unsigned int         x_mask;
+	int                  x_delta;
+	unsigned int         y_mask;
+	int                  y_delta;
+	unsigned int         xy_mask;
+};
+
+#endif /* __IA_CSS_TPG_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_types.h b/drivers/media/atomisp2/css2400/ia_css_types.h
new file mode 100644
index 0000000..74a2469
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_types.h
@@ -0,0 +1,434 @@
+/* Release Version: 140311_1735 */
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_TYPES_H_
+#define _IA_CSS_TYPES_H_
+
+/*! \file */
+
+/** @file ia_css_types.h
+ * This file contains types used for the ia_css parameters.
+ * These types are in a separate file because they are expected
+ * to be used in software layers that do not access the CSS API
+ * directly but still need to forward parameters for it.
+ */
+
+#include <type_support.h>
+
+#if defined(IS_ISP_2500_SYSTEM)
+#if defined(__HOST__)
+#include "components_types.host.h"                /* Skylake kernel settings structs */
+#endif
+#endif
+
+
+#include "ia_css_frac.h"
+
+#include "isp/kernels/aa/aa_2/ia_css_aa2_types.h"
+#include "isp/kernels/anr/anr_1.0/ia_css_anr_types.h"
+#include "isp/kernels/anr/anr_2/ia_css_anr2_types.h"
+#include "isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h"
+#include "isp/kernels/csc/csc_1.0/ia_css_csc_types.h"
+#include "isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h"
+#include "isp/kernels/dp/dp_1.0/ia_css_dp_types.h"
+#include "isp/kernels/de/de_1.0/ia_css_de_types.h"
+#include "isp/kernels/de/de_2/ia_css_de2_types.h"
+#include "isp/kernels/fpn/fpn_1.0/ia_css_fpn_types.h"
+#include "isp/kernels/gc/gc_1.0/ia_css_gc_types.h"
+#include "isp/kernels/gc/gc_2/ia_css_gc2_types.h"
+#include "isp/kernels/macc/macc_1.0/ia_css_macc_types.h"
+#include "isp/kernels/ob/ob_1.0/ia_css_ob_types.h"
+#include "isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h"
+#include "isp/kernels/sc/sc_1.0/ia_css_sc_types.h"
+#include "isp/kernels/tnr/tnr_1.0/ia_css_tnr_types.h"
+#include "isp/kernels/wb/wb_1.0/ia_css_wb_types.h"
+#include "isp/kernels/xnr/xnr_1.0/ia_css_xnr_types.h"
+#include "isp/kernels/ynr/ynr_1.0/ia_css_ynr_types.h"
+#include "isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h"
+
+#define IA_CSS_VERSION_MAJOR    2
+#define IA_CSS_VERSION_MINOR    0
+#define IA_CSS_VERSION_REVISION 2
+
+#define IA_CSS_MORPH_TABLE_NUM_PLANES  6
+
+/** Number of DVS coefficient types */
+#define IA_CSS_DVS_NUM_COEF_TYPES      6
+#define IA_CSS_DVS_COEF_TYPES_ON_DMEM  2
+#define IA_CSS_DVS2_NUM_COEF_TYPES     4
+
+/* Virtual address within the CSS address space. */
+typedef uint32_t ia_css_ptr;
+
+/** Generic resolution structure.
+ */
+struct ia_css_resolution {
+	unsigned int width;  /**< Width */
+	unsigned int height; /**< Height */
+};
+
+/** Vector with signed values. This is used to indicate motion for
+ * Digital Image Stabilization.
+ */
+struct ia_css_vector {
+	int32_t x; /**< horizontal motion (in pixels) */
+	int32_t y; /**< vertical motion (in pixels) */
+};
+
+/* Short hands */
+#define IA_CSS_ISP_DMEM IA_CSS_ISP_DMEM0
+#define IA_CSS_ISP_VMEM IA_CSS_ISP_VMEM0
+
+/** CSS data descriptor */
+struct ia_css_data {
+	ia_css_ptr address; /* CSS virtual address */
+	uint32_t   size;    /* Disabled if 0 */
+};
+
+/** Host data descriptor */
+struct ia_css_host_data {
+	char      *address; /* Host address */
+	uint32_t   size;    /* Disabled if 0 */
+};
+
+/** ISP data descriptor */
+struct ia_css_isp_data {
+	uint32_t   address; /* ISP address */
+	uint32_t   size;    /* Disabled if 0 */
+};
+
+/** DVS statistics grid
+ *
+ *  ISP block: SDVS1 (DIS/DVS Support for DIS/DVS ver.1 (2-axes))
+ *             SDVS2 (DVS Support for DVS ver.2 (6-axes))
+ *  ISP1: SDVS1 is used.
+ *  ISP2: SDVS2 is used.
+ */
+struct ia_css_dvs_grid_info {
+	uint32_t enable;        /**< DVS statistics enabled.
+					0:disabled, 1:enabled */
+	uint32_t width;		/**< Width of DVS grid table.
+					(= Horizontal number of grid cells
+					in table, which cells have effective
+					statistics.)
+					For DVS1, this is equal to
+					 the number of vertical statistics. */
+	uint32_t aligned_width; /**< Stride of each grid line.
+					(= Horizontal number of grid cells
+					in table, which means
+					the allocated width.) */
+	uint32_t height;	/**< Height of DVS grid table.
+					(= Vertical number of grid cells
+					in table, which cells have effective
+					statistics.)
+					For DVS1, This is equal to
+					the number of horizontal statistics. */
+	uint32_t aligned_height;/**< Stride of each grid column.
+					(= Vertical number of grid cells
+					in table, which means
+					the allocated height.) */
+	uint32_t bqs_per_grid_cell; /**< Grid cell size in BQ(Bayer Quad) unit.
+					(1BQ means {Gr,R,B,Gb}(2x2 pixels).)
+					For DVS1, valid value is 64.
+					For DVS2, valid value is only 64,
+					currently. */
+	uint32_t num_hor_coefs;	/**< Number of horizontal coefficients. */
+	uint32_t num_ver_coefs;	/**< Number of vertical coefficients. */
+};
+
+#define DEFAULT_DVS_GRID_INFO \
+{ \
+	0,				/* enable */ \
+	0,				/* width */ \
+	0,				/* aligned_width */ \
+	0,				/* height */ \
+	0,				/* aligned_height */ \
+	0,				/* bqs_per_grid_cell */ \
+	0,				/* num_hor_coefs */ \
+	0,				/* num_ver_coefs */ \
+}
+
+/** structure that describes the 3A and DIS grids */
+struct ia_css_grid_info {
+	/** \name ISP input size
+	  * that is visible for user
+	  * @{
+	  */
+	uint32_t isp_in_width;
+	uint32_t isp_in_height;
+	/** @}*/
+
+	struct ia_css_3a_grid_info  s3a_grid; /**< 3A grid info */
+	struct ia_css_dvs_grid_info dvs_grid; /**< DVS grid info */
+
+	enum ia_css_vamem_type vamem_type;
+};
+
+#define DEFAULT_GRID_INFO \
+{ \
+	0,				/* isp_in_width */ \
+	0,				/* isp_in_height */ \
+	DEFAULT_3A_GRID_INFO,		/* s3a_grid */ \
+	DEFAULT_DVS_GRID_INFO,		/* dvs_grid */ \
+	IA_CSS_VAMEM_TYPE_1		/* vamem_type */ \
+}
+
+/** Morphing table, used for geometric distortion and chromatic abberration
+ *  correction (GDCAC, also called GDC).
+ *  This table describes the imperfections introduced by the lens, the
+ *  advanced ISP can correct for these imperfections using this table.
+ */
+struct ia_css_morph_table {
+	uint32_t enable; /**< To disable GDC, set this field to false. The
+		          coordinates fields can be set to NULL in this case. */
+	uint32_t height; /**< Table height */
+	uint32_t width;  /**< Table width */
+	uint16_t *coordinates_x[IA_CSS_MORPH_TABLE_NUM_PLANES];
+	/**< X coordinates that describe the sensor imperfection */
+	uint16_t *coordinates_y[IA_CSS_MORPH_TABLE_NUM_PLANES];
+	/**< Y coordinates that describe the sensor imperfection */
+};
+
+struct ia_css_dvs_6axis_config {
+	unsigned int exp_id;
+	uint32_t width_y;
+	uint32_t height_y;
+	uint32_t width_uv;
+	uint32_t height_uv;
+	uint32_t *xcoords_y;
+	uint32_t *ycoords_y;
+	uint32_t *xcoords_uv;
+	uint32_t *ycoords_uv;
+};
+
+/**
+ * Digital zoom:
+ * This feature is currently available only for video, but will become
+ * available for preview and capture as well.
+ * Set the digital zoom factor, this is a logarithmic scale. The actual zoom
+ * factor will be 64/x.
+ * Setting dx or dy to 0 disables digital zoom for that direction.
+ */
+struct ia_css_dz_config {
+	uint32_t dx;
+	uint32_t dy;
+};
+
+/** The still capture mode, this can be RAW (simply copy sensor input to DDR),
+ *  Primary ISP, the Advanced ISP (GDC) or the low-light ISP (ANR).
+ */
+enum ia_css_capture_mode {
+	IA_CSS_CAPTURE_MODE_RAW,      /**< no processing, copy data only */
+	IA_CSS_CAPTURE_MODE_BAYER,    /**< bayer processing, up to demosaic */
+	IA_CSS_CAPTURE_MODE_PRIMARY,  /**< primary ISP */
+	IA_CSS_CAPTURE_MODE_ADVANCED, /**< advanced ISP (GDC) */
+	IA_CSS_CAPTURE_MODE_LOW_LIGHT /**< low light ISP (ANR) */
+};
+
+struct ia_css_capture_config {
+	enum ia_css_capture_mode mode; /**< Still capture mode */
+	uint32_t enable_xnr;	       /**< Enable/disable XNR */
+	uint32_t enable_raw_output;
+};
+
+#define DEFAULT_CAPTURE_CONFIG \
+{ \
+	IA_CSS_CAPTURE_MODE_PRIMARY,	/* mode (capture) */ \
+	false,				/* enable_xnr */ \
+	false				/* enable_raw_output */ \
+}
+
+
+/** ISP filter configuration. This is a collection of configurations
+ *  for each of the ISP filters (modules).
+ *
+ *  NOTE! The contents of all pointers is copied when get or set with the
+ *  exception of the shading and morph tables. For these we only copy the
+ *  pointer, so the caller must make sure the memory contents of these pointers
+ *  remain valid as long as they are used by the CSS. This will be fixed in the
+ *  future by copying the contents instead of just the pointer.
+ *
+ *  Comment:
+ *    ["ISP block", 1&2]   : ISP block is used both for ISP1 and ISP2.
+ *    ["ISP block", 1only] : ISP block is used only for ISP1.
+ *    ["ISP block", 2only] : ISP block is used only for ISP2.
+ */
+struct ia_css_isp_config {
+	struct ia_css_wb_config   *wb_config;	/**< White Balance
+							[WB1, 1&2] */
+	struct ia_css_cc_config   *cc_config;	/**< Color Correction
+							[CSC1, 1only] */
+	struct ia_css_tnr_config  *tnr_config;	/**< Temporal Noise Reduction
+							[TNR1, 1&2] */
+	struct ia_css_ecd_config  *ecd_config;	/**< Eigen Color Demosaicing
+							[DE2, 2only] */
+	struct ia_css_ynr_config  *ynr_config;	/**< Y(Luma) Noise Reduction
+							[YNR2&YEE2, 2only] */
+	struct ia_css_fc_config   *fc_config;	/**< Fringe Control
+							[FC2, 2only] */
+	struct ia_css_cnr_config  *cnr_config;	/**< Chroma Noise Reduction
+							[CNR2, 2only] */
+	struct ia_css_macc_config *macc_config;	/**< MACC
+							[MACC2, 2only] */
+	struct ia_css_ctc_config  *ctc_config;	/**< Chroma Tone Control
+							[CTC2, 2only] */
+	struct ia_css_aa_config   *aa_config;	/**< YUV Anti-Aliasing
+							[AA2, 2only]
+						        (not used currently) */
+	struct ia_css_aa_config   *baa_config;	/**< Bayer Anti-Aliasing
+							[BAA2, 1&2] */
+	struct ia_css_ce_config   *ce_config;	/**< Chroma Enhancement
+							[CE1, 1only] */
+	struct ia_css_dvs_6axis_config *dvs_6axis_config;
+	struct ia_css_ob_config   *ob_config;  /**< Objective Black
+							[OB1, 1&2] */
+	struct ia_css_dp_config   *dp_config;  /**< Defect Pixel Correction
+							[DPC1/DPC2, 1&2] */
+	struct ia_css_nr_config   *nr_config;  /**< Noise Reduction
+							[BNR1&YNR1&CNR1, 1&2]*/
+	struct ia_css_ee_config   *ee_config;  /**< Edge Enhancement
+							[YEE1, 1&2] */
+	struct ia_css_de_config   *de_config;  /**< Demosaic
+							[DE1, 1only] */
+	struct ia_css_gc_config   *gc_config;  /**< Gamma Correction (for YUV)
+							[GC1, 1only] */
+	struct ia_css_anr_config  *anr_config; /**< Advanced Noise Reduction */
+	struct ia_css_3a_config   *s3a_config; /**< 3A Statistics config */
+	struct ia_css_xnr_config  *xnr_config; /**< eXtra Noise Reduction */
+	struct ia_css_dz_config   *dz_config;  /**< Digital Zoom */
+	struct ia_css_cc_config *yuv2rgb_cc_config; /**< Color Correction
+							[CCM2, 2only] */
+	struct ia_css_cc_config *rgb2yuv_cc_config; /**< Color Correction
+							[CSC2, 2only] */
+	struct ia_css_macc_table  *macc_table;	/**< MACC
+							[MACC1/MACC2, 1&2]*/
+	struct ia_css_gamma_table *gamma_table;	/**< Gamma Correction (for YUV)
+							[GC1, 1only] */
+	struct ia_css_ctc_table   *ctc_table;	/**< Chroma Tone Control
+							[CTC1, 1only] */
+
+	/** \deprecated */
+	struct ia_css_xnr_table   *xnr_table;	/**< eXtra Noise Reduction
+							[XNR1, 1&2] */
+	struct ia_css_rgb_gamma_table *r_gamma_table;/**< sRGB Gamma Correction
+							[GC2, 2only] */
+	struct ia_css_rgb_gamma_table *g_gamma_table;/**< sRGB Gamma Correction
+							[GC2, 2only] */
+	struct ia_css_rgb_gamma_table *b_gamma_table;/**< sRGB Gamma Correction
+							[GC2, 2only] */
+	struct ia_css_vector      *motion_vector; /**< For 2-axis DVS */
+	struct ia_css_shading_table *shading_table;
+	struct ia_css_morph_table   *morph_table;
+	struct ia_css_dvs_coefficients *dvs_coefs; /**< DVS 1.0 coefficients */
+	struct ia_css_dvs2_coefficients *dvs2_coefs; /**< DVS 2.0 coefficients */
+	struct ia_css_capture_config   *capture_config;
+	struct ia_css_anr_thres   *anr_thres;
+
+	struct ia_css_2500_lin_kernel_config     *lin_2500_config;       /**< Skylake: Linearization config */
+	struct ia_css_2500_obgrid_kernel_config  *obgrid_2500_config;    /**< Skylake: OBGRID config */
+	struct ia_css_2500_bnr_kernel_config     *bnr_2500_config;       /**< Skylake: bayer denoise config */
+	struct ia_css_2500_shd_kernel_config     *shd_2500_config;       /**< Skylake: shading config */
+	struct ia_css_2500_dm_kernel_config      *dm_2500_config;        /**< Skylake: demosaic config */
+	struct ia_css_2500_rgbpp_kernel_config   *rgbpp_2500_config;     /**< Skylake: RGBPP config */
+	struct ia_css_2500_lace_stat_kernel_config *lace_stat_2500_config; /**< Skylake: LACE STAT config */
+	struct ia_css_2500_yuvp1_kernel_config   *yuvp1_2500_config;     /**< Skylake: yuvp1 config */
+	struct ia_css_2500_yuvp2_kernel_config   *yuvp2_2500_config;     /**< Skylake: yuvp2 config */
+	struct ia_css_2500_tnr_kernel_config     *tnr_2500_config;       /**< Skylake: TNR config */
+	struct ia_css_2500_dpc_kernel_config     *dpc_2500_config;       /**< Skylake: DPC config */
+	struct ia_css_2500_awb_kernel_config     *awb_2500_config;       /**< Skylake: auto white balance config */
+	struct ia_css_2500_awb_fr_kernel_config  *awb_fr_2500_config;    /**< Skylake: auto white balance filter response config */
+	struct ia_css_2500_anr_kernel_config     *anr_2500_config;       /**< Skylake: ANR config */
+	struct ia_css_2500_af_kernel_config      *af_2500_config;        /**< Skylake: auto focus config */
+	struct ia_css_2500_ae_kernel_config      *ae_2500_config;        /**< Skylake: auto exposure config */
+	struct ia_css_2500_bds_kernel_config     *bds_2500_config;       /**< Skylake: bayer downscaler config */
+	struct ia_css_2500_dvs_kernel_config     *dvs_2500_config;       /**< Skylake: digital video stabilization config */
+	struct ia_css_2500_res_mgr_config        *res_mgr_2500_config;
+
+	struct ia_css_frame	*output_frame;	/**< Output frame the config is to be applied to (optional) */
+	uint32_t 			isp_config_id;	/**< Unique ID to track which config was actually applied to a particular frame */
+};
+
+/** DVS 1.0 Coefficients.
+ *  This structure describes the coefficients that are needed for the dvs statistics.
+ */
+
+struct ia_css_dvs_coefficients {
+	struct ia_css_dvs_grid_info grid;/**< grid info contains the dimensions of the dvs grid */
+	int16_t *hor_coefs;	/**< the pointer to int16_t[grid.num_hor_coefs * IA_CSS_DVS_NUM_COEF_TYPES]
+				     containing the horizontal coefficients */
+	int16_t *ver_coefs;	/**< the pointer to int16_t[grid.num_ver_coefs * IA_CSS_DVS_NUM_COEF_TYPES]
+				     containing the vertical coefficients */
+};
+
+/** DVS 1.0 Statistics.
+ *  This structure describes the statistics that are generated using the provided coefficients.
+ */
+
+struct ia_css_dvs_statistics {
+	struct ia_css_dvs_grid_info grid;/**< grid info contains the dimensions of the dvs grid */
+	int32_t *hor_proj;	/**< the pointer to int16_t[grid.height * IA_CSS_DVS_NUM_COEF_TYPES]
+				     containing the horizontal projections */
+	int32_t *ver_proj;	/**< the pointer to int16_t[grid.width * IA_CSS_DVS_NUM_COEF_TYPES]
+				     containing the vertical projections */
+};
+
+/** DVS 2.0 Coefficient types. This structure contains 4 pointers to
+ *  arrays that contain the coeffients for each type.
+ */
+struct ia_css_dvs2_coef_types {
+	int16_t *odd_real; /**< real part of the odd coefficients*/
+	int16_t *odd_imag; /**< imaginary part of the odd coefficients*/
+	int16_t *even_real;/**< real part of the even coefficients*/
+	int16_t *even_imag;/**< imaginary part of the even coefficients*/
+};
+
+/** DVS 2.0 Coefficients. This structure describes the coefficients that are needed for the dvs statistics.
+ *  e.g. hor_coefs.odd_real is the pointer to int16_t[grid.num_hor_coefs] containing the horizontal odd real
+ *  coefficients.
+ */
+struct ia_css_dvs2_coefficients {
+	struct ia_css_dvs_grid_info grid;        /**< grid info contains the dimensions of the dvs grid */
+	struct ia_css_dvs2_coef_types hor_coefs; /**< struct with pointers that contain the horizontal coefficients */
+	struct ia_css_dvs2_coef_types ver_coefs; /**< struct with pointers that contain the vertical coefficients */
+};
+
+/** DVS 2.0 Statistic types. This structure contains 4 pointers to
+ *  arrays that contain the statistics for each type.
+ */
+struct ia_css_dvs2_stat_types {
+	int32_t *odd_real; /**< real part of the odd statistics*/
+	int32_t *odd_imag; /**< imaginary part of the odd statistics*/
+	int32_t *even_real;/**< real part of the even statistics*/
+	int32_t *even_imag;/**< imaginary part of the even statistics*/
+};
+
+/** DVS 2.0 Statistics. This structure describes the statistics that are generated using the provided coefficients.
+ *  e.g. hor_prod.odd_real is the pointer to int16_t[grid.aligned_height][grid.aligned_width] containing
+ *  the horizontal odd real statistics. Valid statistics data area is int16_t[0..grid.height-1][0..grid.width-1]
+ */
+struct ia_css_dvs2_statistics {
+	struct ia_css_dvs_grid_info grid;       /**< grid info contains the dimensions of the dvs grid */
+	struct ia_css_dvs2_stat_types hor_prod; /**< struct with pointers that contain the horizontal statistics */
+	struct ia_css_dvs2_stat_types ver_prod; /**< struct with pointers that contain the vertical statistics */
+};
+
+#endif /* _IA_CSS_TYPES_H_ */
diff --git a/drivers/media/atomisp2/css2400/ia_css_version.h b/drivers/media/atomisp2/css2400/ia_css_version.h
new file mode 100644
index 0000000..4a24fb4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_version.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_VERSION_H
+#define __IA_CSS_VERSION_H
+
+#include <ia_css_err.h>
+
+/* a common size for the version arrays */
+#define MAX_VERSION_SIZE	500
+
+/** @brief Retrieves the current CSS version
+ * @param[out]	version		A pointer to a buffer where to put the generated
+ *				version string. NULL is ignored.
+ *
+ * This function generates and returns the version string. If FW is loaded, it
+ * attaches the FW version.
+ */
+enum ia_css_err
+ia_css_get_version(char *version, int max_size);
+
+#endif /* __IA_CSS_VERSION_H */
diff --git a/drivers/media/atomisp2/css2400/ia_css_version_data.h b/drivers/media/atomisp2/css2400/ia_css_version_data.h
new file mode 100644
index 0000000..3cf9b13
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/ia_css_version_data.h
@@ -0,0 +1,36 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+//
+// This file contains the version data for the CSS
+//
+// === Do not change - automatically generated ===
+//
+
+#ifndef __IA_CSS_VERSION_DATA_H
+#define __IA_CSS_VERSION_DATA_H
+
+
+#define CSS_VERSION_STRING "VER:0.8; REL:20140311_11.2_1823; API:2.0.1.0; GIT:irci_20140310_2300_#65136efd36113cefd9efd4d0e9fd1448261dbc4d; SDK:/p/siliconhive/hivepkgs/releases/css/Css_Mizuchi/int_css_mizuchi_20140211_2101; USER:jwu35; "
+
+
+#endif
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2.host.c b/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2.host.c
new file mode 100644
index 0000000..a5d966a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2.host.c
@@ -0,0 +1,60 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_aa2.host.h"
+
+/* YUV Anti-Aliasing configuration. */
+const struct ia_css_aa_config default_aa_config = {
+	8191 /* default should be 0 */
+};
+
+/* Bayer Anti-Aliasing configuration. */
+const struct ia_css_aa_config default_baa_config = {
+	8191 /* default should be 0 */
+};
+
+void
+ia_css_aa_encode(
+	struct sh_css_isp_aa_params *to,
+	const struct ia_css_aa_config *from)
+{
+	to->strength = from->strength;
+}
+
+void
+ia_css_aa_dump(
+	const struct sh_css_isp_aa_params *aa,
+	unsigned level);
+
+void
+ia_css_aa_debug_dtrace(
+	const struct ia_css_aa_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.strength=%d\n",
+		config->strength);
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2.host.h b/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2.host.h
new file mode 100644
index 0000000..fcdfd83
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2.host.h
@@ -0,0 +1,49 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_AA_HOST_H
+#define __IA_CSS_AA_HOST_H
+
+#include "ia_css_aa2_types.h"
+#include "ia_css_aa2_param.h"
+
+/* YUV Anti-Aliasing configuration. */
+extern const struct ia_css_aa_config default_aa_config;
+
+/* Bayer Anti-Aliasing configuration. */
+extern const struct ia_css_aa_config default_baa_config;
+
+void
+ia_css_aa_encode(
+	struct sh_css_isp_aa_params *to,
+	const struct ia_css_aa_config *from);
+
+void
+ia_css_aa_dump(
+	const struct sh_css_isp_aa_params *aa,
+	unsigned level);
+
+void
+ia_css_aa_debug_dtrace(
+	const struct ia_css_aa_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_AA_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2_param.h b/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2_param.h
new file mode 100644
index 0000000..658a614
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2_param.h
@@ -0,0 +1,32 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_AA_PARAM_H
+#define __IA_CSS_AA_PARAM_H
+
+#include "type_support.h"
+
+/* Anti-Aliasing */
+struct sh_css_isp_aa_params {
+	int32_t strength;
+};
+
+#endif /* __IA_CSS_AA_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2_types.h b/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2_types.h
new file mode 100644
index 0000000..ba4c0d7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/aa/aa_2/ia_css_aa2_types.h
@@ -0,0 +1,50 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_AA2_TYPES_H
+#define __IA_CSS_AA2_TYPES_H
+
+/** Anti-Aliasing configuration.
+ *
+ *  This structure is used both for YUV AA and Bayer AA.
+ *
+ *  1. YUV Anti-Aliasing
+ *     struct ia_css_aa_config   *aa_config
+ *
+ *     ISP block: AA2
+ *    (ISP1: AA2 is not used.)
+ *     ISP2: AA2 should be used. But, AA2 is not used currently.
+ *
+ *  2. Bayer Anti-Aliasing
+ *     struct ia_css_aa_config   *baa_config
+ *
+ *     ISP block: BAA2
+ *     ISP1: BAA2 is used.
+ *     ISP2: BAA2 is used.
+ */
+struct ia_css_aa_config {
+	uint16_t strength;	/**< Strength of the filter.
+					u0.13, [0,8191],
+					default/ineffective 0 */
+};
+
+#endif /* __IA_CSS_AA2_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr.host.c b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr.host.c
new file mode 100644
index 0000000..9b03f48
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr.host.c
@@ -0,0 +1,65 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_anr.host.h"
+
+const struct ia_css_anr_config default_anr_config = {
+	10,
+	{ 0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
+	  0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
+	  0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
+	  0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4},
+	{10, 20, 30}
+};
+
+void
+ia_css_anr_encode(
+	struct sh_css_isp_anr_params *to,
+	const struct ia_css_anr_config *from)
+{
+	to->threshold = from->threshold;
+}
+
+void
+ia_css_anr_dump(
+	const struct sh_css_isp_anr_params *anr,
+	unsigned level)
+{
+	if (!anr) return;
+	ia_css_debug_dtrace(level, "Advance Noise Reduction:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"anr_threshold", anr->threshold);
+}
+
+void
+ia_css_anr_debug_dtrace(
+	const struct ia_css_anr_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.threshold=%d\n",
+		config->threshold);
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr.host.h b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr.host.h
new file mode 100644
index 0000000..672203d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr.host.h
@@ -0,0 +1,45 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ANR_HOST_H
+#define __IA_CSS_ANR_HOST_H
+
+#include "ia_css_anr_types.h"
+#include "ia_css_anr_param.h"
+
+extern const struct ia_css_anr_config default_anr_config;
+
+void
+ia_css_anr_encode(
+	struct sh_css_isp_anr_params *to,
+	const struct ia_css_anr_config *from);
+
+void
+ia_css_anr_dump(
+	const struct sh_css_isp_anr_params *anr,
+	unsigned level);
+
+void
+ia_css_anr_debug_dtrace(
+	const struct ia_css_anr_config *config, unsigned level)
+;
+
+#endif /* __IA_CSS_ANR_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr_param.h b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr_param.h
new file mode 100644
index 0000000..8f9c1b8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr_param.h
@@ -0,0 +1,32 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ANR_PARAM_H
+#define __IA_CSS_ANR_PARAM_H
+
+#include "type_support.h"
+
+/* ANR (Advanced Noise Reduction) */
+struct sh_css_isp_anr_params {
+	int32_t threshold;
+};
+
+#endif /* __IA_CSS_ANR_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr_types.h b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr_types.h
new file mode 100644
index 0000000..61c1a6b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_1.0/ia_css_anr_types.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ANR_TYPES_H
+#define __IA_CSS_ANR_TYPES_H
+
+/** Advanced Noise Reduction configuration.
+ *  This is also known as Low-Light.
+ */
+struct ia_css_anr_config {
+	int32_t threshold; /**< Threshold */
+	int32_t thresholds[4*4*4];
+	int32_t factors[3];
+};
+
+#endif /* __IA_CSS_ANR_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2.host.c b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2.host.c
new file mode 100644
index 0000000..3404948
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2.host.c
@@ -0,0 +1,26 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_anr2.host.h"
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2.host.h b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2.host.h
new file mode 100644
index 0000000..f00a107
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2.host.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ANR2_HOST_H
+#define __IA_CSS_ANR2_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_anr2_types.h"
+#include "ia_css_anr2_param.h"
+#include "ia_css_anr2_table.host.h"
+
+#endif /* __IA_CSS_ANR2_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_param.h b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_param.h
new file mode 100644
index 0000000..2f6779c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_param.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ANR2_PARAM_H
+#define __IA_CSS_ANR2_PARAM_H
+
+#include "type_support.h"
+
+/* ANR (Advanced Noise Reduction) */
+
+#endif /* __IA_CSS_ANR2_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_table.host.c b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_table.host.c
new file mode 100644
index 0000000..df3fc41
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_table.host.c
@@ -0,0 +1,59 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "system_global.h"
+#include "ia_css_types.h"
+#include "ia_css_anr2_table.host.h"
+
+#if 1
+const struct ia_css_anr_thres default_anr_thres = {
+{128, 384, 640, 896, 896, 640, 384, 128, 384, 1152, 1920, 2688, 2688, 1920, 1152, 384, 640, 1920, 3200, 4480, 4480, 3200, 1920, 640, 896, 2688, 4480, 6272, 6272, 4480, 2688, 896, 896, 2688, 4480, 6272, 6272, 4480, 2688, 896, 640, 1920, 3200, 4480, 4480, 3200, 1920, 640, 384, 1152, 1920, 2688, 2688, 1920, 1152, 384, 128, 384, 640, 896, 896, 640, 384, 128,
+0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20,
+0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40,
+0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60,
+30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50,
+60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100,
+90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150,
+10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30,
+20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60,
+30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90,
+20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40,
+40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80,
+60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120}
+};
+#else
+const struct ia_css_anr_thres default_anr_thres = {
+{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+};
+#endif
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_table.host.h b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_table.host.h
new file mode 100644
index 0000000..e7143e0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_table.host.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ANR2_TABLE_HOST_H
+#define __IA_CSS_ANR2_TABLE_HOST_H
+
+#include "ia_css_anr2_types.h"
+
+extern const struct ia_css_anr_thres default_anr_thres;
+
+#endif /* __IA_CSS_ANR2_TABLE_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_types.h b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_types.h
new file mode 100644
index 0000000..84ed7b8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/anr/anr_2/ia_css_anr2_types.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ANR2_TYPES_H
+#define __IA_CSS_ANR2_TYPES_H
+
+/** Advanced Noise Reduction (ANR) thresholds */
+struct ia_css_anr_thres {
+	int16_t data[13*64];
+};
+
+#endif /* __IA_CSS_ANR2_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh.host.c b/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh.host.c
new file mode 100644
index 0000000..703c792
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh.host.c
@@ -0,0 +1,84 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#if !defined(HAS_NO_HMEM)
+
+#include "ia_css_memory_access.h"
+#include "memory_access.h"
+#include "ia_css_types.h"
+#include "sh_css_internal.h"
+#include "assert_support.h"
+#include "sh_css_frac.h"
+
+#include "ia_css_bh.host.h"
+
+void
+ia_css_bh_hmem_decode(
+	struct ia_css_3a_rgby_output *out_ptr,
+	hrt_vaddress ddr_ptr)
+{
+	struct ia_css_bh_table *hmem_buf = sh_css_malloc(sizeof(*hmem_buf));
+	int i;
+
+	/*
+	 * No weighted histogram, hence no grid definition
+	 */
+	if(!hmem_buf)
+		return;
+	assert(sizeof_hmem(HMEM0_ID) == sizeof(*hmem_buf));
+	mmgr_load(ddr_ptr, (void *)hmem_buf, sizeof(*hmem_buf));
+
+	/* Deinterleave */
+	for (i = 0; i < HMEM_UNIT_SIZE; i++) {
+		out_ptr[i].r = hmem_buf->hmem[BH_COLOR_R][i];
+		out_ptr[i].g = hmem_buf->hmem[BH_COLOR_G][i];
+		out_ptr[i].b = hmem_buf->hmem[BH_COLOR_B][i];
+		out_ptr[i].y = hmem_buf->hmem[BH_COLOR_Y][i];
+		/* sh_css_print ("hmem[%d] = %d, %d, %d, %d\n",
+			i, out_ptr[i].r, out_ptr[i].g, out_ptr[i].b, out_ptr[i].y); */
+	}
+	sh_css_free(hmem_buf);
+}
+
+void
+ia_css_bh_encode(
+	struct sh_css_isp_bh_params *to,
+	const struct ia_css_3a_config *from)
+{
+	/* coefficients to calculate Y */
+	to->y_coef_r =
+	    uDIGIT_FITTING(from->ae_y_coef_r, 16, SH_CSS_AE_YCOEF_SHIFT);
+	to->y_coef_g =
+	    uDIGIT_FITTING(from->ae_y_coef_g, 16, SH_CSS_AE_YCOEF_SHIFT);
+	to->y_coef_b =
+	    uDIGIT_FITTING(from->ae_y_coef_b, 16, SH_CSS_AE_YCOEF_SHIFT);
+}
+
+void
+ia_css_bh_hmem_encode(
+	struct sh_css_isp_bh_hmem_params *to,
+	const struct ia_css_3a_config *from)
+{
+	(void)from;
+	(void)to;
+}
+
+#endif
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh.host.h b/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh.host.h
new file mode 100644
index 0000000..26647fc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh.host.h
@@ -0,0 +1,44 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_HB_HOST_H
+#define __IA_CSS_HB_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_bh_param.h"
+
+void
+ia_css_bh_hmem_decode(
+	struct ia_css_3a_rgby_output *out_ptr,
+	hrt_vaddress ddr_ptr);
+
+void
+ia_css_bh_encode(
+	struct sh_css_isp_bh_params *to,
+	const struct ia_css_3a_config *from);
+
+void
+ia_css_bh_hmem_encode(
+	struct sh_css_isp_bh_hmem_params *to,
+	const struct ia_css_3a_config *from);
+
+#endif /* __IA_CSS_HB_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh_param.h b/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh_param.h
new file mode 100644
index 0000000..3db827c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh_param.h
@@ -0,0 +1,47 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_HB_PARAM_H
+#define __IA_CSS_HB_PARAM_H
+
+#include "type_support.h"
+
+#ifndef PIPE_GENERATION
+#define __INLINE_HMEM__
+#include "hmem.h"
+#endif
+
+#include "ia_css_bh_types.h"
+
+/* AE (3A Support) */
+struct sh_css_isp_bh_params {
+	/* coefficients to calculate Y */
+	int32_t y_coef_r;
+	int32_t y_coef_g;
+	int32_t y_coef_b;
+};
+
+/* This should be hmem_data_t, but that breaks the pipe generator */
+struct sh_css_isp_bh_hmem_params {
+	uint32_t bh[ISP_HIST_COMPONENTS][IA_CSS_HMEM_BH_UNIT_SIZE];
+};
+
+#endif /* __IA_CSS_HB_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh_types.h b/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh_types.h
new file mode 100644
index 0000000..e92f9bc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/bh/bh_2/ia_css_bh_types.h
@@ -0,0 +1,44 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BH_TYPES_H
+#define __IA_CSS_BH_TYPES_H
+
+/** Number of elements in the BH table.
+  * Should be consistent with hmem.h
+  */
+#define IA_CSS_HMEM_BH_TABLE_SIZE	ISP_HIST_DEPTH
+#define IA_CSS_HMEM_BH_UNIT_SIZE	(ISP_HIST_DEPTH/ISP_HIST_COMPONENTS)
+
+#define BH_COLOR_R	(0)
+#define BH_COLOR_G	(1)
+#define BH_COLOR_B	(2)
+#define BH_COLOR_Y	(3)
+#define BH_COLOR_NUM	(4)
+
+/** BH table */
+struct ia_css_bh_table {
+	uint32_t hmem[ISP_HIST_COMPONENTS][IA_CSS_HMEM_BH_UNIT_SIZE];
+};
+
+#endif /* __IA_CSS_BH_TYPES_H */
+
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.c b/drivers/media/atomisp2/css2400/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.c
new file mode 100644
index 0000000..8f6be56
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.c
@@ -0,0 +1,69 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_frac.h"
+
+#include "ia_css_bnr.host.h"
+
+void
+ia_css_bnr_encode(
+	struct sh_css_isp_bnr_params *to,
+	const struct ia_css_nr_config *from)
+{
+	/* BNR (Bayer Noise Reduction) */
+	to->threshold_low =
+	    uDIGIT_FITTING(from->direction, 16, SH_CSS_BAYER_BITS);
+	to->threshold_width_log2 = uFRACTION_BITS_FITTING(8);
+	to->threshold_width =
+	    1 << to->threshold_width_log2;
+	to->gain_all =
+	    uDIGIT_FITTING(from->bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
+	to->gain_dir =
+	    uDIGIT_FITTING(from->bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
+	to->clip = uDIGIT_FITTING((unsigned)16384, 16, SH_CSS_BAYER_BITS);
+}
+
+void
+ia_css_bnr_dump(
+	const struct sh_css_isp_bnr_params *bnr,
+	unsigned level)
+{
+	if (!bnr) return;
+	ia_css_debug_dtrace(level, "Bayer Noise Reduction:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"bnr_gain_all", bnr->gain_all);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"bnr_gain_dir", bnr->gain_dir);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"bnr_threshold_low",
+			bnr->threshold_low);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"bnr_threshold_width_log2",
+			bnr->threshold_width_log2);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"bnr_threshold_width",
+			bnr->threshold_width);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"bnr_clip", bnr->clip);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h b/drivers/media/atomisp2/css2400/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h
new file mode 100644
index 0000000..c0757a7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR_HOST_H
+#define __IA_CSS_BNR_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ynr/ynr_1.0/ia_css_ynr_types.h"
+#include "ia_css_bnr_param.h"
+
+void
+ia_css_bnr_encode(
+	struct sh_css_isp_bnr_params *to,
+	const struct ia_css_nr_config *from);
+
+void
+ia_css_bnr_dump(
+	const struct sh_css_isp_bnr_params *bnr,
+	unsigned level);
+
+#endif /* __IA_CSS_DP_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/bnr/bnr_1.0/ia_css_bnr_param.h b/drivers/media/atomisp2/css2400/isp/kernels/bnr/bnr_1.0/ia_css_bnr_param.h
new file mode 100644
index 0000000..3ba31a20
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/bnr/bnr_1.0/ia_css_bnr_param.h
@@ -0,0 +1,37 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR_PARAM_H
+#define __IA_CSS_BNR_PARAM_H
+
+#include "type_support.h"
+
+/* BNR (Bayer Noise Reduction) */
+struct sh_css_isp_bnr_params {
+	int32_t gain_all;
+	int32_t gain_dir;
+	int32_t threshold_low;
+	int32_t threshold_width_log2;
+	int32_t threshold_width;
+	int32_t clip;
+};
+
+#endif /* __IA_CSS_BNR_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.c b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.c
new file mode 100644
index 0000000..4edd453
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.c
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_cnr.host.h"
+
+/* keep the interface here, it is not enabled yet because host doesn't know the size of individual state */
+void
+ia_css_init_cnr_state(void/*struct sh_css_isp_cnr_vmem_state *state*/)
+{
+	//memset(state, 0, sizeof(*state));
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.h b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.h
new file mode 100644
index 0000000..080b812
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.h
@@ -0,0 +1,30 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CNR_HOST_H
+#define __IA_CSS_CNR_HOST_H
+
+#include "ia_css_cnr_param.h"
+
+void
+ia_css_init_cnr_state(
+	void/*struct sh_css_isp_cnr_vmem_state *state*/);
+#endif /* __IA_CSS_CNR_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr_param.h b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr_param.h
new file mode 100644
index 0000000..122d2c4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr_param.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CNR_PARAM_H
+#define __IA_CSS_CNR_PARAM_H
+
+#include "type_support.h"
+
+/* CNR (Chroma Noise Reduction) */
+/* Reuse YNR1 param structure */
+#include  "../../ynr/ynr_1.0/ia_css_ynr_param.h"
+
+#endif /* __IA_CSS_CNR_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr_state.h b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr_state.h
new file mode 100644
index 0000000..22841462
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_1.0/ia_css_cnr_state.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CNR_STATE_H
+#define __IA_CSS_CNR_STATE_H
+
+#include "type_support.h"
+
+#include "vmem.h"
+
+typedef struct
+{
+  VMEM_ARRAY(u, ISP_NWAY);
+  VMEM_ARRAY(v, ISP_NWAY);
+} s_cnr_buf;
+
+/* CNR (color noise reduction) */
+struct sh_css_isp_cnr_vmem_state {
+	s_cnr_buf cnr_buf[2][MAX_VECTORS_PER_BUF_LINE/2];
+};
+
+#endif /* __IA_CSS_CNR_STATE_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.c b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.c
new file mode 100644
index 0000000..b599f96
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.c
@@ -0,0 +1,79 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_cnr2.host.h"
+
+const struct ia_css_cnr_config default_cnr_config = {
+	0,
+	0,
+	100,
+	100,
+	100,
+	50,
+	50,
+	50
+};
+
+void
+ia_css_cnr_encode(
+	struct sh_css_isp_cnr_params *to,
+	const struct ia_css_cnr_config *from)
+{
+	to->coring_u = from->coring_u;
+	to->coring_v = from->coring_v;
+	to->sense_gain_vy = from->sense_gain_vy;
+	to->sense_gain_vu = from->sense_gain_vu;
+	to->sense_gain_vv = from->sense_gain_vv;
+	to->sense_gain_hy = from->sense_gain_hy;
+	to->sense_gain_hu = from->sense_gain_hu;
+	to->sense_gain_hv = from->sense_gain_hv;
+}
+
+void
+ia_css_cnr_dump(
+	const struct sh_css_isp_cnr_params *cnr,
+	unsigned level);
+
+void
+ia_css_cnr_debug_dtrace(
+	const struct ia_css_cnr_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.coring_u=%d, config.coring_v=%d, "
+		"config.sense_gain_vy=%d, config.sense_gain_hy=%d, "
+		"config.sense_gain_vu=%d, config.sense_gain_hu=%d, "
+		"config.sense_gain_vv=%d, config.sense_gain_hv=%d\n",
+		config->coring_u, config->coring_v,
+		config->sense_gain_vy, config->sense_gain_hy,
+		config->sense_gain_vu, config->sense_gain_hu,
+		config->sense_gain_vv, config->sense_gain_hv);
+}
+
+void
+ia_css_init_cnr2_state(void/*struct sh_css_isp_cnr_vmem_state *state*/)
+{
+	//memset(state, 0, sizeof(*state));
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h
new file mode 100644
index 0000000..04b9b8f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h
@@ -0,0 +1,48 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CNR2_HOST_H
+#define __IA_CSS_CNR2_HOST_H
+
+#include "ia_css_cnr2_types.h"
+#include "ia_css_cnr2_param.h"
+
+extern const struct ia_css_cnr_config default_cnr_config;
+
+void
+ia_css_cnr_encode(
+	struct sh_css_isp_cnr_params *to,
+	const struct ia_css_cnr_config *from);
+
+void
+ia_css_cnr_dump(
+	const struct sh_css_isp_cnr_params *cnr,
+	unsigned level);
+
+void
+ia_css_cnr_debug_dtrace(
+	const struct ia_css_cnr_config *config,
+	unsigned level);
+
+void
+ia_css_init_cnr2_state(
+	void/*struct sh_css_isp_cnr_vmem_state *state*/);
+#endif /* __IA_CSS_CNR2_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2_param.h b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2_param.h
new file mode 100644
index 0000000..5dd543f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2_param.h
@@ -0,0 +1,39 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CNR2_PARAM_H
+#define __IA_CSS_CNR2_PARAM_H
+
+#include "type_support.h"
+
+/* CNR (Chroma Noise Reduction) */
+struct sh_css_isp_cnr_params {
+	int32_t coring_u;
+	int32_t coring_v;
+	int32_t sense_gain_vy;
+	int32_t sense_gain_vu;
+	int32_t sense_gain_vv;
+	int32_t sense_gain_hy;
+	int32_t sense_gain_hu;
+	int32_t sense_gain_hv;
+};
+
+#endif /* __IA_CSS_CNR2_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
new file mode 100644
index 0000000..055d10b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
@@ -0,0 +1,58 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CNR2_TYPES_H
+#define __IA_CSS_CNR2_TYPES_H
+
+/** Chroma Noise Reduction configuration.
+ *
+ *  Small sensitivity of edge means strong smoothness and NR performance.
+ *  If you see blurred color on vertical edges,
+ *  set higher values on sense_gain_h*.
+ *  If you see blurred color on horizontal edges,
+ *  set higher values on sense_gain_v*.
+ *
+ *  ISP block: CNR2
+ * (ISP1: CNR1 is used.)
+ * (ISP2: CNR1 is used for Preview/Video.)
+ *  ISP2: CNR2 is used for Still.
+ */
+struct ia_css_cnr_config {
+	uint16_t coring_u;	/**< Coring level of U.
+				u0.13, [0,8191], default/ineffective 0 */
+	uint16_t coring_v;	/**< Coring level of V.
+				u0.13, [0,8191], default/ineffective 0 */
+	uint16_t sense_gain_vy;	/**< Sensitivity of horizontal edge of Y.
+				u13.0, [0,8191], default 100, ineffective 0 */
+	uint16_t sense_gain_vu;	/**< Sensitivity of horizontal edge of U.
+				u13.0, [0,8191], default 100, ineffective 0 */
+	uint16_t sense_gain_vv;	/**< Sensitivity of horizontal edge of V.
+				u13.0, [0,8191], default 100, ineffective 0 */
+	uint16_t sense_gain_hy;	/**< Sensitivity of vertical edge of Y.
+				u13.0, [0,8191], default 50, ineffective 0 */
+	uint16_t sense_gain_hu;	/**< Sensitivity of vertical edge of U.
+				u13.0, [0,8191], default 50, ineffective 0 */
+	uint16_t sense_gain_hv;	/**< Sensitivity of vertical edge of V.
+				u13.0, [0,8191], default 50, ineffective 0 */
+};
+
+#endif /* __IA_CSS_CNR2_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr_param.h b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr_param.h
new file mode 100644
index 0000000..94186cb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CNRX_PARAM_H
+#define __IA_CSS_CNRX_PARAM_H
+
+#include  "ia_css_cnr2_param.h"
+
+#endif /* __IA_CSS_CNRX_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr_state.h b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr_state.h
new file mode 100644
index 0000000..93b772e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/cnr/cnr_2/ia_css_cnr_state.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CNR2_STATE_H
+#define __IA_CSS_CNR2_STATE_H
+
+#include "type_support.h"
+#include "vmem.h"
+
+typedef struct
+{
+  VMEM_ARRAY(y, (MAX_VECTORS_PER_BUF_LINE/2)*ISP_NWAY);
+  VMEM_ARRAY(u, (MAX_VECTORS_PER_BUF_LINE/2)*ISP_NWAY);
+  VMEM_ARRAY(v, (MAX_VECTORS_PER_BUF_LINE/2)*ISP_NWAY);
+} s_cnr_buf;
+
+/* CNR (color noise reduction) */
+struct sh_css_isp_cnr_vmem_state {
+	s_cnr_buf cnr_buf;
+};
+
+#endif /* __IA_CSS_CNR2_STATE_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c b/drivers/media/atomisp2/css2400/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
new file mode 100644
index 0000000..c0febea
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
@@ -0,0 +1,46 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_frame.h"
+#include "ia_css.h"
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#include "ia_css_copy_output.host.h"
+#include "isp.h"
+
+void
+ia_css_copy_output_config(
+	struct sh_css_isp_copy_output_isp_config      *to,
+	const struct ia_css_copy_output_configuration *from)
+{
+	to->enable = from->output != NULL;
+}
+
+void
+ia_css_copy_output_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *output)
+{
+	const struct ia_css_copy_output_configuration config =
+		{ output };
+	ia_css_configure_copy_output(binary, &config);
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.h b/drivers/media/atomisp2/css2400/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.h
new file mode 100644
index 0000000..aea0028
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_COPY_OUTPUT_HOST_H
+#define __IA_CSS_COPY_OUTPUT_HOST_H
+
+#include "ia_css.h"
+#include "ia_css_binary.h"
+
+#include "ia_css_copy_output_param.h"
+
+void
+ia_css_copy_output_config(
+	struct sh_css_isp_copy_output_isp_config      *to,
+	const struct ia_css_copy_output_configuration *from);
+
+void
+ia_css_copy_output_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *output);
+
+#endif /* __IA_CSS_COPY_OUTPUT_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output_param.h b/drivers/media/atomisp2/css2400/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output_param.h
new file mode 100644
index 0000000..9bc6ce4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output_param.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_COPY_PARAM_H
+#define __IA_CSS_COPY_PARAM_H
+
+struct ia_css_copy_output_configuration {
+	const struct ia_css_frame_info *output;
+};
+
+struct sh_css_isp_copy_output_isp_config {
+	uint32_t enable;
+};
+
+#endif /* __IA_CSS_COPY_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop.host.c b/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
new file mode 100644
index 0000000..8d89d20
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
@@ -0,0 +1,60 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <assert_support.h>
+#include <ia_css_frame_public.h>
+#include <ia_css_frame.h>
+#include <ia_css_binary.h>
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#include "isp.h"
+#include "ia_css_crop.host.h"
+
+void
+ia_css_crop_encode(
+	struct sh_css_isp_crop_isp_params *to,
+	const struct ia_css_crop_config *from)
+{
+	to->crop_pos = from->crop_pos;
+}
+
+void
+ia_css_crop_config(
+	struct sh_css_isp_crop_isp_config *to,
+	const struct ia_css_crop_configuration  *from)
+{
+	unsigned elems_a = ISP_VEC_NELEMS;
+	ia_css_dma_configure_from_info(&to->port_b, from->info);
+	to->width_a_over_b = elems_a / to->port_b.elems;
+
+	/* Assume divisiblity here, may need to generalize to fixed point. */
+	assert (elems_a % to->port_b.elems == 0);
+}
+
+void
+ia_css_crop_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *info)
+{
+	const struct ia_css_crop_configuration config =
+		{ info };
+	ia_css_configure_crop(binary, &config);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop.host.h b/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop.host.h
new file mode 100644
index 0000000..b98d1fb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop.host.h
@@ -0,0 +1,46 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CROP_HOST_H
+#define __IA_CSS_CROP_HOST_H
+
+#include <ia_css_frame_public.h>
+#include <ia_css_binary.h>
+
+#include "ia_css_crop_types.h"
+#include "ia_css_crop_param.h"
+
+void
+ia_css_crop_encode(
+	struct sh_css_isp_crop_isp_params *to,
+	const struct ia_css_crop_config *from);
+
+void
+ia_css_crop_config(
+	struct sh_css_isp_crop_isp_config      *to,
+	const struct ia_css_crop_configuration *from);
+
+void
+ia_css_crop_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *from);
+
+#endif /* __IA_CSS_CROP_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop_param.h b/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop_param.h
new file mode 100644
index 0000000..08475ab
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop_param.h
@@ -0,0 +1,39 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CROP_PARAM_H
+#define __IA_CSS_CROP_PARAM_H
+
+#include <type_support.h>
+#include "dma.h"
+#include "sh_css_internal.h" /* sh_css_crop_pos */
+
+/** Crop frame */
+struct sh_css_isp_crop_isp_config {
+	uint32_t width_a_over_b;
+	struct dma_port_config port_b;
+};
+
+struct sh_css_isp_crop_isp_params {
+	struct sh_css_crop_pos crop_pos;
+};
+
+#endif /* __IA_CSS_CROP_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop_types.h b/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop_types.h
new file mode 100644
index 0000000..583f2ce
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/crop/crop_1.0/ia_css_crop_types.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CROP_TYPES_H
+#define __IA_CSS_CROP_TYPES_H
+
+/** Crop frame
+ *
+ *  ISP block: crop frame
+ */
+
+#include <ia_css_frame_public.h>
+#include "sh_css_uds.h" /* sh_css_crop_pos */
+
+struct ia_css_crop_config {
+	struct sh_css_crop_pos crop_pos;
+};
+
+struct ia_css_crop_configuration {
+	const struct ia_css_frame_info *info;
+};
+
+#endif /* __IA_CSS_CROP_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc.host.c b/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc.host.c
new file mode 100644
index 0000000..2b43fc4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc.host.c
@@ -0,0 +1,128 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_csc.host.h"
+
+const struct ia_css_cc_config default_cc_config = {
+	8,
+	{255, 29, 120, 0, -374, -342, 0, -672, 301},
+};
+
+void
+ia_css_encode_cc(
+	struct sh_css_isp_csc_params *to,
+	const struct ia_css_cc_config *from)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_encode_cc() enter:\n");
+
+	to->m_shift    = (int) from->fraction_bits;
+	to->m00 = (int) from->matrix[0];
+	to->m01 = (int) from->matrix[1];
+	to->m02 = (int) from->matrix[2];
+	to->m10 = (int) from->matrix[3];
+	to->m11 = (int) from->matrix[4];
+	to->m12 = (int) from->matrix[5];
+	to->m20 = (int) from->matrix[6];
+	to->m21 = (int) from->matrix[7];
+	to->m22 = (int) from->matrix[8];
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_encode_cc() leave:\n");
+}
+
+void
+ia_css_csc_encode(
+	struct sh_css_isp_csc_params *to,
+	const struct ia_css_cc_config *from)
+{
+	ia_css_encode_cc(to, from);
+}
+
+void
+ia_css_cc_dump(
+	const struct sh_css_isp_csc_params *csc,
+	unsigned level,
+	const char *name)
+{
+	if (!csc) return;
+	ia_css_debug_dtrace(level, "%s\n", name);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"m_shift",
+		csc->m_shift);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"m00",
+		csc->m00);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"m01",
+		csc->m01);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"m02",
+		csc->m02);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"m10",
+		csc->m10);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"m11",
+		csc->m11);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"m12",
+		csc->m12);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"m20",
+		csc->m20);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"m21",
+		csc->m21);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"m22",
+		csc->m22);
+}
+
+void
+ia_css_csc_dump(
+	const struct sh_css_isp_csc_params *csc,
+	unsigned level)
+{
+	ia_css_cc_dump(csc, level, "Color Space Conversion");
+}
+
+void
+ia_css_cc_config_debug_dtrace(
+	const struct ia_css_cc_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.m[0]=%d, "
+		"config.m[1]=%d, config.m[2]=%d, "
+		"config.m[3]=%d, config.m[4]=%d, "
+		"config.m[5]=%d, config.m[6]=%d, "
+		"config.m[7]=%d, config.m[8]=%d\n",
+		config->matrix[0],
+		config->matrix[1], config->matrix[2],
+		config->matrix[3], config->matrix[4],
+		config->matrix[5], config->matrix[6],
+		config->matrix[7], config->matrix[8]);
+}
+
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc.host.h b/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc.host.h
new file mode 100644
index 0000000..babbac6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc.host.h
@@ -0,0 +1,59 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CSC_HOST_H
+#define __IA_CSS_CSC_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_csc_types.h"
+#include "ia_css_csc_param.h"
+
+extern const struct ia_css_cc_config default_cc_config;
+
+void
+ia_css_encode_cc(
+	struct sh_css_isp_csc_params *to,
+	const struct ia_css_cc_config *from);
+
+void
+ia_css_csc_encode(
+	struct sh_css_isp_csc_params *to,
+	const struct ia_css_cc_config *from);
+
+void
+ia_css_cc_dump(
+	const struct sh_css_isp_csc_params *csc, unsigned level,
+	const char *name);
+
+void
+ia_css_csc_dump(
+	const struct sh_css_isp_csc_params *csc,
+	unsigned level);
+
+void
+ia_css_cc_config_debug_dtrace(
+	const struct ia_css_cc_config *config,
+	unsigned level);
+
+#define ia_css_csc_debug_dtrace ia_css_cc_config_debug_dtrace
+
+#endif /* __IA_CSS_CSC_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc_param.h b/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc_param.h
new file mode 100644
index 0000000..48e9b08
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc_param.h
@@ -0,0 +1,41 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CSC_PARAM_H
+#define __IA_CSS_CSC_PARAM_H
+
+#include "type_support.h"
+/* CSC (Color Space Conversion) */
+struct sh_css_isp_csc_params {
+	uint16_t	m_shift;
+	int16_t		m00;
+	int16_t		m01;
+	int16_t		m02;
+	int16_t		m10;
+	int16_t		m11;
+	int16_t		m12;
+	int16_t		m20;
+	int16_t		m21;
+	int16_t		m22;
+};
+
+
+#endif /* __IA_CSS_CSC_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc_types.h b/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc_types.h
new file mode 100644
index 0000000..e17ade6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/csc/csc_1.0/ia_css_csc_types.h
@@ -0,0 +1,81 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CSC_TYPES_H
+#define __IA_CSS_CSC_TYPES_H
+
+/** Color Correction configuration.
+ *
+ *  This structure is used for 3 cases.
+ *  ("YCgCo" is the output format of Demosaic.)
+ *
+ *  1. Color Space Conversion (YCgCo to YUV) for ISP1.
+ *     ISP block: CSC1 (Color Space Conversion)
+ *     struct ia_css_cc_config   *cc_config
+ *
+ *  2. Color Correction Matrix (YCgCo to RGB) for ISP2.
+ *     ISP block: CCM2 (Color Correction Matrix)
+ *     struct ia_css_cc_config   *yuv2rgb_cc_config
+ *
+ *  3. Color Space Conversion (RGB to YUV) for ISP2.
+ *     ISP block: CSC2 (Color Space Conversion)
+ *     struct ia_css_cc_config   *rgb2yuv_cc_config
+ *
+ *  default/ineffective:
+ *  1. YCgCo -> YUV
+ *  	1	0.174		0.185
+ *  	0	-0.66252	-0.66874
+ *  	0	-0.83738	0.58131
+ *
+ *	fraction_bits = 12
+ *  	4096	713	758
+ *  	0	-2714	-2739
+ *  	0	-3430	2381
+ *
+ *  2. YCgCo -> RGB
+ *  	1	-1	1
+ *  	1	1	0
+ *  	1	-1	-1
+ *
+ *	fraction_bits = 12
+ *  	4096	-4096	4096
+ *  	4096	4096	0
+ *  	4096	-4096	-4096
+ *
+ *  3. RGB -> YUV
+ *	0.299	   0.587	0.114
+ * 	-0.16874   -0.33126	0.5
+ * 	0.5	   -0.41869	-0.08131
+ *
+ *	fraction_bits = 13
+ *  	2449	4809	934
+ *  	-1382	-2714	4096
+ *  	4096	-3430	-666
+ */
+struct ia_css_cc_config {
+	uint32_t fraction_bits;/**< Fractional bits of matrix.
+					u8.0, [0,13] */
+	int32_t matrix[3 * 3]; /**< Conversion matrix.
+					s[13-fraction_bits].[fraction_bits],
+					[-8192,8191] */
+};
+
+#endif /* __IA_CSS_CSC_TYPES_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.c b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.c
new file mode 100644
index 0000000..7e6b343
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.c
@@ -0,0 +1,68 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+
+#include "ia_css_ctc.host.h"
+
+const struct ia_css_ctc_config default_ctc_config = {
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
+	1,
+	SH_CSS_BAYER_MAXVAL / 5,	/* To be implemented */
+	SH_CSS_BAYER_MAXVAL * 2 / 5,	/* To be implemented */
+	SH_CSS_BAYER_MAXVAL * 3 / 5,	/* To be implemented */
+	SH_CSS_BAYER_MAXVAL * 4 / 5,	/* To be implemented */
+};
+
+void
+ia_css_ctc_vamem_encode(
+	struct sh_css_isp_ctc_vamem_params *to,
+	const struct ia_css_ctc_table *from)
+{
+	memcpy (&to->ctc,  &from->data, sizeof(to->ctc));
+}
+
+void
+ia_css_ctc_debug_dtrace(
+	const struct ia_css_ctc_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.ce_gain_exp=%d, config.y0=%d, "
+		"config.x1=%d, config.y1=%d, "
+		"config.x2=%d, config.y2=%d, "
+		"config.x3=%d, config.y3=%d, "
+		"config.x4=%d, config.y4=%d\n",
+		config->ce_gain_exp, config->y0,
+		config->x1, config->y1,
+		config->x2, config->y2,
+		config->x3, config->y3,
+		config->x4, config->y4);
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h
new file mode 100644
index 0000000..e2c6378
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC_HOST_H
+#define __IA_CSS_CTC_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_ctc_param.h"
+#include "ia_css_ctc_table.host.h"
+
+extern const struct ia_css_ctc_config default_ctc_config;
+
+void
+ia_css_ctc_vamem_encode(
+	struct sh_css_isp_ctc_vamem_params *to,
+	const struct ia_css_ctc_table *from);
+
+void
+ia_css_ctc_debug_dtrace(
+	const struct ia_css_ctc_config *config, unsigned level)
+;
+
+#endif /* __IA_CSS_CTC_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_param.h b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_param.h
new file mode 100644
index 0000000..2e55019
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_param.h
@@ -0,0 +1,51 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC_PARAM_H
+#define __IA_CSS_CTC_PARAM_H
+
+#include "type_support.h"
+#include <system_global.h>
+
+#include "ia_css_ctc_types.h"
+
+#ifndef PIPE_GENERATION
+#if defined(HAS_VAMEM_VERSION_2)
+#define SH_CSS_ISP_CTC_TABLE_SIZE_LOG2       IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_CTC_TABLE_SIZE            IA_CSS_VAMEM_2_CTC_TABLE_SIZE
+#elif defined(HAS_VAMEM_VERSION_1)
+#define SH_CSS_ISP_CTC_TABLE_SIZE_LOG2       IA_CSS_VAMEM_1_CTC_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_CTC_TABLE_SIZE            IA_CSS_VAMEM_1_CTC_TABLE_SIZE
+#else
+#error "VAMEM should be {VERSION1, VERSION2}"
+#endif
+
+#else
+/* For pipe generation, the size is not relevant */
+#define SH_CSS_ISP_CTC_TABLE_SIZE 0
+#endif
+
+/* This should be vamem_data_t, but that breaks the pipe generator */
+struct sh_css_isp_ctc_vamem_params {
+	uint16_t ctc[SH_CSS_ISP_CTC_TABLE_SIZE];
+};
+
+#endif /* __IA_CSS_CTC_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_table.host.c b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_table.host.c
new file mode 100644
index 0000000..0c7025c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_table.host.c
@@ -0,0 +1,222 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <type_support.h>
+#include <string_support.h> /* memcpy */
+#include "system_global.h"
+#include "vamem.h"
+#include "ia_css_types.h"
+#include "ia_css_ctc_table.host.h"
+
+struct ia_css_ctc_table       default_ctc_table;
+
+#if defined(HAS_VAMEM_VERSION_2)
+
+static const uint16_t
+default_ctc_table_data[IA_CSS_VAMEM_2_CTC_TABLE_SIZE] = {
+   0,  384,  837,  957, 1011, 1062, 1083, 1080,
+1078, 1077, 1053, 1039, 1012,  992,  969,  951,
+ 929,  906,  886,  866,  845,  823,  809,  790,
+ 772,  758,  741,  726,  711,  701,  688,  675,
+ 666,  656,  648,  639,  633,  626,  618,  612,
+ 603,  594,  582,  572,  557,  545,  529,  516,
+ 504,  491,  480,  467,  459,  447,  438,  429,
+ 419,  412,  404,  397,  389,  382,  376,  368,
+ 363,  357,  351,  345,  340,  336,  330,  326,
+ 321,  318,  312,  308,  304,  300,  297,  294,
+ 291,  286,  284,  281,  278,  275,  271,  268,
+ 261,  257,  251,  245,  240,  235,  232,  225,
+ 223,  218,  213,  209,  206,  204,  199,  197,
+ 193,  189,  186,  185,  183,  179,  177,  175,
+ 172,  170,  169,  167,  164,  164,  162,  160,
+ 158,  157,  156,  154,  154,  152,  151,  150,
+ 149,  148,  146,  147,  146,  144,  143,  143,
+ 142,  141,  140,  141,  139,  138,  138,  138,
+ 137,  136,  136,  135,  134,  134,  134,  133,
+ 132,  132,  131,  130,  131,  130,  129,  128,
+ 129,  127,  127,  127,  127,  125,  125,  125,
+ 123,  123,  122,  120,  118,  115,  114,  111,
+ 110,  108,  106,  105,  103,  102,  100,   99,
+  97,   97,   96,   95,   94,   93,   93,   91,
+  91,   91,   90,   90,   89,   89,   88,   88,
+  89,   88,   88,   87,   87,   87,   87,   86,
+  87,   87,   86,   87,   86,   86,   84,   84,
+  82,   80,   78,   76,   74,   72,   70,   68,
+  67,   65,   62,   60,   58,   56,   55,   54,
+  53,   51,   49,   49,   47,   45,   45,   45,
+  41,   40,   39,   39,   34,   33,   34,   32,
+  25,   23,   24,   20,   13,    9,   12,    0,
+   0
+};
+
+#elif defined(HAS_VAMEM_VERSION_1)
+
+/* Default Parameters */
+static const uint16_t
+default_ctc_table_data[IA_CSS_VAMEM_1_CTC_TABLE_SIZE] = {
+		0, 0, 256, 384, 384, 497, 765, 806,
+		837, 851, 888, 901, 957, 981, 993, 1001,
+		1011, 1029, 1028, 1039, 1062, 1059, 1073, 1080,
+		1083, 1085, 1085, 1098, 1080, 1084, 1085, 1093,
+		1078, 1073, 1070, 1069, 1077, 1066, 1072, 1063,
+		1053, 1044, 1046, 1053, 1039, 1028, 1025, 1024,
+		1012, 1013, 1016, 996, 992, 990, 990, 980,
+		969, 968, 961, 955, 951, 949, 933, 930,
+		929, 925, 921, 916, 906, 901, 895, 893,
+		886, 877, 872, 869, 866, 861, 857, 849,
+		845, 838, 836, 832, 823, 821, 815, 813,
+		809, 805, 796, 793, 790, 785, 784, 778,
+		772, 768, 766, 763, 758, 752, 749, 745,
+		741, 740, 736, 730, 726, 724, 723, 718,
+		711, 709, 706, 704, 701, 698, 691, 689,
+		688, 683, 683, 678, 675, 673, 671, 669,
+		666, 663, 661, 660, 656, 656, 653, 650,
+		648, 647, 646, 643, 639, 638, 637, 635,
+		633, 632, 629, 627, 626, 625, 622, 621,
+		618, 618, 614, 614, 612, 609, 606, 606,
+		603, 600, 600, 597, 594, 591, 590, 586,
+		582, 581, 578, 575, 572, 569, 563, 560,
+		557, 554, 551, 548, 545, 539, 536, 533,
+		529, 527, 524, 519, 516, 513, 510, 507,
+		504, 501, 498, 493, 491, 488, 485, 484,
+		480, 476, 474, 471, 467, 466, 464, 460,
+		459, 455, 453, 449, 447, 446, 443, 441,
+		438, 435, 432, 432, 429, 427, 426, 422,
+		419, 418, 416, 414, 412, 410, 408, 406,
+		404, 402, 401, 398, 397, 395, 393, 390,
+		389, 388, 387, 384, 382, 380, 378, 377,
+		376, 375, 372, 370, 368, 368, 366, 364,
+		363, 361, 360, 358, 357, 355, 354, 352,
+		351, 350, 349, 346, 345, 344, 344, 342,
+		340, 339, 337, 337, 336, 335, 333, 331,
+		330, 329, 328, 326, 326, 324, 324, 322,
+		321, 320, 318, 318, 318, 317, 315, 313,
+		312, 311, 311, 310, 308, 307, 306, 306,
+		304, 304, 302, 301, 300, 300, 299, 297,
+		297, 296, 296, 294, 294, 292, 291, 291,
+		291, 290, 288, 287, 286, 286, 287, 285,
+		284, 283, 282, 282, 281, 281, 279, 278,
+		278, 278, 276, 276, 275, 274, 274, 273,
+		271, 270, 269, 268, 268, 267, 265, 262,
+		261, 260, 260, 259, 257, 254, 252, 252,
+		251, 251, 249, 246, 245, 244, 243, 242,
+		240, 239, 239, 237, 235, 235, 233, 231,
+		232, 230, 229, 226, 225, 224, 225, 224,
+		223, 220, 219, 219, 218, 217, 217, 214,
+		213, 213, 212, 211, 209, 209, 209, 208,
+		206, 205, 204, 203, 204, 203, 201, 200,
+		199, 197, 198, 198, 197, 195, 194, 194,
+		193, 192, 192, 191, 189, 190, 189, 188,
+		186, 187, 186, 185, 185, 184, 183, 181,
+		183, 182, 181, 180, 179, 178, 178, 178,
+		177, 176, 175, 176, 175, 174, 174, 173,
+		172, 173, 172, 171, 170, 170, 169, 169,
+		169, 168, 167, 166, 167, 167, 166, 165,
+		164, 164, 164, 163, 164, 163, 162, 163,
+		162, 161, 160, 161, 160, 160, 160, 159,
+		158, 157, 158, 158, 157, 157, 156, 156,
+		156, 156, 155, 155, 154, 154, 154, 154,
+		154, 153, 152, 153, 152, 152, 151, 152,
+		151, 152, 151, 150, 150, 149, 149, 150,
+		149, 149, 148, 148, 148, 149, 148, 147,
+		146, 146, 147, 146, 147, 146, 145, 146,
+		146, 145, 144, 145, 144, 145, 144, 144,
+		143, 143, 143, 144, 143, 142, 142, 142,
+		142, 142, 142, 141, 141, 141, 141, 140,
+		140, 141, 140, 140, 141, 140, 139, 139,
+		139, 140, 139, 139, 138, 138, 137, 139,
+		138, 138, 138, 137, 138, 137, 137, 137,
+		137, 136, 137, 136, 136, 136, 136, 135,
+		136, 135, 135, 135, 135, 136, 135, 135,
+		134, 134, 133, 135, 134, 134, 134, 133,
+		134, 133, 134, 133, 133, 132, 133, 133,
+		132, 133, 132, 132, 132, 132, 131, 131,
+		131, 132, 131, 131, 130, 131, 130, 132,
+		131, 130, 130, 129, 130, 129, 130, 129,
+		129, 129, 130, 129, 128, 128, 128, 128,
+		129, 128, 128, 127, 127, 128, 128, 127,
+		127, 126, 126, 127, 127, 126, 126, 126,
+		127, 126, 126, 126, 125, 125, 126, 125,
+		125, 124, 124, 124, 125, 125, 124, 124,
+		123, 124, 124, 123, 123, 122, 122, 122,
+		122, 122, 121, 120, 120, 119, 118, 118,
+		118, 117, 117, 116, 115, 115, 115, 114,
+		114, 113, 113, 112, 111, 111, 111, 110,
+		110, 109, 109, 108, 108, 108, 107, 107,
+		106, 106, 105, 105, 105, 104, 104, 103,
+		103, 102, 102, 102, 102, 101, 101, 100,
+		100, 99, 99, 99, 99, 99, 99, 98,
+		97, 98, 97, 97, 97, 96, 96, 95,
+		96, 95, 96, 95, 95, 94, 94, 95,
+		94, 94, 94, 93, 93, 92, 93, 93,
+		93, 93, 92, 92, 91, 92, 92, 92,
+		91, 91, 90, 90, 91, 91, 91, 90,
+		90, 90, 90, 91, 90, 90, 90, 89,
+		89, 89, 90, 89, 89, 89, 89, 89,
+		88, 89, 89, 88, 88, 88, 88, 87,
+		89, 88, 88, 88, 88, 88, 87, 88,
+		88, 88, 87, 87, 87, 87, 87, 88,
+		87, 87, 87, 87, 87, 87, 88, 87,
+		87, 87, 87, 86, 86, 87, 87, 87,
+		87, 86, 86, 86, 87, 87, 86, 87,
+		86, 86, 86, 87, 87, 86, 86, 86,
+		86, 86, 87, 87, 86, 85, 85, 85,
+		84, 85, 85, 84, 84, 83, 83, 82,
+		82, 82, 81, 81, 80, 79, 79, 79,
+		78, 77, 77, 76, 76, 76, 75, 74,
+		74, 74, 73, 73, 72, 71, 71, 71,
+		70, 70, 69, 69, 68, 68, 67, 67,
+		67, 66, 66, 65, 65, 64, 64, 63,
+		62, 62, 62, 61, 60, 60, 59, 59,
+		58, 58, 57, 57, 56, 56, 56, 55,
+		55, 54, 55, 55, 54, 53, 53, 52,
+		53, 53, 52, 51, 51, 50, 51, 50,
+		49, 49, 50, 49, 49, 48, 48, 47,
+		47, 48, 46, 45, 45, 45, 46, 45,
+		45, 44, 45, 45, 45, 43, 42, 42,
+		41, 43, 41, 40, 40, 39, 40, 41,
+		39, 39, 39, 39, 39, 38, 35, 35,
+		34, 37, 36, 34, 33, 33, 33, 35,
+		34, 32, 32, 31, 32, 30, 29, 26,
+		25, 25, 27, 26, 23, 23, 23, 25,
+		24, 24, 22, 21, 20, 19, 16, 14,
+		13, 13, 13, 10, 9, 7, 7, 7,
+		12, 12, 12, 7, 0, 0, 0, 0
+};
+
+#else
+#error "VAMEM version must be one of {VAMEM_VERSION_1, VAMEM_VERSION_2}"
+#endif
+
+void
+ia_css_config_ctc_table(void)
+{
+#if defined(HAS_VAMEM_VERSION_2)
+	memcpy(default_ctc_table.data.vamem_2, default_ctc_table_data,
+	       sizeof(default_ctc_table_data));
+	default_ctc_table.vamem_type     = IA_CSS_VAMEM_TYPE_2;
+#else
+	memcpy(default_ctc_table.data.vamem_1, default_ctc_table_data,
+	       sizeof(default_ctc_table_data));
+	default_ctc_table.vamem_type     = 1IA_CSS_VAMEM_TYPE_1;
+#endif
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_table.host.h b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_table.host.h
new file mode 100644
index 0000000..e207f33
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_table.host.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC_TABLE_HOST_H
+#define __IA_CSS_CTC_TABLE_HOST_H
+
+#include "ia_css_ctc_types.h"
+
+extern struct ia_css_ctc_table default_ctc_table;
+
+void ia_css_config_ctc_table(void);
+
+#endif /* __IA_CSS_CTC_TABLE_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h
new file mode 100644
index 0000000..732956c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_1.0/ia_css_ctc_types.h
@@ -0,0 +1,111 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC_TYPES_H
+#define __IA_CSS_CTC_TYPES_H
+
+/** Fractional bits for CTC gain (used only for ISP1).
+ *
+ *  IA_CSS_CTC_COEF_SHIFT(=13) includes not only the fractional bits
+ *  of gain(=8), but also the bits(=5) to convert chroma
+ *  from 13bit precision to 8bit precision.
+ *
+ *    Gain (struct ia_css_ctc_table) : u5.8
+ *    Input(Chorma) : s0.12 (13bit precision)
+ *    Output(Chorma): s0.7  (8bit precision)
+ *    Output = (Input * Gain) >> IA_CSS_CTC_COEF_SHIFT
+ */
+#define IA_CSS_CTC_COEF_SHIFT          13
+
+/** Number of elements in the CTC table. */
+#define IA_CSS_VAMEM_1_CTC_TABLE_SIZE_LOG2      10
+#define IA_CSS_VAMEM_1_CTC_TABLE_SIZE           (1U<<IA_CSS_VAMEM_1_CTC_TABLE_SIZE_LOG2)
+
+/** Number of elements in the CTC table. */
+#define IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2      8
+#define IA_CSS_VAMEM_2_CTC_TABLE_SIZE           ((1U<<IA_CSS_VAMEM_2_CTC_TABLE_SIZE_LOG2) + 1)
+
+enum ia_css_vamem_type {
+	IA_CSS_VAMEM_TYPE_1,
+	IA_CSS_VAMEM_TYPE_2
+};
+
+/** Chroma Tone Control configuration.
+ *
+ *  ISP block: CTC2 (CTC by polygonal line approximation)
+ * (ISP1: CTC1 (CTC by look-up table) is used.)
+ *  ISP2: CTC2 is used.
+ */
+struct ia_css_ctc_config {
+	uint16_t y0;	/**< 1st kneepoint gain.
+				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
+				default/ineffective 4096(0.5) */
+	uint16_t y1;	/**< 2nd kneepoint gain.
+				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
+				default/ineffective 4096(0.5) */
+	uint16_t y2;	/**< 3rd kneepoint gain.
+				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
+				default/ineffective 4096(0.5) */
+	uint16_t y3;	/**< 4th kneepoint gain.
+				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
+				default/ineffective 4096(0.5) */
+	uint16_t y4;	/**< 5th kneepoint gain.
+				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
+				default/ineffective 4096(0.5) */
+	uint16_t y5;	/**< 6th kneepoint gain.
+				u[ce_gain_exp].[13-ce_gain_exp], [0,8191],
+				default/ineffective 4096(0.5) */
+	uint16_t ce_gain_exp;	/**< Common exponent of y-axis gain.
+				u8.0, [0,13],
+				default/ineffective 1 */
+	uint16_t x1;	/**< 2nd kneepoint luma.
+				u0.13, [0,8191], constraints: 0<x1<x2,
+				default/ineffective 1024 */
+	uint16_t x2;	/**< 3rd kneepoint luma.
+				u0.13, [0,8191], constraints: x1<x2<x3,
+				default/ineffective 2048 */
+	uint16_t x3;	/**< 4th kneepoint luma.
+				u0.13, [0,8191], constraints: x2<x3<x4,
+				default/ineffective 6144 */
+	uint16_t x4;	/**< 5tn kneepoint luma.
+				u0.13, [0,8191], constraints: x3<x4<8191,
+				default/ineffective 7168 */
+};
+
+union ia_css_ctc_data {
+	uint16_t vamem_1[IA_CSS_VAMEM_1_CTC_TABLE_SIZE];
+	uint16_t vamem_2[IA_CSS_VAMEM_2_CTC_TABLE_SIZE];
+};
+
+/** CTC table, used for Chroma Tone Control.
+ *
+ *  ISP block: CTC1 (CTC by look-up table)
+ *  ISP1: CTC1 is used.
+ * (ISP2: CTC2 (CTC by polygonal line approximation) is used.)
+ */
+struct ia_css_ctc_table {
+	enum ia_css_vamem_type vamem_type;
+	union ia_css_ctc_data data;
+};
+
+#endif /* __IA_CSS_CTC_TYPES_H */
+
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc2.host.c b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc2.host.c
new file mode 100644
index 0000000..790f3bb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc2.host.c
@@ -0,0 +1,118 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+
+#include "ctc/ctc_1.0/ia_css_ctc.host.h"
+#include "ia_css_ctc2.host.h"
+
+static void ctc_gradient(
+	int *dydx, int *shift,
+	int y1, int y0, int x1, int x0)
+{
+	int frc_bits = max(IA_CSS_CTC_COEF_SHIFT, 16);
+	int dy = y1 - y0;
+	int dx = x1 - x0;
+	int dydx_int = dy / dx;
+	int dydx_frc = ((dy - dydx_int * dx) << frc_bits) / dx;
+	int sft;
+
+	/* max_dydx = the maxinum gradient = the maximum y (gain) */
+	int max_dydx = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;
+
+	assert(y0 >= 0 && y0 <= max_dydx);
+	assert(y1 >= 0 && y1 <= max_dydx);
+	assert(x0 < x1);
+	assert(dydx != NULL);
+	assert(shift != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() enter:\n");
+
+	/* search "sft" which meets this condition:
+		   (1 << (IA_CSS_CTC_COEF_SHIFT - 1))
+		<= (((float)dy / (float)dx) * (1 << sft))
+		<= ((1 << IA_CSS_CTC_COEF_SHIFT) - 1) */
+	for (sft = 0; sft <= IA_CSS_CTC_COEF_SHIFT; sft++) {
+		int tmp_dydx = (dydx_int << sft)
+			     + (dydx_frc >> (frc_bits - sft));
+		if (tmp_dydx <= max_dydx) {
+			*dydx = tmp_dydx;
+			*shift = sft;
+		}
+		if (tmp_dydx >= max_dydx)
+			break;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() leave:\n");
+}
+
+void
+ia_css_ctc_encode(
+	struct sh_css_isp_ctc_params *to,
+	const struct ia_css_ctc_config *from)
+{
+	to->y0 = from->y0;
+	to->y1 = from->y1;
+	to->y2 = from->y2;
+	to->y3 = from->y3;
+	to->y4 = from->y4;
+	to->y5 = from->y5;
+
+	to->ce_gain_exp = from->ce_gain_exp;
+
+	to->x1 = from->x1;
+	to->x2 = from->x2;
+	to->x3 = from->x3;
+	to->x4 = from->x4;
+
+	ctc_gradient(&(to->dydx0),
+		     &(to->dydx0_shift),
+		     from->y1, from->y0,
+		     from->x1, 0);
+
+	ctc_gradient(&(to->dydx1),
+		     &(to->dydx1_shift),
+		     from->y2, from->y1,
+		     from->x2, from->x1);
+
+	ctc_gradient(&to->dydx2,
+		     &to->dydx2_shift,
+		     from->y3, from->y2,
+		     from->x3, from->x2);
+
+	ctc_gradient(&to->dydx3,
+		     &to->dydx3_shift,
+		     from->y4, from->y3,
+		     from->x4, from->x3);
+
+	ctc_gradient(&(to->dydx4),
+		     &(to->dydx4_shift),
+		     from->y5, from->y4,
+		     SH_CSS_BAYER_MAXVAL, from->x4);
+}
+
+void
+ia_css_ctc_dump(
+	const struct sh_css_isp_ctc_params *ctc,
+	unsigned level);
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc2.host.h b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc2.host.h
new file mode 100644
index 0000000..64e8b36
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc2.host.h
@@ -0,0 +1,39 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC2_HOST_H
+#define __IA_CSS_CTC2_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_ctc2_param.h"
+
+void
+ia_css_ctc_encode(
+	struct sh_css_isp_ctc_params *to,
+	const struct ia_css_ctc_config *from);
+
+void
+ia_css_ctc_dump(
+	const struct sh_css_isp_ctc_params *ctc,
+	unsigned level);
+
+#endif /* __IA_CSS_CTC2_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc2_param.h b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc2_param.h
new file mode 100644
index 0000000..bb334c0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc2_param.h
@@ -0,0 +1,53 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC2_PARAM_H
+#define __IA_CSS_CTC2_PARAM_H
+
+#include "type_support.h"
+#include "ctc/ctc_1.0/ia_css_ctc_param.h" /* vamem params */
+
+/* CTC (Color Tone Control) */
+struct sh_css_isp_ctc_params {
+	int32_t y0;
+	int32_t y1;
+	int32_t y2;
+	int32_t y3;
+	int32_t y4;
+	int32_t y5;
+	int32_t ce_gain_exp;
+	int32_t x1;
+	int32_t x2;
+	int32_t x3;
+	int32_t x4;
+	int32_t dydx0;
+	int32_t dydx0_shift;
+	int32_t dydx1;
+	int32_t dydx1_shift;
+	int32_t dydx2;
+	int32_t dydx2_shift;
+	int32_t dydx3;
+	int32_t dydx3_shift;
+	int32_t dydx4;
+	int32_t dydx4_shift;
+};
+
+#endif /* __IA_CSS_CTC2_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc_param.h b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc_param.h
new file mode 100644
index 0000000..79c86da
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ctc/ctc_2/ia_css_ctc_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTCX_PARAM_H
+#define __IA_CSS_CTCX_PARAM_H
+
+#include "ia_css_ctc2_param.h"
+
+#endif /* __IA_CSS_CTCX_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de.host.c b/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de.host.c
new file mode 100644
index 0000000..5794e2d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de.host.c
@@ -0,0 +1,82 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_frac.h"
+#include "ia_css_de.host.h"
+
+const struct ia_css_de_config default_de_config = {
+	0,
+	0,
+	0
+};
+
+void
+ia_css_de_encode(
+	struct sh_css_isp_de_params *to,
+	const struct ia_css_de_config *from)
+{
+	to->pixelnoise =
+	    uDIGIT_FITTING(from->pixelnoise, 16, SH_CSS_BAYER_BITS);
+	to->c1_coring_threshold =
+	    uDIGIT_FITTING(from->c1_coring_threshold, 16,
+			   SH_CSS_BAYER_BITS);
+	to->c2_coring_threshold =
+	    uDIGIT_FITTING(from->c2_coring_threshold, 16,
+			   SH_CSS_BAYER_BITS);
+}
+
+void
+ia_css_de_dump(
+	const struct sh_css_isp_de_params *de,
+	unsigned level)
+{
+	if (!de) return;
+	ia_css_debug_dtrace(level, "Demosaic:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"de_pixelnoise", de->pixelnoise);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"de_c1_coring_threshold",
+			de->c1_coring_threshold);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"de_c2_coring_threshold",
+			de->c2_coring_threshold);
+}
+
+void
+ia_css_de_debug_dtrace(
+	const struct ia_css_de_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.pixelnoise=%d, "
+		"config.c1_coring_threshold=%d, config.c2_coring_threshold=%d\n",
+		config->pixelnoise,
+		config->c1_coring_threshold, config->c2_coring_threshold);
+}
+
+void
+ia_css_init_de_state(void/*struct sh_css_isp_de_vmem_state *state*/)
+{
+	//memset(state, 0, sizeof(*state));
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de.host.h b/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de.host.h
new file mode 100644
index 0000000..e9e73d6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de.host.h
@@ -0,0 +1,49 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DE_HOST_H
+#define __IA_CSS_DE_HOST_H
+
+#include "ia_css_de_types.h"
+#include "ia_css_de_param.h"
+
+extern const struct ia_css_de_config default_de_config;
+
+void
+ia_css_de_encode(
+	struct sh_css_isp_de_params *to,
+	const struct ia_css_de_config *from);
+
+void
+ia_css_de_dump(
+	const struct sh_css_isp_de_params *de,
+	unsigned level);
+
+void
+ia_css_de_debug_dtrace(
+	const struct ia_css_de_config *config,
+	unsigned level);
+
+void
+ia_css_init_de_state(
+	void/*struct sh_css_isp_de_vmem_state *state*/);
+
+#endif /* __IA_CSS_DE_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de_param.h b/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de_param.h
new file mode 100644
index 0000000..e80a3d5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de_param.h
@@ -0,0 +1,34 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DE_PARAM_H
+#define __IA_CSS_DE_PARAM_H
+
+#include "type_support.h"
+
+/* DE (Demosaic) */
+struct sh_css_isp_de_params {
+	int32_t pixelnoise;
+	int32_t c1_coring_threshold;
+	int32_t c2_coring_threshold;
+};
+
+#endif /* __IA_CSS_DE_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de_state.h b/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de_state.h
new file mode 100644
index 0000000..46a8e1c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de_state.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DE_STATE_H
+#define __IA_CSS_DE_STATE_H
+
+#include "type_support.h"
+#include "vmem.h"
+
+/* DE (Demosaic) */
+struct sh_css_isp_de_vmem_state {
+	VMEM_ARRAY(de_buf[4], MAX_VECTORS_PER_BUF_LINE*ISP_NWAY);
+};
+
+#endif /* __IA_CSS_DE_STATE_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de_types.h b/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de_types.h
new file mode 100644
index 0000000..ee8936b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_1.0/ia_css_de_types.h
@@ -0,0 +1,46 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DE_TYPES_H
+#define __IA_CSS_DE_TYPES_H
+
+/** Demosaic (bayer-to-YCgCo) configuration.
+ *
+ *  ISP block: DE1
+ *  ISP1: DE1 is used.
+ * (ISP2: DE2 is used.)
+ */
+struct ia_css_de_config {
+	ia_css_u0_16 pixelnoise; /**< Pixel noise used in moire elimination.
+				u0.16, [0,65535],
+				default 0, ineffective 0 */
+	ia_css_u0_16 c1_coring_threshold; /**< Coring threshold for C1.
+				This is the same as nr_config.threshold_cb.
+				u0.16, [0,65535],
+				default 128(0.001953125), ineffective 0 */
+	ia_css_u0_16 c2_coring_threshold; /**< Coring threshold for C2.
+				This is the same as nr_config.threshold_cr.
+				u0.16, [0,65535],
+				default 128(0.001953125), ineffective 0 */
+};
+
+#endif /* __IA_CSS_DE_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2.host.c b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2.host.c
new file mode 100644
index 0000000..1dfbe09
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2.host.c
@@ -0,0 +1,59 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_de2.host.h"
+
+const struct ia_css_ecd_config default_ecd_config = {
+	(1 << (ISP_VEC_ELEMBITS - 1)) * 2 / 3,	/* 2/3 */
+	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1.0 */
+	0,					/* 0.0 */
+};
+
+void
+ia_css_ecd_encode(
+	struct sh_css_isp_ecd_params *to,
+	const struct ia_css_ecd_config *from)
+{
+	to->zip_strength = from->zip_strength;
+	to->fc_strength  = from->fc_strength;
+	to->fc_debias    = from->fc_debias;
+}
+
+void
+ia_css_ecd_dump(
+	const struct sh_css_isp_ecd_params *ecd,
+	unsigned level);
+
+void
+ia_css_ecd_debug_dtrace(
+	const struct ia_css_ecd_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.zip_strength=%d, "
+		"config.fc_strength=%d, config.fc_debias=%d\n",
+		config->zip_strength,
+		config->fc_strength, config->fc_debias);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2.host.h b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2.host.h
new file mode 100644
index 0000000..e9e148a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2.host.h
@@ -0,0 +1,44 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DE2_HOST_H
+#define __IA_CSS_DE2_HOST_H
+
+#include "ia_css_de2_types.h"
+#include "ia_css_de2_param.h"
+
+extern const struct ia_css_ecd_config default_ecd_config;
+
+void
+ia_css_ecd_encode(
+	struct sh_css_isp_ecd_params *to,
+	const struct ia_css_ecd_config *from);
+
+void
+ia_css_ecd_dump(
+	const struct sh_css_isp_ecd_params *ecd,
+	unsigned level);
+
+void
+ia_css_ecd_debug_dtrace(
+	const struct ia_css_ecd_config *config, unsigned level);
+
+#endif /* __IA_CSS_DE2_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2_param.h b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2_param.h
new file mode 100644
index 0000000..3cd9f90
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2_param.h
@@ -0,0 +1,37 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DE2_PARAM_H
+#define __IA_CSS_DE2_PARAM_H
+
+#include "type_support.h"
+
+/* Reuse DE1 params and extend them */
+#include "../de_1.0/ia_css_de_param.h"
+
+/* DE (Demosaic) */
+struct sh_css_isp_ecd_params {
+	int32_t zip_strength;
+	int32_t fc_strength;
+	int32_t fc_debias;
+};
+
+#endif /* __IA_CSS_DE2_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2_types.h b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2_types.h
new file mode 100644
index 0000000..f582bc1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de2_types.h
@@ -0,0 +1,45 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DE2_TYPES_H
+#define __IA_CSS_DE2_TYPES_H
+
+/** Eigen Color Demosaicing configuration.
+ *
+ *  ISP block: DE2
+ * (ISP1: DE1 is used.)
+ *  ISP2: DE2 is used.
+ */
+struct ia_css_ecd_config {
+	uint16_t zip_strength;	/**< Strength of zipper reduction.
+				u0.13, [0,8191],
+				default 5489(0.67), ineffective 0 */
+	uint16_t fc_strength;	/**< Strength of false color reduction.
+				u0.13, [0,8191],
+				default 8191(almost 1.0), ineffective 0 */
+	uint16_t fc_debias;	/**< Prevent color change
+				     on noise or Gr/Gb imbalance.
+				u0.13, [0,8191],
+				default 0, ineffective 0 */
+};
+
+#endif /* __IA_CSS_DE2_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de_param.h b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de_param.h
new file mode 100644
index 0000000..3a37af8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DEX_PARAM_H
+#define __IA_CSS_DEX_PARAM_H
+
+#include "ia_css_de2_param.h"
+
+#endif /* __IA_CSS_DEX_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de_state.h b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de_state.h
new file mode 100644
index 0000000..7d82dbf
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/de/de_2/ia_css_de_state.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DE2_STATE_H
+#define __IA_CSS_DE2_STATE_H
+
+/* Reuse DE1 states */
+#include "../de_1.0/ia_css_de_state.h"
+
+#endif /* __IA_CSS_DE2_STATE_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp.host.c b/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp.host.c
new file mode 100644
index 0000000..635f2df
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp.host.c
@@ -0,0 +1,120 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_frac.h"
+
+#include "ia_css_dp.host.h"
+
+const struct ia_css_dp_config default_dp_config = {
+	8192,
+	2048,
+	32768,
+	32768,
+	32768,
+	32768
+};
+
+void
+ia_css_dp_encode(
+	struct sh_css_isp_dp_params *to,
+	const struct ia_css_dp_config *from)
+{
+	int gain = from->gain;
+	int gr   = from->gr;
+	int r    = from->r;
+	int b    = from->b;
+	int gb   = from->gb;
+	to->threshold_single =
+	    SH_CSS_BAYER_MAXVAL;
+	to->threshold_2adjacent =
+	    uDIGIT_FITTING(from->threshold, 16, SH_CSS_BAYER_BITS);
+	to->gain =
+	    uDIGIT_FITTING(from->gain, 8, SH_CSS_DP_GAIN_SHIFT);
+
+	to->coef_rr_gr =
+	    uDIGIT_FITTING (gain * gr / r, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_rr_gb =
+	    uDIGIT_FITTING (gain * gb / r, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_bb_gb =
+	    uDIGIT_FITTING (gain * gb / b, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_bb_gr =
+	    uDIGIT_FITTING (gain * gr / b, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_gr_rr =
+	    uDIGIT_FITTING (gain * r / gr, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_gr_bb =
+	    uDIGIT_FITTING (gain * b / gr, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_gb_bb =
+	    uDIGIT_FITTING (gain * b / gb, 8, SH_CSS_DP_GAIN_SHIFT);
+	to->coef_gb_rr =
+	    uDIGIT_FITTING (gain * r / gb, 8, SH_CSS_DP_GAIN_SHIFT);
+}
+
+void
+ia_css_dp_dump(
+	const struct sh_css_isp_dp_params *dp,
+	unsigned level)
+{
+	if (!dp) return;
+	ia_css_debug_dtrace(level, "Defect Pixel Correction:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dp_threshold_single_w_2adj_on",
+		dp->threshold_single);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dp_threshold_2adj_w_2adj_on",
+		dp->threshold_2adjacent);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dp_gain", dp->gain);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dpc_coef_rr_gr", dp->coef_rr_gr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dpc_coef_rr_gb", dp->coef_rr_gb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dpc_coef_bb_gb", dp->coef_bb_gb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dpc_coef_bb_gr", dp->coef_bb_gr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dpc_coef_gr_rr", dp->coef_gr_rr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dpc_coef_gr_bb", dp->coef_gr_bb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dpc_coef_gb_bb", dp->coef_gb_bb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"dpc_coef_gb_rr", dp->coef_gb_rr);
+}
+
+void
+ia_css_dp_debug_dtrace(
+	const struct ia_css_dp_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.threshold=%d, config.gain=%d\n",
+		config->threshold, config->gain);
+}
+
+void
+ia_css_init_dp_state(void/*struct sh_css_isp_dp_vmem_state *state*/)
+{
+	//memset(state, 0, sizeof(*state));
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp.host.h b/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp.host.h
new file mode 100644
index 0000000..37ae931
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp.host.h
@@ -0,0 +1,50 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+
+#ifndef __IA_CSS_DP_HOST_H
+#define __IA_CSS_DP_HOST_H
+
+#include "ia_css_dp_types.h"
+#include "ia_css_dp_param.h"
+
+extern const struct ia_css_dp_config default_dp_config;
+
+void
+ia_css_dp_encode(
+	struct sh_css_isp_dp_params *to,
+	const struct ia_css_dp_config *from);
+
+void
+ia_css_dp_dump(
+	const struct sh_css_isp_dp_params *dp,
+	unsigned level);
+
+void
+ia_css_dp_debug_dtrace(
+	const struct ia_css_dp_config *config,
+	unsigned level);
+
+void
+ia_css_init_dp_state(
+	void/*struct sh_css_isp_dp_vmem_state *state*/);
+
+#endif /* __IA_CSS_DP_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp_param.h b/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp_param.h
new file mode 100644
index 0000000..304d10e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp_param.h
@@ -0,0 +1,43 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DP_PARAM_H
+#define __IA_CSS_DP_PARAM_H
+
+#include "type_support.h"
+#include "bnr/bnr_1.0/ia_css_bnr_param.h"
+
+/* DP (Defect Pixel Correction) */
+struct sh_css_isp_dp_params {
+	int32_t threshold_single;
+	int32_t threshold_2adjacent;
+	int32_t gain;
+	int32_t coef_rr_gr;
+	int32_t coef_rr_gb;
+	int32_t coef_bb_gb;
+	int32_t coef_bb_gr;
+	int32_t coef_gr_rr;
+	int32_t coef_gr_bb;
+	int32_t coef_gb_bb;
+	int32_t coef_gb_rr;
+};
+
+#endif /* __IA_CSS_DP_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp_state.h b/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp_state.h
new file mode 100644
index 0000000..659af56
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp_state.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DP_STATE_H
+#define __IA_CSS_DP_STATE_H
+
+#include "type_support.h"
+
+#include "vmem.h"
+#define MAX_VECTORS_PER_DP_LINE MAX_VECTORS_PER_BUF_LINE
+
+/* DP (Defect Pixel Correction) */
+struct sh_css_isp_dp_vmem_state {
+	VMEM_ARRAY(dp_buf[4], MAX_VECTORS_PER_DP_LINE*ISP_NWAY);
+};
+
+#endif /* __IA_CSS_DP_STATE_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp_types.h b/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp_types.h
new file mode 100644
index 0000000..9dbb608
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/dp/dp_1.0/ia_css_dp_types.h
@@ -0,0 +1,52 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DP_TYPES_H
+#define __IA_CSS_DP_TYPES_H
+
+/** Defect Pixel Correction configuration.
+ *
+ *  ISP block: DPC1 (DPC after WB)
+ *             DPC2 (DPC before WB)
+ *  ISP1: DPC1 is used.
+ *  ISP2: DPC2 is used.
+ */
+struct ia_css_dp_config {
+	ia_css_u0_16 threshold; /**< The threshold of defect pixel correction,
+			      representing the permissible difference of
+			      intensity between one pixel and its
+			      surrounding pixels. Smaller values result
+				in more frequent pixel corrections.
+				u0.16, [0,65535],
+				default 8192, ineffective 65535 */
+	ia_css_u8_8 gain;	 /**< The sensitivity of mis-correction. ISP will
+			      miss a lot of defects if the value is set
+				too large.
+				u8.8, [0,65535],
+				default 4096, ineffective 65535 */
+	uint32_t gr;	/* unsigned <integer_bits>.<16-integer_bits> */
+	uint32_t r;	/* unsigned <integer_bits>.<16-integer_bits> */
+	uint32_t b;	/* unsigned <integer_bits>.<16-integer_bits> */
+	uint32_t gb;	/* unsigned <integer_bits>.<16-integer_bits> */
+};
+
+#endif /* __IA_CSS_DP_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c b/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
new file mode 100644
index 0000000..b279e1d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
@@ -0,0 +1,51 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_frame.h"
+#include "math_support.h"
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+
+#include "sh_css_param_dvs.h"
+
+#include "ia_css_dvs.host.h"
+
+
+void
+ia_css_dvs_config(
+	struct sh_css_isp_dvs_isp_config *to,
+	const struct ia_css_dvs_configuration  *from)
+{
+	to->num_horizontal_blocks =
+	    DVS_NUM_BLOCKS_X(from->info->res.width);
+	to->num_vertical_blocks =
+	    DVS_NUM_BLOCKS_Y(from->info->res.height);
+}
+
+void
+ia_css_dvs_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *info)
+{
+	const struct ia_css_dvs_configuration config =
+		{ info };
+	ia_css_configure_dvs(binary, &config);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h b/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
new file mode 100644
index 0000000..020d51a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
@@ -0,0 +1,41 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DVS_HOST_H
+#define __IA_CSS_DVS_HOST_H
+
+#include "ia_css.h"
+#include "ia_css_binary.h"
+
+#include "ia_css_dvs_types.h"
+#include "ia_css_dvs_param.h"
+
+void
+ia_css_dvs_config(
+	struct sh_css_isp_dvs_isp_config      *to,
+	const struct ia_css_dvs_configuration *from);
+
+void
+ia_css_dvs_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *from);
+
+#endif /* __IA_CSS_DVS_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs_param.h b/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs_param.h
new file mode 100644
index 0000000..f4e1f35
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs_param.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DVS_PARAM_H
+#define __IA_CSS_DVS_PARAM_H
+
+#include <type_support.h>
+#include "dma.h"
+#include "uds/uds_1.0/ia_css_uds_param.h"
+
+/** dvserence frame */
+struct sh_css_isp_dvs_isp_config {
+	uint32_t num_horizontal_blocks;
+	uint32_t num_vertical_blocks;
+};
+
+#endif /* __IA_CSS_DVS_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs_types.h b/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs_types.h
new file mode 100644
index 0000000..31a2289
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/dvs/dvs_1.0/ia_css_dvs_types.h
@@ -0,0 +1,37 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_DVS_TYPES_H
+#define __IA_CSS_DVS_TYPES_H
+
+/** DVS frame
+ *
+ *  ISP block: dvs frame
+ */
+
+#include "ia_css.h"
+
+struct ia_css_dvs_configuration {
+	const struct ia_css_frame_info *info;
+};
+
+#endif /* __IA_CSS_DVS_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h b/drivers/media/atomisp2/css2400/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
new file mode 100644
index 0000000..2b38a94
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FIXEDBDS_HOST_H
+#define __IA_CSS_FIXEDBDS_HOST_H
+
+
+struct sh_css_bds_factor {
+	unsigned numerator;
+	unsigned denominator;
+	unsigned int bds_factor;
+};
+
+
+#endif	/*__IA_CSS_FIXEDBDS_HOST_H*/
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c b/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
new file mode 100644
index 0000000..ecc1545
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
@@ -0,0 +1,88 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <assert_support.h>
+#include <ia_css_frame_public.h>
+#include <ia_css_frame.h>
+#include <ia_css_binary.h>
+#include <ia_css_types.h>
+#include <sh_css_defs.h>
+#include <ia_css_debug.h>
+
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#include "isp.h"
+
+#include "ia_css_fpn.host.h"
+
+void
+ia_css_fpn_encode(
+	struct sh_css_isp_fpn_params *to,
+	const struct ia_css_fpn_table *from)
+{
+	to->shift = from->shift;
+	to->enabled = from->data != NULL;
+}
+
+void
+ia_css_fpn_dump(
+	const struct sh_css_isp_fpn_params *fpn,
+	unsigned level)
+{
+	if (!fpn) return;
+	ia_css_debug_dtrace(level, "Fixed Pattern Noise Reduction:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"fpn_shift", fpn->shift);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"fpn_enabled", fpn->enabled);
+}
+
+void
+ia_css_fpn_config(
+	struct sh_css_isp_fpn_isp_config *to,
+	const struct ia_css_fpn_configuration *from)
+{
+	unsigned elems_a = ISP_VEC_NELEMS;
+	ia_css_dma_configure_from_info(&to->port_b, from->info);
+	to->width_a_over_b = elems_a / to->port_b.elems;
+
+	/* Assume divisiblity here, may need to generalize to fixed point. */
+	assert (elems_a % to->port_b.elems == 0);
+}
+
+void
+ia_css_fpn_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *info)
+{
+	const struct ia_css_frame_info my_info =
+		{ { CEIL_DIV(info->res.width, 2), /* Packed by 2x */
+		    info->res.height
+		  },
+		  CEIL_DIV(info->padded_width, 2), /* Packed by 2x */
+		  info->format,
+		  info->raw_bit_depth,
+		  info->raw_bayer_order
+		};
+	const struct ia_css_fpn_configuration config =
+		{ &my_info };
+	ia_css_configure_fpn(binary, &config);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h b/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h
new file mode 100644
index 0000000..1def98b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h
@@ -0,0 +1,49 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FPN_HOST_H
+#define __IA_CSS_FPN_HOST_H
+
+#include "ia_css_binary.h"
+#include "ia_css_fpn_types.h"
+#include "ia_css_fpn_param.h"
+
+void
+ia_css_fpn_encode(
+	struct sh_css_isp_fpn_params *to,
+	const struct ia_css_fpn_table *from);
+
+void
+ia_css_fpn_dump(
+	const struct sh_css_isp_fpn_params *fpn,
+	unsigned level);
+
+void
+ia_css_fpn_config(
+	struct sh_css_isp_fpn_isp_config      *to,
+	const struct ia_css_fpn_configuration *from);
+
+void
+ia_css_fpn_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *from);
+
+#endif /* __IA_CSS_FPN_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn_param.h b/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn_param.h
new file mode 100644
index 0000000..bc82b2e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn_param.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FPN_PARAM_H
+#define __IA_CSS_FPN_PARAM_H
+
+#include "type_support.h"
+
+#include "dma.h"
+
+/* FPNR (Fixed Pattern Noise Reduction) */
+struct sh_css_isp_fpn_params {
+	int32_t shift;
+	int32_t enabled;
+};
+
+struct sh_css_isp_fpn_isp_config {
+	uint32_t width_a_over_b;
+	struct dma_port_config port_b;
+};
+
+#endif /* __IA_CSS_FPN_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn_types.h b/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn_types.h
new file mode 100644
index 0000000..6421423
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/fpn/fpn_1.0/ia_css_fpn_types.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FPN_TYPES_H
+#define __IA_CSS_FPN_TYPES_H
+
+/** Fixed Pattern Noise table.
+ *
+ *  This contains the fixed patterns noise values
+ *  obtained from a black frame capture.
+ *
+ *  "shift" should be set as the smallest value
+ *  which satisfies the requirement the maximum data is less than 64.
+ *
+ *  ISP block: FPN1
+ *  ISP1: FPN1 is used.
+ *  ISP2: FPN1 is used.
+ */
+
+struct ia_css_fpn_table {
+	int16_t *data;		/**< Table content (fixed patterns noise).
+					u0.[13-shift], [0,63] */
+	uint32_t width;		/**< Table width (in pixels).
+					This is the input frame width. */
+	uint32_t height;	/**< Table height (in pixels).
+					This is the input frame height. */
+	uint32_t shift;		/**< Common exponent of table content.
+					u8.0, [0,13] */
+	uint32_t enabled;	/**< Fpn is enabled.
+					bool */
+};
+
+struct ia_css_fpn_configuration {
+	const struct ia_css_frame_info *info;
+};
+
+#endif /* __IA_CSS_FPN_TYPES_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc.host.c b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc.host.c
new file mode 100644
index 0000000..abe6b48
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc.host.c
@@ -0,0 +1,114 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_frac.h"
+#include "vamem.h"
+
+#include "ia_css_gc.host.h"
+
+const struct ia_css_gc_config default_gc_config = {
+	0,
+	0
+};
+
+const struct ia_css_ce_config default_ce_config = {
+	0,
+	255
+};
+
+void
+ia_css_gc_encode(
+	struct sh_css_isp_gc_params *to,
+	const struct ia_css_gc_config *from)
+{
+	to->gain_k1 =
+	    uDIGIT_FITTING((int)from->gain_k1, 16,
+		IA_CSS_GAMMA_GAIN_K_SHIFT);
+	to->gain_k2 =
+	    uDIGIT_FITTING((int)from->gain_k2, 16,
+		IA_CSS_GAMMA_GAIN_K_SHIFT);
+}
+
+void
+ia_css_ce_encode(
+	struct sh_css_isp_ce_params *to,
+	const struct ia_css_ce_config *from)
+{
+	to->uv_level_min = from->uv_level_min;
+	to->uv_level_max = from->uv_level_max;
+}
+
+void
+ia_css_gc_vamem_encode(
+	struct sh_css_isp_gc_vamem_params *to,
+	const struct ia_css_gamma_table *from)
+{
+	memcpy (&to->gc,  &from->data, sizeof(to->gc));
+}
+
+void
+ia_css_gc_dump(
+	const struct sh_css_isp_gc_params *gc,
+	unsigned level)
+{
+	if (!gc) return;
+	ia_css_debug_dtrace(level, "Gamma Correction:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"gamma_gain_k1", gc->gain_k1);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"gamma_gain_k2", gc->gain_k2);
+}
+
+void
+ia_css_ce_dump(
+	const struct sh_css_isp_ce_params *ce,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level, "Chroma Enhancement:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ce_uv_level_min", ce->uv_level_min);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ce_uv_level_max", ce->uv_level_max);
+}
+
+void
+ia_css_gc_debug_dtrace(
+	const struct ia_css_gc_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.gain_k1=%d, config.gain_k2=%d\n",
+		config->gain_k1, config->gain_k2);
+}
+
+void
+ia_css_ce_debug_dtrace(
+	const struct ia_css_ce_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.uv_level_min=%d, config.uv_level_max=%d\n",
+		config->uv_level_min, config->uv_level_max);
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc.host.h b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc.host.h
new file mode 100644
index 0000000..bf5e36f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc.host.h
@@ -0,0 +1,68 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_GC_HOST_H
+#define __IA_CSS_GC_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_gc_param.h"
+#include "ia_css_gc_table.host.h"
+
+extern const struct ia_css_gc_config default_gc_config;
+extern const struct ia_css_ce_config default_ce_config;
+
+void
+ia_css_gc_encode(
+	struct sh_css_isp_gc_params *to,
+	const struct ia_css_gc_config *from);
+
+void
+ia_css_gc_vamem_encode(
+	struct sh_css_isp_gc_vamem_params *to,
+	const struct ia_css_gamma_table *from);
+
+void
+ia_css_ce_encode(
+	struct sh_css_isp_ce_params *to,
+	const struct ia_css_ce_config *from);
+
+void
+ia_css_gc_dump(
+	const struct sh_css_isp_gc_params *gc,
+	unsigned level);
+
+void
+ia_css_ce_dump(
+	const struct sh_css_isp_ce_params *ce,
+	unsigned level);
+
+void
+ia_css_gc_debug_dtrace(
+	const struct ia_css_gc_config *config,
+	unsigned level);
+
+void
+ia_css_ce_debug_dtrace(
+	const struct ia_css_ce_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_GC_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_param.h b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_param.h
new file mode 100644
index 0000000..f8ca7a0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_param.h
@@ -0,0 +1,67 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_GC_PARAM_H
+#define __IA_CSS_GC_PARAM_H
+
+#include "type_support.h"
+#ifndef PIPE_GENERATION
+#ifdef __ISP
+#define __INLINE_VAMEM__
+#endif
+#include "vamem.h"
+
+#if defined(IS_VAMEM_VERSION_1)
+#define SH_CSS_ISP_GAMMA_TABLE_SIZE_LOG2 IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_GC_TABLE_SIZE	 IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE
+#elif defined(IS_VAMEM_VERSION_2)
+#define SH_CSS_ISP_GAMMA_TABLE_SIZE_LOG2 IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_GC_TABLE_SIZE	 IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE
+#else
+#error "Undefined vamem version"
+#endif
+
+#else
+/* For pipe generation, the size is not relevant */
+#define SH_CSS_ISP_GC_TABLE_SIZE 0
+#endif
+
+#define GAMMA_OUTPUT_BITS		8
+#define GAMMA_OUTPUT_MAX_VAL		((1<<GAMMA_OUTPUT_BITS)-1)
+
+/* GC (Gamma Correction) */
+struct sh_css_isp_gc_params {
+	int32_t gain_k1;
+	int32_t gain_k2;
+};
+
+/* CE (Chroma Enhancement) */
+struct sh_css_isp_ce_params {
+	int32_t uv_level_min;
+	int32_t uv_level_max;
+};
+
+/* This should be vamem_data_t, but that breaks the pipe generator */
+struct sh_css_isp_gc_vamem_params {
+	uint16_t gc[SH_CSS_ISP_GC_TABLE_SIZE];
+};
+
+#endif /* __IA_CSS_GC_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_table.host.c b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_table.host.c
new file mode 100644
index 0000000..e01fbfd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_table.host.c
@@ -0,0 +1,221 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <type_support.h>
+#include <string_support.h> /* memcpy */
+#include "system_global.h"
+#include "vamem.h"
+#include "ia_css_types.h"
+#include "ia_css_gc_table.host.h"
+
+#if defined(HAS_VAMEM_VERSION_2)
+
+struct ia_css_gamma_table default_gamma_table;
+
+static const uint16_t
+default_gamma_table_data[IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE] = {
+  0,   4,   8,  12,  17,  21,  27,  32,
+ 38,  44,  49,  55,  61,  66,  71,  76,
+ 80,  84,  88,  92,  95,  98, 102, 105,
+108, 110, 113, 116, 118, 121, 123, 126,
+128, 130, 132, 135, 137, 139, 141, 143,
+145, 146, 148, 150, 152, 153, 155, 156,
+158, 160, 161, 162, 164, 165, 166, 168,
+169, 170, 171, 172, 174, 175, 176, 177,
+178, 179, 180, 181, 182, 183, 184, 184,
+185, 186, 187, 188, 189, 189, 190, 191,
+192, 192, 193, 194, 195, 195, 196, 197,
+197, 198, 198, 199, 200, 200, 201, 201,
+202, 203, 203, 204, 204, 205, 205, 206,
+206, 207, 207, 208, 208, 209, 209, 210,
+210, 210, 211, 211, 212, 212, 213, 213,
+214, 214, 214, 215, 215, 216, 216, 216,
+217, 217, 218, 218, 218, 219, 219, 220,
+220, 220, 221, 221, 222, 222, 222, 223,
+223, 223, 224, 224, 225, 225, 225, 226,
+226, 226, 227, 227, 227, 228, 228, 228,
+229, 229, 229, 230, 230, 230, 231, 231,
+231, 232, 232, 232, 233, 233, 233, 234,
+234, 234, 234, 235, 235, 235, 236, 236,
+236, 237, 237, 237, 237, 238, 238, 238,
+239, 239, 239, 239, 240, 240, 240, 241,
+241, 241, 241, 242, 242, 242, 242, 243,
+243, 243, 243, 244, 244, 244, 245, 245,
+245, 245, 246, 246, 246, 246, 247, 247,
+247, 247, 248, 248, 248, 248, 249, 249,
+249, 249, 250, 250, 250, 250, 251, 251,
+251, 251, 252, 252, 252, 252, 253, 253,
+253, 253, 254, 254, 254, 254, 255, 255,
+255
+};
+
+#elif defined(HAS_VAMEM_VERSION_1)
+
+static const uint16_t
+default_gamma_table_data[IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE] = {
+		0, 1, 2, 3, 4, 5, 6, 7,
+		8, 9, 10, 11, 12, 13, 14, 16,
+		17, 18, 19, 20, 21, 23, 24, 25,
+		27, 28, 29, 31, 32, 33, 35, 36,
+		38, 39, 41, 42, 44, 45, 47, 48,
+		49, 51, 52, 54, 55, 57, 58, 60,
+		61, 62, 64, 65, 66, 68, 69, 70,
+		71, 72, 74, 75, 76, 77, 78, 79,
+		80, 81, 82, 83, 84, 85, 86, 87,
+		88, 89, 90, 91, 92, 93, 93, 94,
+		95, 96, 97, 98, 98, 99, 100, 101,
+		102, 102, 103, 104, 105, 105, 106, 107,
+		108, 108, 109, 110, 110, 111, 112, 112,
+		113, 114, 114, 115, 116, 116, 117, 118,
+		118, 119, 120, 120, 121, 121, 122, 123,
+		123, 124, 125, 125, 126, 126, 127, 127,	/* 128 */
+		128, 129, 129, 130, 130, 131, 131, 132,
+		132, 133, 134, 134, 135, 135, 136, 136,
+		137, 137, 138, 138, 139, 139, 140, 140,
+		141, 141, 142, 142, 143, 143, 144, 144,
+		145, 145, 145, 146, 146, 147, 147, 148,
+		148, 149, 149, 150, 150, 150, 151, 151,
+		152, 152, 152, 153, 153, 154, 154, 155,
+		155, 155, 156, 156, 156, 157, 157, 158,
+		158, 158, 159, 159, 160, 160, 160, 161,
+		161, 161, 162, 162, 162, 163, 163, 163,
+		164, 164, 164, 165, 165, 165, 166, 166,
+		166, 167, 167, 167, 168, 168, 168, 169,
+		169, 169, 170, 170, 170, 170, 171, 171,
+		171, 172, 172, 172, 172, 173, 173, 173,
+		174, 174, 174, 174, 175, 175, 175, 176,
+		176, 176, 176, 177, 177, 177, 177, 178,	/* 256 */
+		178, 178, 178, 179, 179, 179, 179, 180,
+		180, 180, 180, 181, 181, 181, 181, 182,
+		182, 182, 182, 182, 183, 183, 183, 183,
+		184, 184, 184, 184, 184, 185, 185, 185,
+		185, 186, 186, 186, 186, 186, 187, 187,
+		187, 187, 187, 188, 188, 188, 188, 188,
+		189, 189, 189, 189, 189, 190, 190, 190,
+		190, 190, 191, 191, 191, 191, 191, 192,
+		192, 192, 192, 192, 192, 193, 193, 193,
+		193, 193, 194, 194, 194, 194, 194, 194,
+		195, 195, 195, 195, 195, 195, 196, 196,
+		196, 196, 196, 196, 197, 197, 197, 197,
+		197, 197, 198, 198, 198, 198, 198, 198,
+		198, 199, 199, 199, 199, 199, 199, 200,
+		200, 200, 200, 200, 200, 200, 201, 201,
+		201, 201, 201, 201, 201, 202, 202, 202,	/* 384 */
+		202, 202, 202, 202, 203, 203, 203, 203,
+		203, 203, 203, 204, 204, 204, 204, 204,
+		204, 204, 204, 205, 205, 205, 205, 205,
+		205, 205, 205, 206, 206, 206, 206, 206,
+		206, 206, 206, 207, 207, 207, 207, 207,
+		207, 207, 207, 208, 208, 208, 208, 208,
+		208, 208, 208, 209, 209, 209, 209, 209,
+		209, 209, 209, 209, 210, 210, 210, 210,
+		210, 210, 210, 210, 210, 211, 211, 211,
+		211, 211, 211, 211, 211, 211, 212, 212,
+		212, 212, 212, 212, 212, 212, 212, 213,
+		213, 213, 213, 213, 213, 213, 213, 213,
+		214, 214, 214, 214, 214, 214, 214, 214,
+		214, 214, 215, 215, 215, 215, 215, 215,
+		215, 215, 215, 216, 216, 216, 216, 216,
+		216, 216, 216, 216, 216, 217, 217, 217,	/* 512 */
+		217, 217, 217, 217, 217, 217, 217, 218,
+		218, 218, 218, 218, 218, 218, 218, 218,
+		218, 219, 219, 219, 219, 219, 219, 219,
+		219, 219, 219, 220, 220, 220, 220, 220,
+		220, 220, 220, 220, 220, 221, 221, 221,
+		221, 221, 221, 221, 221, 221, 221, 221,
+		222, 222, 222, 222, 222, 222, 222, 222,
+		222, 222, 223, 223, 223, 223, 223, 223,
+		223, 223, 223, 223, 223, 224, 224, 224,
+		224, 224, 224, 224, 224, 224, 224, 224,
+		225, 225, 225, 225, 225, 225, 225, 225,
+		225, 225, 225, 226, 226, 226, 226, 226,
+		226, 226, 226, 226, 226, 226, 226, 227,
+		227, 227, 227, 227, 227, 227, 227, 227,
+		227, 227, 228, 228, 228, 228, 228, 228,
+		228, 228, 228, 228, 228, 228, 229, 229,
+		229, 229, 229, 229, 229, 229, 229, 229,
+		229, 229, 230, 230, 230, 230, 230, 230,
+		230, 230, 230, 230, 230, 230, 231, 231,
+		231, 231, 231, 231, 231, 231, 231, 231,
+		231, 231, 231, 232, 232, 232, 232, 232,
+		232, 232, 232, 232, 232, 232, 232, 233,
+		233, 233, 233, 233, 233, 233, 233, 233,
+		233, 233, 233, 233, 234, 234, 234, 234,
+		234, 234, 234, 234, 234, 234, 234, 234,
+		234, 235, 235, 235, 235, 235, 235, 235,
+		235, 235, 235, 235, 235, 235, 236, 236,
+		236, 236, 236, 236, 236, 236, 236, 236,
+		236, 236, 236, 236, 237, 237, 237, 237,
+		237, 237, 237, 237, 237, 237, 237, 237,
+		237, 237, 238, 238, 238, 238, 238, 238,
+		238, 238, 238, 238, 238, 238, 238, 238,
+		239, 239, 239, 239, 239, 239, 239, 239,
+		239, 239, 239, 239, 239, 239, 240, 240,
+		240, 240, 240, 240, 240, 240, 240, 240,
+		240, 240, 240, 240, 241, 241, 241, 241,
+		241, 241, 241, 241, 241, 241, 241, 241,
+		241, 241, 241, 242, 242, 242, 242, 242,
+		242, 242, 242, 242, 242, 242, 242, 242,
+		242, 242, 243, 243, 243, 243, 243, 243,
+		243, 243, 243, 243, 243, 243, 243, 243,
+		243, 244, 244, 244, 244, 244, 244, 244,
+		244, 244, 244, 244, 244, 244, 244, 244,
+		245, 245, 245, 245, 245, 245, 245, 245,
+		245, 245, 245, 245, 245, 245, 245, 246,
+		246, 246, 246, 246, 246, 246, 246, 246,
+		246, 246, 246, 246, 246, 246, 246, 247,
+		247, 247, 247, 247, 247, 247, 247, 247,
+		247, 247, 247, 247, 247, 247, 247, 248,
+		248, 248, 248, 248, 248, 248, 248, 248,
+		248, 248, 248, 248, 248, 248, 248, 249,
+		249, 249, 249, 249, 249, 249, 249, 249,
+		249, 249, 249, 249, 249, 249, 249, 250,
+		250, 250, 250, 250, 250, 250, 250, 250,
+		250, 250, 250, 250, 250, 250, 250, 251,
+		251, 251, 251, 251, 251, 251, 251, 251,
+		251, 251, 251, 251, 251, 251, 251, 252,
+		252, 252, 252, 252, 252, 252, 252, 252,
+		252, 252, 252, 252, 252, 252, 252, 253,
+		253, 253, 253, 253, 253, 253, 253, 253,
+		253, 253, 253, 253, 253, 253, 253, 253,
+		254, 254, 254, 254, 254, 254, 254, 254,
+		254, 254, 254, 254, 254, 254, 254, 254,
+		255, 255, 255, 255, 255, 255, 255, 255
+};
+
+#else
+#error "VAMEM version must be one of {VAMEM_VERSION_1, VAMEM_VERSION_2}"
+#endif
+
+void
+ia_css_config_gamma_table(void)
+{
+#if defined(HAS_VAMEM_VERSION_2)
+	memcpy(default_gamma_table.data.vamem_2, default_gamma_table_data,
+	       sizeof(default_gamma_table_data));
+	default_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_2;
+#else
+	memcpy(default_gamma_table.data.vamem_1, default_gamma_table_data,
+	       sizeof(default_gamma_table_data));
+	default_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_1;
+#endif
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_table.host.h b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_table.host.h
new file mode 100644
index 0000000..991ccfec
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_table.host.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_GC_TABLE_HOST_H
+#define __IA_CSS_GC_TABLE_HOST_H
+
+#include "ia_css_gc_types.h"
+
+extern struct ia_css_gamma_table default_gamma_table;
+
+void ia_css_config_gamma_table(void);
+
+#endif /* __IA_CSS_GC_TABLE_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_types.h b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_types.h
new file mode 100644
index 0000000..f4ae959
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_1.0/ia_css_gc_types.h
@@ -0,0 +1,98 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_GC_TYPES_H
+#define __IA_CSS_GC_TYPES_H
+
+/** Fractional bits for GAMMA gain */
+#define IA_CSS_GAMMA_GAIN_K_SHIFT      13
+
+/** Number of elements in the gamma table. */
+#define IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2    10
+#define IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE         (1U<<IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE_LOG2)
+
+/** Number of elements in the gamma table. */
+#define IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2    8
+#define IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE         ((1U<<IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE_LOG2) + 1)
+
+/** Gamma table, used for Y(Luma) Gamma Correction.
+ *
+ *  ISP block: GC1 (YUV Gamma Correction)
+ *  ISP1: GC1 is used.
+ * (ISP2: GC2(sRGB Gamma Correction) is used.)
+ */
+/**< IA_CSS_VAMEM_TYPE_1(ISP2300) or
+     IA_CSS_VAMEM_TYPE_2(ISP2400) */
+union ia_css_gc_data {
+	uint16_t vamem_1[IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE];
+	/**< Y(Luma) Gamma table on vamem type 1. u0.8, [0,255] */
+	uint16_t vamem_2[IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE];
+	/**< Y(Luma) Gamma table on vamem type 2. u0.8, [0,255] */
+};
+
+struct ia_css_gamma_table {
+	enum ia_css_vamem_type vamem_type;
+	union ia_css_gc_data data;
+};
+
+/** Gamma Correction configuration (used only for YUV Gamma Correction).
+ *
+ *  ISP block: GC1 (YUV Gamma Correction)
+ *  ISP1: GC1 is used.
+ * (ISP2: GC2 (sRGB Gamma Correction) is used.)
+  */
+struct ia_css_gc_config {
+	uint16_t gain_k1; /**< Gain to adjust U after YUV Gamma Correction.
+				u0.16, [0,65535],
+				default/ineffective 19000(0.29) */
+	uint16_t gain_k2; /**< Gain to adjust V after YUV Gamma Correction.
+				u0.16, [0,65535],
+				default/ineffective 19000(0.29) */
+};
+
+/** Chroma Enhancement configuration.
+ *
+ *  This parameter specifies range of chroma output level.
+ *  The standard range is [0,255] or [16,240].
+ *
+ *  ISP block: CE1
+ *  ISP1: CE1 is used.
+ * (ISP2: CE1 is not used.)
+ */
+struct ia_css_ce_config {
+	uint8_t uv_level_min; /**< Minimum of chroma output level.
+				u0.8, [0,255], default/ineffective 0 */
+	uint8_t uv_level_max; /**< Maximum of chroma output level.
+				u0.8, [0,255], default/ineffective 255 */
+};
+
+/** Multi-Axes Color Correction (MACC) configuration.
+ *
+ *  ISP block: MACC2 (MACC by matrix and exponent(ia_css_macc_config))
+ * (ISP1: MACC1 (MACC by only matrix) is used.)
+ *  ISP2: MACC2 is used.
+ */
+struct ia_css_macc_config {
+	uint8_t exp;	/**< Common exponent of ia_css_macc_table.
+				u8.0, [0,13], default 1, ineffective 1 */
+};
+
+#endif /* __IA_CSS_GC_TYPES_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2.host.c b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2.host.c
new file mode 100644
index 0000000..c52ad84
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2.host.c
@@ -0,0 +1,103 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "csc/csc_1.0/ia_css_csc.host.h"
+#include "vamem.h"
+
+#include "ia_css_gc2.host.h"
+
+const struct ia_css_cc_config default_yuv2rgb_cc_config = {
+	12,
+	{4096, -4096, 4096, 4096, 4096, 0, 4096, -4096, -4096}
+};
+
+const struct ia_css_cc_config default_rgb2yuv_cc_config = {
+	13,
+	{2449, 4809, 934, -1382, -2714, 4096, 4096, -3430, -666}
+};
+
+void
+ia_css_yuv2rgb_encode(
+	struct sh_css_isp_csc_params *to,
+	const struct ia_css_cc_config *from)
+{
+	ia_css_encode_cc(to, from);
+}
+
+void
+ia_css_rgb2yuv_encode(
+	struct sh_css_isp_csc_params *to,
+	const struct ia_css_cc_config *from)
+{
+	ia_css_encode_cc(to, from);
+}
+
+void
+ia_css_r_gamma_vamem_encode(
+	struct sh_css_isp_rgb_gamma_vamem_params *to,
+	const struct ia_css_rgb_gamma_table *from)
+{
+	memcpy (&to->gc,  &from->data, sizeof(to->gc));
+}
+
+void
+ia_css_g_gamma_vamem_encode(
+	struct sh_css_isp_rgb_gamma_vamem_params *to,
+	const struct ia_css_rgb_gamma_table *from)
+{
+	memcpy (&to->gc,  &from->data, sizeof(to->gc));
+}
+
+void
+ia_css_b_gamma_vamem_encode(
+	struct sh_css_isp_rgb_gamma_vamem_params *to,
+	const struct ia_css_rgb_gamma_table *from)
+{
+	memcpy (&to->gc,  &from->data, sizeof(to->gc));
+}
+
+void
+ia_css_yuv2rgb_dump(
+	const struct sh_css_isp_csc_params *yuv2rgb,
+	unsigned level)
+{
+	ia_css_cc_dump(yuv2rgb, level, "YUV to RGB Conversion");
+}
+
+void
+ia_css_rgb2yuv_dump(
+	const struct sh_css_isp_csc_params *rgb2yuv,
+	unsigned level)
+{
+	ia_css_cc_dump(rgb2yuv, level, "RGB to YUV Conversion");
+}
+
+void
+ia_css_rgb_gamma_table_debug_dtrace(
+	const struct ia_css_rgb_gamma_table *config,
+	unsigned level)
+{
+	(void)config;
+	(void)level;
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2.host.h b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2.host.h
new file mode 100644
index 0000000..d70cae2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2.host.h
@@ -0,0 +1,80 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_GC2_HOST_H
+#define __IA_CSS_GC2_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_gc2_types.h"
+#include "ia_css_gc2_param.h"
+#include "ia_css_gc2_table.host.h"
+
+extern const struct ia_css_cc_config default_yuv2rgb_cc_config;
+extern const struct ia_css_cc_config default_rgb2yuv_cc_config;
+
+void
+ia_css_yuv2rgb_encode(
+	struct sh_css_isp_csc_params *to,
+	const struct ia_css_cc_config *from);
+
+void
+ia_css_rgb2yuv_encode(
+	struct sh_css_isp_csc_params *to,
+	const struct ia_css_cc_config *from);
+
+void
+ia_css_r_gamma_vamem_encode(
+	struct sh_css_isp_rgb_gamma_vamem_params *to,
+	const struct ia_css_rgb_gamma_table *from);
+
+void
+ia_css_g_gamma_vamem_encode(
+	struct sh_css_isp_rgb_gamma_vamem_params *to,
+	const struct ia_css_rgb_gamma_table *from);
+
+void
+ia_css_b_gamma_vamem_encode(
+	struct sh_css_isp_rgb_gamma_vamem_params *to,
+	const struct ia_css_rgb_gamma_table *from);
+
+void
+ia_css_yuv2rgb_dump(
+	const struct sh_css_isp_csc_params *yuv2rgb,
+	unsigned level);
+
+void
+ia_css_rgb2yuv_dump(
+	const struct sh_css_isp_csc_params *rgb2yuv,
+	unsigned level);
+
+void
+ia_css_rgb_gamma_table_debug_dtrace(
+	const struct ia_css_rgb_gamma_table *config,
+	unsigned level);
+
+#define ia_css_yuv2rgb_debug_dtrace ia_css_cc_config_debug_dtrace
+#define ia_css_rgb2yuv_debug_dtrace ia_css_cc_config_debug_dtrace
+#define ia_css_r_gamma_debug_dtrace ia_css_rgb_gamma_table_debug_dtrace
+#define ia_css_g_gamma_debug_dtrace ia_css_rgb_gamma_table_debug_dtrace
+#define ia_css_b_gamma_debug_dtrace ia_css_rgb_gamma_table_debug_dtrace
+
+#endif /* __IA_CSS_GC2_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_param.h b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_param.h
new file mode 100644
index 0000000..e99fa9c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_param.h
@@ -0,0 +1,49 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_GC2_PARAM_H
+#define __IA_CSS_GC2_PARAM_H
+
+#include "type_support.h"
+/* Extend GC1 */
+#include "gc/gc_1.0/ia_css_gc_param.h"
+#include "csc/csc_1.0/ia_css_csc_param.h"
+
+#ifndef PIPE_GENERATION
+#if defined(IS_VAMEM_VERSION_1)
+#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE
+#elif defined(IS_VAMEM_VERSION_2)
+#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE
+#else
+#error "Undefined vamem version"
+#endif
+
+#else
+/* For pipe generation, the size is not relevant */
+#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE 0
+#endif
+
+/* This should be vamem_data_t, but that breaks the pipe generator */
+struct sh_css_isp_rgb_gamma_vamem_params {
+	uint16_t gc[SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE];
+};
+
+#endif /* __IA_CSS_GC2_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_table.host.c b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_table.host.c
new file mode 100644
index 0000000..a512b5d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_table.host.c
@@ -0,0 +1,139 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <type_support.h>
+#include <string_support.h> /* memcpy */
+#include "system_global.h"
+#include "vamem.h"
+#include "ia_css_types.h"
+#include "ia_css_gc2_table.host.h"
+
+struct ia_css_rgb_gamma_table default_r_gamma_table;
+struct ia_css_rgb_gamma_table default_g_gamma_table;
+struct ia_css_rgb_gamma_table default_b_gamma_table;
+
+/* Identical default gamma table for R, G, and B. */
+
+#if defined(HAS_VAMEM_VERSION_2)
+
+static const uint16_t
+default_gamma_table_data[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE] = {
+   0,   72,  144,  216,  288,  360,  426,  486,
+ 541,  592,  641,  687,  730,  772,  812,  850,
+ 887,  923,  958,  991, 1024, 1055, 1086, 1117,
+1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
+1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
+1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
+1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
+1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
+2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
+2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
+2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
+2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
+2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
+2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
+2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
+2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
+2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
+2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
+3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
+3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
+3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
+3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
+3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
+3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
+3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
+3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
+3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
+3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
+3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
+3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
+3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
+4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
+4095
+};
+#elif defined(HAS_VAMEM_VERSION_1)
+
+static const uint16_t
+default_gamma_table_data[IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE] = {
+   0,   72,  144,  216,  288,  360,  426,  486,
+ 541,  592,  641,  687,  730,  772,  812,  850,
+ 887,  923,  958,  991, 1024, 1055, 1086, 1117,
+1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
+1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
+1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
+1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
+1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
+2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
+2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
+2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
+2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
+2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
+2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
+2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
+2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
+2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
+2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
+3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
+3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
+3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
+3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
+3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
+3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
+3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
+3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
+3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
+3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
+3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
+3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
+3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
+4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088
+};
+#else
+#error "VAMEM version must be one of {VAMEM_VERSION_1, VAMEM_VERSION_2}"
+#endif
+
+void
+ia_css_config_rgb_gamma_tables(void)
+{
+#if defined(HAS_VAMEM_VERSION_2)
+	default_r_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_2;
+	default_g_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_2;
+	default_b_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_2;
+	memcpy(default_r_gamma_table.data.vamem_2, default_gamma_table_data,
+	       sizeof(default_gamma_table_data));
+	memcpy(default_g_gamma_table.data.vamem_2, default_gamma_table_data,
+	       sizeof(default_gamma_table_data));
+	memcpy(default_b_gamma_table.data.vamem_2, default_gamma_table_data,
+	       sizeof(default_gamma_table_data));
+#else
+	memcpy(default_r_gamma_table.data.vamem_1, default_gamma_table_data,
+	       sizeof(default_gamma_table_data));
+	memcpy(default_g_gamma_table.data.vamem_1, default_gamma_table_data,
+	       sizeof(default_gamma_table_data));
+	memcpy(default_b_gamma_table.data.vamem_1, default_gamma_table_data,
+	       sizeof(default_gamma_table_data));
+	default_r_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_1;
+	default_g_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_1;
+	default_b_gamma_table.vamem_type   = IA_CSS_VAMEM_TYPE_1;
+#endif
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_table.host.h b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_table.host.h
new file mode 100644
index 0000000..6d0243b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_table.host.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_GC2_TABLE_HOST_H
+#define __IA_CSS_GC2_TABLE_HOST_H
+
+#include "ia_css_gc2_types.h"
+
+extern struct ia_css_rgb_gamma_table default_r_gamma_table;
+extern struct ia_css_rgb_gamma_table default_g_gamma_table;
+extern struct ia_css_rgb_gamma_table default_b_gamma_table;
+
+void ia_css_config_rgb_gamma_tables(void);
+
+#endif /* __IA_CSS_GC2_TABLE_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_types.h b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_types.h
new file mode 100644
index 0000000..69a3ad5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/gc/gc_2/ia_css_gc2_types.h
@@ -0,0 +1,55 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_GC2_TYPES_H
+#define __IA_CSS_GC2_TYPES_H
+
+/** sRGB Gamma table, used for sRGB Gamma Correction.
+ *
+ *  ISP block: GC2 (sRGB Gamma Correction)
+ * (ISP1: GC1(YUV Gamma Correction) is used.)
+ *  ISP2: GC2 is used.
+ */
+
+/** Number of elements in the sRGB gamma table. */
+#define IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE_LOG2 8
+#define IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE      (1U<<IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE_LOG2)
+
+/** Number of elements in the sRGB gamma table. */
+#define IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE_LOG2    8
+#define IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE     ((1U<<IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE_LOG2) + 1)
+
+/**< IA_CSS_VAMEM_TYPE_1(ISP2300) or
+     IA_CSS_VAMEM_TYPE_2(ISP2400) */
+union ia_css_rgb_gamma_data {
+	uint16_t vamem_1[IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE];
+	/**< RGB Gamma table on vamem type1. This table is not used,
+		because sRGB Gamma Correction is not implemented for ISP2300. */
+	uint16_t vamem_2[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE];
+		/**< RGB Gamma table on vamem type2. u0.12, [0,4095] */
+};
+
+struct ia_css_rgb_gamma_table {
+	enum ia_css_vamem_type vamem_type;
+	union ia_css_rgb_gamma_data data;
+};
+
+#endif /* __IA_CSS_GC2_TYPES_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c b/drivers/media/atomisp2/css2400/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
new file mode 100644
index 0000000..8582487
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
@@ -0,0 +1,60 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_frame.h"
+#include "ia_css.h"
+#include "ia_css_pipeline.h"
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#include "ia_css_iterator.host.h"
+
+void
+ia_css_iterator_config(
+	struct sh_css_isp_iterator_isp_config *to,
+	const struct ia_css_iterator_configuration *from)
+{
+	ia_css_frame_info_to_frame_sp_info(&to->input_info,    from->input_info);
+	ia_css_frame_info_to_frame_sp_info(&to->internal_info, from->internal_info);
+	ia_css_frame_info_to_frame_sp_info(&to->output_info,   from->output_info);
+	ia_css_resolution_to_sp_resolution(&to->dvs_envelope,  from->dvs_envelope);
+}
+
+enum ia_css_err
+ia_css_iterator_configure(
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *in_info)
+{
+	struct ia_css_iterator_configuration config = {
+		&binary->in_frame_info,
+		&binary->internal_frame_info,
+		&binary->out_frame_info[0],
+		&binary->dvs_envelope };
+	/* Use in_info iso binary->in_frame_info.
+	 * They can differ in padded width in case of scaling, e.g. for capture_pp.
+	 * Find out why.
+	*/
+	if (in_info)
+		config.input_info = in_info;
+	if (binary->out_frame_info[0].res.width == 0)
+		config.output_info = &binary->out_frame_info[1];
+	ia_css_configure_iterator (binary, &config);
+	return IA_CSS_SUCCESS;
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h b/drivers/media/atomisp2/css2400/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
new file mode 100644
index 0000000..2c5ce43
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ITERATOR_HOST_H
+#define __IA_CSS_ITERATOR_HOST_H
+
+#include "ia_css.h"
+#include "ia_css_binary.h"
+
+#include "ia_css_iterator_param.h"
+
+void
+ia_css_iterator_config(
+	struct sh_css_isp_iterator_isp_config *to,
+	const struct ia_css_iterator_configuration *from);
+
+enum ia_css_err
+ia_css_iterator_configure(
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *in_info);
+
+#endif /* __IA_CSS_ITERATOR_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h b/drivers/media/atomisp2/css2400/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h
new file mode 100644
index 0000000..19f4cd9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h
@@ -0,0 +1,43 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ITERATOR_PARAM_H
+#define __IA_CSS_ITERATOR_PARAM_H
+
+#include "type_support.h"
+#include "ia_css.h" /* ia_css_frame_info */
+#include "ia_css_frame_comm.h" /* ia_css_frame_sp_info */
+
+struct ia_css_iterator_configuration {
+	const struct ia_css_frame_info *input_info;
+	const struct ia_css_frame_info *internal_info;
+	const struct ia_css_frame_info *output_info;
+	const struct ia_css_resolution *dvs_envelope;
+};
+
+struct sh_css_isp_iterator_isp_config {
+	struct ia_css_frame_sp_info input_info;
+	struct ia_css_frame_sp_info internal_info;
+	struct ia_css_frame_sp_info output_info;
+	struct ia_css_sp_resolution dvs_envelope;
+};
+
+#endif /* __IA_CSS_ITERATOR_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc.host.c b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc.host.c
new file mode 100644
index 0000000..eb62635
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc.host.c
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_frac.h"
+
+#include "ia_css_macc.host.h"
+
+const struct ia_css_macc_config default_macc_config = {
+	1,
+};
+
+void
+ia_css_macc_encode(
+	struct sh_css_isp_macc_params *to,
+	const struct ia_css_macc_config *from)
+{
+	to->exp = from->exp;
+}
+
+void
+ia_css_macc_dump(
+	const struct sh_css_isp_macc_params *macc,
+	unsigned level);
+
+void
+ia_css_macc_debug_dtrace(
+	const struct ia_css_macc_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.exp=%d\n",
+		config->exp);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc.host.h b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc.host.h
new file mode 100644
index 0000000..2e43597
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc.host.h
@@ -0,0 +1,47 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_MACC_HOST_H
+#define __IA_CSS_MACC_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_macc_param.h"
+#include "ia_css_macc_table.host.h"
+
+extern const struct ia_css_macc_config default_macc_config;
+
+void
+ia_css_macc_encode(
+	struct sh_css_isp_macc_params *to,
+	const struct ia_css_macc_config *from);
+
+void
+ia_css_macc_dump(
+	const struct sh_css_isp_macc_params *macc,
+	unsigned level);
+
+void
+ia_css_macc_debug_dtrace(
+	const struct ia_css_macc_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_MACC_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_param.h b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_param.h
new file mode 100644
index 0000000..9350f48
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_param.h
@@ -0,0 +1,32 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_MACC_PARAM_H
+#define __IA_CSS_MACC_PARAM_H
+
+#include "type_support.h"
+
+/* MACC */
+struct sh_css_isp_macc_params {
+	int32_t exp;
+};
+
+#endif /* __IA_CSS_MACC_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_table.host.c b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_table.host.c
new file mode 100644
index 0000000..d2b04c3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_table.host.c
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "system_global.h"
+#include "ia_css_types.h"
+#include "ia_css_macc_table.host.h"
+
+/* Multi-Axes Color Correction table for ISP1.
+ * 	64values = 2x2matrix for 16area, [s2.13]
+ * 	ineffective: 16 of "identity 2x2 matix" {8192,0,0,8192}
+ */
+const struct ia_css_macc_table default_macc_table = {
+		{ 8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192,
+		8192, 0, 0, 8192, 8192, 0, 0, 8192 }
+};
+
+/* Multi-Axes Color Correction table for ISP2.
+ * 	64values = 2x2matrix for 16area, [s1.12]
+ * 	ineffective: 16 of "identity 2x2 matix" {4096,0,0,4096}
+ */
+const struct ia_css_macc_table default_macc2_table = {
+	      { 4096, 0, 0, 4096, 4096, 0, 0, 4096,
+		4096, 0, 0, 4096, 4096, 0, 0, 4096,
+		4096, 0, 0, 4096, 4096, 0, 0, 4096,
+		4096, 0, 0, 4096, 4096, 0, 0, 4096,
+		4096, 0, 0, 4096, 4096, 0, 0, 4096,
+		4096, 0, 0, 4096, 4096, 0, 0, 4096,
+		4096, 0, 0, 4096, 4096, 0, 0, 4096,
+		4096, 0, 0, 4096, 4096, 0, 0, 4096 }
+};
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_table.host.h b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_table.host.h
new file mode 100644
index 0000000..b1a4ec3
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_table.host.h
@@ -0,0 +1,30 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_MACC_TABLE_HOST_H
+#define __IA_CSS_MACC_TABLE_HOST_H
+
+#include "ia_css_macc_types.h"
+
+extern const struct ia_css_macc_table default_macc_table;
+extern const struct ia_css_macc_table default_macc2_table;
+
+#endif /* __IA_CSS_MACC_TABLE_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_types.h b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_types.h
new file mode 100644
index 0000000..571cb22
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/macc/macc_1.0/ia_css_macc_types.h
@@ -0,0 +1,66 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_MACC_TYPES_H
+#define __IA_CSS_MACC_TYPES_H
+
+/** Number of axes in the MACC table. */
+#define IA_CSS_MACC_NUM_AXES           16
+/** Number of coefficients per MACC axes. */
+#define IA_CSS_MACC_NUM_COEFS          4
+/** The number of planes in the morphing table. */
+
+/** Multi-Axes Color Correction (MACC) table.
+ *
+ *  ISP block: MACC1 (MACC by only matrix)
+ *             MACC2 (MACC by matrix and exponent(ia_css_macc_config))
+ *  ISP1: MACC1 is used.
+ *  ISP2: MACC2 is used.
+ *
+ *  [MACC1]
+ *   OutU = (data00 * InU + data01 * InV) >> 13
+ *   OutV = (data10 * InU + data11 * InV) >> 13
+ *
+ *   default/ineffective:
+ *   OutU = (8192 * InU +    0 * InV) >> 13
+ *   OutV = (   0 * InU + 8192 * InV) >> 13
+ *
+ *  [MACC2]
+ *   OutU = (data00 * InU + data01 * InV) >> (13 - exp)
+ *   OutV = (data10 * InU + data11 * InV) >> (13 - exp)
+ *
+ *   default/ineffective: (exp=1)
+ *   OutU = (4096 * InU +    0 * InV) >> (13 - 1)
+ *   OutV = (   0 * InU + 4096 * InV) >> (13 - 1)
+ */
+
+struct ia_css_macc_table {
+	int16_t data[IA_CSS_MACC_NUM_COEFS * IA_CSS_MACC_NUM_AXES];
+	/**< 16 of 2x2 matix
+	  MACC1: s2.13, [-65536,65535]
+	    default/ineffective:
+		16 of "identity 2x2 matix" {8192,0,0,8192}
+	  MACC2: s[macc_config.exp].[13-macc_config.exp], [-8192,8191]
+	    default/ineffective: (s1.12)
+		16 of "identity 2x2 matix" {4096,0,0,4096} */
+};
+
+#endif /* __IA_CSS_MACC_TYPES_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob.host.c b/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
new file mode 100644
index 0000000..70df668
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
@@ -0,0 +1,162 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "isp.h"
+
+#include "ia_css_ob.host.h"
+
+const struct ia_css_ob_config default_ob_config = {
+	IA_CSS_OB_MODE_NONE,
+	0,
+	0,
+	0,
+	0,
+	0,
+	0
+};
+
+/* TODO: include ob.isp.h to get isp knowledge and
+   add assert on platform restrictions */
+
+/* AREA_LENGTH_UNIT is dependent on NWAY, requires rewrite */
+#define AREA_LENGTH_UNIT (1<<12)
+
+void
+ia_css_ob_configure(
+	struct sh_css_isp_ob_stream_config *config,
+	unsigned int isp_pipe_version,
+	unsigned int raw_bit_depth)
+{
+	config->isp_pipe_version = isp_pipe_version;
+	config->raw_bit_depth    = raw_bit_depth;
+}
+
+void
+ia_css_ob_encode(
+	struct sh_css_isp_ob_params *to,
+	const struct ia_css_ob_config *from,
+	const struct sh_css_isp_ob_stream_config *config)
+{
+	unsigned int ob_bit_depth
+		= config->isp_pipe_version == 2 ? SH_CSS_BAYER_BITS : config->raw_bit_depth;
+	unsigned int scale = 16 - ob_bit_depth;
+
+	switch (from->mode) {
+	case IA_CSS_OB_MODE_FIXED:
+		to->blacklevel_gr = from->level_gr >> scale;
+		to->blacklevel_r  = from->level_r  >> scale;
+		to->blacklevel_b  = from->level_b  >> scale;
+		to->blacklevel_gb = from->level_gb >> scale;
+		to->area_start_bq = 0;
+		to->area_length_bq = 0;
+		to->area_length_bq_inverse = 0;
+		break;
+	case IA_CSS_OB_MODE_RASTER:
+		to->blacklevel_gr = 0;
+		to->blacklevel_r = 0;
+		to->blacklevel_b = 0;
+		to->blacklevel_gb = 0;
+		to->area_start_bq = from->start_position;
+		to->area_length_bq =
+		    (from->end_position - from->start_position) + 1;
+		to->area_length_bq_inverse = AREA_LENGTH_UNIT / to->area_length_bq;
+		break;
+	default:
+		to->blacklevel_gr = 0;
+		to->blacklevel_r = 0;
+		to->blacklevel_b = 0;
+		to->blacklevel_gb = 0;
+		to->area_start_bq = 0;
+		to->area_length_bq = 0;
+		to->area_length_bq_inverse = 0;
+		break;
+	}
+}
+
+void
+ia_css_ob_vmem_encode(
+	struct sh_css_isp_ob_vmem_params *to,
+	const struct ia_css_ob_config *from,
+	const struct sh_css_isp_ob_stream_config *config)
+{
+	struct sh_css_isp_ob_params tmp;
+	struct sh_css_isp_ob_params *ob = &tmp;
+
+	ia_css_ob_encode(&tmp, from, config);
+
+	{
+		unsigned i;
+		unsigned sp_obarea_start_bq  = ob->area_start_bq;
+		unsigned sp_obarea_length_bq = ob->area_length_bq;
+		unsigned low = sp_obarea_start_bq;
+		unsigned high = low + sp_obarea_length_bq;
+		unsigned all_ones = ~0;
+
+		for (i = 0; i < OBAREA_MASK_SIZE; i++) {
+			to->vmask[i/ISP_VEC_NELEMS][i%ISP_VEC_NELEMS] = (i >= low && i < high) * all_ones;
+		}
+	}
+}
+
+void
+ia_css_ob_dump(
+	const struct sh_css_isp_ob_params *ob,
+	unsigned level)
+{
+	if (!ob) return;
+	ia_css_debug_dtrace(level, "Optical Black:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"ob_blacklevel_gr", ob->blacklevel_gr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"ob_blacklevel_r", ob->blacklevel_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"ob_blacklevel_b", ob->blacklevel_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"ob_blacklevel_gb", ob->blacklevel_gb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"obarea_start_bq", ob->area_start_bq);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"obarea_length_bq", ob->area_length_bq);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+		"obarea_length_bq_inverse",
+		ob->area_length_bq_inverse);
+}
+
+
+void
+ia_css_ob_debug_dtrace(
+	const struct ia_css_ob_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.mode=%d, "
+		"config.level_gr=%d, config.level_r=%d, "
+		"config.level_b=%d,  config.level_gb=%d, "
+		"config.start_position=%d, config.end_position=%d\n",
+		config->mode,
+		config->level_gr, config->level_r,
+		config->level_b, config->level_gb,
+		config->start_position, config->end_position);
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob.host.h b/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob.host.h
new file mode 100644
index 0000000..30b3d74
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob.host.h
@@ -0,0 +1,58 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_OB_HOST_H
+#define __IA_CSS_OB_HOST_H
+
+#include "ia_css_ob_types.h"
+#include "ia_css_ob_param.h"
+
+extern const struct ia_css_ob_config default_ob_config;
+
+void
+ia_css_ob_configure(
+	struct sh_css_isp_ob_stream_config *config,
+	unsigned int isp_pipe_version,
+	unsigned int raw_bit_depth);
+
+void
+ia_css_ob_encode(
+	struct sh_css_isp_ob_params *to,
+	const struct ia_css_ob_config *from,
+	const struct sh_css_isp_ob_stream_config *config);
+
+void
+ia_css_ob_vmem_encode(
+	struct sh_css_isp_ob_vmem_params *to,
+	const struct ia_css_ob_config *from,
+	const struct sh_css_isp_ob_stream_config *config);
+
+void
+ia_css_ob_dump(
+	const struct sh_css_isp_ob_params *ob,
+	unsigned level);
+
+void
+ia_css_ob_debug_dtrace(
+	const struct ia_css_ob_config *config, unsigned level)
+;
+
+#endif /* __IA_CSS_OB_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob_param.h b/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob_param.h
new file mode 100644
index 0000000..1e33b51
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob_param.h
@@ -0,0 +1,50 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_OB_PARAM_H
+#define __IA_CSS_OB_PARAM_H
+
+#include "type_support.h"
+#include "vmem.h"
+
+#define OBAREA_MASK_SIZE 64
+
+/* OB (Optical Black) */
+struct sh_css_isp_ob_stream_config {
+	unsigned isp_pipe_version;
+	unsigned raw_bit_depth;
+};
+
+struct sh_css_isp_ob_params {
+	int32_t blacklevel_gr;
+	int32_t blacklevel_r;
+	int32_t blacklevel_b;
+	int32_t blacklevel_gb;
+	int32_t area_start_bq;
+	int32_t area_length_bq;
+	int32_t area_length_bq_inverse;
+};
+
+struct sh_css_isp_ob_vmem_params {
+	VMEM_ARRAY(vmask, OBAREA_MASK_SIZE);
+};
+
+#endif /* __IA_CSS_OB_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob_types.h b/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob_types.h
new file mode 100644
index 0000000..bd2dfb4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ob/ob_1.0/ia_css_ob_types.h
@@ -0,0 +1,72 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_OB_TYPES_H
+#define __IA_CSS_OB_TYPES_H
+
+#include "ia_css_frac.h"
+
+/** Optical black mode.
+ */
+enum ia_css_ob_mode {
+	IA_CSS_OB_MODE_NONE,	/**< OB has no effect. */
+	IA_CSS_OB_MODE_FIXED,	/**< Fixed OB */
+	IA_CSS_OB_MODE_RASTER	/**< Raster OB */
+};
+
+/** Optical Black level configuration.
+ *
+ *  ISP block: OB1
+ *  ISP1: OB1 is used.
+ *  ISP2: OB1 is used.
+ */
+struct ia_css_ob_config {
+	enum ia_css_ob_mode mode; /**< Mode (None / Fixed / Raster).
+					enum, [0,2],
+					default 1, ineffective 0 */
+	ia_css_u0_16 level_gr;    /**< Black level for GR pixels
+					(used for Fixed Mode only).
+					u0.16, [0,65535],
+					default/ineffective 0 */
+	ia_css_u0_16 level_r;     /**< Black level for R pixels
+					(used for Fixed Mode only).
+					u0.16, [0,65535],
+					default/ineffective 0 */
+	ia_css_u0_16 level_b;     /**< Black level for B pixels
+					(used for Fixed Mode only).
+					u0.16, [0,65535],
+					default/ineffective 0 */
+	ia_css_u0_16 level_gb;    /**< Black level for GB pixels
+					(used for Fixed Mode only).
+					u0.16, [0,65535],
+					default/ineffective 0 */
+	uint16_t start_position; /**< Start position of OB area
+					(used for Raster Mode only).
+					u16.0, [0,63],
+					default/ineffective 0 */
+	uint16_t end_position;  /**< End position of OB area
+					(used for Raster Mode only).
+					u16.0, [0,63],
+					default/ineffective 0 */
+};
+
+#endif /* __IA_CSS_OB_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output.host.c b/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output.host.c
new file mode 100644
index 0000000..b654e43
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output.host.c
@@ -0,0 +1,98 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_frame.h"
+#include "ia_css.h"
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#include "ia_css_output.host.h"
+#include "isp.h"
+
+#include "assert_support.h"
+
+void
+ia_css_output_config(
+	struct sh_css_isp_output_isp_config *to,
+	const struct ia_css_output_configuration  *from)
+{
+	unsigned elems_a = ISP_VEC_NELEMS;
+	ia_css_dma_configure_from_info(&to->port_b, from->info);
+	to->width_a_over_b = elems_a / to->port_b.elems;
+	to->height = from->info->res.height;
+	to->enable = from->info != NULL;
+	if (from->info) {
+		ia_css_frame_info_to_frame_sp_info(&to->info, from->info);
+	}
+
+	/* Assume divisiblity here, may need to generalize to fixed point. */
+	assert (elems_a % to->port_b.elems == 0);
+}
+
+void
+ia_css_output0_config(
+	struct sh_css_isp_output_isp_config      *to,
+	const struct ia_css_output0_configuration *from)
+{
+	ia_css_output_config (
+		to, (const struct ia_css_output_configuration *)from);
+}
+
+void
+ia_css_output1_config(
+	struct sh_css_isp_output_isp_config      *to,
+	const struct ia_css_output1_configuration *from)
+{
+	ia_css_output_config (
+		to, (const struct ia_css_output_configuration *)from);
+}
+
+void
+ia_css_output_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *info)
+{
+	const struct ia_css_output_configuration config =
+		{ info };
+	if (info)
+		ia_css_configure_output(binary, &config);
+}
+
+void
+ia_css_output0_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *info)
+{
+	const struct ia_css_output0_configuration config =
+		{ info };
+	if (info)
+		ia_css_configure_output0(binary, &config);
+}
+
+void
+ia_css_output1_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *info)
+{
+	const struct ia_css_output1_configuration config =
+		{ info };
+	if (info)
+		ia_css_configure_output1(binary, &config);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output.host.h b/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output.host.h
new file mode 100644
index 0000000..34800d8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output.host.h
@@ -0,0 +1,61 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_OUTPUT_HOST_H
+#define __IA_CSS_OUTPUT_HOST_H
+
+#include "ia_css.h"
+#include "ia_css_binary.h"
+
+#include "ia_css_output_types.h"
+#include "ia_css_output_param.h"
+
+void
+ia_css_output_config(
+	struct sh_css_isp_output_isp_config      *to,
+	const struct ia_css_output_configuration *from);
+
+void
+ia_css_output0_config(
+	struct sh_css_isp_output_isp_config      *to,
+	const struct ia_css_output0_configuration *from);
+
+void
+ia_css_output1_config(
+	struct sh_css_isp_output_isp_config      *to,
+	const struct ia_css_output1_configuration *from);
+
+void
+ia_css_output_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *from);
+
+void
+ia_css_output0_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *from);
+
+void
+ia_css_output1_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *from);
+
+#endif /* __IA_CSS_OUTPUT_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output_param.h b/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output_param.h
new file mode 100644
index 0000000..017bca4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output_param.h
@@ -0,0 +1,38 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_OUTPUT_PARAM_H
+#define __IA_CSS_OUTPUT_PARAM_H
+
+#include <type_support.h>
+#include "dma.h"
+#include "ia_css_frame_comm.h" /* ia_css_frame_sp_info */
+
+/** output frame */
+struct sh_css_isp_output_isp_config {
+	uint32_t width_a_over_b;
+	uint32_t height;
+	uint32_t enable;
+	struct ia_css_frame_sp_info info;
+	struct dma_port_config port_b;
+};
+
+#endif /* __IA_CSS_OUTPUT_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output_types.h b/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output_types.h
new file mode 100644
index 0000000..69c2416
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/output/output_1.0/ia_css_output_types.h
@@ -0,0 +1,45 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_OUTPUT_TYPES_H
+#define __IA_CSS_OUTPUT_TYPES_H
+
+/** Output frame
+ *
+ *  ISP block: output frame
+ */
+
+#include "ia_css.h"
+
+struct ia_css_output_configuration {
+	const struct ia_css_frame_info *info;
+};
+
+struct ia_css_output0_configuration {
+	const struct ia_css_frame_info *info;
+};
+
+struct ia_css_output1_configuration {
+	const struct ia_css_frame_info *info;
+};
+
+#endif /* __IA_CSS_OUTPUT_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c b/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
new file mode 100644
index 0000000..d3e9efd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
@@ -0,0 +1,58 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_frame.h"
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#include "isp.h"
+
+#include "ia_css_qplane.host.h"
+
+void
+ia_css_qplane_config(
+	struct sh_css_isp_qplane_isp_config *to,
+	const struct ia_css_qplane_configuration  *from)
+{
+	unsigned elems_a = ISP_VEC_NELEMS;
+	ia_css_dma_configure_from_info(&to->port_b, from->info);
+	to->width_a_over_b = elems_a / to->port_b.elems;
+
+	/* Assume divisiblity here, may need to generalize to fixed point. */
+	assert (elems_a % to->port_b.elems == 0);
+
+	to->inout_port_config       = from->pipe->inout_port_config;
+	to->format = from->info->format;
+}
+
+void
+ia_css_qplane_configure(
+	const struct sh_css_sp_pipeline *pipe,
+	const struct ia_css_binary      *binary,
+	const struct ia_css_frame_info  *info)
+{
+	const struct ia_css_qplane_configuration config =
+		{ pipe, info };
+	ia_css_configure_qplane(binary, &config);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane.host.h b/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane.host.h
new file mode 100644
index 0000000..9de1d89
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane.host.h
@@ -0,0 +1,49 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_QPLANE_HOST_H
+#define __IA_CSS_QPLANE_HOST_H
+
+#include <ia_css_frame_public.h>
+#include <ia_css_binary.h>
+
+#if 0
+/* Cannot be included, since sh_css_internal.h is too generic
+ * e.g. for FW generation.
+*/
+#include "sh_css_internal.h"	/* sh_css_sp_pipeline */
+#endif
+
+#include "ia_css_qplane_types.h"
+#include "ia_css_qplane_param.h"
+
+void
+ia_css_qplane_config(
+	struct sh_css_isp_qplane_isp_config      *to,
+	const struct ia_css_qplane_configuration *from);
+
+void
+ia_css_qplane_configure(
+	const struct sh_css_sp_pipeline *pipe,
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *from);
+
+#endif /* __IA_CSS_QPLANE_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane_param.h b/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane_param.h
new file mode 100644
index 0000000..f6708cb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane_param.h
@@ -0,0 +1,37 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_QPLANE_PARAM_H
+#define __IA_CSS_QPLANE_PARAM_H
+
+#include <type_support.h>
+#include "dma.h"
+
+/* qplane channel */
+struct sh_css_isp_qplane_isp_config {
+	uint32_t width_a_over_b;
+	struct dma_port_config port_b;
+	uint32_t inout_port_config;
+	uint32_t input_needs_raw_binning;
+	uint32_t format; /* enum ia_css_frame_format */
+};
+
+#endif /* __IA_CSS_QPLANE_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane_types.h b/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane_types.h
new file mode 100644
index 0000000..91e93e2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/qplane/qplane_2/ia_css_qplane_types.h
@@ -0,0 +1,41 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_QPLANE_TYPES_H
+#define __IA_CSS_QPLANE_TYPES_H
+
+#include <ia_css_frame_public.h>
+/* need include for sh_css_sp_pipeline but cannot include sh_css_internal.h */
+
+/** qplane frame
+ *
+ *  ISP block: qplane frame
+ */
+
+#include "ia_css.h"
+
+struct ia_css_qplane_configuration {
+	const struct sh_css_sp_pipeline *pipe;
+	const struct ia_css_frame_info  *info;
+};
+
+#endif /* __IA_CSS_QPLANE_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw.host.c b/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
new file mode 100644
index 0000000..3a62e1b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
@@ -0,0 +1,157 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_frame.h"
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#include "isp.h"
+#include "isp/modes/interface/isp_types.h"
+
+#include "ia_css_raw.host.h"
+
+void
+ia_css_raw_encode(
+	struct sh_css_isp_raw_params *to,
+	const struct ia_css_aa_config *from)
+{
+	to->baf_strength = from->strength;
+}
+
+void
+ia_css_raw_dump(
+	const struct sh_css_isp_raw_params *raw,
+	unsigned level)
+{
+	(void)raw;
+	(void)level;
+}
+
+static inline unsigned
+sh_css_elems_bytes_from_info (unsigned raw_bit_depth)
+{
+	return CEIL_DIV(raw_bit_depth,8);
+}
+
+static inline unsigned
+sh_css_stride_from_info (
+	enum ia_css_frame_format format,
+	unsigned stride_b,
+	unsigned raw_bit_depth)
+{
+	/* padded_width is in terms of elements */
+	unsigned stride;
+	if (format == IA_CSS_FRAME_FORMAT_RAW_PACKED) {
+		stride = ((unsigned)HIVE_ISP_DDR_WORD_BYTES) *
+				CEIL_DIV(stride_b,
+				(unsigned char)(HIVE_ISP_DDR_WORD_BITS /
+					raw_bit_depth));
+	} else {
+		stride = stride_b * sh_css_elems_bytes_from_info(raw_bit_depth);
+	}
+	return stride;
+}
+
+/* MW: These areMIPI / ISYS properties, not camera function properties */
+static enum sh_stream_format
+css2isp_stream_format(enum ia_css_stream_format from)
+{
+	switch (from) {
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+		return sh_stream_format_yuv420_legacy;
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+		return sh_stream_format_yuv420;
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+		return sh_stream_format_yuv422;
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+		return sh_stream_format_rgb;
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+		return sh_stream_format_raw;
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+	default:
+		return sh_stream_format_raw;
+	}
+}
+
+void
+ia_css_raw_config(
+	struct sh_css_isp_raw_isp_config *to,
+	const struct ia_css_raw_configuration  *from)
+{
+	unsigned elems_a = ISP_VEC_NELEMS;
+	const struct ia_css_frame_info *in_info = from->in_info;
+	const struct ia_css_frame_info *internal_info = from->internal_info;
+#if !defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* 2401 input system uses input width width */
+	in_info = internal_info;
+#else
+	/*in some cases, in_info is NULL*/
+	if (in_info)
+		(void)internal_info;
+	else
+		in_info = internal_info;
+
+#endif
+	ia_css_dma_configure_from_info(&to->port_b, in_info);
+	to->width_a_over_b = elems_a / to->port_b.elems;
+	to->port_b.stride /= 2; /* Half BQ lines */
+
+	to->port_b.stride = sh_css_stride_from_info(in_info->format, to->port_b.stride, in_info->raw_bit_depth);
+
+	/* Assume divisiblity here, may need to generalize to fixed point. */
+	assert (elems_a % to->port_b.elems == 0);
+
+	to->inout_port_config       = from->pipe->inout_port_config;
+	to->format = in_info->format;
+	to->required_bds_factor = from->pipe->required_bds_factor;
+	to->two_ppc = from->two_ppc;
+	to->stream_format = css2isp_stream_format(from->stream_format);
+	to->deinterleaved = from->deinterleaved;
+}
+
+void
+ia_css_raw_configure(
+	const struct sh_css_sp_pipeline *pipe,
+	const struct ia_css_binary      *binary,
+	const struct ia_css_frame_info  *in_info,
+	const struct ia_css_frame_info  *internal_info,
+	bool two_ppc,
+	bool deinterleaved)
+{
+	const struct ia_css_raw_configuration config =
+		{ pipe, in_info, internal_info, two_ppc, binary->input_format, deinterleaved };
+	ia_css_configure_raw(binary, &config);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw.host.h b/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw.host.h
new file mode 100644
index 0000000..2499ad4
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw.host.h
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_RAW_HOST_H
+#define __IA_CSS_RAW_HOST_H
+
+#include "ia_css_binary.h"
+
+#include "ia_css_raw_types.h"
+#include "ia_css_raw_param.h"
+
+void
+ia_css_raw_encode(
+	struct sh_css_isp_raw_params *to,
+	const struct ia_css_aa_config *from);
+
+void
+ia_css_raw_dump(
+	const struct sh_css_isp_raw_params *raw,
+	unsigned level);
+
+void
+ia_css_raw_config(
+	struct sh_css_isp_raw_isp_config      *to,
+	const struct ia_css_raw_configuration *from);
+
+void
+ia_css_raw_configure(
+	const struct sh_css_sp_pipeline *pipe,
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *in_info,
+	const struct ia_css_frame_info *internal_info,
+	bool two_ppc,
+	bool deinterleaved);
+
+#endif /* __IA_CSS_RAW_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw_param.h b/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
new file mode 100644
index 0000000..3b0650b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
@@ -0,0 +1,47 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_RAW_PARAM_H
+#define __IA_CSS_RAW_PARAM_H
+
+#include "type_support.h"
+
+#include "dma.h"
+
+/* RAW (Optical Black) */
+struct sh_css_isp_raw_params {
+	int baf_strength;
+};
+
+/* Raw channel */
+struct sh_css_isp_raw_isp_config {
+	uint32_t width_a_over_b;
+	struct dma_port_config port_b;
+	uint32_t inout_port_config;
+	uint32_t input_needs_raw_binning;
+	uint32_t format; /* enum ia_css_frame_format */
+	uint32_t required_bds_factor;
+	uint32_t two_ppc;
+	uint32_t stream_format; /* enum sh_stream_format */
+	uint32_t deinterleaved;
+};
+
+#endif /* __IA_CSS_RAW_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw_types.h b/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw_types.h
new file mode 100644
index 0000000..5d52264
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/raw/raw_1.0/ia_css_raw_types.h
@@ -0,0 +1,45 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_RAW_TYPES_H
+#define __IA_CSS_RAW_TYPES_H
+
+#include <ia_css_frame_public.h>
+/* need include for sh_css_sp_pipeline but cannot include sh_css_internal.h */
+
+/** Raw frame
+ *
+ *  ISP block: Raw frame
+ */
+
+#include "ia_css.h"
+
+struct ia_css_raw_configuration {
+	const struct sh_css_sp_pipeline *pipe;
+	const struct ia_css_frame_info  *in_info;
+	const struct ia_css_frame_info  *internal_info;
+	bool two_ppc;
+	enum ia_css_stream_format stream_format;
+	bool deinterleaved;
+};
+
+#endif /* __IA_CSS_RAW_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.c b/drivers/media/atomisp2/css2400/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.c
new file mode 100644
index 0000000..b28408f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.c
@@ -0,0 +1,41 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#if !defined(HAS_NO_HMEM)
+
+#include "ia_css_memory_access.h"
+#include "memory_access.h"
+#include "ia_css_types.h"
+#include "sh_css_internal.h"
+#include "sh_css_frac.h"
+
+#include "ia_css_raa.host.h"
+
+void
+ia_css_raa_encode(
+	struct sh_css_isp_aa_params *to,
+	const struct ia_css_aa_config *from)
+{
+	(void)to;
+	(void)from;
+}
+
+#endif
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.h b/drivers/media/atomisp2/css2400/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.h
new file mode 100644
index 0000000..a456fc1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_RAA_HOST_H
+#define __IA_CSS_RAA_HOST_H
+
+#include "aa/aa_2/ia_css_aa2_types.h"
+#include "aa/aa_2/ia_css_aa2_param.h"
+
+void
+ia_css_raa_encode(
+	struct sh_css_isp_aa_params *to,
+	const struct ia_css_aa_config *from);
+
+#endif /* __IA_CSS_RAA_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref.host.c b/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref.host.c
new file mode 100644
index 0000000..0b94d29
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref.host.c
@@ -0,0 +1,52 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <assert_support.h>
+#include <ia_css_frame_public.h>
+#include <ia_css_frame.h>
+#include <ia_css_binary.h>
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#include "isp.h"
+#include "ia_css_ref.host.h"
+
+void
+ia_css_ref_config(
+	struct sh_css_isp_ref_isp_config *to,
+	const struct ia_css_ref_configuration  *from)
+{
+	unsigned elems_a = ISP_VEC_NELEMS;
+	ia_css_dma_configure_from_info(&to->port_b, from->info);
+	to->width_a_over_b = elems_a / to->port_b.elems;
+
+	/* Assume divisiblity here, may need to generalize to fixed point. */
+	assert (elems_a % to->port_b.elems == 0);
+}
+
+void
+ia_css_ref_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *info)
+{
+	const struct ia_css_ref_configuration config =
+		{ info };
+	ia_css_configure_ref(binary, &config);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref.host.h b/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref.host.h
new file mode 100644
index 0000000..95c4a1d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref.host.h
@@ -0,0 +1,41 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_REF_HOST_H
+#define __IA_CSS_REF_HOST_H
+
+#include <ia_css_frame_public.h>
+#include <ia_css_binary.h>
+
+#include "ia_css_ref_types.h"
+#include "ia_css_ref_param.h"
+
+void
+ia_css_ref_config(
+	struct sh_css_isp_ref_isp_config      *to,
+	const struct ia_css_ref_configuration *from);
+
+void
+ia_css_ref_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame_info *from);
+
+#endif /* __IA_CSS_REF_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref_param.h b/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref_param.h
new file mode 100644
index 0000000..0eac6a8
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref_param.h
@@ -0,0 +1,34 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_REF_PARAM_H
+#define __IA_CSS_REF_PARAM_H
+
+#include <type_support.h>
+#include "dma.h"
+
+/** Reference frame */
+struct sh_css_isp_ref_isp_config {
+	uint32_t width_a_over_b;
+	struct dma_port_config port_b;
+};
+
+#endif /* __IA_CSS_REF_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref_state.h b/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref_state.h
new file mode 100644
index 0000000..db29c9e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref_state.h
@@ -0,0 +1,32 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_REF_STATE_H
+#define __IA_CSS_REF_STATE_H
+
+#include "type_support.h"
+
+/* REF (temporal noise reduction) */
+struct sh_css_isp_ref_dmem_state {
+	int32_t ref_buf_idx;
+};
+
+#endif /* __IA_CSS_REF_STATE_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref_types.h b/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref_types.h
new file mode 100644
index 0000000..6a9daeb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ref/ref_1.0/ia_css_ref_types.h
@@ -0,0 +1,37 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_REF_TYPES_H
+#define __IA_CSS_REF_TYPES_H
+
+/** Reference frame
+ *
+ *  ISP block: reference frame
+ */
+
+#include <ia_css_frame_public.h>
+
+struct ia_css_ref_configuration {
+	const struct ia_css_frame_info *info;
+};
+
+#endif /* __IA_CSS_REF_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.c b/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.c
new file mode 100644
index 0000000..5b0b048
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.c
@@ -0,0 +1,218 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_frac.h"
+#include "assert_support.h"
+
+#include "bh/bh_2/ia_css_bh.host.h"
+#include "ia_css_s3a.host.h"
+
+const struct ia_css_3a_config default_3a_config = {
+	25559,
+	32768,
+	7209,
+	65535,
+	0,
+	65535,
+	{-3344, -6104, -19143, 19143, 6104, 3344, 0},
+	{1027, 0, -9219, 16384, -9219, 1027, 0}
+};
+
+static unsigned int s3a_raw_bit_depth;
+
+void
+ia_css_s3a_configure(unsigned int raw_bit_depth)
+{
+  s3a_raw_bit_depth = raw_bit_depth;
+}
+
+static void
+ia_css_ae_encode(
+	struct sh_css_isp_ae_params *to,
+	const struct ia_css_3a_config *from)
+{
+	/* coefficients to calculate Y */
+	to->y_coef_r =
+	    uDIGIT_FITTING(from->ae_y_coef_r, 16, SH_CSS_AE_YCOEF_SHIFT);
+	to->y_coef_g =
+	    uDIGIT_FITTING(from->ae_y_coef_g, 16, SH_CSS_AE_YCOEF_SHIFT);
+	to->y_coef_b =
+	    uDIGIT_FITTING(from->ae_y_coef_b, 16, SH_CSS_AE_YCOEF_SHIFT);
+}
+
+static void
+ia_css_awb_encode(
+	struct sh_css_isp_awb_params *to,
+	const struct ia_css_3a_config *from)
+{
+	/* AWB level gate */
+	to->lg_high_raw =
+		uDIGIT_FITTING(from->awb_lg_high_raw, 16, s3a_raw_bit_depth);
+	to->lg_low =
+		uDIGIT_FITTING(from->awb_lg_low, 16, SH_CSS_BAYER_BITS);
+	to->lg_high =
+		uDIGIT_FITTING(from->awb_lg_high, 16, SH_CSS_BAYER_BITS);
+}
+
+static void
+ia_css_af_encode(
+	struct sh_css_isp_af_params *to,
+	const struct ia_css_3a_config *from)
+{
+	unsigned int i;
+
+	/* af fir coefficients */
+	for (i = 0; i < 7; ++i) {
+		to->fir1[i] =
+		  sDIGIT_FITTING(from->af_fir1_coef[i], 15,
+				 SH_CSS_AF_FIR_SHIFT);
+		to->fir2[i] =
+		  sDIGIT_FITTING(from->af_fir2_coef[i], 15,
+				 SH_CSS_AF_FIR_SHIFT);
+	}
+}
+
+void
+ia_css_s3a_encode(
+	struct sh_css_isp_s3a_params *to,
+	const struct ia_css_3a_config *from)
+{
+	ia_css_ae_encode(&to->ae,  from);
+	ia_css_awb_encode(&to->awb, from);
+	ia_css_af_encode(&to->af,  from);
+}
+
+#if 0
+void
+ia_css_process_s3a(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	short dmem_offset = stage->binary->info->mem_offsets->dmem.s3a;
+
+	assert(params != NULL);
+
+	if (dmem_offset >= 0) {
+		ia_css_s3a_encode((struct sh_css_isp_s3a_params *)
+				&stage->isp_mem_params[IA_CSS_ISP_DMEM0].address[dmem_offset],
+				&params->s3a_config);
+		ia_css_bh_encode((struct sh_css_isp_bh_params *)
+				&stage->isp_mem_params[IA_CSS_ISP_DMEM0].address[dmem_offset],
+				&params->s3a_config);
+		params->isp_params_changed = true;
+		params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM0] = true;
+	}
+
+	params->isp_params_changed = true;
+}
+#endif
+
+void
+ia_css_ae_dump(
+	const struct sh_css_isp_ae_params *ae,
+	unsigned level)
+{
+	if (!ae) return;
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ae_y_coef_r", ae->y_coef_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ae_y_coef_g", ae->y_coef_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ae_y_coef_b", ae->y_coef_b);
+}
+
+void
+ia_css_awb_dump(
+	const struct sh_css_isp_awb_params *awb,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"awb_lg_high_raw", awb->lg_high_raw);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"awb_lg_low", awb->lg_low);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"awb_lg_high", awb->lg_high);
+}
+
+void
+ia_css_af_dump(
+	const struct sh_css_isp_af_params *af,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir1[0]", af->fir1[0]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir1[1]", af->fir1[1]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir1[2]", af->fir1[2]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir1[3]", af->fir1[3]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir1[4]", af->fir1[4]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir1[5]", af->fir1[5]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir1[6]", af->fir1[6]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir2[0]", af->fir2[0]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir2[1]", af->fir2[1]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir2[2]", af->fir2[2]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir2[3]", af->fir2[3]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir2[4]", af->fir2[4]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir2[5]", af->fir2[5]);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"af_fir2[6]", af->fir2[6]);
+}
+
+void
+ia_css_s3a_dump(
+	const struct sh_css_isp_s3a_params *s3a,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level, "S3A Support:\n");
+	ia_css_ae_dump  (&s3a->ae, level);
+	ia_css_awb_dump (&s3a->awb, level);
+	ia_css_af_dump  (&s3a->af, level);
+}
+
+void
+ia_css_s3a_debug_dtrace(
+	const struct ia_css_3a_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.ae_y_coef_r=%d, config.ae_y_coef_g=%d, "
+		"config.ae_y_coef_b=%d, config.awb_lg_high_raw=%d, "
+		"config.awb_lg_low=%d, config.awb_lg_high=%d\n",
+		config->ae_y_coef_r, config->ae_y_coef_g,
+		config->ae_y_coef_b, config->awb_lg_high_raw,
+		config->awb_lg_low, config->awb_lg_high);
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h b/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h
new file mode 100644
index 0000000..d47972c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h
@@ -0,0 +1,65 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+
+#ifndef __IA_CSS_S3A_HOST_H
+#define __IA_CSS_S3A_HOST_H
+
+#include "ia_css_s3a_types.h"
+#include "ia_css_s3a_param.h"
+
+extern const struct ia_css_3a_config default_3a_config;
+
+void
+ia_css_s3a_configure(
+	unsigned int raw_bit_depth);
+
+void
+ia_css_s3a_encode(
+	struct sh_css_isp_s3a_params *to,
+	const struct ia_css_3a_config *from);
+
+void
+ia_css_ae_dump(
+	const struct sh_css_isp_ae_params *ae,
+	unsigned level);
+
+void
+ia_css_awb_dump(
+	const struct sh_css_isp_awb_params *awb,
+	unsigned level);
+
+void
+ia_css_af_dump(
+	const struct sh_css_isp_af_params *af,
+	unsigned level);
+
+void
+ia_css_s3a_dump(
+	const struct sh_css_isp_s3a_params *s3a,
+	unsigned level);
+
+void
+ia_css_s3a_debug_dtrace(
+	const struct ia_css_3a_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_S3A_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a_param.h b/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a_param.h
new file mode 100644
index 0000000..05a8c42
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a_param.h
@@ -0,0 +1,61 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_S3A_PARAM_H
+#define __IA_CSS_S3A_PARAM_H
+
+#include "type_support.h"
+
+/* AE (3A Support) */
+struct sh_css_isp_ae_params {
+	/* coefficients to calculate Y */
+	int32_t y_coef_r;
+	int32_t y_coef_g;
+	int32_t y_coef_b;
+};
+
+/* AWB (3A Support) */
+struct sh_css_isp_awb_params {
+	int32_t lg_high_raw;
+	int32_t lg_low;
+	int32_t lg_high;
+};
+
+/* AF (3A Support) */
+struct sh_css_isp_af_params {
+	int32_t fir1[7];
+	int32_t fir2[7];
+};
+
+/* S3A (3A Support) */
+struct sh_css_isp_s3a_params {
+	/* coefficients to calculate Y */
+	struct sh_css_isp_ae_params ae;
+
+	/* AWB level gate */
+	struct sh_css_isp_awb_params awb;
+
+	/* af fir coefficients */
+	struct sh_css_isp_af_params af;
+};
+
+
+#endif /* __IA_CSS_S3A_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h b/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
new file mode 100644
index 0000000..4ebff65
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
@@ -0,0 +1,250 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_S3A_TYPES_H
+#define __IA_CSS_S3A_TYPES_H
+
+#if (defined(SYSTEM_css_skycam_a0t_system) || defined(SYSTEM_css_skycam_c0_system)) && (! defined(PIPE_GENERATION) )
+#include "../../../../components/stats_3a/src/stats_3a_public.h"
+#endif
+
+/** 3A configuration. This configures the 3A statistics collection
+ *  module.
+ */
+
+/** 3A statistics grid
+ *
+ *  ISP block: S3A1 (3A Support for 3A ver.1 (Histogram is not used for AE))
+ *             S3A2 (3A Support for 3A ver.2 (Histogram is used for AE))
+ *  ISP1: S3A1 is used.
+ *  ISP2: S3A2 is used.
+ */
+struct ia_css_3a_grid_info {
+
+#if defined(SYSTEM_css_skycam_a0t_system) || defined(SYSTEM_css_skycam_c0_system)
+	uint32_t ae_enable;					/**< ae enabled in binary,
+								   0:disabled, 1:enabled */
+	struct ae_public_config_grid_config	ae_grd_info;	/**< see description in ae_public.h*/
+
+  	uint32_t awb_enable;					/**< awb enabled in binary,
+								   0:disabled, 1:enabled */
+	struct awb_public_config_grid_config	awb_grd_info;	/**< see description in awb_public.h*/
+
+  	uint32_t af_enable;					/**< af enabled in binary,
+								   0:disabled, 1:enabled */
+	struct af_public_grid_config		af_grd_info;	/**< see description in af_public.h*/
+
+  	uint32_t awb_fr_enable;					/**< awb_fr enabled in binary,
+								   0:disabled, 1:enabled */
+	struct awb_fr_public_grid_config	awb_fr_grd_info;/**< see description in awb_fr_public.h*/
+
+        uint32_t elem_bit_depth;    /**< TODO:Taken from BYT  - need input from AIQ
+					if needed for SKC
+					Bit depth of element used
+					to calculate 3A statistics.
+					This is 13, which is the normalized
+					bayer bit depth in DSP. */
+
+#else
+	uint32_t enable;            /**< 3A statistics enabled.
+					0:disabled, 1:enabled */
+	uint32_t use_dmem;          /**< DMEM or VMEM determines layout.
+					0:3A statistics are stored to VMEM,
+					1:3A statistics are stored to DMEM */
+	uint32_t has_histogram;     /**< Statistics include histogram.
+					0:no histogram, 1:has histogram */
+	uint32_t width;	    	    /**< Width of 3A grid table.
+					(= Horizontal number of grid cells
+					in table, which cells have effective
+					statistics.) */
+	uint32_t height;	    /**< Height of 3A grid table.
+					(= Vertical number of grid cells
+					in table, which cells have effective
+					statistics.) */
+	uint32_t aligned_width;     /**< Horizontal stride (for alloc).
+					(= Horizontal number of grid cells
+					in table, which means
+					the allocated width.) */
+	uint32_t aligned_height;    /**< Vertical stride (for alloc).
+					(= Vertical number of grid cells
+					in table, which means
+					the allocated height.) */
+	uint32_t bqs_per_grid_cell; /**< Grid cell size in BQ(Bayer Quad) unit.
+					(1BQ means {Gr,R,B,Gb}(2x2 pixels).)
+					Valid values are 8,16,32,64. */
+	uint32_t deci_factor_log2;  /**< log2 of bqs_per_grid_cell. */
+	uint32_t elem_bit_depth;    /**< Bit depth of element used
+					to calculate 3A statistics.
+					This is 13, which is the normalized
+					bayer bit depth in DSP. */
+#endif
+};
+
+#if defined(SYSTEM_css_skycam_a0t_system) || defined(SYSTEM_css_skycam_c0_system)
+#define DEFAULT_3A_GRID_INFO \
+{ \
+	0,				/* ae_enable */ \
+	{0,0,0,0,0,0,0,0,0},	        /* AE:     width,height,b_width,b_height,x_start,y_start,x_end,y_end*/ \
+	0,				/* awb_enable */ \
+	{0,0,0,0,0,0,0,0},              /* AWB:    width,height,b_width,b_height,x_start,y_start,x_end,y_end*/ \
+	0,				/* af_enable */ \
+	{0,0,0,0,0,0,0},		/* AF:     width,height,b_width,b_height,x_start,y_start,ff_en*/ \
+	0,				/* awb_fr_enable */ \
+	{0,0,0,0,0,0,0},                  /* AWB_FR: width,height,b_width,b_height,x_start,y_start,ff_en*/ \
+	0,				/* elem_bit_depth */ \
+}
+#else
+#define DEFAULT_3A_GRID_INFO \
+{ \
+	0,				/* enable */ \
+	0,				/* use_dmem */ \
+	0,				/* has_histogram */ \
+	0,				/* width */ \
+	0,				/* height */ \
+	0,				/* aligned_width */ \
+	0,				/* aligned_height */ \
+	0,				/* bqs_per_grid_cell */ \
+	0,				/* deci_factor_log2 */ \
+	0,				/* elem_bit_depth */ \
+}
+
+#endif
+
+/* This struct should be split into 3, for AE, AWB and AF.
+ * However, that will require driver/ 3A lib modifications.
+ */
+
+/** 3A configuration. This configures the 3A statistics collection
+ *  module.
+ *
+ *  ae_y_*: Coefficients to calculate luminance from bayer.
+ *  awb_lg_*: Thresholds to check the saturated bayer pixels for AWB.
+ *    Condition of effective pixel for AWB level gate check:
+ *      bayer(sensor) <= awb_lg_high_raw &&
+ *      bayer(when AWB statisitcs is calculated) >= awb_lg_low &&
+ *      bayer(when AWB statisitcs is calculated) <= awb_lg_high
+ *  af_fir*: Coefficients of high pass filter to calculate AF statistics.
+ *
+ *  ISP block: S3A1(ae_y_* for AE/AF, awb_lg_* for AWB)
+ *             S3A2(ae_y_* for AF, awb_lg_* for AWB)
+ *             SDVS1(ae_y_*)
+ *             SDVS2(ae_y_*)
+ *  ISP1: S3A1 and SDVS1 are used.
+ *  ISP2: S3A2 and SDVS2 are used.
+ */
+struct ia_css_3a_config {
+	ia_css_u0_16 ae_y_coef_r;	/**< Weight of R for Y.
+						u0.16, [0,65535],
+						default/ineffective 25559 */
+	ia_css_u0_16 ae_y_coef_g;	/**< Weight of G for Y.
+						u0.16, [0,65535],
+						default/ineffective 32768 */
+	ia_css_u0_16 ae_y_coef_b;	/**< Weight of B for Y.
+						u0.16, [0,65535],
+						default/ineffective 7209 */
+	ia_css_u0_16 awb_lg_high_raw;	/**< AWB level gate high for raw.
+						u0.16, [0,65535],
+						default 65472(=1023*64),
+						ineffective 65535 */
+	ia_css_u0_16 awb_lg_low;	/**< AWB level gate low.
+						u0.16, [0,65535],
+						default 64(=1*64),
+						ineffective 0 */
+	ia_css_u0_16 awb_lg_high;	/**< AWB level gate high.
+						u0.16, [0,65535],
+						default 65535,
+						ineffective 65535 */
+	ia_css_s0_15 af_fir1_coef[7];	/**< AF FIR coefficients of fir1.
+						s0.15, [-32768,32767],
+				default/ineffective
+				-6689,-12207,-32768,32767,12207,6689,0 */
+	ia_css_s0_15 af_fir2_coef[7];	/**< AF FIR coefficients of fir2.
+						s0.15, [-32768,32767],
+				default/ineffective
+				2053,0,-18437,32767,-18437,2053,0 */
+};
+
+/** 3A statistics. This structure describes the data stored
+ *  in each 3A grid point.
+ *
+ *  ISP block: S3A1 (3A Support for 3A ver.1) (Histogram is not used for AE)
+ *             S3A2 (3A Support for 3A ver.2) (Histogram is used for AE)
+ *             - ae_y is used only for S3A1.
+ *             - awb_* and af_* are used both for S3A1 and S3A2.
+ *  ISP1: S3A1 is used.
+ *  ISP2: S3A2 is used.
+ */
+struct ia_css_3a_output {
+	int32_t ae_y;    /**< Sum of Y in a statistics window, for AE.
+				(u19.13) */
+	int32_t awb_cnt; /**< Number of effective pixels
+				in a statistics window.
+				Pixels passed by the AWB level gate check are
+				judged as "effective". (u32) */
+	int32_t awb_gr;  /**< Sum of Gr in a statistics window, for AWB.
+				All Gr pixels (not only for effective pixels)
+				are summed. (u19.13) */
+	int32_t awb_r;   /**< Sum of R in a statistics window, for AWB.
+				All R pixels (not only for effective pixels)
+				are summed. (u19.13) */
+	int32_t awb_b;   /**< Sum of B in a statistics window, for AWB.
+				All B pixels (not only for effective pixels)
+				are summed. (u19.13) */
+	int32_t awb_gb;  /**< Sum of Gb in a statistics window, for AWB.
+				All Gb pixels (not only for effective pixels)
+				are summed. (u19.13) */
+	int32_t af_hpf1; /**< Sum of |Y| following high pass filter af_fir1
+				within a statistics window, for AF. (u19.13) */
+	int32_t af_hpf2; /**< Sum of |Y| following high pass filter af_fir2
+				within a statistics window, for AF. (u19.13) */
+};
+
+
+/** 3A Statistics. This structure describes the statistics that are generated
+ *  using the provided configuration (ia_css_3a_config).
+ */
+struct ia_css_3a_statistics {
+	struct ia_css_3a_grid_info    grid;	/**< grid info contains the dimensions of the 3A grid */
+	struct ia_css_3a_output      *data;	/**< the pointer to 3a_output[grid.width * grid.height]
+						     containing the 3A statistics */
+	struct ia_css_3a_rgby_output *rgby_data;/**< the pointer to 3a_rgby_output[256]
+						     containing the histogram */
+};
+
+/** Histogram (Statistics for AE).
+ *
+ *  4 histograms(r,g,b,y),
+ *  256 bins for each histogram, unsigned 24bit value for each bin.
+ *    struct ia_css_3a_rgby_output data[256];
+
+ *  ISP block: HIST2
+ * (ISP1: HIST2 is not used.)
+ *  ISP2: HIST2 is used.
+ */
+struct ia_css_3a_rgby_output {
+	uint32_t r;	/**< Number of R of one bin of the histogram R. (u24) */
+	uint32_t g;	/**< Number of G of one bin of the histogram G. (u24) */
+	uint32_t b;	/**< Number of B of one bin of the histogram B. (u24) */
+	uint32_t y;	/**< Number of Y of one bin of the histogram Y. (u24) */
+};
+
+#endif /* __IA_CSS_S3A_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc.host.c b/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc.host.c
new file mode 100644
index 0000000..0109ab5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc.host.c
@@ -0,0 +1,68 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_sc.host.h"
+
+void
+ia_css_sc_encode(
+	struct sh_css_isp_sc_params *to,
+	struct ia_css_shading_table **from)
+{
+	to->gain_shift = (*from)->fraction_bits;
+}
+
+#if 0
+void
+ia_css_process_sc(
+	unsigned pipe_id,
+	const struct ia_css_pipeline_stage *stage,
+	struct ia_css_isp_parameters *params)
+{
+	short dmem_offset = stage->binary->info->mem_offsets->dmem.sc;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_sc() enter:\n");
+
+	if (dmem_offset >= 0) {
+		ia_css_sc_encode((struct sh_css_isp_sc_params *)
+				&stage->isp_mem_params[IA_CSS_ISP_DMEM0].address[dmem_offset],
+				params->tmp_sc_table);
+		params->isp_params_changed = true;
+		params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM0] = true;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_sc() leave:\n");
+}
+#endif
+
+void
+ia_css_sc_dump(
+	const struct sh_css_isp_sc_params *sc,
+	unsigned level)
+{
+	if (!sc) return;
+	ia_css_debug_dtrace(level, "Shading Correction:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"sc_gain_shift", sc->gain_shift);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc.host.h b/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc.host.h
new file mode 100644
index 0000000..c5e47a9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc.host.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_SC_HOST_H
+#define __IA_CSS_SC_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_sc_types.h"
+#include "ia_css_sc_param.h"
+
+void
+ia_css_sc_encode(
+	struct sh_css_isp_sc_params *to,
+	struct ia_css_shading_table **from);
+
+void
+ia_css_sc_dump(
+	const struct sh_css_isp_sc_params *sc,
+	unsigned level);
+
+#endif /* __IA_CSS_SC_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc_param.h b/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc_param.h
new file mode 100644
index 0000000..836e6c5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc_param.h
@@ -0,0 +1,32 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_SC_PARAM_H
+#define __IA_CSS_SC_PARAM_H
+
+#include "type_support.h"
+
+/* SC (Shading Corrction) */
+struct sh_css_isp_sc_params {
+	int32_t gain_shift;
+};
+
+#endif /* __IA_CSS_SC_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc_types.h b/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc_types.h
new file mode 100644
index 0000000..1ab3edd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/sc/sc_1.0/ia_css_sc_types.h
@@ -0,0 +1,67 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_SC_TYPES_H
+#define __IA_CSS_SC_TYPES_H
+
+/** Number of color planes in the shading table. */
+#define IA_CSS_SC_NUM_COLORS           4
+
+/** The 4 colors that a shading table consists of.
+ *  For each color we store a grid of values.
+ */
+enum ia_css_sc_color {
+	IA_CSS_SC_COLOR_GR, /**< Green on a green-red line */
+	IA_CSS_SC_COLOR_R,  /**< Red */
+	IA_CSS_SC_COLOR_B,  /**< Blue */
+	IA_CSS_SC_COLOR_GB  /**< Green on a green-blue line */
+};
+
+/** Lens Shading Correction table.
+ *
+ *  This describes the color shading artefacts
+ *  introduced by lens imperfections. To correct artefacts,
+ *  bayer values should be multiplied by gains in this table.
+ *
+ *  ISP block: SC1
+ *  ISP1: SC1 is used.
+ *  ISP2: SC1 is used.
+ */
+struct ia_css_shading_table {
+	uint32_t enable; /**< Set to false for no shading correction.
+		          The data field can be NULL when enable == true */
+	uint32_t sensor_width;  /**< Native sensor width in pixels. */
+	uint32_t sensor_height; /**< Native sensor height in lines. */
+	uint32_t width;  /**< Number of data points per line per color.
+				u8.0, [0,81] */
+	uint32_t height; /**< Number of lines of data points per color.
+				u8.0, [0,61] */
+	uint32_t fraction_bits; /**< Bits of fractional part in the data
+				points.
+				u8.0, [0,13] */
+	uint16_t *data[IA_CSS_SC_NUM_COLORS];
+	/**< Table data, one array for each color.
+	     Use ia_css_sc_color to index this array.
+	     u[13-fraction_bits].[fraction_bits], [0,8191] */
+};
+
+#endif /* __IA_CSS_SC_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/scale/scale_1.0/ia_css_scale_param.h b/drivers/media/atomisp2/css2400/isp/kernels/scale/scale_1.0/ia_css_scale_param.h
new file mode 100644
index 0000000..bed3519
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/scale/scale_1.0/ia_css_scale_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_SCALE_PARAM_H
+#define _IA_CSS_SCALE_PARAM_H
+
+#include "uds/uds_1.0/ia_css_uds_param.h"
+
+#endif /* _IA_CSS_SCALE_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.c b/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.c
new file mode 100644
index 0000000..18653a9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.c
@@ -0,0 +1,116 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "ia_css_frame.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_frac.h"
+#include "assert_support.h"
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#include "isp.h"
+
+#include "ia_css_tnr.host.h"
+const struct ia_css_tnr_config default_tnr_config = {
+	32768,
+	32,
+	32,
+};
+
+void
+ia_css_tnr_encode(
+	struct sh_css_isp_tnr_params *to,
+	const struct ia_css_tnr_config *from)
+{
+	to->coef =
+	    uDIGIT_FITTING(from->gain, 16, SH_CSS_TNR_COEF_SHIFT);
+	to->threshold_Y =
+	    uDIGIT_FITTING(from->threshold_y, 16, SH_CSS_ISP_YUV_BITS);
+	to->threshold_C =
+	    uDIGIT_FITTING(from->threshold_uv, 16, SH_CSS_ISP_YUV_BITS);
+}
+
+void
+ia_css_tnr_dump(
+	const struct sh_css_isp_tnr_params *tnr,
+	unsigned level)
+{
+	if (!tnr) return;
+	ia_css_debug_dtrace(level, "Temporal Noise Reduction:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"tnr_coef", tnr->coef);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"tnr_threshold_Y", tnr->threshold_Y);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n"
+			"tnr_threshold_C", tnr->threshold_C);
+}
+
+void
+ia_css_tnr_debug_dtrace(
+	const struct ia_css_tnr_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.gain=%d, "
+		"config.threshold_y=%d, config.threshold_uv=%d\n",
+		config->gain,
+		config->threshold_y, config->threshold_uv);
+}
+
+void
+ia_css_tnr_config(
+	struct sh_css_isp_tnr_isp_config *to,
+	const struct ia_css_tnr_configuration *from)
+{
+	unsigned elems_a = ISP_VEC_NELEMS, i;
+	ia_css_dma_configure_from_info(&to->port_b, &(from->tnr_frames[0]->info));
+	to->width_a_over_b = elems_a / to->port_b.elems;
+	to->frame_height = from->tnr_frames[0]->info.res.height;
+	for (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++) {
+		to->tnr_frame_addr[i] = from->tnr_frames[i]->data + from->tnr_frames[i]->planes.yuyv.offset;
+	}
+
+	/* Assume divisiblity here, may need to generalize to fixed point. */
+	assert (elems_a % to->port_b.elems == 0);
+}
+
+void
+ia_css_tnr_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame **frames)
+{
+	struct ia_css_tnr_configuration config;
+	unsigned i;
+
+	for (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++)
+		config.tnr_frames[i] = frames[i];
+
+	ia_css_configure_tnr(binary, &config);
+}
+
+void
+ia_css_init_tnr_state(struct sh_css_isp_tnr_dmem_state *state)
+{
+	assert(NUM_VIDEO_TNR_FRAMES >= 2);
+	state->tnr_in_buf_idx = 0;
+	state->tnr_out_buf_idx = 1;
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h b/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h
new file mode 100644
index 0000000..7020815
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h
@@ -0,0 +1,60 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_TNR_HOST_H
+#define __IA_CSS_TNR_HOST_H
+
+#include "ia_css_binary.h"
+#include "ia_css_tnr_state.h"
+#include "ia_css_tnr_types.h"
+#include "ia_css_tnr_param.h"
+
+extern const struct ia_css_tnr_config default_tnr_config;
+
+void
+ia_css_tnr_encode(
+	struct sh_css_isp_tnr_params *to,
+	const struct ia_css_tnr_config *from);
+
+void
+ia_css_tnr_dump(
+	const struct sh_css_isp_tnr_params *tnr,
+	unsigned level);
+
+void
+ia_css_tnr_debug_dtrace(
+	const struct ia_css_tnr_config *config,
+	unsigned level);
+
+void
+ia_css_tnr_config(
+	struct sh_css_isp_tnr_isp_config      *to,
+	const struct ia_css_tnr_configuration *from);
+
+void
+ia_css_tnr_configure(
+	const struct ia_css_binary     *binary,
+	const struct ia_css_frame **frames);
+
+void
+ia_css_init_tnr_state(
+	struct sh_css_isp_tnr_dmem_state *state);
+#endif /* __IA_CSS_TNR_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr_param.h b/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr_param.h
new file mode 100644
index 0000000..71149f0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr_param.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_TNR_PARAM_H
+#define __IA_CSS_TNR_PARAM_H
+
+#include "type_support.h"
+#include "dma.h"
+
+/* TNR (Temporal Noise Reduction) */
+struct sh_css_isp_tnr_params {
+	int32_t coef;
+	int32_t threshold_Y;
+	int32_t threshold_C;
+};
+
+struct sh_css_isp_tnr_isp_config {
+	uint32_t width_a_over_b;
+	uint32_t frame_height;
+	struct dma_port_config port_b;
+	hrt_vaddress tnr_frame_addr[NUM_VIDEO_TNR_FRAMES];
+};
+
+#endif /* __IA_CSS_TNR_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr_state.h b/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr_state.h
new file mode 100644
index 0000000..e9cd1eb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr_state.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_TNR_STATE_H
+#define __IA_CSS_TNR_STATE_H
+
+#include "type_support.h"
+
+/* TNR (temporal noise reduction) */
+struct sh_css_isp_tnr_dmem_state {
+	uint32_t tnr_in_buf_idx;
+	uint32_t tnr_out_buf_idx;
+};
+
+#endif /* __IA_CSS_TNR_STATE_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr_types.h b/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr_types.h
new file mode 100644
index 0000000..d62b120
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/tnr/tnr_1.0/ia_css_tnr_types.h
@@ -0,0 +1,68 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_TNR_TYPES_H
+#define __IA_CSS_TNR_TYPES_H
+
+/** Temporal Noise Reduction (TNR) configuration.
+ *
+ *  When difference between current frame and previous frame is less than or
+ *  equal to threshold, TNR works and current frame is mixed
+ *  with previous frame.
+ *  When difference between current frame and previous frame is greater
+ *  than threshold, we judge motion is detected. Then, TNR does not work and
+ *  current frame is outputted as it is.
+ *  Therefore, when threshold_y and threshold_uv are set as 0, TNR can be disabled.
+ *
+ *  ISP block: TNR1
+ *  ISP1: TNR1 is used.
+ *  ISP2: TNR1 is used.
+ */
+
+/* copied from sh_css_defs.h, should find a proper place for this host ISP shared defs */
+#define NUM_VIDEO_TNR_FRAMES 2
+
+struct ia_css_tnr_config {
+	ia_css_u0_16 gain; /**< Interpolation ratio of current frame
+			        and previous frame.
+				gain=0.0 -> previous frame is outputted.
+				gain=1.0 -> current frame is outputted.
+				u0.16, [0,65535],
+			default 32768(0.5), ineffective 65535(almost 1.0) */
+	ia_css_u0_16 threshold_y; /**< Threshold to enable interpolation of Y.
+				If difference between current frame and
+				previous frame is greater than threshold_y,
+				TNR for Y is disabled.
+				u0.16, [0,65535], default/ineffective 0 */
+	ia_css_u0_16 threshold_uv; /**< Threshold to enable interpolation of
+				U/V.
+				If difference between current frame and
+				previous frame is greater than threshold_uv,
+				TNR for UV is disabled.
+				u0.16, [0,65535], default/ineffective 0 */
+};
+
+struct ia_css_tnr_configuration {
+	const struct ia_css_frame *tnr_frames[NUM_VIDEO_TNR_FRAMES];
+};
+
+#endif /* __IA_CSS_TNR_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/uds/uds_1.0/ia_css_uds.host.c b/drivers/media/atomisp2/css2400/isp/kernels/uds/uds_1.0/ia_css_uds.host.c
new file mode 100644
index 0000000..f3be89d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/uds/uds_1.0/ia_css_uds.host.c
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_uds.host.h"
+
+void
+ia_css_uds_encode(
+	struct sh_css_sp_uds_params *to,
+	const struct ia_css_uds_config *from)
+{
+	to->crop_pos = from->crop_pos;
+	to->uds      = from->uds;
+}
+
+void
+ia_css_uds_dump(
+	const struct sh_css_sp_uds_params *uds,
+	unsigned level);
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/uds/uds_1.0/ia_css_uds.host.h b/drivers/media/atomisp2/css2400/isp/kernels/uds/uds_1.0/ia_css_uds.host.h
new file mode 100644
index 0000000..92da6da
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/uds/uds_1.0/ia_css_uds.host.h
@@ -0,0 +1,39 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_UDS_HOST_H
+#define __IA_CSS_UDS_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_uds_param.h"
+
+void
+ia_css_uds_encode(
+	struct sh_css_sp_uds_params *to,
+	const struct ia_css_uds_config *from);
+
+void
+ia_css_uds_dump(
+	const struct sh_css_sp_uds_params *uds,
+	unsigned level);
+
+#endif /* __IA_CSS_UDS_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/uds/uds_1.0/ia_css_uds_param.h b/drivers/media/atomisp2/css2400/isp/kernels/uds/uds_1.0/ia_css_uds_param.h
new file mode 100644
index 0000000..ee6fe9e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/uds/uds_1.0/ia_css_uds_param.h
@@ -0,0 +1,38 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_UDS_PARAM_H
+#define __IA_CSS_UDS_PARAM_H
+
+#include "sh_css_uds.h"
+
+/* uds (Up and Down scaling) */
+struct ia_css_uds_config {
+	struct sh_css_crop_pos crop_pos;
+	struct sh_css_uds_info uds;
+};
+
+struct sh_css_sp_uds_params {
+	struct sh_css_crop_pos crop_pos;
+	struct sh_css_uds_info uds;
+};
+
+#endif /* __IA_CSS_UDS_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf.host.c b/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf.host.c
new file mode 100644
index 0000000..66be21b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf.host.c
@@ -0,0 +1,146 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_vf.host.h"
+#include <assert_support.h>
+#include <ia_css_err.h>
+#include <ia_css_frame.h>
+#include <ia_css_frame_public.h>
+#include <ia_css_pipeline.h>
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#include <assert_support.h>
+
+#include "isp.h"
+
+void
+ia_css_vf_config(
+	struct sh_css_isp_vf_isp_config *to,
+	const struct ia_css_vf_configuration  *from)
+{
+	unsigned elems_a = ISP_VEC_NELEMS;
+
+	to->vf_downscale_bits = from->vf_downscale_bits;
+	to->enable = from->info != NULL;
+
+	if (from->info) {
+		ia_css_frame_info_to_frame_sp_info(&to->info, from->info);
+		ia_css_dma_configure_from_info(&to->dma.port_b, from->info);
+		to->dma.width_a_over_b = elems_a / to->dma.port_b.elems;
+
+		/* Assume divisiblity here, may need to generalize to fixed point. */
+		assert (elems_a % to->dma.port_b.elems == 0);
+	}
+}
+
+/* compute the log2 of the downscale factor needed to get closest
+ * to the requested viewfinder resolution on the upper side. The output cannot
+ * be smaller than the requested viewfinder resolution.
+ */
+enum ia_css_err
+sh_css_vf_downscale_log2(
+	const struct ia_css_frame_info *out_info,
+	const struct ia_css_frame_info *vf_info,
+	unsigned int *downscale_log2)
+{
+       unsigned int ds_log2 = 0;
+       unsigned int out_width;
+
+       if ((out_info == NULL) | (vf_info == NULL))
+	       return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+       out_width = out_info->res.width;
+
+       if (out_width == 0)
+	       return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+       /* downscale until width smaller than the viewfinder width. We don't
+	* test for the height since the vmem buffers only put restrictions on
+	* the width of a line, not on the number of lines in a frame.
+	*/
+       while (out_width >= vf_info->res.width) {
+	       ds_log2++;
+	       out_width /= 2;
+       }
+       /* now width is smaller, so we go up one step */
+       if ((ds_log2 > 0) && (out_width < ia_css_binary_max_vf_width()))
+	       ds_log2--;
+       /* TODO: use actual max input resolution of vf_pp binary */
+       if ((out_info->res.width >> ds_log2) >= 2 * ia_css_binary_max_vf_width())
+	       return IA_CSS_ERR_INVALID_ARGUMENTS;
+       *downscale_log2 = ds_log2;
+       return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+configure_kernel(
+	const struct ia_css_binary_info *info,
+	const struct ia_css_frame_info *out_info,
+	const struct ia_css_frame_info *vf_info,
+	unsigned int *downscale_log2,
+	struct ia_css_vf_configuration *config)
+{
+       enum ia_css_err err;
+       unsigned vf_log_ds = 0;
+
+       /* First compute value */
+       if (vf_info) {
+	       err = sh_css_vf_downscale_log2(out_info, vf_info, &vf_log_ds);
+	       if (err != IA_CSS_SUCCESS)
+		       return err;
+       }
+       vf_log_ds = min(vf_log_ds, info->max_vf_log_downscale);
+       *downscale_log2 = vf_log_ds;
+
+       /* Then store it in isp config section */
+       config->vf_downscale_bits = vf_log_ds;
+       return IA_CSS_SUCCESS;
+}
+
+static void
+configure_dma(
+	struct ia_css_vf_configuration *config,
+	const struct ia_css_frame_info *vf_info)
+{
+	config->info = vf_info;
+}
+
+enum ia_css_err
+ia_css_vf_configure(
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info,
+	unsigned int *downscale_log2)
+{
+	enum ia_css_err err;
+	struct ia_css_vf_configuration config;
+	const struct ia_css_binary_info *info = &binary->info->sp;
+
+	err = configure_kernel(info, out_info, vf_info, downscale_log2, &config);
+	configure_dma(&config, vf_info);
+	if (binary) {
+		if (vf_info)
+			vf_info->raw_bit_depth = info->dma.vfdec_bits_per_pixel;
+		ia_css_configure_vf (binary, &config);
+	}
+	return IA_CSS_SUCCESS;
+}
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf.host.h b/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf.host.h
new file mode 100644
index 0000000..85ef8c5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf.host.h
@@ -0,0 +1,53 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_VF_HOST_H
+#define __IA_CSS_VF_HOST_H
+
+#include "ia_css_frame_public.h"
+#include "ia_css_binary.h"
+
+#include "ia_css_vf_types.h"
+#include "ia_css_vf_param.h"
+
+/* compute the log2 of the downscale factor needed to get closest
+ * to the requested viewfinder resolution on the upper side. The output cannot
+ * be smaller than the requested viewfinder resolution.
+ */
+enum ia_css_err
+sh_css_vf_downscale_log2(
+	const struct ia_css_frame_info *out_info,
+	const struct ia_css_frame_info *vf_info,
+	unsigned int *downscale_log2);
+
+void
+ia_css_vf_config(
+	struct sh_css_isp_vf_isp_config *to,
+	const struct ia_css_vf_configuration  *from);
+
+enum ia_css_err
+ia_css_vf_configure(
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *out_info,
+	struct ia_css_frame_info *vf_info,
+	unsigned int *downscale_log2);
+
+#endif /* __IA_CSS_VF_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf_param.h b/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf_param.h
new file mode 100644
index 0000000..de23424
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf_param.h
@@ -0,0 +1,44 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_VF_PARAM_H
+#define __IA_CSS_VF_PARAM_H
+
+#include "type_support.h"
+#include "dma.h"
+#include "gc/gc_1.0/ia_css_gc_param.h" /* GAMMA_OUTPUT_BITS */
+#include "ia_css_frame_comm.h" /* ia_css_frame_sp_info */
+#include "ia_css_vf_types.h"
+
+#define VFDEC_BITS_PER_PIXEL	GAMMA_OUTPUT_BITS
+
+/** Viewfinder decimation */
+struct sh_css_isp_vf_isp_config {
+	uint32_t vf_downscale_bits; /**< Log VF downscale value */
+	uint32_t enable;
+	struct ia_css_frame_sp_info info;
+	struct {
+		uint32_t width_a_over_b;
+		struct dma_port_config port_b;
+	} dma;
+};
+
+#endif /* __IA_CSS_VF_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf_types.h b/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf_types.h
new file mode 100644
index 0000000..b44e661
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/vf/vf_1.0/ia_css_vf_types.h
@@ -0,0 +1,39 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_VF_TYPES_H
+#define __IA_CSS_VF_TYPES_H
+
+/** Viewfinder decimation
+ *
+ *  ISP block: vfeven_horizontal_downscale
+ */
+
+#include <ia_css_frame_public.h>
+#include <type_support.h>
+
+struct ia_css_vf_configuration {
+	uint32_t vf_downscale_bits; /**< Log VF downscale value */
+	const struct ia_css_frame_info *info;
+};
+
+#endif /* __IA_CSS_VF_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb.host.c b/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb.host.c
new file mode 100644
index 0000000..47c0998
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb.host.c
@@ -0,0 +1,90 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_frac.h"
+
+#include "ia_css_wb.host.h"
+
+const struct ia_css_wb_config default_wb_config = {
+	1,
+	32768,
+	32768,
+	32768,
+	32768
+};
+
+void
+ia_css_wb_encode(
+	struct sh_css_isp_wb_params *to,
+	const struct ia_css_wb_config *from)
+{
+	to->gain_shift =
+	    uISP_REG_BIT - from->integer_bits;
+	to->gain_gr =
+	    uDIGIT_FITTING(from->gr, 16 - from->integer_bits,
+			   to->gain_shift);
+	to->gain_r =
+	    uDIGIT_FITTING(from->r, 16 - from->integer_bits,
+			   to->gain_shift);
+	to->gain_b =
+	    uDIGIT_FITTING(from->b, 16 - from->integer_bits,
+			   to->gain_shift);
+	to->gain_gb =
+	    uDIGIT_FITTING(from->gb, 16 - from->integer_bits,
+			   to->gain_shift);
+}
+
+void
+ia_css_wb_dump(
+	const struct sh_css_isp_wb_params *wb,
+	unsigned level)
+{
+	if (!wb) return;
+	ia_css_debug_dtrace(level, "White Balance:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"wb_gain_shift", wb->gain_shift);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"wb_gain_gr", wb->gain_gr);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"wb_gain_r", wb->gain_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"wb_gain_b", wb->gain_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"wb_gain_gb", wb->gain_gb);
+}
+
+void
+ia_css_wb_debug_dtrace(
+	const struct ia_css_wb_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.integer_bits=%d, "
+		"config.gr=%d, config.r=%d, "
+		"config.b=%d, config.gb=%d\n",
+		config->integer_bits,
+		config->gr, config->r,
+		config->b, config->gb);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb.host.h b/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb.host.h
new file mode 100644
index 0000000..f416bed
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb.host.h
@@ -0,0 +1,45 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_WB_HOST_H
+#define __IA_CSS_WB_HOST_H
+
+#include "ia_css_wb_types.h"
+#include "ia_css_wb_param.h"
+
+extern const struct ia_css_wb_config default_wb_config;
+
+void
+ia_css_wb_encode(
+	struct sh_css_isp_wb_params *to,
+	const struct ia_css_wb_config *from);
+
+void
+ia_css_wb_dump(
+	const struct sh_css_isp_wb_params *wb,
+	unsigned level);
+
+void
+ia_css_wb_debug_dtrace(
+	const struct ia_css_wb_config *wb,
+	unsigned level);
+
+#endif /* __IA_CSS_WB_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb_param.h b/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb_param.h
new file mode 100644
index 0000000..5879652
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb_param.h
@@ -0,0 +1,36 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_WB_PARAM_H
+#define __IA_CSS_WB_PARAM_H
+
+#include "type_support.h"
+
+/* WB (White Balance) */
+struct sh_css_isp_wb_params {
+	int32_t gain_shift;
+	int32_t gain_gr;
+	int32_t gain_r;
+	int32_t gain_b;
+	int32_t gain_gb;
+};
+
+#endif /* __IA_CSS_WB_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb_types.h b/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb_types.h
new file mode 100644
index 0000000..008844d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/wb/wb_1.0/ia_css_wb_types.h
@@ -0,0 +1,49 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_WB_TYPES_H
+#define __IA_CSS_WB_TYPES_H
+
+/** White Balance configuration (Gain Adjust).
+ *
+ *  ISP block: WB1
+ *  ISP1: WB1 is used.
+ *  ISP2: WB1 is used.
+ */
+struct ia_css_wb_config {
+	uint32_t integer_bits; /**< Common exponent of gains.
+				u8.0, [0,3],
+				default 1, ineffective 1 */
+	uint32_t gr;	/**< Significand of Gr gain.
+				u[integer_bits].[16-integer_bits], [0,65535],
+				default/ineffective 32768(u1.15, 1.0) */
+	uint32_t r;	/**< Significand of R gain.
+				u[integer_bits].[16-integer_bits], [0,65535],
+				default/ineffective 32768(u1.15, 1.0) */
+	uint32_t b;	/**< Significand of B gain.
+				u[integer_bits].[16-integer_bits], [0,65535],
+				default/ineffective 32768(u1.15, 1.0) */
+	uint32_t gb;	/**< Significand of Gb gain.
+				u[integer_bits].[16-integer_bits], [0,65535],
+				default/ineffective 32768(u1.15, 1.0) */
+};
+
+#endif /* __IA_CSS_WB_TYPES_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
new file mode 100644
index 0000000..1a5be95
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
@@ -0,0 +1,68 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_frac.h"
+
+#include "ia_css_xnr.host.h"
+
+const struct ia_css_xnr_config default_xnr_config = {
+	/** default threshold 6400 translates to 25 on ISP. */
+	6400
+};
+
+void
+ia_css_xnr_table_vamem_encode(
+	struct sh_css_isp_xnr_vamem_params *to,
+	const struct ia_css_xnr_table *from)
+{
+	memcpy (&to->xnr,  &from->data, sizeof(to->xnr));
+}
+
+void
+ia_css_xnr_encode(
+	struct sh_css_isp_xnr_params *to,
+	const struct ia_css_xnr_config *from)
+{
+	to->threshold =
+		uDIGIT_FITTING(from->threshold, 16, SH_CSS_ISP_YUV_BITS);
+}
+
+void
+ia_css_xnr_table_debug_dtrace(
+	const struct ia_css_xnr_table *config,
+	unsigned level)
+{
+	(void)config;
+	(void)level;
+}
+
+void
+ia_css_xnr_debug_dtrace(
+	const struct ia_css_xnr_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.threshold=%d\n", config->threshold);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.h b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.h
new file mode 100644
index 0000000..0bd647f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.h
@@ -0,0 +1,52 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_XNR_HOST_H
+#define __IA_CSS_XNR_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_xnr_param.h"
+#include "ia_css_xnr_table.host.h"
+
+extern const struct ia_css_xnr_config default_xnr_config;
+
+void
+ia_css_xnr_table_vamem_encode(
+	struct sh_css_isp_xnr_vamem_params *to,
+	const struct ia_css_xnr_table *from);
+
+void
+ia_css_xnr_encode(
+	struct sh_css_isp_xnr_params *to,
+	const struct ia_css_xnr_config *from);
+
+void
+ia_css_xnr_table_debug_dtrace(
+	const struct ia_css_xnr_table *s3a,
+	unsigned level);
+
+void
+ia_css_xnr_debug_dtrace(
+	const struct ia_css_xnr_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_XNR_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_param.h b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_param.h
new file mode 100644
index 0000000..e653d96
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_param.h
@@ -0,0 +1,58 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_XNR_PARAM_H
+#define __IA_CSS_XNR_PARAM_H
+
+#include "type_support.h"
+#include <system_global.h>
+
+#ifndef PIPE_GENERATION
+#if defined(HAS_VAMEM_VERSION_2)
+#define SH_CSS_ISP_XNR_TABLE_SIZE_LOG2       IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_XNR_TABLE_SIZE            IA_CSS_VAMEM_2_XNR_TABLE_SIZE
+#elif defined(HAS_VAMEM_VERSION_1)
+#define SH_CSS_ISP_XNR_TABLE_SIZE_LOG2       IA_CSS_VAMEM_1_XNR_TABLE_SIZE_LOG2
+#define SH_CSS_ISP_XNR_TABLE_SIZE            IA_CSS_VAMEM_1_XNR_TABLE_SIZE
+#else
+#error "Unknown vamem type"
+#endif
+
+
+#else
+/* For pipe generation, the size is not relevant */
+#define SH_CSS_ISP_XNR_TABLE_SIZE 0
+#endif
+
+/* This should be vamem_data_t, but that breaks the pipe generator */
+struct sh_css_isp_xnr_vamem_params {
+	uint16_t xnr[SH_CSS_ISP_XNR_TABLE_SIZE];
+};
+
+struct sh_css_isp_xnr_params {
+	/** XNR threshold.
+	 * type:u0.16 but actual valid range is:[0,255]
+	 * valid range is dependent on SH_CSS_ISP_YUV_BITS (currently 8bits)
+	 * default: 25 */
+	uint16_t threshold;
+};
+
+#endif /* __IA_CSS_XNR_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_table.host.c b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_table.host.c
new file mode 100644
index 0000000..83c9489
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_table.host.c
@@ -0,0 +1,88 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <type_support.h>
+#include <string_support.h> /* memcpy */
+#include "system_global.h"
+#include "vamem.h"
+#include "ia_css_types.h"
+#include "ia_css_xnr_table.host.h"
+
+struct ia_css_xnr_table default_xnr_table;
+
+#if defined(HAS_VAMEM_VERSION_2)
+
+static const uint16_t
+default_xnr_table_data[IA_CSS_VAMEM_2_XNR_TABLE_SIZE] = {
+  /* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 */
+  8191>>1, 4096>>1, 2730>>1, 2048>>1, 1638>>1, 1365>>1, 1170>>1, 1024>>1, 910>>1, 819>>1, 744>>1, 682>>1, 630>>1, 585>>1,
+    546>>1, 512>>1,
+
+  /* 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 */
+  481>>1, 455>>1, 431>>1, 409>>1, 390>>1, 372>>1, 356>>1, 341>>1, 327>>1, 315>>1, 303>>1, 292>>1, 282>>1, 273>>1, 264>>1,
+    256>>1,
+
+  /* 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 */
+  248>>1, 240>>1, 234>>1, 227>>1, 221>>1, 215>>1, 210>>1, 204>>1, 199>>1, 195>>1, 190>>1, 186>>1, 182>>1, 178>>1, 174>>1,
+    170>>1,
+
+  /* 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 */
+  167>>1, 163>>1, 160>>1, 157>>1, 154>>1, 151>>1, 148>>1, 146>>1, 143>>1, 141>>1, 138>>1, 136>>1, 134>>1, 132>>1, 130>>1, 128>>1
+};
+
+#elif defined(HAS_VAMEM_VERSION_1)
+
+static const uint16_t
+default_xnr_table_data[IA_CSS_VAMEM_1_XNR_TABLE_SIZE] = {
+  /* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 */
+  8191>>1, 4096>>1, 2730>>1, 2048>>1, 1638>>1, 1365>>1, 1170>>1, 1024>>1, 910>>1, 819>>1, 744>>1, 682>>1, 630>>1, 585>>1,
+    546>>1, 512>>1,
+
+  /* 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 */
+  481>>1, 455>>1, 431>>1, 409>>1, 390>>1, 372>>1, 356>>1, 341>>1, 327>>1, 315>>1, 303>>1, 292>>1, 282>>1, 273>>1, 264>>1,
+    256>>1,
+
+  /* 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 */
+  248>>1, 240>>1, 234>>1, 227>>1, 221>>1, 215>>1, 210>>1, 204>>1, 199>>1, 195>>1, 190>>1, 186>>1, 182>>1, 178>>1, 174>>1,
+    170>>1,
+
+  /* 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 */
+  167>>1, 163>>1, 160>>1, 157>>1, 154>>1, 151>>1, 148>>1, 146>>1, 143>>1, 141>>1, 138>>1, 136>>1, 134>>1, 132>>1, 130>>1, 128>>1
+};
+
+#else
+#error "sh_css_params.c: VAMEM version must \
+	be one of {VAMEM_VERSION_1, VAMEM_VERSION_2}"
+#endif
+
+void
+ia_css_config_xnr_table(void)
+{
+#if defined(HAS_VAMEM_VERSION_2)
+	memcpy(default_xnr_table.data.vamem_2, default_xnr_table_data,
+	       sizeof(default_xnr_table_data));
+	default_xnr_table.vamem_type     = IA_CSS_VAMEM_TYPE_2;
+#else
+	memcpy(default_xnr_table.data.vamem_1, default_xnr_table_data,
+	       sizeof(default_xnr_table_data));
+	default_xnr_table.vamem_type     = IA_CSS_VAMEM_TYPE_1;
+#endif
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_table.host.h b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_table.host.h
new file mode 100644
index 0000000..bdbfbfb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_table.host.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_XNR_TABLE_HOST_H
+#define __IA_CSS_XNR_TABLE_HOST_H
+
+extern struct ia_css_xnr_table default_xnr_table;
+
+void ia_css_config_xnr_table(void);
+
+#endif /* __IA_CSS_XNR_TABLE_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_types.h b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_types.h
new file mode 100644
index 0000000..74ed46a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/xnr/xnr_1.0/ia_css_xnr_types.h
@@ -0,0 +1,72 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_XNR_TYPES_H
+#define __IA_CSS_XNR_TYPES_H
+
+/** XNR table.
+ *
+ *  NOTE: The driver does not need to set this table,
+ *        because the default values are set inside the css.
+ *
+ *  This table contains coefficients used for division in XNR.
+ *
+ *  	u0.12, [0,4095],
+ *      {4095, 2048, 1365, .........., 65, 64}
+ *      ({1/1, 1/2, 1/3, ............., 1/63, 1/64})
+ *
+ *  ISP block: XNR1
+ *  ISP1: XNR1 is used.
+ *  ISP2: XNR1 is used.
+ *
+ */
+
+/** Number of elements in the xnr table. */
+#define IA_CSS_VAMEM_1_XNR_TABLE_SIZE_LOG2      6
+#define IA_CSS_VAMEM_1_XNR_TABLE_SIZE           (1U<<IA_CSS_VAMEM_1_XNR_TABLE_SIZE_LOG2)
+
+/** Number of elements in the xnr table. */
+#define IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2      6
+#define IA_CSS_VAMEM_2_XNR_TABLE_SIZE	        (1U<<IA_CSS_VAMEM_2_XNR_TABLE_SIZE_LOG2)
+
+/**< IA_CSS_VAMEM_TYPE_1(ISP2300) or
+     IA_CSS_VAMEM_TYPE_2(ISP2400) */
+union ia_css_xnr_data {
+	uint16_t vamem_1[IA_CSS_VAMEM_1_XNR_TABLE_SIZE];
+	/**< Coefficients table on vamem type1. u0.12, [0,4095] */
+	uint16_t vamem_2[IA_CSS_VAMEM_2_XNR_TABLE_SIZE];
+	/**< Coefficients table on vamem type2. u0.12, [0,4095] */
+};
+
+struct ia_css_xnr_table {
+	enum ia_css_vamem_type vamem_type;
+	union ia_css_xnr_data data;
+};
+
+struct ia_css_xnr_config {
+	/** XNR threshold.
+	 * type:u0.16 valid range:[0,65535]
+	 * default: 6400 */
+	uint16_t threshold;
+};
+
+#endif /* __IA_CSS_XNR_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.c b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.c
new file mode 100644
index 0000000..93765c0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.c
@@ -0,0 +1,221 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_frac.h"
+
+#include "bnr/bnr_1.0/ia_css_bnr.host.h"
+#include "ia_css_ynr.host.h"
+
+const struct ia_css_nr_config default_nr_config = {
+	16384,
+	8192,
+	1280,
+	0,
+	0
+};
+
+const struct ia_css_ee_config default_ee_config = {
+	8192,
+	128,
+	2048
+};
+
+void
+ia_css_nr_encode(
+	struct sh_css_isp_ynr_params *to,
+	const struct ia_css_nr_config *from)
+{
+	/* YNR (Y Noise Reduction) */
+	to->threshold =
+		uDIGIT_FITTING((unsigned)8192, 16, SH_CSS_BAYER_BITS);
+	to->gain_all =
+	    uDIGIT_FITTING(from->ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
+	to->gain_dir =
+	    uDIGIT_FITTING(from->ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
+	to->threshold_cb =
+	    uDIGIT_FITTING(from->threshold_cb, 16, SH_CSS_BAYER_BITS);
+	to->threshold_cr =
+	    uDIGIT_FITTING(from->threshold_cr, 16, SH_CSS_BAYER_BITS);
+}
+
+void
+ia_css_yee_encode(
+	struct sh_css_isp_yee_params *to,
+	const struct ia_css_yee_config *from)
+{
+	int asiWk1 = (int) from->ee.gain;
+	int asiWk2 = asiWk1 / 8;
+	int asiWk3 = asiWk1 / 4;
+
+	/* YEE (Y Edge Enhancement) */
+	to->dirthreshold_s =
+	    min((uDIGIT_FITTING(from->nr.direction, 16, SH_CSS_BAYER_BITS)
+				    << 1),
+		SH_CSS_BAYER_MAXVAL);
+	to->dirthreshold_g =
+	    min((uDIGIT_FITTING(from->nr.direction, 16, SH_CSS_BAYER_BITS)
+				    << 4),
+		SH_CSS_BAYER_MAXVAL);
+	to->dirthreshold_width_log2 =
+	    uFRACTION_BITS_FITTING(8);
+	to->dirthreshold_width =
+	    1 << to->dirthreshold_width_log2;
+	to->detailgain =
+	    uDIGIT_FITTING(from->ee.detail_gain, 11,
+			   SH_CSS_YEE_DETAIL_GAIN_SHIFT);
+	to->coring_s =
+	    (uDIGIT_FITTING((unsigned)56, 16, SH_CSS_BAYER_BITS) *
+	     from->ee.threshold) >> 8;
+	to->coring_g =
+	    (uDIGIT_FITTING((unsigned)224, 16, SH_CSS_BAYER_BITS) *
+	     from->ee.threshold) >> 8;
+	/* 8; // *1.125 ->[s4.8] */
+	to->scale_plus_s =
+	    (asiWk1 + asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	/* 8; // ( * -.25)->[s4.8] */
+	to->scale_plus_g =
+	    (0 - asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	/* 8; // *0.875 ->[s4.8] */
+	to->scale_minus_s =
+	    (asiWk1 - asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	/* 8; // ( *.25 ) ->[s4.8] */
+	to->scale_minus_g =
+	    (asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
+	to->clip_plus_s =
+	    uDIGIT_FITTING((unsigned)32760, 16, SH_CSS_BAYER_BITS);
+	to->clip_plus_g = 0;
+	to->clip_minus_s =
+	    uDIGIT_FITTING((unsigned)504, 16, SH_CSS_BAYER_BITS);
+	to->clip_minus_g =
+	    uDIGIT_FITTING((unsigned)32256, 16, SH_CSS_BAYER_BITS);
+	to->Yclip = SH_CSS_BAYER_MAXVAL;
+}
+
+void
+ia_css_nr_dump(
+	const struct sh_css_isp_ynr_params *ynr,
+	unsigned level)
+{
+	if (!ynr) return;
+	ia_css_debug_dtrace(level,
+		"Y Noise Reduction:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ynr_threshold", ynr->threshold);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ynr_gain_all", ynr->gain_all);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ynr_gain_dir", ynr->gain_dir);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ynr_threshold_cb", ynr->threshold_cb);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ynr_threshold_cr", ynr->threshold_cr);
+}
+
+void
+ia_css_yee_dump(
+	const struct sh_css_isp_yee_params *yee,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"Y Edge Enhancement:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ynryee_dirthreshold_s",
+			yee->dirthreshold_s);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ynryee_dirthreshold_g",
+			yee->dirthreshold_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ynryee_dirthreshold_width_log2",
+			yee->dirthreshold_width_log2);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ynryee_dirthreshold_width",
+			yee->dirthreshold_width);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_detailgain",
+			yee->detailgain);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_coring_s",
+			yee->coring_s);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_coring_g",
+			yee->coring_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_scale_plus_s",
+			yee->scale_plus_s);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_scale_plus_g",
+			yee->scale_plus_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_scale_minus_s",
+			yee->scale_minus_s);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_scale_minus_g",
+			yee->scale_minus_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_clip_plus_s",
+			yee->clip_plus_s);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_clip_plus_g",
+			yee->clip_plus_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_clip_minus_s",
+			yee->clip_minus_s);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"yee_clip_minus_g",
+			yee->clip_minus_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n",
+			"ynryee_Yclip",
+			yee->Yclip);
+}
+
+void
+ia_css_nr_debug_dtrace(
+	const struct ia_css_nr_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.direction=%d, "
+		"config.bnr_gain=%d, config.ynr_gain=%d, "
+		"config.threshold_cb=%d, config.threshold_cr=%d\n",
+		config->direction,
+		config->bnr_gain, config->ynr_gain,
+		config->threshold_cb, config->threshold_cr);
+}
+
+void
+ia_css_ee_debug_dtrace(
+	const struct ia_css_ee_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.gain=%d, config.detail_gain=%d\n",
+		config->threshold,
+		config->gain, config->detail_gain);
+}
+
+void
+ia_css_init_ynr_state(void/*struct sh_css_isp_ynr_vmem_state *state*/)
+{
+	//memset(state, 0, sizeof(*state));
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h
new file mode 100644
index 0000000..bb6beda
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h
@@ -0,0 +1,64 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YNR_HOST_H
+#define __IA_CSS_YNR_HOST_H
+
+#include "ia_css_ynr_types.h"
+#include "ia_css_ynr_param.h"
+
+extern const struct ia_css_nr_config default_nr_config;
+extern const struct ia_css_ee_config default_ee_config;
+
+void
+ia_css_nr_encode(
+	struct sh_css_isp_ynr_params *to,
+	const struct ia_css_nr_config *from);
+
+void
+ia_css_yee_encode(
+	struct sh_css_isp_yee_params *to,
+	const struct ia_css_yee_config *from);
+
+void
+ia_css_nr_dump(
+	const struct sh_css_isp_ynr_params *ynr,
+	unsigned level);
+
+void
+ia_css_yee_dump(
+	const struct sh_css_isp_yee_params *yee,
+	unsigned level);
+
+void
+ia_css_nr_debug_dtrace(
+	const struct ia_css_nr_config *config,
+	unsigned level);
+
+void
+ia_css_ee_debug_dtrace(
+	const struct ia_css_ee_config *config,
+	unsigned level);
+
+void
+ia_css_init_ynr_state(
+	void/*struct sh_css_isp_ynr_vmem_state *state*/);
+#endif /* __IA_CSS_YNR_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr_param.h b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr_param.h
new file mode 100644
index 0000000..cd6c091
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr_param.h
@@ -0,0 +1,56 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YNR_PARAM_H
+#define __IA_CSS_YNR_PARAM_H
+
+#include "type_support.h"
+
+/* YNR (Y Noise Reduction) */
+struct sh_css_isp_ynr_params {
+	int32_t threshold;
+	int32_t gain_all;
+	int32_t gain_dir;
+	int32_t threshold_cb;
+	int32_t threshold_cr;
+};
+
+/* YEE (Y Edge Enhancement) */
+struct sh_css_isp_yee_params {
+	int32_t dirthreshold_s;
+	int32_t dirthreshold_g;
+	int32_t dirthreshold_width_log2;
+	int32_t dirthreshold_width;
+	int32_t detailgain;
+	int32_t coring_s;
+	int32_t coring_g;
+	int32_t scale_plus_s;
+	int32_t scale_plus_g;
+	int32_t scale_minus_s;
+	int32_t scale_minus_g;
+	int32_t clip_plus_s;
+	int32_t clip_plus_g;
+	int32_t clip_minus_s;
+	int32_t clip_minus_g;
+	int32_t Yclip;
+};
+
+#endif /* __IA_CSS_YNR_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr_state.h b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr_state.h
new file mode 100644
index 0000000..ac2d168
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr_state.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YNR_STATE_H
+#define __IA_CSS_YNR_STATE_H
+
+#include "type_support.h"
+#include "vmem.h"
+
+/* YNR (luminance noise reduction) */
+struct sh_css_isp_ynr_vmem_state {
+	VMEM_ARRAY(ynr_buf[4], MAX_VECTORS_PER_BUF_LINE*ISP_NWAY);
+};
+
+#endif /* __IA_CSS_YNR_STATE_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr_types.h b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr_types.h
new file mode 100644
index 0000000..2e67f41
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_1.0/ia_css_ynr_types.h
@@ -0,0 +1,84 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YNR_TYPES_H
+#define __IA_CSS_YNR_TYPES_H
+
+/** Configuration used by Bayer Noise Reduction (BNR) and
+ *  YCC Noise Reduction (YNR,CNR).
+ *
+ *  ISP block: BNR1, YNR1, CNR1
+ *  ISP1: BNR1,YNR1,CNR1 are used.
+ *  ISP2: BNR1,YNR1,CNR1 are used for Preview/Video.
+ *        BNR1,YNR2,CNR2 are used for Still.
+ */
+struct ia_css_nr_config {
+	ia_css_u0_16 bnr_gain;	   /**< Strength of noise reduction (BNR).
+				u0.16, [0,65535],
+				default 14336(0.21875), ineffective 0 */
+	ia_css_u0_16 ynr_gain;	   /**< Strength of noise reduction (YNR).
+				u0.16, [0,65535],
+				default 14336(0.21875), ineffective 0 */
+	ia_css_u0_16 direction;    /**< Sensitivity of edge (BNR).
+				u0.16, [0,65535],
+				default 512(0.0078125), ineffective 0 */
+	ia_css_u0_16 threshold_cb; /**< Coring threshold for Cb (CNR).
+				This is the same as
+				de_config.c1_coring_threshold.
+				u0.16, [0,65535],
+				default 0(0), ineffective 0 */
+	ia_css_u0_16 threshold_cr; /**< Coring threshold for Cr (CNR).
+				This is the same as
+				de_config.c2_coring_threshold.
+				u0.16, [0,65535],
+				default 0(0), ineffective 0 */
+};
+
+/** Edge Enhancement (sharpen) configuration.
+ *
+ *  ISP block: YEE1
+ *  ISP1: YEE1 is used.
+ *  ISP2: YEE1 is used for Preview/Video.
+ *       (YEE2 is used for Still.)
+ */
+struct ia_css_ee_config {
+	ia_css_u5_11 gain;	  /**< The strength of sharpness.
+					u5.11, [0,65535],
+					default 8192(4.0), ineffective 0 */
+	ia_css_u8_8 threshold;    /**< The threshold that divides noises from
+					edge.
+					u8.8, [0,65535],
+					default 256(1.0), ineffective 65535 */
+	ia_css_u5_11 detail_gain; /**< The strength of sharpness in pell-mell
+					area.
+					u5.11, [0,65535],
+					default 2048(1.0), ineffective 0 */
+};
+
+/** YNR and YEE (sharpen) configuration.
+ */
+struct ia_css_yee_config {
+	struct ia_css_nr_config nr; /**< The NR configuration. */
+	struct ia_css_ee_config ee; /**< The EE configuration. */
+};
+
+#endif /* __IA_CSS_YNR_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.c b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.c
new file mode 100644
index 0000000..a8e59aa
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.c
@@ -0,0 +1,128 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+
+#include "ia_css_ynr2.host.h"
+
+const struct ia_css_ynr_config default_ynr_config = {
+	0,
+	0,
+	0,
+	0,
+};
+
+const struct ia_css_fc_config default_fc_config = {
+	1,
+	0,		/* 0 -> ineffective */
+	0,		/* 0 -> ineffective */
+	0,		/* 0 -> ineffective */
+	0,		/* 0 -> ineffective */
+	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
+	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
+	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
+	(int16_t)- (1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
+	(int16_t)- (1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
+};
+
+void
+ia_css_ynr_encode(
+	struct sh_css_isp_yee2_params *to,
+	const struct ia_css_ynr_config *from)
+{
+	to->edge_sense_gain_0   = from->edge_sense_gain_0;
+	to->edge_sense_gain_1   = from->edge_sense_gain_1;
+	to->corner_sense_gain_0 = from->corner_sense_gain_0;
+	to->corner_sense_gain_1 = from->corner_sense_gain_1;
+}
+
+void
+ia_css_fc_encode(
+	struct sh_css_isp_fc_params *to,
+	const struct ia_css_fc_config *from)
+{
+	to->gain_exp   = from->gain_exp;
+
+	to->coring_pos_0 = from->coring_pos_0;
+	to->coring_pos_1 = from->coring_pos_1;
+	to->coring_neg_0 = from->coring_neg_0;
+	to->coring_neg_1 = from->coring_neg_1;
+
+	to->gain_pos_0 = from->gain_pos_0;
+	to->gain_pos_1 = from->gain_pos_1;
+	to->gain_neg_0 = from->gain_neg_0;
+	to->gain_neg_1 = from->gain_neg_1;
+
+	to->crop_pos_0 = from->crop_pos_0;
+	to->crop_pos_1 = from->crop_pos_1;
+	to->crop_neg_0 = from->crop_neg_0;
+	to->crop_neg_1 = from->crop_neg_1;
+}
+
+void
+ia_css_ynr_dump(
+	const struct sh_css_isp_yee2_params *yee2,
+	unsigned level);
+
+void
+ia_css_fc_dump(
+	const struct sh_css_isp_fc_params *fc,
+	unsigned level);
+
+void
+ia_css_fc_debug_dtrace(
+	const struct ia_css_fc_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.gain_exp=%d, "
+		"config.coring_pos_0=%d, config.coring_pos_1=%d, "
+		"config.coring_neg_0=%d, config.coring_neg_1=%d, "
+		"config.gain_pos_0=%d, config.gain_pos_1=%d, "
+		"config.gain_neg_0=%d, config.gain_neg_1=%d, "
+		"config.crop_pos_0=%d, config.crop_pos_1=%d, "
+		"config.crop_neg_0=%d, config.crop_neg_1=%d\n",
+		config->gain_exp,
+		config->coring_pos_0, config->coring_pos_1,
+		config->coring_neg_0, config->coring_neg_1,
+		config->gain_pos_0, config->gain_pos_1,
+		config->gain_neg_0, config->gain_neg_1,
+		config->crop_pos_0, config->crop_pos_1,
+		config->crop_neg_0, config->crop_neg_1);
+}
+
+void
+ia_css_ynr_debug_dtrace(
+	const struct ia_css_ynr_config *config,
+	unsigned level)
+{
+	ia_css_debug_dtrace(level,
+		"config.edge_sense_gain_0=%d, config.edge_sense_gain_1=%d, "
+		"config.corner_sense_gain_0=%d, config.corner_sense_gain_1=%d\n",
+		config->edge_sense_gain_0, config->edge_sense_gain_1,
+		config->corner_sense_gain_0, config->corner_sense_gain_1);
+}
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.h b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.h
new file mode 100644
index 0000000..5dfe1eb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2.host.h
@@ -0,0 +1,61 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YNR2_HOST_H
+#define __IA_CSS_YNR2_HOST_H
+
+#include "ia_css_ynr2_types.h"
+#include "ia_css_ynr2_param.h"
+
+extern const struct ia_css_ynr_config default_ynr_config;
+extern const struct ia_css_fc_config  default_fc_config;
+
+void
+ia_css_ynr_encode(
+	struct sh_css_isp_yee2_params *to,
+	const struct ia_css_ynr_config *from);
+
+void
+ia_css_fc_encode(
+	struct sh_css_isp_fc_params *to,
+	const struct ia_css_fc_config *from);
+
+void
+ia_css_ynr_dump(
+	const struct sh_css_isp_yee2_params *yee2,
+	unsigned level);
+
+void
+ia_css_fc_dump(
+	const struct sh_css_isp_fc_params *fc,
+	unsigned level);
+
+void
+ia_css_fc_debug_dtrace(
+	const struct ia_css_fc_config *config,
+	unsigned level);
+
+void
+ia_css_ynr_debug_dtrace(
+	const struct ia_css_ynr_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_YNR2_HOST_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2_param.h b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2_param.h
new file mode 100644
index 0000000..bc91b27
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2_param.h
@@ -0,0 +1,52 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YNR2_PARAM_H
+#define __IA_CSS_YNR2_PARAM_H
+
+#include "type_support.h"
+
+/* YNR (Y Noise Reduction), YEE (Y Edge Enhancement) */
+struct sh_css_isp_yee2_params {
+	int32_t edge_sense_gain_0;
+	int32_t edge_sense_gain_1;
+	int32_t corner_sense_gain_0;
+	int32_t corner_sense_gain_1;
+};
+
+/* Fringe Control */
+struct sh_css_isp_fc_params {
+	int32_t gain_exp;
+	uint16_t coring_pos_0;
+	uint16_t coring_pos_1;
+	uint16_t coring_neg_0;
+	uint16_t coring_neg_1;
+	int32_t gain_pos_0;
+	int32_t gain_pos_1;
+	int32_t gain_neg_0;
+	int32_t gain_neg_1;
+	int32_t crop_pos_0;
+	int32_t crop_pos_1;
+	int32_t crop_neg_0;
+	int32_t crop_neg_1;
+};
+
+#endif /* __IA_CSS_YNR2_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h
new file mode 100644
index 0000000..6c14628
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h
@@ -0,0 +1,97 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YNR2_TYPES_H
+#define __IA_CSS_YNR2_TYPES_H
+
+/** Y(Luma) Noise Reduction configuration.
+ *
+ *  ISP block: YNR2 & YEE2
+ * (ISP1: YNR1 and YEE1 are used.)
+ * (ISP2: YNR1 and YEE1 are used for Preview/Video.)
+ *  ISP2: YNR2 and YEE2 are used for Still.
+ */
+struct ia_css_ynr_config {
+	uint16_t edge_sense_gain_0;   /**< Sensitivity of edge in dark area.
+					u13.0, [0,8191],
+					default 1000, ineffective 0 */
+	uint16_t edge_sense_gain_1;   /**< Sensitivity of edge in bright area.
+					u13.0, [0,8191],
+					default 1000, ineffective 0 */
+	uint16_t corner_sense_gain_0; /**< Sensitivity of corner in dark area.
+					u13.0, [0,8191],
+					default 1000, ineffective 0 */
+	uint16_t corner_sense_gain_1; /**< Sensitivity of corner in bright area.
+					u13.0, [0,8191],
+					default 1000, ineffective 0 */
+};
+
+/** Fringe Control configuration.
+ *
+ *  ISP block: FC2 (FC2 is used with YNR2/YEE2.)
+ * (ISP1: FC2 is not used.)
+ * (ISP2: FC2 is not for Preview/Video.)
+ *  ISP2: FC2 is used for Still.
+ */
+struct ia_css_fc_config {
+	uint8_t  gain_exp;   /**< Common exponent of gains.
+				u8.0, [0,13],
+				default 1, ineffective 0 */
+	uint16_t coring_pos_0; /**< Coring threshold for positive edge in dark area.
+				u0.13, [0,8191],
+				default 0(0), ineffective 0 */
+	uint16_t coring_pos_1; /**< Coring threshold for positive edge in bright area.
+				u0.13, [0,8191],
+				default 0(0), ineffective 0 */
+	uint16_t coring_neg_0; /**< Coring threshold for negative edge in dark area.
+				u0.13, [0,8191],
+				default 0(0), ineffective 0 */
+	uint16_t coring_neg_1; /**< Coring threshold for negative edge in bright area.
+				u0.13, [0,8191],
+				default 0(0), ineffective 0 */
+	uint16_t gain_pos_0; /**< Gain for positive edge in dark area.
+				u0.13, [0,8191],
+				default 4096(0.5), ineffective 0 */
+	uint16_t gain_pos_1; /**< Gain for positive edge in bright area.
+				u0.13, [0,8191],
+				default 4096(0.5), ineffective 0 */
+	uint16_t gain_neg_0; /**< Gain for negative edge in dark area.
+				u0.13, [0,8191],
+				default 4096(0.5), ineffective 0 */
+	uint16_t gain_neg_1; /**< Gain for negative edge in bright area.
+				u0.13, [0,8191],
+				default 4096(0.5), ineffective 0 */
+	uint16_t crop_pos_0; /**< Limit for positive edge in dark area.
+				u0.13, [0,8191],
+				default/ineffective 8191(almost 1.0) */
+	uint16_t crop_pos_1; /**< Limit for positive edge in bright area.
+				u0.13, [0,8191],
+				default/ineffective 8191(almost 1.0) */
+	int16_t  crop_neg_0; /**< Limit for negative edge in dark area.
+				s0.13, [-8192,0],
+				default/ineffective -8192(-1.0) */
+	int16_t  crop_neg_1; /**< Limit for negative edge in bright area.
+				s0.13, [-8192,0],
+				default/ineffective -8192(-1.0) */
+};
+
+#endif /* __IA_CSS_YNR2_TYPES_H */
+
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr_param.h b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr_param.h
new file mode 100644
index 0000000..9a6704e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YNRX_PARAM_H
+#define __IA_CSS_YNRX_PARAM_H
+
+#include "ia_css_ynr2_param.h"
+
+#endif /* __IA_CSS_YNRX_PARAM_H */
diff --git a/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr_state.h b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr_state.h
new file mode 100644
index 0000000..11b99cb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/kernels/ynr/ynr_2/ia_css_ynr_state.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YNR2_STATE_H
+#define __IA_CSS_YNR2_STATE_H
+
+/* Reuse YNR1 states */
+#include "../ynr_1.0/ia_css_ynr_state.h"
+
+#endif /* __IA_CSS_YNR2_STATE_H */
diff --git a/drivers/media/atomisp2/css2400/isp/modes/interface/dma_settings.hive.h b/drivers/media/atomisp2/css2400/isp/modes/interface/dma_settings.hive.h
new file mode 100644
index 0000000..74761dc
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/modes/interface/dma_settings.hive.h
@@ -0,0 +1,355 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2013 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef _dma_settings_hive_h_
+#define _dma_settings_hive_h_
+
+/* ***************************************
+ * 					DMA macros
+ * ***************************************/
+
+/* ***************************************
+ * 					DMA settings
+ * ***************************************/
+
+/* application specific DMA settings */
+#define DMA_CONNECTION_0      		dma_isp_to_ddr_connection
+
+#define DUMMY_NUM_XFERS 1
+
+/* ****************************************************************
+ * parameters for fixed pattern noise table communication
+ *		ddr -> isp vmem
+ * ****************************************************************/
+/* isp side */
+#define FPNTBL_BLOCK_HEIGHT  	INPUT_BUF_DMA_HEIGHT       // [lines] lines to write on every DMA transaction
+#define DMA_FPNTBL_BLOCK_WIDTH_A  	CEIL_DIV(INPUT_VECTORS_PER_CHUNK,2)        // [vectors] vectors to write on every DMA transaction
+#define MAX_FPNTBL_BLOCK_WIDTH_A  	CEIL_DIV(MAX_VECTORS_PER_INPUT_CHUNK,2)        // [vectors] vectors to write on every DMA transaction
+#define DMA_FPNTBL_STRIDE_A       	(MAX_FPNTBL_BLOCK_WIDTH_A*ISP_VEC_ALIGN)       // [byte address] stride for VMEM. Round next power of two[ (64elem x 14bits/elem) / 8bits/byte ]
+#define DMA_FPNTBL_ELEMS_A        	ISP_VEC_NELEMS  // [elements] elements per vector
+#define DMA_FPNTBL_CROPPING_A     	0       // [elements] elements to skip on every line
+#define DMA_FPNTBL_SUB_XFERS      	NUM_FPNTBL_SUB_XFERS       // Number of sub transfers per DMA transaction
+#define DMA_FPNTBL_LINE_WIDTH_A         CEIL_DIV(ISP_INPUT_WIDTH_VECS,2)
+
+
+/* xmem side */
+#define DMA_FPNTBL_ELEMS_B        (XMEM_WIDTH_BITS/16)  // [elements] We will store 2 elements on a 32bits word
+#define DMA_FPNTBL_BLOCK_WIDTH_B  CEIL_DIV(DMA_FPNTBL_BLOCK_WIDTH_A * DMA_FPNTBL_ELEMS_A, DMA_FPNTBL_ELEMS_B) // [elements] to write
+#define DMA_FPNTBL_LINE_WIDTH_B   CEIL_DIV(DMA_FPNTBL_LINE_WIDTH_A * DMA_FPNTBL_ELEMS_A, DMA_FPNTBL_ELEMS_B)
+#define DMA_FPNTBL_STRIDE_B       (DMA_FPNTBL_LINE_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)      // [byte address] stride for xmem
+#define DMA_FPNTBL_CROPPING_B     0     // [elements] elements to skip on every line
+
+#define DMA_FPNTBL_STRIPE_OFFSET_A	CEIL_DIV(INPUT_VECTORS_PER_CHUNK-ISP_LEFT_PADDING_VECS, 2)
+#define DMA_FPNTBL_STRIPE_OFFSET_B	CEIL_DIV(DMA_FPNTBL_STRIPE_OFFSET_A * DMA_FPNTBL_ELEMS_A, DMA_FPNTBL_ELEMS_B)
+
+/* ****************************************************************
+ * parameters for shading correction table communication
+ *		ddr -> isp vmem
+ * ****************************************************************/
+/* isp side */
+#define DMA_SCT_BLOCK_HEIGHT     1      // [lines] lines to write on every DMA transaction
+#define DMA_SCTBL_BLOCK_WIDTH_A  SCTBL_VECTORS_PER_LINE // [vectors] vectors to write on every DMA transaction
+#define DMA_SCTBL_STRIDE_A       DMA_SCTBL_BLOCK_WIDTH_A*ISP_VEC_ALIGN    // [byte address] stride for VMEM. Round next power of two[ (64elem x 14bits/elem) / 8bits/byte ]
+#define DMA_SCTBL_ELEMS_A        ISP_VEC_NELEMS // [elements] elements per vector
+#define DMA_SCTBL_CROPPING_A     0      // [elements] elements to skip on every line
+#define DMA_SCTBL_SUB_XFERS      NUM_SCTBL_SUB_XFERS    // Number of sub transfers per DMA transaction     //TODO
+
+/* xmem side */
+#define DMA_SCTBL_ELEMS_B        (XMEM_WIDTH_BITS/16)   // [elements] We will store 2 elements on a 32bits word
+#define DMA_SCTBL_BLOCK_WIDTH_B  CEIL_DIV(DMA_SCTBL_BLOCK_WIDTH_A * DMA_SCTBL_ELEMS_A, DMA_SCTBL_ELEMS_B)      // [elements] to write
+#define DMA_SCTBL_STRIDE_B       (DMA_SCTBL_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)        // [byte address] stride for xmem
+#define DMA_SCTBL_CROPPING_B     0      // [elements] elements to skip on every line
+
+#define DMA_SCTBL_STRIPE_ROW_HEIGHT       ((ISP_ROW_STRIPES_HEIGHT) >> (DECI_FACTOR_LOG2 + 1))
+#define DMA_SCTBL_STRIPE_ROW_ZEROBIT_MASK ((1 << (DECI_FACTOR_LOG2 + 2)) - 1)
+
+
+/* ******************************************************
+ * parameters for YUV communication (by 1line)
+ *    1. output_y_buf  2lines x 2
+ *		2. output_uv_buf 1line  x 2
+ * ******************************************************/
+#define DMA_BLOCK_OUTPUT         ENABLE_BLOCK_OUTPUT
+
+/* isp side */
+#define DMA_OUTPUT_BLOCK_HEIGHT  (DMA_BLOCK_OUTPUT ? (VARIABLE_OUTPUT_FORMAT ? OUTPUT_BLOCK_HEIGHT / 2 : OUTPUT_BLOCK_HEIGHT) : (VARIABLE_RESOLUTION ? 1 : 2))       // [lines] lines to write on every DMA transaction
+#define DMA_OUTPUT_BLOCK_WIDTH_A (DMA_BLOCK_OUTPUT && (BLOCK_WIDTH < ISP_OUTPUT_CHUNK_VECS)? BLOCK_WIDTH : ISP_OUTPUT_CHUNK_VECS)      // [vectors] vectors to write on every DMA transaction
+// stride is 2 * BLOCK width, because the dma is split into two jobs, one for the odd lines, one for the even lines. this is also the case for the non block output, but there the 2* is done in _dma_yuv_configure()
+#define DMA_OUTPUT_STRIDE_A      (DMA_BLOCK_OUTPUT ? BLOCK_WIDTH * ISP_VEC_ALIGN : MAX_VECTORS_PER_OUTPUT_CHUNK*ISP_VEC_ALIGN ) // [byte address] stride for VMEM. Round next power of two[ (64elem x 14bits/elem) / 8bits/byte ]
+#define DMA_OUTPUT_ELEMS_A       ISP_VEC_NELEMS  // [elements] elements per vector
+#define DMA_OUTPUT_CROPPING_A    0       // [elements] elements to skip on every line
+#define DMA_OUTPUT_SUB_XFERS     NUM_OUTPUT_SUB_XFERS   // Number of sub transfers per DMA transaction
+
+/* xmem side */
+#define DMA_OUTPUT_ELEMS_B       (XMEM_WIDTH_BITS/8)   // [elements] We will store 4 values on a 32bits word
+#define DMA_OUTPUT_BLOCK_WIDTH_B CEIL_DIV(DMA_OUTPUT_BLOCK_WIDTH_A * DMA_OUTPUT_ELEMS_A, DMA_OUTPUT_ELEMS_B)  // [elements] to write
+#define DMA_OUTPUT_STRIDE_B      (DMA_OUTPUT_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)       // [byte address] stride for xmem
+//#define DMA_OUTPUT_STRIDE_B      	2*640//(DMA_OUTPUT_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)       // [byte address] stride for xmem
+#define DMA_OUTPUT_CROPPING_B    0       // [elements] elements to skip on every line
+
+/* ******************************************************
+ * parameters for U/V communication (by 1line)
+ * ******************************************************/
+/* isp side */
+#define DMA_C_BLOCK_HEIGHT              (DMA_BLOCK_OUTPUT ? OUTPUT_BLOCK_HEIGHT / 2 : 1)   // [lines] lines to write on every DMA transaction
+#define DMA_C_BLOCK_WIDTH_A             (DMA_BLOCK_OUTPUT && ((BLOCK_WIDTH / 2) < OUTPUT_C_VECTORS_PER_CHUNK)? BLOCK_WIDTH / 2 : OUTPUT_C_VECTORS_PER_CHUNK)        // [vectors] vectors to write on every DMA transaction
+#define DMA_OUTPUT_C_BLOCK_WIDTH_A      (DMA_BLOCK_OUTPUT && ((BLOCK_WIDTH / 2) < ISP_UV_OUTPUT_CHUNK_VECS)? BLOCK_WIDTH / 2 : ISP_UV_OUTPUT_CHUNK_VECS)
+#define DMA_C_STRIDE_A                  ( BLOCK_WIDTH * ISP_VEC_ALIGN)        // [byte address] stride for VMEM. Round next power of two[ (64elem x 14bits/elem) / 8bits/byte ]
+#define DMA_C_ELEMS_A                   ISP_VEC_NELEMS      // [elements] elements per vector
+#define DMA_C_CROPPING_A                0   // [elements] elements to skip on every line
+#define DMA_C_SUB_XFERS                 NUM_C_SUB_XFERS     // Number of sub transfers per DMA transaction
+
+/* xmem side */
+#define DMA_C_ELEMS_B                   (XMEM_WIDTH_BITS/8) // [elements] We will store 4 values on a 32bits word
+#define DMA_C_BLOCK_WIDTH_B             CEIL_DIV(DMA_C_BLOCK_WIDTH_A * DMA_C_ELEMS_A, DMA_C_ELEMS_B )     // [elements] to write
+#define DMA_OUTPUT_C_BLOCK_WIDTH_B      CEIL_DIV(DMA_OUTPUT_C_BLOCK_WIDTH_A * DMA_C_ELEMS_A, DMA_C_ELEMS_B)     // [elements] to write
+#define DMA_C_STRIDE_B                  (DMA_C_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)        // [byte address] stride for xmem
+#define DMA_OUTPUT_C_STRIDE_B           (DMA_OUTPUT_C_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)        // [byte address] stride for xmem
+#define DMA_C_CROPPING_B                0   // [elements] elements to skip on every line
+
+
+/* *****************************************************************************
+ * parameters for output pixels communication for view finder (vmem -> xmem)	//TODO: sp dmem
+ * ***************************************************************************** */
+
+/* isp side */
+#define DMA_VFOUT_BLOCK_HEIGHT  1                       // [lines] lines to write on every DMA transaction
+#define DMA_VFOUT_BLOCK_WIDTH_A ISP_VF_OUTPUT_WIDTH_VECS// [vectors] vectors to write on every DMA transaction
+#define DMA_VFOUT_LINE_WIDTH_A  __ISP_VF_OUTPUT_WIDTH_VECS(ISP_OUTPUT_WIDTH, VF_LOG_DOWNSCALE) // CHANGEE
+#define DMA_VFOUT_STRIDE_A      (ISP_MAX_VF_OUTPUT_CHUNK_VECS*ISP_VEC_ALIGN) // Width of one y or uv line
+#define DMA_VFOUT_ELEMS_A       ISP_VEC_NELEMS          // [elements] elements per vector
+#define DMA_VFOUT_CROPPING_A    0                       // [elements] elements to skip on every line
+#define DMA_VFOUT_SUB_XFERS     NUM_VFOUT_SUB_XFERS     // Number of sub transfers per DMA transaction
+
+
+/* xmem side */
+#define DMA_VFOUT_ELEMS_B       (XMEM_WIDTH_BITS/8)     // [elements] We will store 4 values on a 32bits word
+#define DMA_VFOUT_BLOCK_WIDTH_B CEIL_DIV(DMA_VFOUT_BLOCK_WIDTH_A * DMA_VFOUT_ELEMS_A, DMA_VFOUT_ELEMS_B)
+#define DMA_VFOUT_LINE_WIDTH_B 	CEIL_DIV(DMA_VFOUT_LINE_WIDTH_A * DMA_VFOUT_ELEMS_A, DMA_VFOUT_ELEMS_B)
+#define DMA_VFOUT_STRIDE_B      (DMA_VFOUT_LINE_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)// [byte address] stride for xmem
+#define DMA_VFOUT_CROPPING_B    0                       // [elements] elements to skip on every line
+
+/* *********************************************************************************************
+ * 	parameters for TNR (temporal noise reduction) pixels communication
+ *			1. input previous frame pixels after CNR,YNR: xmem (16bit unit) ---> vmem (14bit unit)
+ * 			2. output current frame pixels after CNR,YNR: xmem (16bit unit) <--- vmem (14bit unit)
+ *
+ *      YYYY  YYYY  UVUV : VECTORS_PER_LINE x 3
+ *				1st VECTORS_PER_LINE : Y for GR,R,GR,R....
+ *				2nd VECTORS_PER_LINE : Y for B,GB,B,GB....
+ *				3rd VECTORS_PER_LINE : UV for GR,GR,....
+ * ********************************************************************************************/
+
+/* isp side */
+#define TNR_BUF_HEIGHT          (ENABLE_BLOCK_OUTPUT ? OUTPUT_BLOCK_HEIGHT : 2)
+#define TNR_BUF_C_HEIGHT        (ENABLE_BLOCK_OUTPUT ? OUTPUT_BLOCK_HEIGHT/2 :1)
+#define TNR_BLOCK_HEIGHT	(TNR_BUF_HEIGHT+TNR_BUF_C_HEIGHT)
+#define DMA_TNR_BUF_BLOCK_HEIGHT	TNR_BLOCK_HEIGHT
+
+#define DMA_TNR_BUF_BLOCK_WIDTH_A   (ENABLE_BLOCK_OUTPUT ? BLOCK_WIDTH : (ENABLE_DIS_CROP || ENABLE_UDS ? ISP_OUTPUT_CHUNK_VECS : OUTPUT_VECTORS_PER_CHUNK))    // [vectors] vectors to write on every DMA transaction
+#define MAX_TNR_BLOCK_WIDTH_A   (ENABLE_BLOCK_OUTPUT ? BLOCK_WIDTH : (ENABLE_DIS_CROP || ENABLE_UDS ? MAX_VECTORS_PER_OUTPUT_CHUNK : MAX_VECTORS_PER_CHUNK))
+#define TNR_STRIDE_A     	(MAX_TNR_BLOCK_WIDTH_A * ISP_VEC_ALIGN)    // [byte address] stride for VMEM. Round next power of two[ (64elem x 14bits/elem) / 8bits/byte ]
+#define DMA_TNR_BUF_ELEMS_A      	ISP_VEC_NELEMS  // [elements] elements per vector
+#define DMA_TNR_BUF_CROPPING_A   	0       // [elements] elements to skip on every line
+#define DMA_TNR_BUF_SUB_XFERS       NUM_TNR_SUB_XFERS // Number of sub transfers per DMA transaction
+
+/* *********************************************************************************************
+ * 	parameters for CROP
+ * ********************************************************************************************/
+
+/* isp side */
+#define DMA_CROP_Y_BLOCK_HEIGHT (2)       // [lines] lines to write on every DMA transaction
+#define DMA_CROP_C_BLOCK_HEIGHT (1)       // [lines] lines to write on every DMA transaction
+#define DMA_CROP_BLOCK_WIDTH_A  ISP_OUTPUT_CHUNK_VECS    // [vectors] vectors to write on every DMA transaction
+#define DMA_CROP_STRIDE_A     	(MAX_VECTORS_PER_OUTPUT_CHUNK * ISP_VEC_ALIGN)    // [byte address] stride for VMEM. Round next power of two[ (64elem x 14bits/elem) / 8bits/byte ]
+#define DMA_CROP_ELEMS_A      	ISP_VEC_NELEMS  // [elements] elements per vector
+#define DMA_CROP_CROPPING_A   	0       // [elements] elements to skip on every line
+#define DMA_CROP_SUB_XFERS       NUM_CROP_SUB_XFERS // Number of sub transfers per DMA transaction
+
+/* xmem side */
+#define DMA_CROP_ELEMS_B      	(XMEM_WIDTH_BITS/8)    // [elements] We will store 4 values on a 32bits word
+#define DMA_CROP_BLOCK_WIDTH_B	CEIL_DIV(DMA_CROP_BLOCK_WIDTH_A * DMA_CROP_ELEMS_A, DMA_CROP_ELEMS_B)   // [elements] to write
+#define DMA_CROP_STRIDE_B     	(DMA_CROP_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)  // [byte address] stride for xmem
+#define DMA_CROP_CROPPING_B   	0       // [elements] elements to skip on every line
+
+/* *********************************************************************************************
+ * 	parameters for REF (reference) pixels communication
+  * ********************************************************************************************/
+
+/* isp side */
+#define DMA_REF_BUF_Y_BLOCK_HEIGHT 	(1+(DMA_REF_BUF_Y_CHANNEL != DMA_REF_BUF_C_CHANNEL))       // [lines] lines to write on every DMA transaction
+#define DMA_REF_BUF_C_BLOCK_HEIGHT 	1       // [lines] lines to write on every DMA transaction
+#define DMA_REF_BUF_UV_BLOCK_HEIGHT DMA_REF_BUF_C_BLOCK_HEIGHT
+#define DMA_REF_BUF_BLOCK_WIDTH_A	OUTPUT_VECTORS_PER_CHUNK    // [vectors] vectors to write on every DMA transaction
+#define DMA_REF_BUF_STRIDE_A     	(MAX_VECTORS_PER_CHUNK * ISP_VEC_ALIGN)    // [byte address] stride for VMEM. Round next power of two[ (64elem x 14bits/elem) / 8bits/byte ]
+#define DMA_REF_BUF_ELEMS_A      	ISP_VEC_NELEMS  // [elements] elements per vector
+#define DMA_REF_BUF_CROPPING_A   	0       // [elements] elements to skip on every line
+#define DMA_REF_BUF_SUB_XFERS       NUM_REF_SUB_XFERS // Number of sub transfers per DMA transaction
+
+
+/* *********************************************************************************************
+ * 	Configuration for DVS Input Data (XMEM->ISP)
+  * ********************************************************************************************/
+#define DMA_DVS_BLOCK_HEIGHT	(DVS_IN_BLOCK_HEIGHT / 2)
+#define DMA_DVS_ELEMS_A      	ISP_VEC_NELEMS
+#define DMA_DVS_BLOCK_WIDTH_A	(DVS_IN_BLOCK_WIDTH)
+#define DMA_DVS_STRIDE_A	(DVS_IN_BLOCK_WIDTH * ISP_VEC_ALIGN)
+#define DMA_DVS_CROPPING_A	0
+
+#define DMA_DVS_ELEMS_B      	(XMEM_WIDTH_BITS / 8)    // [elements] We will store 4 values on a 32-bit word
+#define DMA_DVS_BLOCK_WIDTH_B	CEIL_DIV(DMA_DVS_BLOCK_WIDTH_A * DMA_DVS_ELEMS_A, DMA_DVS_ELEMS_B)
+#define DMA_DVS_LINE_WIDTH_B	CEIL_DIV(VECTORS_PER_LINE * DMA_DVS_ELEMS_A, DMA_DVS_ELEMS_B)
+#define DMA_DVS_STRIDE_B	(DMA_DVS_LINE_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)
+#define DMA_DVS_CROPPING_B	0
+#define DMA_DVS_SUB_XFERS       NUM_REF_SUB_XFERS
+
+
+/* *********************************************************************************************
+ * 	Configuration for DVS Coords (XMEM->DMEM)
+  * ********************************************************************************************/
+#define DMA_COORDS_BLOCK_HEIGHT		1
+#define DMA_COORDS_ELEMS_A		HIVE_ISP_CTRL_DATA_BYTES
+#define DMA_COORDS_BLOCK_WIDTH_A	 (3 * CEIL_DIV(sizeof(gdc_warp_param_mem_t), DMA_COORDS_ELEMS_A))
+#define DMA_COORDS_STRIDE_A		0
+#define DMA_COORDS_CROPPING_A		0
+
+#define DMA_COORDS_ELEMS_B	     	HIVE_ISP_DDR_WORD_BYTES
+#define DMA_COORDS_BLOCK_WIDTH_B	CEIL_DIV(DMA_COORDS_BLOCK_WIDTH_A * DMA_COORDS_ELEMS_A, DMA_COORDS_ELEMS_B)
+#define DMA_COORDS_STRIDE_B		0
+
+#define DMA_NEXT_COORD_OFFSET_B		CEIL_MUL(sizeof(gdc_warp_param_mem_t), HIVE_ISP_DDR_WORD_BYTES)
+
+/* ******************************************************************
+ * parameters for 3A support table communication 	(isp dmem -> ddr)
+ * 		isp dmem -> ddr
+ *		1value : signed 32bit
+ *		transfer unit : unsigned 16bit because 32bit elements are not supported inside the CSS.
+ * ****************************************************************** */
+
+/* some pre-definitions */
+#define S3A_STRUCT_ELEMS		(sizeof(struct ia_css_3a_output)/sizeof(int))
+#define STRIPE_OFFSET_VECS		(VECTORS_PER_LINE - ISP_LEFT_PADDING_VECS)	// stripe width excluding left padded part
+#define ISP_STRIPE_OFFSET_WIDTH		(STRIPE_OFFSET_VECS * ISP_VEC_NELEMS)
+#define ISP_S3ATBL_WIDTH_STRIPE 	_ISP_S3ATBL_WIDTH(ISP_STRIPE_OFFSET_WIDTH, DECI_FACTOR_LOG2)
+
+#define ISP_S3ATBL_WIDTH_STRIPE_A \
+	(ISP_NUM_STRIPES == 1	? ISP_S3ATBL_VECTORS \
+	 			: CEIL_DIV(ISP_S3ATBL_WIDTH_STRIPE * S3A_STRUCT_ELEMS, DMA_S3ATBL_ELEMS_A))
+#define ISP_S3ATBL_WIDTH_STRIPE_B \
+	(ISP_NUM_STRIPES == 1	? CEIL_DIV(DMA_S3ATBL_BLOCK_WIDTH_A * DMA_S3ATBL_ELEMS_A, DMA_S3ATBL_ELEMS_B) \
+	 			: CEIL_DIV(ISP_S3ATBL_WIDTH_STRIPE * S3A_STRUCT_ELEMS, DMA_S3ATBL_ELEMS_B))
+
+// TODO: DMEM part should be modified for striping in case of non-variable resolution
+/* isp side */
+#define DMA_S3ATBL_BLOCK_WIDTH_A	(S3ATBL_USE_DMEM ? CEIL_DIV(S3ATBL_WIDTH_SHORTS, DMA_S3ATBL_ELEMS_A) : ISP_S3ATBL_WIDTH_STRIPE_A) // 1value(32bit)=2elements
+#define DMA_S3ATBL_STRIDE_A     	(S3ATBL_USE_DMEM ? 1 : ISP_S3ATBL_VECTORS * ISP_VEC_ALIGN)  // [byte address] stride for VMEM. Round next power of two[ (64elem x 14bits/elem) / 8bits/byte ]
+#define DMA_S3ATBL_ELEMS_A      	(S3ATBL_USE_DMEM ? 2 : ISP_VEC_NELEMS)       // 2 : 16 bit elements
+#define DMA_S3ATBL_CROPPING_A   	0
+#define DMA_S3ATBL_BLOCK_HEIGHT 	1
+
+/* ddr side */
+#define DMA_S3ATBL_BLOCK_WIDTH_B	ISP_S3ATBL_WIDTH_STRIPE_B    // [elements] to write
+#define DMA_S3ATBL_STRIDE_B     	(S3ATBL_USE_DMEM ? 1 : DMA_S3ATBL_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)
+#define DMA_S3ATBL_ELEMS_B      	XMEM_SHORTS_PER_WORD    // 16 bit elements
+#define DMA_S3ATBL_CROPPING_B		0
+
+/* ****************************************************************
+ * parameters for raw image communication
+ *		ddr -> isp vmem
+ * ****************************************************************/
+/* isp side */
+
+#define DMA_RAW_BLOCK_WIDTH_A  		CEIL_MUL(INPUT_VECTORS_PER_CHUNK, 2)        // [vectors] vectors to write on every DMA transaction
+#define MAX_DMA_RAW_BLOCK_WIDTH_A  	MAX_VECTORS_PER_INPUT_STRIPE        // [vectors] vectors to write on every DMA transaction
+#define DMA_RAW_ELEMS_A        		ISP_VEC_NELEMS  // [elements] elements per vector
+#define DMA_RAW_CROPPING_A     		0       // [elements] elements to skip on every line
+#define DMA_RAW_SUB_XFERS      		NUM_RAW_SUB_XFERS       // Number of sub transfers per DMA transaction
+#define DMA_RAW_LINE_WIDTH_A    	ISP_INPUT_WIDTH_VECS
+
+/* xmem side */
+#define DMA_RAW_ELEMS_B        		(XMEM_WIDTH_BITS/16)  // [elements] We will store 2 elements on a 32bits word
+#define DMA_RAW_BLOCK_WIDTH_B  		CEIL_DIV(DMA_RAW_BLOCK_WIDTH_A * DMA_RAW_ELEMS_A, DMA_RAW_ELEMS_B) // [elements] to write
+#define DMA_RAW_LINE_WIDTH_B   		CEIL_DIV(DMA_RAW_LINE_WIDTH_A * DMA_RAW_ELEMS_A, DMA_RAW_ELEMS_B)
+#define DMA_RAW_STRIDE_B       		(DMA_RAW_LINE_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)      // [byte address] stride for xmem
+#define DMA_RAW_CROPPING_B     		0     // [elements] elements to skip on every line
+
+#define DMA_RAW_STRIPE_OFFSET_B		CEIL_DIV(STRIPE_OFFSET_VECS*DMA_RAW_ELEMS_A, DMA_RAW_ELEMS_B)
+
+
+#define DMA_RAW_ELEMS_B_PACK(bits_per_pixel)       		(XMEM_WIDTH_BITS/bits_per_pixel)  // [elements] We will store 2 elements on a 32bits word
+#define DMA_RAW_BLOCK_WIDTH_B_PACK(bpp)  		CEIL_DIV(DMA_RAW_BLOCK_WIDTH_A * DMA_RAW_ELEMS_A, DMA_RAW_ELEMS_B_PACK(bpp))	// [elements] to write
+#define DMA_RAW_LINE_WIDTH_B_PACK(bpp)   		CEIL_DIV(DMA_RAW_LINE_WIDTH_A * DMA_RAW_ELEMS_A, DMA_RAW_ELEMS_B_PACK(bpp))
+#define DMA_RAW_STRIDE_B_PACK(bpp)      		(DMA_RAW_LINE_WIDTH_B_PACK(bpp) * HIVE_ISP_DDR_WORD_BYTES)    // [byte address] stride for xmem
+
+#define REMAINING_ELEMS_B_PACK_STRIPE(stripe_id, bpp)  ((CEIL_MUL((stripe_id) * STRIPE_OFFSET_VECS * DMA_RAW_ELEMS_A, DMA_RAW_ELEMS_B_PACK(bpp)) - (stripe_id) * STRIPE_OFFSET_VECS * DMA_RAW_ELEMS_A))  //remaining elems in one DDR word from last DMA transaction
+#define EXTRA_ELEMS_B_PACK_STRIPE(bpp) (DMA_RAW_BLOCK_WIDTH_A * DMA_RAW_ELEMS_A - (DMA_RAW_BLOCK_WIDTH_A * DMA_RAW_ELEMS_A / DMA_RAW_ELEMS_B_PACK(bpp)) * DMA_RAW_ELEMS_B_PACK(bpp))  //extra elements needed from last DDR word during one transfer
+
+#define DMA_RAW_BLOCK_WIDTH_B_PACK_STRIPE(stripe_id, bpp)  		((((REMAINING_ELEMS_B_PACK_STRIPE(stripe_id, bpp) >= EXTRA_ELEMS_B_PACK_STRIPE(bpp)) || (REMAINING_ELEMS_B_PACK_STRIPE(stripe_id, bpp) == 0)) ? DMA_RAW_BLOCK_WIDTH_B_PACK(bpp) : (DMA_RAW_BLOCK_WIDTH_B_PACK(bpp) + 1)))	// [elements] to write
+#define DMA_RAW_STRIPE_OFFSET_B_PACK_STRIPE(stripe_id, bpp)		(((stripe_id) * STRIPE_OFFSET_VECS * DMA_RAW_ELEMS_A / DMA_RAW_ELEMS_B_PACK(bpp)))
+#define DMA_RAW_CROPPING_B_PACK_STRIPE(stripe_id, bpp)	((DMA_RAW_ELEMS_B_PACK(bpp) - (REMAINING_ELEMS_B_PACK_STRIPE(stripe_id, bpp) ? REMAINING_ELEMS_B_PACK_STRIPE(stripe_id, bpp) : DMA_RAW_ELEMS_B_PACK(bpp))))
+
+
+/* ****************************************************************
+ * parameters for raw image communication
+ *		isp vmem -> ddr
+ * ****************************************************************/
+/* isp side */
+#define DMA_RAW_OUT_BLOCK_HEIGHT  	2       // [lines] lines to write on every DMA transaction
+#define DMA_RAW_OUT_BLOCK_WIDTH_A  	VECTORS_PER_LINE        // [vectors] vectors to write on every DMA transaction
+#define MAX_DMA_RAW_OUT_BLOCK_WIDTH_A  	MAX_VECTORS_PER_LINE        // [vectors] vectors to write on every DMA transaction
+#define DMA_RAW_OUT_STRIDE_A       	MAX_DMA_RAW_BLOCK_WIDTH_A*ISP_VEC_ALIGN       // [byte address] stride for VMEM. Round next power of two[ (64elem x 14bits/elem) / 8bits/byte ]
+#define DMA_RAW_OUT_ELEMS_A        	ISP_VEC_NELEMS  // [elements] elements per vector
+#define DMA_RAW_OUT_CROPPING_A     	0       // [elements] elements to skip on every line
+#define DMA_RAW_OUT_SUB_XFERS      	NUM_RAW_SUB_XFERS       // Number of sub transfers per DMA transaction
+#define DMA_RAW_OUT_LINE_WIDTH_A    ISP_OUTPUT_WIDTH_VECS
+
+/* xmem side */
+#define DMA_RAW_OUT_ELEMS_B        (XMEM_WIDTH_BITS/16)  // [elements] We will store 2 elements on a 32bits word
+#define DMA_RAW_OUT_BLOCK_WIDTH_B  CEIL_DIV(DMA_RAW_OUT_BLOCK_WIDTH_A * DMA_RAW_OUT_ELEMS_A, DMA_RAW_OUT_ELEMS_B) // [elements] to write
+#define DMA_RAW_OUT_LINE_WIDTH_B   CEIL_DIV(DMA_RAW_OUT_LINE_WIDTH_A * DMA_RAW_OUT_ELEMS_A, DMA_RAW_OUT_ELEMS_B)
+#define DMA_RAW_OUT_STRIDE_B       (DMA_RAW_LINE_OUT_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)      // [byte address] stride for xmem
+#define DMA_RAW_OUT_CROPPING_B     0     // [elements] elements to skip on every line
+
+/* ******************************************************
+ * parameters for crop communication
+ * ******************************************************/
+//#define DMA_CROP_Y_BLOCK_WIDTH_A          OUTPUT_VECTORS_PER_CHUNK
+#define DMA_CROP_Y_BLOCK_WIDTH_A          (DMA_BLOCK_OUTPUT ? BLOCK_WIDTH : ISP_OUTPUT_CHUNK_VECS)
+#define DMA_CROP_Y_BLOCK_WIDTH_B          CEIL_DIV(DMA_CROP_Y_BLOCK_WIDTH_A * DMA_OUTPUT_ELEMS_A, DMA_OUTPUT_ELEMS_B)
+#define DMA_CROP_Y_STRIDE_B               (DMA_CROP_Y_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)
+
+//#define DMA_CROP_C_BLOCK_WIDTH_A          OUTPUT_C_VECTORS_PER_CHUNK
+#define DMA_CROP_C_BLOCK_WIDTH_A          (DMA_BLOCK_OUTPUT ? BLOCK_WIDTH / 2 : ISP_UV_OUTPUT_CHUNK_VECS)
+#define DMA_CROP_C_BLOCK_WIDTH_B          CEIL_DIV(DMA_CROP_C_BLOCK_WIDTH_A * DMA_C_ELEMS_A, DMA_C_ELEMS_B)
+#define DMA_CROP_C_STRIDE_B               (DMA_CROP_C_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)
+
+#define DMA_CROP_VFOUT_Y_BLOCK_WIDTH_A    ISP_VF_OUTPUT_WIDTH_VECS
+#define DMA_CROP_VFOUT_Y_BLOCK_WIDTH_B    CEIL_DIV(ISP_VF_OUTPUT_WIDTH, DMA_VFOUT_ELEMS_B)
+#define DMA_CROP_VFOUT_Y_STRIDE_B         (DMA_CROP_VFOUT_Y_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)
+
+#define DMA_CROP_VFOUT_C_BLOCK_WIDTH_A    ISP_VF_UV_OUTPUT_WIDTH_VECS
+#define DMA_CROP_VFOUT_C_BLOCK_WIDTH_B    CEIL_DIV(ISP_VF_UV_OUTPUT_WIDTH, DMA_VFOUT_ELEMS_B)
+#define DMA_CROP_VFOUT_C_STRIDE_B         (DMA_CROP_VFOUT_C_BLOCK_WIDTH_B * HIVE_ISP_DDR_WORD_BYTES)
+
+#endif /* _dma_settings_hive_h_ */
diff --git a/drivers/media/atomisp2/css2400/isp/modes/interface/input_buf.isp.h b/drivers/media/atomisp2/css2400/isp/modes/interface/input_buf.isp.h
new file mode 100644
index 0000000..1f48341
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/modes/interface/input_buf.isp.h
@@ -0,0 +1,61 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _INPUT_BUF_ISP_H_
+#define _INPUT_BUF_ISP_H_
+
+/* Temporary include, since IA_CSS_BINARY_MODE_COPY is still needed */
+#include "sh_css_defs.h"
+
+#define INPUT_BUF_HEIGHT	2 /* double buffer */
+#define INPUT_BUF_LINES		2
+
+#ifndef ENABLE_CONTINUOUS
+#define ENABLE_CONTINUOUS 0
+#endif
+
+/* In continuous mode, the input buffer must be a fixed size for all binaries
+ * and at a fixed address since it will be used by the SP. */
+#define EXTRA_INPUT_VECTORS	2 /* For left padding */
+#define MAX_VECTORS_PER_INPUT_LINE_CONT (CEIL_DIV(SH_CSS_MAX_SENSOR_WIDTH, ISP_NWAY) + EXTRA_INPUT_VECTORS)
+
+/* The input buffer should be on a fixed address in vmem, for continuous capture */
+#define INPUT_BUF_ADDR 0x0
+
+#if !defined(__ISP)
+
+#elif !defined(MODE) || MODE != IA_CSS_BINARY_MODE_COPY
+
+#if ENABLE_CONTINUOUS
+typedef struct {
+  tmemvectoru  raw[INPUT_BUF_HEIGHT][INPUT_BUF_LINES][MAX_VECTORS_PER_INPUT_LINE_CONT]; /* 2 bayer lines */
+  /* Two more lines for SP raw copy efficiency */
+  tmemvectoru _raw[INPUT_BUF_HEIGHT][INPUT_BUF_LINES][MAX_VECTORS_PER_INPUT_LINE_CONT]; /* 2 bayer lines */
+} input_line_type;
+#else
+typedef struct {
+  tmemvectoru  raw[INPUT_BUF_HEIGHT][INPUT_BUF_LINES][MAX_VECTORS_PER_INPUT_LINE]; /* 2 bayer lines */
+} input_line_type;
+#endif /* ENABLE_CONTINUOUS */
+
+#endif /* ISP */
+
+#endif /* _INPUT_BUF_ISP_H_ */
diff --git a/drivers/media/atomisp2/css2400/isp/modes/interface/isp_acc.hive.h b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_acc.hive.h
new file mode 100644
index 0000000..b3da3a0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_acc.hive.h
@@ -0,0 +1,29 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _ISP_ACC_H_
+#define _ISP_ACC_H_
+
+/* Isp interface to accelerators */
+
+#include "input_buf.isp.h"
+
+#endif /* _ISP_ACC_H_ */
diff --git a/drivers/media/atomisp2/css2400/isp/modes/interface/isp_const.h b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_const.h
new file mode 100644
index 0000000..06ed24a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_const.h
@@ -0,0 +1,253 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2013 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef _COMMON_ISP_CONST_H_
+#define _COMMON_ISP_CONST_H_
+
+/*#include "isp.h"*/	/* ISP_VEC_NELEMS */
+
+/* Binary independent constants */
+
+#ifdef MODE
+//#error __FILE__ "is mode independent"
+#endif
+
+#ifndef NO_HOIST
+#  define		NO_HOIST 	HIVE_ATTRIBUTE (( no_hoist ))
+#endif
+
+#define NO_HOIST_CSE HIVE_ATTRIBUTE ((no_hoist, no_cse))
+
+#ifdef __HIVECC
+#define UNION union
+#else
+#define UNION struct /* Union constructors not allowed in C++ */
+#endif
+
+/* ISP binary identifiers.
+   These determine the order in which the binaries are looked up, do not change
+   this!
+   Also, the SP firmware uses this same order (isp_loader.hive.c).
+   Also, gen_firmware.c uses this order in its firmware_header.
+*/
+/* The binary id is used in pre-processor expressions so we cannot
+ * use an enum here. */
+#define SH_CSS_BINARY_ID_COPY                      0
+#define SH_CSS_BINARY_ID_BAYER_DS                  1
+#define SH_CSS_BINARY_ID_VF_PP_FULL                2
+#define SH_CSS_BINARY_ID_VF_PP_OPT                 3
+#define SH_CSS_BINARY_ID_YUV_SCALE                 4
+#define SH_CSS_BINARY_ID_CAPTURE_PP                5
+#define SH_CSS_BINARY_ID_PRE_ISP                   6
+#define SH_CSS_BINARY_ID_PRE_ISP_ISP2              7
+#define SH_CSS_BINARY_ID_GDC                       8
+#define SH_CSS_BINARY_ID_POST_ISP                  9
+#define SH_CSS_BINARY_ID_POST_ISP_ISP2            10
+#define SH_CSS_BINARY_ID_ANR                      11
+#define SH_CSS_BINARY_ID_ANR_ISP2                 12
+#define SH_CSS_BINARY_ID_PREVIEW_CONT_DS          13
+#define SH_CSS_BINARY_ID_PREVIEW_DS               14
+#define SH_CSS_BINARY_ID_PREVIEW_DEC              15
+#define SH_CSS_BINARY_ID_PREVIEW_CONT_BDS125_ISP2 16
+#define SH_CSS_BINARY_ID_PREVIEW_CONT_BDS150_ISP2 17
+#define SH_CSS_BINARY_ID_PREVIEW_CONT_BDS200_ISP2 18
+#define SH_CSS_BINARY_ID_PREVIEW_DZ               19
+#define SH_CSS_BINARY_ID_PREVIEW_DZ_ISP2          20
+#define SH_CSS_BINARY_ID_PRIMARY_DS               21
+#define SH_CSS_BINARY_ID_PRIMARY_VAR              22
+#define SH_CSS_BINARY_ID_PRIMARY_VAR_ISP2         23
+#define SH_CSS_BINARY_ID_PRIMARY_SMALL            24
+#define SH_CSS_BINARY_ID_PRIMARY_STRIPED          25
+#define SH_CSS_BINARY_ID_PRIMARY_STRIPED_ISP2     26
+#define SH_CSS_BINARY_ID_PRIMARY_8MP              27
+#define SH_CSS_BINARY_ID_PRIMARY_14MP             28
+#define SH_CSS_BINARY_ID_PRIMARY_16MP             29
+#define SH_CSS_BINARY_ID_PRIMARY_REF              30
+#define SH_CSS_BINARY_ID_VIDEO_OFFLINE            31
+#define SH_CSS_BINARY_ID_VIDEO_DS                 32
+#define SH_CSS_BINARY_ID_VIDEO_YUV_DS             33
+#define SH_CSS_BINARY_ID_VIDEO_DZ                 34
+#define SH_CSS_BINARY_ID_VIDEO_DZ_2400_ONLY       35
+#define SH_CSS_BINARY_ID_VIDEO_HIGH               36
+#define SH_CSS_BINARY_ID_VIDEO_NODZ               37
+#define SH_CSS_BINARY_ID_VIDEO_CONT_MULTIBDS_ISP2_MIN 38
+#define SH_CSS_BINARY_ID_VIDEO_CONT_BDS150_ISP2_MIN   39
+#define SH_CSS_BINARY_ID_VIDEO_CONT_BDS200_ISP2_MIN   40
+#define SH_CSS_BINARY_ID_VIDEO_CONT_NOBDS_ISP2_MIN    41
+#define SH_CSS_BINARY_ID_VIDEO_DZ_ISP2_MIN      42
+#define SH_CSS_BINARY_ID_VIDEO_DZ_ISP2          43
+#define SH_CSS_BINARY_ID_RESERVED1              44
+#define SH_CSS_BINARY_ID_ACCELERATION           45
+#define SH_CSS_BINARY_ID_PRE_DE_ISP2            46
+#define SH_CSS_BINARY_ID_KERNEL_TEST_LOAD_STORE 47
+#define SH_CSS_BINARY_NUM_IDS                   48
+
+#define XMEM_WIDTH_BITS              HIVE_ISP_DDR_WORD_BITS
+#define XMEM_SHORTS_PER_WORD         (HIVE_ISP_DDR_WORD_BITS/16)
+#define XMEM_INTS_PER_WORD           (HIVE_ISP_DDR_WORD_BITS/32)
+#define XMEM_POW2_BYTES_PER_WORD      HIVE_ISP_DDR_WORD_BYTES
+
+#define BITS8_ELEMENTS_PER_XMEM_ADDR    CEIL_DIV(XMEM_WIDTH_BITS, 8)
+#define BITS16_ELEMENTS_PER_XMEM_ADDR    CEIL_DIV(XMEM_WIDTH_BITS, 16)
+
+#if ISP_VEC_NELEMS == 64
+#define ISP_NWAY_LOG2  6
+#elif ISP_VEC_NELEMS == 32
+#define ISP_NWAY_LOG2  5
+#elif ISP_VEC_NELEMS == 16
+#define ISP_NWAY_LOG2  4
+#elif ISP_VEC_NELEMS == 8
+#define ISP_NWAY_LOG2  3
+#else
+#error "isp_const.h ISP_VEC_NELEMS must be one of {8, 16, 32, 64}"
+#endif
+
+/* *****************************
+ * ISP input/output buffer sizes
+ * ****************************/
+/* input image */
+#define INPUT_BUF_DMA_HEIGHT          2
+#define INPUT_BUF_HEIGHT              2 /* double buffer */
+#define OUTPUT_BUF_DMA_HEIGHT         2
+#define OUTPUT_BUF_HEIGHT             2 /* double buffer */
+#define OUTPUT_NUM_TRANSFERS	      4
+
+/* GDC accelerator: Up/Down Scaling */
+/* These should be moved to the gdc_defs.h in the device */
+#define UDS_SCALING_N                 HRT_GDC_N
+/* AB: This should cover the zooming up to 16MP */
+#define UDS_MAX_OXDIM                 5000
+/* We support maximally 2 planes with different parameters
+       - luma and chroma (YUV420) */
+#define UDS_MAX_PLANES                2
+#define UDS_BLI_BLOCK_HEIGHT          2
+#define UDS_BCI_BLOCK_HEIGHT          4
+#define UDS_BLI_INTERP_ENVELOPE       1
+#define UDS_BCI_INTERP_ENVELOPE       3
+#define UDS_MAX_ZOOM_FAC              64
+/* Make it always one FPGA vector.
+   Four FPGA vectors are required and
+   four of them fit in one ASIC vector.*/
+#define UDS_MAX_CHUNKS                16
+
+/* ************
+ * lookup table
+ * ************/
+
+#define ISP_LEFT_PADDING	_ISP_LEFT_CROP_EXTRA(ISP_LEFT_CROPPING)
+#define ISP_LEFT_PADDING_VECS	CEIL_DIV(ISP_LEFT_PADDING, ISP_VEC_NELEMS)
+/* in case of continuous the croppong of the current binary doesn't matter for the buffer calculation, but the cropping of the sp copy should be used */
+#define ISP_LEFT_PADDING_CONT	_ISP_LEFT_CROP_EXTRA(SH_CSS_MAX_LEFT_CROPPING)
+#define ISP_LEFT_PADDING_VECS_CONT	CEIL_DIV(ISP_LEFT_PADDING_CONT, ISP_VEC_NELEMS)
+
+#define CEIL_ROUND_DIV_STRIPE(width, stripe, padding) \
+	CEIL_MUL(padding + CEIL_DIV(width - padding, stripe), ((ENABLE_RAW_BINNING || ENABLE_FIXED_BAYER_DS)?4:2))
+
+/* output (Y,U,V) image, 4:2:0 */
+#define MAX_VECTORS_PER_LINE \
+	CEIL_ROUND_DIV_STRIPE(CEIL_DIV(ISP_MAX_INTERNAL_WIDTH, ISP_VEC_NELEMS), \
+			      ISP_NUM_STRIPES, \
+			      ISP_LEFT_PADDING_VECS)
+
+#define MAX_VECTORS_PER_OUTPUT_LINE \
+	CEIL_DIV(CEIL_DIV(ISP_MAX_OUTPUT_WIDTH, ISP_NUM_STRIPES) + ISP_LEFT_PADDING, ISP_VEC_NELEMS)
+
+/* Must be even due to interlaced bayer input */
+#define MAX_VECTORS_PER_INPUT_LINE	CEIL_MUL((CEIL_DIV(ISP_MAX_INPUT_WIDTH, ISP_VEC_NELEMS) + ISP_LEFT_PADDING_VECS), 2)
+#define MAX_VECTORS_PER_INPUT_STRIPE	CEIL_ROUND_DIV_STRIPE(MAX_VECTORS_PER_INPUT_LINE, \
+							      ISP_NUM_STRIPES, \
+							      ISP_LEFT_PADDING_VECS)
+
+/* Add 2 for left croppping */
+#define MAX_SP_RAW_COPY_VECTORS_PER_INPUT_LINE	(CEIL_DIV(ISP_MAX_INPUT_WIDTH, ISP_VEC_NELEMS) + 2)
+
+#define MAX_VECTORS_PER_BUF_LINE \
+	(MAX_VECTORS_PER_LINE + DUMMY_BUF_VECTORS)
+#define MAX_VECTORS_PER_BUF_INPUT_LINE \
+	(MAX_VECTORS_PER_INPUT_STRIPE + DUMMY_BUF_VECTORS)
+#define MAX_OUTPUT_Y_FRAME_WIDTH \
+	(MAX_VECTORS_PER_LINE * ISP_VEC_NELEMS)
+#define MAX_OUTPUT_Y_FRAME_SIMDWIDTH \
+	MAX_VECTORS_PER_LINE
+#define MAX_OUTPUT_C_FRAME_WIDTH \
+	(MAX_OUTPUT_Y_FRAME_WIDTH / 2)
+#define MAX_OUTPUT_C_FRAME_SIMDWIDTH \
+	CEIL_DIV(MAX_OUTPUT_C_FRAME_WIDTH, ISP_VEC_NELEMS)
+
+/* should be even */
+#define NO_CHUNKING (OUTPUT_NUM_CHUNKS == 1)
+
+#define MAX_VECTORS_PER_CHUNK \
+	(NO_CHUNKING ? MAX_VECTORS_PER_LINE \
+				: 2*CEIL_DIV(MAX_VECTORS_PER_LINE, \
+					     2*OUTPUT_NUM_CHUNKS))
+
+#define MAX_C_VECTORS_PER_CHUNK \
+	(MAX_VECTORS_PER_CHUNK/2)
+
+/* should be even */
+#define MAX_VECTORS_PER_OUTPUT_CHUNK \
+	(NO_CHUNKING ? MAX_VECTORS_PER_OUTPUT_LINE \
+				: 2*CEIL_DIV(MAX_VECTORS_PER_OUTPUT_LINE, \
+					     2*OUTPUT_NUM_CHUNKS))
+
+#define MAX_C_VECTORS_PER_OUTPUT_CHUNK \
+	(MAX_VECTORS_PER_OUTPUT_CHUNK/2)
+
+
+
+/* should be even */
+#define MAX_VECTORS_PER_INPUT_CHUNK \
+	(INPUT_NUM_CHUNKS == 1 ? MAX_VECTORS_PER_INPUT_STRIPE \
+			       : 2*CEIL_DIV(MAX_VECTORS_PER_INPUT_STRIPE, \
+					    2*OUTPUT_NUM_CHUNKS))
+
+#define DEFAULT_C_SUBSAMPLING      2
+
+/****** DMA buffer properties */
+
+#define RAW_BUF_LINES ((ENABLE_RAW_BINNING || ENABLE_FIXED_BAYER_DS) ? 4 : 2)
+
+#define RAW_BUF_STRIDE \
+	(BINARY_ID == SH_CSS_BINARY_ID_POST_ISP ? MAX_VECTORS_PER_INPUT_CHUNK : \
+	 ISP_NUM_STRIPES > 1 ? MAX_VECTORS_PER_INPUT_STRIPE : \
+	 !ENABLE_CONTINUOUS ? MAX_VECTORS_PER_INPUT_LINE : \
+	 MAX_VECTORS_PER_INPUT_CHUNK)
+
+/* [isp vmem] table size[vectors] per line per color (GR,R,B,GB),
+   multiples of NWAY */
+#define SCTBL_VECTORS_PER_LINE_PER_COLOR \
+	CEIL_DIV(SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR, ISP_VEC_NELEMS)
+/* [isp vmem] table size[vectors] per line for 4colors (GR,R,B,GB),
+   multiples of NWAY */
+#define SCTBL_VECTORS_PER_LINE \
+	(SCTBL_VECTORS_PER_LINE_PER_COLOR * IA_CSS_SC_NUM_COLORS)
+
+/*************/
+
+/* Format for fixed primaries */
+
+#define ISP_FIXED_PRIMARY_FORMAT IA_CSS_FRAME_FORMAT_NV12
+
+#endif /* _COMMON_ISP_CONST_H_ */
diff --git a/drivers/media/atomisp2/css2400/isp/modes/interface/isp_defaults.h b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_defaults.h
new file mode 100644
index 0000000..b15abb7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_defaults.h
@@ -0,0 +1,306 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2013 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef _ISP_DEFAULTS
+#define _ISP_DEFAULTS
+
+#if !defined(USE_DMA_PROXY)
+#define USE_DMA_PROXY 1
+#endif
+
+#if !defined(ENABLE_DIS_CROP)
+#define ENABLE_DIS_CROP 0
+#endif
+
+/* Duplicates from "isp/common/defs.h" */
+#if !defined(ENABLE_FIXED_BAYER_DS)
+#define ENABLE_FIXED_BAYER_DS 0
+#endif
+
+#if !defined(SUPPORTED_BDS_FACTORS)
+#define SUPPORTED_BDS_FACTORS PACK_BDS_FACTOR(SH_CSS_BDS_FACTOR_1_00)
+#endif
+
+#if !defined(ENABLE_RAW_BINNING)
+#define ENABLE_RAW_BINNING 0
+#endif
+
+#if !defined(ENABLE_AA_BEFORE_RAW_BINNING)
+#define ENABLE_AA_BEFORE_RAW_BINNING 0
+#endif
+
+#if !defined(ENABLE_YUV_AA)
+#define ENABLE_YUV_AA           0
+#endif
+
+#if !defined(ENABLE_VF_BINNING)
+#define ENABLE_VF_BINNING       0
+#endif
+
+#if !defined(ENABLE_PARAMS)
+#define ENABLE_PARAMS		1
+#endif
+
+#if !defined(ENABLE_RAW)
+#define ENABLE_RAW		0
+#endif
+
+#if !defined(ENABLE_DVS_6AXIS)
+#define ENABLE_DVS_6AXIS	0
+#endif
+
+#if !defined(ENABLE_TNR)
+#define ENABLE_TNR              0
+#endif
+
+#if !defined(ENABLE_UDS)
+#define ENABLE_UDS              0
+#endif
+
+#if !defined(ENABLE_OUTPUT)
+#define ENABLE_OUTPUT           0
+#define NUM_OUTPUT_PINS         0
+#endif
+
+#if !defined(ENABLE_MACC)
+#define ENABLE_MACC           0
+#endif
+
+#if !defined(ENABLE_SS)
+#define ENABLE_SS             0
+#endif
+
+#if !defined(ENABLE_OB)
+#define ENABLE_OB		1
+#endif
+
+#if !defined(ENABLE_DP)
+#define ENABLE_DP		1
+#endif
+
+#if !defined(ENABLE_DPC)
+#define ENABLE_DPC		1
+#endif
+
+#if !defined(ENABLE_DPCBNR)
+#define ENABLE_DPCBNR         1
+#endif
+
+#if !defined(ENABLE_RGBA)
+#define ENABLE_RGBA 0
+#endif
+
+#if !defined(ENABLE_YEE)
+#define ENABLE_YEE            0
+#endif
+
+#if !defined(ENABLE_PIXELNOISE_IN_DE_MOIRE_CORING)
+#define ENABLE_PIXELNOISE_IN_DE_MOIRE_CORING 0
+#endif
+
+#if !defined(ENABLE_DE_C1C2_CORING)
+#define ENABLE_DE_C1C2_CORING 0
+#endif
+
+#if !defined(ENABLE_YNR)
+#define ENABLE_YNR            0
+#endif
+
+#if !defined(ENABLE_CNR)
+#define ENABLE_CNR            1
+#endif
+
+#if !defined(ENABLE_XNR)
+#define ENABLE_XNR            0
+#endif
+
+#if !defined(ENABLE_GAMMA)
+#define ENABLE_GAMMA          0
+#endif
+
+#if !defined(ENABLE_CTC)
+#define ENABLE_CTC            0
+#endif
+
+#if !defined(ENABLE_CLIPPING_IN_YEE)
+#define ENABLE_CLIPPING_IN_YEE 0
+#endif
+
+#if !defined(ENABLE_GAMMA_UPGRADE)
+#define ENABLE_GAMMA_UPGRADE  0
+#endif
+
+#if !defined(ENABLE_BAYER_HIST)
+#if ISP_PIPE_VERSION == 2
+#define ENABLE_BAYER_HIST  0 /* should be 1 */
+#else
+#define ENABLE_BAYER_HIST  0
+#endif
+#endif
+
+#if !defined(ENABLE_QPLANE_STORE)
+#define ENABLE_QPLANE_STORE     0
+#endif
+
+#if !defined(ENABLE_QPLANE_LOAD)
+#define ENABLE_QPLANE_LOAD      0
+#endif
+
+#if !defined(ENABLE_HIGH_SPEED)
+#define ENABLE_HIGH_SPEED 0
+#endif
+
+#ifndef ENABLE_REF_FRAME
+#define ENABLE_REF_FRAME        (ENABLE_TNR || ENABLE_DIS_CROP || \
+				ENABLE_UDS || ENABLE_DVS_6AXIS)
+#endif
+
+/* sdis2 supports 64/32/16BQ grid */
+#if !defined(ENABLE_SDIS2_64BQ_32BQ_16BQ_GRID)
+#define ENABLE_SDIS2_64BQ_32BQ_16BQ_GRID  0
+#endif
+
+/* sdis2 supports 64/32BQ grid */
+#if !defined(ENABLE_SDIS2_64BQ_32BQ_GRID)
+#define ENABLE_SDIS2_64BQ_32BQ_GRID       0
+#endif
+
+#ifndef ENABLE_CONTINUOUS
+#define ENABLE_CONTINUOUS       0
+#endif
+
+#ifndef ENABLE_CA_GDC
+#define ENABLE_CA_GDC           0
+#endif
+
+#ifndef ENABLE_OVERLAY
+#define ENABLE_OVERLAY          0
+#endif
+
+#ifndef ENABLE_ISP_ADDRESSES
+#define ENABLE_ISP_ADDRESSES    1
+#endif
+
+#ifndef ENABLE_IN_FRAME
+#define ENABLE_IN_FRAME		0
+#endif
+
+#ifndef ENABLE_OUT_FRAME
+#define ENABLE_OUT_FRAME	0
+#endif
+
+#ifndef ISP_DMEM_PARAMETERS_SIZE
+#define ISP_DMEM_PARAMETERS_SIZE	0
+#endif
+
+#ifndef ISP_DMEM_RESULTS_SIZE
+#define ISP_DMEM_RESULTS_SIZE		0
+#endif
+
+#ifndef ISP_VMEM_PARAMETERS_SIZE
+#define ISP_VMEM_PARAMETERS_SIZE	0
+#endif
+
+#ifndef ISP_VMEM_RESULTS_SIZE
+#define ISP_VMEM_RESULTS_SIZE		0
+#endif
+
+#ifndef ISP_VAMEM0_PARAMETERS_SIZE
+#define ISP_VAMEM0_PARAMETERS_SIZE	0
+#endif
+
+#ifndef ISP_VAMEM0_RESULTS_SIZE
+#define ISP_VAMEM0_RESULTS_SIZE		0
+#endif
+
+#ifndef ISP_VAMEM1_PARAMETERS_SIZE
+#define ISP_VAMEM1_PARAMETERS_SIZE	0
+#endif
+
+#ifndef ISP_VAMEM1_RESULTS_SIZE
+#define ISP_VAMEM1_RESULTS_SIZE		0
+#endif
+
+#ifndef ISP_VAMEM2_PARAMETERS_SIZE
+#define ISP_VAMEM2_PARAMETERS_SIZE	0
+#endif
+
+#ifndef ISP_VAMEM2_RESULTS_SIZE
+#define ISP_VAMEM2_RESULTS_SIZE		0
+#endif
+
+#if !defined(USE_BNR_LITE)
+#if ISP_PIPE_VERSION == 2
+#define USE_BNR_LITE  1 /* should be 0 */
+#else
+#define USE_BNR_LITE  1
+#endif
+#endif
+
+#if !defined(USE_YEEYNR_LITE)
+#if ISP_PIPE_VERSION == 2
+#define USE_YEEYNR_LITE  0
+#else
+#define USE_YEEYNR_LITE  1
+#endif
+#endif
+
+#if !defined(SPLIT_DP)
+#define SPLIT_DP 0
+#endif
+
+#ifndef ISP_NUM_STRIPES
+#define ISP_NUM_STRIPES         1
+#endif
+
+#ifndef ISP_ROW_STRIPES_HEIGHT
+#define ISP_ROW_STRIPES_HEIGHT         0
+#endif
+
+#ifndef ISP_ROW_STRIPES_OVERLAP_LINES
+#define ISP_ROW_STRIPES_OVERLAP_LINES         0
+#endif
+
+#ifndef VARIABLE_OUTPUT_FORMAT
+#define VARIABLE_OUTPUT_FORMAT  1
+#endif
+
+#ifndef STREAM_OUTPUT
+#define STREAM_OUTPUT  0
+#endif
+
+#ifndef VARIABLE_RESOLUTION
+#define VARIABLE_RESOLUTION  1
+#endif
+
+#ifndef ISP_MAX_INTERNAL_WIDTH
+#define ISP_MAX_INTERNAL_WIDTH  0
+#endif
+
+#ifndef ENABLE_INPUT_CHUNKING
+#define ENABLE_INPUT_CHUNKING  0
+#endif
+
+#endif /* _ISP_DEFAULTS */
+
diff --git a/drivers/media/atomisp2/css2400/isp/modes/interface/isp_exprs.h b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_exprs.h
new file mode 100644
index 0000000..55c1a2a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_exprs.h
@@ -0,0 +1,305 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2013 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+
+#ifndef _COMMON_ISP_EXPRS_H_
+#define _COMMON_ISP_EXPRS_H_
+
+/* Binary independent pre-processor expressions */
+
+#include "sh_css_defs.h"
+#include "isp_const.h"
+
+#ifdef __HOST
+#error "isp_exprs.h: Do not include on HOST, contains ISP specific defines"
+#endif
+
+#ifndef __ISP
+#if defined(MODE)
+#define MODE aap
+#error "isp_exprs.h: is mode independent, but MODE is set"
+#endif
+#if defined(VARIABLE_RESOLUTION)
+#define VARIABLE_RESOLUTION noot
+#error "isp_exprs.h: is mode independent, but VARIABLE_RESOLUTION is set"
+#endif
+#if defined(DECI_FACTOR_LOG2)
+#define DECI_FACTOR_LOG2 mies
+#error "isp_exprs.h: is mode independent, but DECI_FACTOR_LOG2 is set"
+#endif
+#endif
+
+#define LOG_VECTOR_STEP        _ISP_LOG_VECTOR_STEP(MODE)
+/* should be even and multiple of vf downscaling */
+#define ISP_OUTPUT_CHUNK_LOG_FACTOR (MAX_VF_LOG_DOWNSCALE<=1 ? LOG_VECTOR_STEP : \
+					max(VF_LOG_DOWNSCALE,LOG_VECTOR_STEP))
+
+#define CEIL_DIV_CHUNKS(n,c)	((c) == 1 ? (n) \
+		  		          : CEIL_SHIFT(CEIL_DIV((n), (c)), ISP_OUTPUT_CHUNK_LOG_FACTOR)<<ISP_OUTPUT_CHUNK_LOG_FACTOR)
+
+
+#define ISP_VARIABLE_INPUT 	(ISP_INPUT == IA_CSS_BINARY_INPUT_VARIABLE)
+
+/* Binary independent versions, see isp_defs.h for binary dependent ones */
+#ifndef __ISP
+#define IMAGEFORMAT_IS_RAW(fmt)			((fmt) == IA_CSS_FRAME_FORMAT_RAW)
+
+#define IMAGEFORMAT_IS_RAW_INTERLEAVED(fmt) 	((fmt) == IA_CSS_FRAME_FORMAT_RAW)
+
+#define IMAGEFORMAT_IS_RGB(fmt) 		((fmt) == IA_CSS_FRAME_FORMAT_RGBA888 || (fmt) == IA_CSS_FRAME_FORMAT_PLANAR_RGB888 || \
+						 (fmt) == IA_CSS_FRAME_FORMAT_RGB565)
+
+#define IMAGEFORMAT_IS_RGB_INTERLEAVED(fmt) 	((fmt) == IA_CSS_FRAME_FORMAT_RGBA888 || (fmt) == IA_CSS_FRAME_FORMAT_RGB565)
+
+#define IMAGEFORMAT_UV_INTERLEAVED(fmt) 	((fmt) == IA_CSS_FRAME_FORMAT_NV11    || \
+						 (fmt) == IA_CSS_FRAME_FORMAT_NV12    || (fmt) == IA_CSS_FRAME_FORMAT_NV21 || \
+						 (fmt) == IA_CSS_FRAME_FORMAT_NV16    || (fmt) == IA_CSS_FRAME_FORMAT_NV61 || \
+						 (fmt) == IA_CSS_FRAME_FORMAT_UYVY    || (fmt) == IA_CSS_FRAME_FORMAT_YUYV)
+
+#define IMAGEFORMAT_YUV_INTERLEAVED(fmt)	((fmt) == IA_CSS_FRAME_FORMAT_UYVY    || (fmt) == IA_CSS_FRAME_FORMAT_YUYV)
+
+#define IMAGEFORMAT_INTERLEAVED(fmt)		(IMAGEFORMAT_UV_INTERLEAVED(fmt) || IMAGEFORMAT_IS_RGB_INTERLEAVED(fmt))
+
+#define IMAGEFORMAT_SUB_SAMPL_420(fmt)		((fmt) == IA_CSS_FRAME_FORMAT_YUV420 || (fmt) == IA_CSS_FRAME_FORMAT_YV12 || \
+						 (fmt) == IA_CSS_FRAME_FORMAT_NV12   || (fmt) == IA_CSS_FRAME_FORMAT_NV21)
+
+#define IMAGEFORMAT_SUB_SAMPL_422(fmt)		((fmt) == IA_CSS_FRAME_FORMAT_YUV422 || (fmt) == IA_CSS_FRAME_FORMAT_YV16 || \
+						 (fmt) == IA_CSS_FRAME_FORMAT_NV16   || (fmt) == IA_CSS_FRAME_FORMAT_NV61)
+
+#define IMAGEFORMAT_SUB_SAMPL_444(fmt) 		((fmt) == IA_CSS_FRAME_FORMAT_YUV444)
+
+#define IMAGEFORMAT_UV_SWAPPED(fmt)		((fmt) == IA_CSS_FRAME_FORMAT_NV21 || (fmt) == IA_CSS_FRAME_FORMAT_NV61)
+
+#define IMAGEFORMAT_IS_RGBA(fmt)		((fmt) == IA_CSS_FRAME_FORMAT_RGBA888)
+
+#define IMAGEFORMAT_IS_NV11(fmt)		((fmt) == IA_CSS_FRAME_FORMAT_NV11)
+#endif
+
+
+/******** GDCAC settings *******/
+#define GDCAC_BPP			ISP_VEC_ELEMBITS  /* We use 14 bits per pixel component for the GDCAC mode */
+#define GDC_INPUT_BLOCK_WIDTH		2 /* Two vectors are needed */
+#define GDC_OUTPUT_BLOCK_WIDTH		1 /* One vector is produced */
+
+#if ISP_VEC_NELEMS == 16
+/* For 16*16 output block, the distortion fits in 13.312 lines __ALWAYS__ */
+#define GDC_INPUT_BLOCK_HEIGHT		14
+#elif ISP_VEC_NELEMS == 64
+/* For 64*64 output block, the distortion fits in 47.    lines __ALWAYS__ */
+#define GDC_INPUT_BLOCK_HEIGHT		48
+#endif
+/*******************************/
+
+
+#define ENABLE_HUP ((isp_input_width  - isp_envelope_width)  < isp_output_width)
+#define ENABLE_VUP ((isp_input_height - isp_envelope_height) < isp_output_height)
+
+#define ISP_INPUT_WIDTH  (ENABLE_DS | ENABLE_HUP ? isp_input_width  : ISP_INTERNAL_WIDTH)
+#define ISP_INPUT_HEIGHT (ENABLE_DS | ENABLE_VUP ? isp_input_height : isp_internal_height)
+
+#define DECI_FACTOR_LOG2 (ISP_FIXED_S3A_DECI_LOG ? ISP_FIXED_S3A_DECI_LOG : isp_deci_log_factor)
+
+#define ISP_S3ATBL_WIDTH \
+  _ISP_S3ATBL_ISP_WIDTH(_ISP_S3A_ELEMS_ISP_WIDTH((ENABLE_HUP ? ISP_INTERNAL_WIDTH : ISP_INPUT_WIDTH), ISP_LEFT_CROPPING), \
+    DECI_FACTOR_LOG2)
+#define S3ATBL_WIDTH_BYTES   (sizeof(struct ia_css_3a_output) * ISP_S3ATBL_WIDTH)
+#define S3ATBL_WIDTH_SHORTS  (S3ATBL_WIDTH_BYTES / sizeof(short))
+
+#define ISP_SDIS_ELEMS_ISP_HEIGHT \
+  _ISP_SDIS_ELEMS_ISP(ISP_INPUT_HEIGHT, ISP_INTERNAL_HEIGHT, ENABLE_VUP)
+
+/* should be even?? */
+#define ISP_UV_OUTPUT_CHUNK_VECS   	CEIL_DIV(ISP_OUTPUT_CHUNK_VECS, 2)
+
+
+#if defined(__ISP) || defined(INIT_VARS)
+
+#define ISP_USE_IF	(ISP_INPUT == IA_CSS_BINARY_INPUT_MEMORY ? 0 : \
+	       	         ISP_INPUT == IA_CSS_BINARY_INPUT_SENSOR ? 1 : \
+	                 isp_online)
+
+#if defined(__SP)
+#define ISP_DVS_ENVELOPE_WIDTH	(ENABLE_DVS_ENVELOPE ? stage->dvs_envelope.width : 0)
+#define ISP_DVS_ENVELOPE_HEIGHT (ENABLE_DVS_ENVELOPE ? stage->dvs_envelope.height : 0)
+#else
+#define ISP_DVS_ENVELOPE_WIDTH  0
+#define ISP_DVS_ENVELOPE_HEIGHT 0
+#endif
+
+#define _ISP_INPUT_WIDTH_VECS	_ISP_VECS(ISP_INPUT_WIDTH)
+
+#if !defined(__ISP) || (VARIABLE_RESOLUTION && !__HOST)
+#define ISP_INPUT_WIDTH_VECS	isp_vectors_per_input_line
+#else
+#define ISP_INPUT_WIDTH_VECS	_ISP_INPUT_WIDTH_VECS
+#endif
+
+#if !defined(__ISP) || VARIABLE_RESOLUTION
+#define ISP_INTERNAL_WIDTH_VECS		isp_vectors_per_line
+#else
+#define ISP_INTERNAL_WIDTH_VECS		_ISP_INTERNAL_WIDTH_VECS
+#endif
+
+#define _ISP_INTERNAL_HEIGHT	__ISP_INTERNAL_HEIGHT(isp_output_height, ISP_TOP_CROPPING, ISP_DVS_ENVELOPE_HEIGHT)
+
+#define ISP_INTERNAL_HEIGHT	isp_internal_height
+
+#define _ISP_INTERNAL_WIDTH	__ISP_INTERNAL_WIDTH(ISP_OUTPUT_WIDTH, ISP_DVS_ENVELOPE_WIDTH, \
+			     			     ISP_LEFT_CROPPING, MODE, ISP_C_SUBSAMPLING, \
+						     OUTPUT_NUM_CHUNKS, ISP_PIPELINING)
+
+#define ISP_UV_INTERNAL_WIDTH	(ISP_INTERNAL_WIDTH / 2)
+#define ISP_UV_INTERNAL_HEIGHT	(ISP_INTERNAL_HEIGHT / 2)
+
+#define _ISP_INTERNAL_WIDTH_VECS	(_ISP_INTERNAL_WIDTH / ISP_VEC_NELEMS)
+#define _ISP_UV_INTERNAL_WIDTH_VECS	CEIL_DIV(ISP_UV_INTERNAL_WIDTH, ISP_VEC_NELEMS)
+
+#define ISP_VF_OUTPUT_WIDTH		_ISP_VF_OUTPUT_WIDTH(ISP_VF_OUTPUT_WIDTH_VECS)
+#define ISP_VF_OUTPUT_HEIGHT		_ISP_VF_OUTPUT_HEIGHT(isp_output_height, VF_LOG_DOWNSCALE)
+
+#if defined (__ISP) && !VARIABLE_RESOLUTION
+#define ISP_INTERNAL_WIDTH         _ISP_INTERNAL_WIDTH
+#define ISP_VF_OUTPUT_WIDTH_VECS   _ISP_VF_OUTPUT_WIDTH_VECS
+#else
+#define ISP_INTERNAL_WIDTH         (VARIABLE_RESOLUTION ? isp_internal_width : _ISP_INTERNAL_WIDTH)
+#define ISP_VF_OUTPUT_WIDTH_VECS   (VARIABLE_RESOLUTION ? isp_vf_output_width_vecs : _ISP_VF_OUTPUT_WIDTH_VECS)
+#endif
+
+#if defined(__ISP) && !VARIABLE_RESOLUTION
+#define ISP_OUTPUT_WIDTH        ISP_MAX_OUTPUT_WIDTH
+#define VF_LOG_DOWNSCALE        MAX_VF_LOG_DOWNSCALE
+#else
+#define ISP_OUTPUT_WIDTH        isp_output_width
+#define VF_LOG_DOWNSCALE        isp_vf_downscale_bits
+#endif
+
+#if !defined(__ISP) || VARIABLE_RESOLUTION
+#define _ISP_MAX_VF_OUTPUT_WIDTH	__ISP_MAX_VF_OUTPUT_WIDTH(2*SH_CSS_MAX_VF_WIDTH, ISP_LEFT_CROPPING)
+#elif defined(MODE) && MODE == IA_CSS_BINARY_MODE_PRIMARY && ISP_OUTPUT_WIDTH > 3328
+/* Because of vmem issues, should be fixed later */
+#define _ISP_MAX_VF_OUTPUT_WIDTH	(SH_CSS_MAX_VF_WIDTH - 2*ISP_VEC_NELEMS + (ISP_LEFT_CROPPING ? 2 * ISP_VEC_NELEMS : 0))
+#else
+#define _ISP_MAX_VF_OUTPUT_WIDTH	(ISP_VF_OUTPUT_WIDTH + (ISP_LEFT_CROPPING ? (2 >> VF_LOG_DOWNSCALE) * ISP_VEC_NELEMS : 0))
+#endif
+
+#define ISP_MAX_VF_OUTPUT_VECS 		CEIL_DIV(_ISP_MAX_VF_OUTPUT_WIDTH, ISP_VEC_NELEMS)
+
+
+
+#define ISP_LOG_VECTOR_STEP(mode) \
+	((mode) == IA_CSS_BINARY_MODE_CAPTURE_PP ? 2 : 1)
+
+#define ISP_MIN_STRIPE_WIDTH (ISP_PIPELINING * (1<<_ISP_LOG_VECTOR_STEP(MODE)))
+
+/******* STRIPING-RELATED MACROS *******/
+#define NO_STRIPING (ISP_NUM_STRIPES == 1)
+
+#define ISP_OUTPUT_CHUNK_VECS \
+	(NO_STRIPING 	? CEIL_DIV_CHUNKS(ISP_OUTPUT_VECS_EXTRA_CROP, OUTPUT_NUM_CHUNKS) \
+				: ISP_IO_STRIPE_WIDTH_VECS(ISP_OUTPUT_VECS_EXTRA_CROP, ISP_LEFT_PADDING_VECS, ISP_NUM_STRIPES, ISP_MIN_STRIPE_WIDTH) )
+
+#define VECTORS_PER_LINE \
+	(NO_STRIPING 	? ISP_INTERNAL_WIDTH_VECS \
+				: ISP_IO_STRIPE_WIDTH_VECS(ISP_INTERNAL_WIDTH_VECS, ISP_LEFT_PADDING_VECS, ISP_NUM_STRIPES, ISP_MIN_STRIPE_WIDTH) )
+
+#define VECTORS_PER_INPUT_LINE \
+	(NO_STRIPING 	? ISP_INPUT_WIDTH_VECS \
+				: ISP_IO_STRIPE_WIDTH_VECS(ISP_INPUT_WIDTH_VECS, ISP_LEFT_PADDING_VECS, ISP_NUM_STRIPES, ISP_MIN_STRIPE_WIDTH) )
+
+#define ISP_MAX_VF_OUTPUT_STRIPE_VECS \
+	(NO_STRIPING 	? ISP_MAX_VF_OUTPUT_VECS \
+				: CEIL_MUL(CEIL_DIV(ISP_MAX_VF_OUTPUT_VECS, ISP_NUM_STRIPES), 2))
+#define _ISP_VF_OUTPUT_WIDTH_VECS \
+	(NO_STRIPING 	? __ISP_VF_OUTPUT_WIDTH_VECS(ISP_OUTPUT_WIDTH, VF_LOG_DOWNSCALE) \
+				: __ISP_VF_OUTPUT_WIDTH_VECS(CEIL_DIV(ISP_OUTPUT_WIDTH, ISP_NUM_STRIPES), VF_LOG_DOWNSCALE))
+
+#define ISP_IO_STRIPE_WIDTH_VECS(width, padding, num_stripes, min_stripe) \
+	MAX(CEIL_MUL(padding + CEIL_DIV(width-padding, num_stripes) \
+		   , 2) \
+	  , min_stripe)
+////////// INPUT & INTERNAL
+/* should be even */
+#define INPUT_NUM_CHUNKS	OUTPUT_NUM_CHUNKS
+
+#define INPUT_VECTORS_PER_CHUNK	CEIL_DIV_CHUNKS(VECTORS_PER_INPUT_LINE, INPUT_NUM_CHUNKS)
+
+/* only for ISP code, will be removed: */
+#define VECTORS_PER_FULL_LINE         	ISP_INTERNAL_WIDTH_VECS
+#define VECTORS_PER_INPUT_FULL_LINE   	ISP_INPUT_WIDTH_VECS
+
+////////// OUTPUT
+/* should at least even and also multiple of vf scaling */
+#define ISP_OUTPUT_VECS_EXTRA_CROP	CEIL_DIV(ISP_OUTPUT_WIDTH_EXTRA_CROP, ISP_VEC_NELEMS)
+
+/* Output is decoupled from input */
+#define ISP_OUTPUT_WIDTH_EXTRA_CROP	CEIL_MUL(CEIL_MUL((ENABLE_DVS_ENVELOPE ? ISP_OUTPUT_WIDTH : ISP_INTERNAL_WIDTH), 2*ISP_VEC_NELEMS), \
+		 				ISP_C_SUBSAMPLING * OUTPUT_NUM_CHUNKS *  HIVE_ISP_DDR_WORD_BYTES)
+
+#define ISP_MAX_VF_OUTPUT_CHUNK_VECS \
+        (NO_CHUNKING ? ISP_MAX_VF_OUTPUT_STRIPE_VECS \
+                                : 2*CEIL_DIV(ISP_MAX_VF_OUTPUT_STRIPE_VECS, 2*OUTPUT_NUM_CHUNKS))
+
+#define OUTPUT_VECTORS_PER_CHUNK	CEIL_DIV_CHUNKS(VECTORS_PER_LINE,OUTPUT_NUM_CHUNKS)
+/* should be even?? */
+#define OUTPUT_C_VECTORS_PER_CHUNK  	CEIL_DIV(OUTPUT_VECTORS_PER_CHUNK, 2)
+
+
+
+/**** SCTBL defs *******/
+#define ISP_SCTBL_HEIGHT \
+	_ISP_SCTBL_HEIGHT(ISP_INPUT_HEIGHT, DECI_FACTOR_LOG2)
+
+/**** UDS defs *********/
+#define UDS_DMACH_STRIDE_B_IN_Y           (( ISP_INTERNAL_WIDTH   /BITS8_ELEMENTS_PER_XMEM_ADDR)*HIVE_ISP_DDR_WORD_BYTES)
+#define UDS_DMACH_STRIDE_B_IN_C           (((ISP_INTERNAL_WIDTH/2)/BITS8_ELEMENTS_PER_XMEM_ADDR)*HIVE_ISP_DDR_WORD_BYTES)
+
+
+/**** SDIS defs ********/
+#define _ISP_SDIS_HOR_PROJ_NUM_ISP \
+  __ISP_SDIS_HOR_PROJ_NUM_ISP(_ISP_SDIS_ELEMS_ISP(ISP_INPUT_WIDTH, ISP_INTERNAL_WIDTH, ENABLE_HUP), \
+                              _ISP_SDIS_ELEMS_ISP(ISP_INPUT_HEIGHT, ISP_INTERNAL_HEIGHT, ENABLE_VUP), \
+                              SH_CSS_DIS_DECI_FACTOR_LOG2, ISP_PIPE_VERSION)
+#define _ISP_SDIS_VER_PROJ_NUM_ISP \
+  __ISP_SDIS_VER_PROJ_NUM_ISP(_ISP_SDIS_ELEMS_ISP(ISP_INPUT_WIDTH, ISP_INTERNAL_WIDTH, ENABLE_HUP), \
+                              _ISP_SDIS_ELEMS_ISP(ISP_INPUT_HEIGHT, ISP_INTERNAL_HEIGHT, ENABLE_VUP), \
+                              SH_CSS_DIS_DECI_FACTOR_LOG2, ISP_PIPE_VERSION)
+
+#define _ISP_SDIS_HOR_COEF_NUM_VECS \
+  __ISP_SDIS_HOR_COEF_NUM_VECS(_ISP_SDIS_ELEMS_ISP(ISP_INPUT_WIDTH, ISP_INTERNAL_WIDTH, ENABLE_HUP))
+#define _ISP_SDIS_VER_COEF_NUM_VECS \
+  __ISP_SDIS_VER_COEF_NUM_VECS(_ISP_SDIS_ELEMS_ISP(ISP_INPUT_HEIGHT, ISP_INTERNAL_HEIGHT, ENABLE_VUP))
+
+/* Use dmem to store sdis vertical coefficients */
+#define SDIS_VER_COEF_TBL_USE_DMEM \
+	_SDIS_VER_COEF_TBL_USE_DMEM(MODE, ENABLE_SDIS, ENABLE_DS, ISP_PIPE_VERSION)
+
+#else /* defined(__ISP) || defined(INIT_VARS) */
+
+#define ISP_INTERNAL_WIDTH         isp_internal_width
+#define ISP_INTERNAL_HEIGHT        isp_internal_height
+
+#endif /* defined(__ISP) || defined(INIT_VARS) */
+
+#endif /* _COMMON_ISP_EXPRS_H_ */
+
diff --git a/drivers/media/atomisp2/css2400/isp/modes/interface/isp_formats.isp.h b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_formats.isp.h
new file mode 100644
index 0000000..50597c1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_formats.isp.h
@@ -0,0 +1,159 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _ISP_FORMATS_ISP_H
+#define _ISP_FORMATS_ISP_H
+
+#include "assert_support.h"
+
+/* internal isp representation for the frame formats.
+ * always use the encode and decode functions to translate
+ * between this format and the enum in ia_css.h
+ *
+ * to simplify the encode and decode functions these have to be the
+ * same as the enum ia_css_frame_format*/
+
+#define	FRAME_FORMAT_NV11 0       /**< 12 bit YUV 411, Y, UV plane */
+#define	FRAME_FORMAT_NV12 1       /**< 12 bit YUV 420, Y, UV plane */
+#define	FRAME_FORMAT_NV16 2       /**< 16 bit YUV 422, Y, UV plane */
+#define	FRAME_FORMAT_NV21 3       /**< 12 bit YUV 420, Y, VU plane */
+#define	FRAME_FORMAT_NV61 4       /**< 16 bit YUV 422, Y, VU plane */
+#define	FRAME_FORMAT_YV12 5       /**< 12 bit YUV 420, Y, V, U plane */
+#define	FRAME_FORMAT_YV16 6       /**< 16 bit YUV 422, Y, V, U plane */
+#define	FRAME_FORMAT_YUV420    7  /**< 12 bit YUV 420, Y, U, V plane */
+#define	FRAME_FORMAT_YUV420_16 8  /**< yuv420, 16 bits per subpixel */
+#define	FRAME_FORMAT_YUV422    9  /**< 16 bit YUV 422, Y, U, V plane */
+#define	FRAME_FORMAT_YUV422_16 10  /**< yuv422, 16 bits per subpixel */
+#define	FRAME_FORMAT_UYVY      11  /**< 16 bit YUV 422, UYVY interleaved */
+#define	FRAME_FORMAT_YUYV      12  /**< 16 bit YUV 422, YUYV interleaved */
+#define	FRAME_FORMAT_YUV444    13  /**< 24 bit YUV 444, Y, U, V plane */
+#define	FRAME_FORMAT_YUV_LINE  14  /**< Internal format, 2 y lines followed
+           by a uvinterleaved line */
+#define	FRAME_FORMAT_RAW 15	/**< RAW, 1 plane */
+#define	FRAME_FORMAT_RGB565 16     /**< 16 bit RGB, 1 plane. Each 3 sub
+           pixels are packed into one 16 bit
+           value, 5 bits for R, 6 bits for G
+           and 5 bits for B. */
+#define	FRAME_FORMAT_PLANAR_RGB888 17 /**< 24 bit RGB, 3 planes */
+#define	FRAME_FORMAT_RGBA888 18	/**< 32 bit RGBA, 1 plane, A=Alpha
+           (alpha is unused) */
+#define	FRAME_FORMAT_QPLANE6 19 /**< Internal, for advanced ISP */
+#define	FRAME_FORMAT_BINARY_8 20	/**< byte stream, used for jpeg. For
+           frames of this type, we set the
+           height to 1 and the width to the
+           number of allocated bytes. */
+#define	FRAME_FORMAT_MIPI 21	/**< MIPI frame, 1 plane */
+
+// PACK_FMT() is used to pack the format identifier to the corresponding bit.
+#define PACK_FMT(fmt) (1<<fmt)
+#define SUPPORT_FMT(fmt) ((SUPPORTED_OUTPUT_FORMATS & PACK_FMT(fmt)) != 0)
+
+#ifndef PARAM_GENERATION
+#include "isp_defs_for_hive.h" /* SUPPORTED_OUTPUT_FORMATS */
+#endif
+
+/***************************/
+
+#define SUPPORTS_422      (SUPPORT_FMT(FRAME_FORMAT_NV16)   || SUPPORT_FMT(FRAME_FORMAT_NV61) \
+                        || SUPPORT_FMT(FRAME_FORMAT_YUV422) || SUPPORT_FMT(FRAME_FORMAT_YUV422_16) \
+                        || SUPPORT_FMT(FRAME_FORMAT_UYVY)   || SUPPORT_FMT(FRAME_FORMAT_YUYV))
+
+#define SUPPORTS_444      (SUPPORT_FMT(FRAME_FORMAT_YUV444))
+
+#define SUPPORTS_RGB      (SUPPORT_FMT(FRAME_FORMAT_RGB565) || SUPPORT_FMT(FRAME_FORMAT_RGBA888) || SUPPORT_FMT(FRAME_FORMAT_PLANAR_RGB888) )
+
+#define SUPPORTS_NV11     (SUPPORT_FMT(FRAME_FORMAT_NV11))
+
+#define SUPPORTS_UV_SWAP  (SUPPORT_FMT(FRAME_FORMAT_NV21) || SUPPORT_FMT(FRAME_FORMAT_NV61))
+
+#define SUPPORTS_UV_IL    (SUPPORT_FMT(FRAME_FORMAT_NV11) || SUPPORT_FMT(FRAME_FORMAT_NV12) \
+                        || SUPPORT_FMT(FRAME_FORMAT_NV16) || SUPPORT_FMT(FRAME_FORMAT_NV21) \
+                        || SUPPORT_FMT(FRAME_FORMAT_NV61) || SUPPORT_FMT(FRAME_FORMAT_YUV_LINE) \
+                        || SUPPORT_FMT(FRAME_FORMAT_UYVY) || SUPPORT_FMT(FRAME_FORMAT_YUYV))
+
+#define SUPPORTS_YUV_IL   (SUPPORT_FMT(FRAME_FORMAT_UYVY) || SUPPORT_FMT(FRAME_FORMAT_YUYV))
+
+#define SUPPORTS_RGB_IL   (SUPPORT_FMT(FRAME_FORMAT_RGBA888) || SUPPORT_FMT(FRAME_FORMAT_RGB565))
+
+#define SUPPORTS_IL       (SUPPORTS_YUV_IL || SUPPORTS_RGB_IL)
+
+#define SUPPORTS_UYVY     (SUPPORT_FMT(FRAME_FORMAT_UYVY))
+
+#ifndef PIPE_GENERATION
+// encode and decode are used to translate between the host enum, and the isp internal representation.
+static inline uint32_t
+format_encode(enum ia_css_frame_format fmt)
+{
+  OP___assert(FRAME_FORMAT_NV11          == IA_CSS_FRAME_FORMAT_NV11);
+  OP___assert(FRAME_FORMAT_NV12          == IA_CSS_FRAME_FORMAT_NV12);
+  OP___assert(FRAME_FORMAT_NV16          == IA_CSS_FRAME_FORMAT_NV16);
+  OP___assert(FRAME_FORMAT_NV21          == IA_CSS_FRAME_FORMAT_NV21);
+  OP___assert(FRAME_FORMAT_NV61          == IA_CSS_FRAME_FORMAT_NV61);
+  OP___assert(FRAME_FORMAT_YV12          == IA_CSS_FRAME_FORMAT_YV12);
+  OP___assert(FRAME_FORMAT_YV16          == IA_CSS_FRAME_FORMAT_YV16);
+  OP___assert(FRAME_FORMAT_YUV420        == IA_CSS_FRAME_FORMAT_YUV420);
+  OP___assert(FRAME_FORMAT_YUV420_16     == IA_CSS_FRAME_FORMAT_YUV420_16);
+  OP___assert(FRAME_FORMAT_YUV422        == IA_CSS_FRAME_FORMAT_YUV422);
+  OP___assert(FRAME_FORMAT_YUV422_16     == IA_CSS_FRAME_FORMAT_YUV422_16);
+  OP___assert(FRAME_FORMAT_UYVY          == IA_CSS_FRAME_FORMAT_UYVY);
+  OP___assert(FRAME_FORMAT_YUYV          == IA_CSS_FRAME_FORMAT_YUYV);
+  OP___assert(FRAME_FORMAT_YUV444        == IA_CSS_FRAME_FORMAT_YUV444);
+  OP___assert(FRAME_FORMAT_YUV_LINE      == IA_CSS_FRAME_FORMAT_YUV_LINE);
+  OP___assert(FRAME_FORMAT_RAW           == IA_CSS_FRAME_FORMAT_RAW);
+  OP___assert(FRAME_FORMAT_RGB565        == IA_CSS_FRAME_FORMAT_RGB565);
+  OP___assert(FRAME_FORMAT_PLANAR_RGB888 == IA_CSS_FRAME_FORMAT_PLANAR_RGB888);
+  OP___assert(FRAME_FORMAT_RGBA888       == IA_CSS_FRAME_FORMAT_RGBA888);
+  OP___assert(FRAME_FORMAT_QPLANE6       == IA_CSS_FRAME_FORMAT_QPLANE6);
+  OP___assert(FRAME_FORMAT_BINARY_8      == IA_CSS_FRAME_FORMAT_BINARY_8);
+  OP___assert(FRAME_FORMAT_MIPI          == IA_CSS_FRAME_FORMAT_MIPI);
+  return (uint32_t)fmt;
+}
+
+static inline enum ia_css_frame_format
+format_decode(uint32_t internal_fmt)
+{
+  OP___assert(FRAME_FORMAT_NV11          == IA_CSS_FRAME_FORMAT_NV11);
+  OP___assert(FRAME_FORMAT_NV12          == IA_CSS_FRAME_FORMAT_NV12);
+  OP___assert(FRAME_FORMAT_NV16          == IA_CSS_FRAME_FORMAT_NV16);
+  OP___assert(FRAME_FORMAT_NV21          == IA_CSS_FRAME_FORMAT_NV21);
+  OP___assert(FRAME_FORMAT_NV61          == IA_CSS_FRAME_FORMAT_NV61);
+  OP___assert(FRAME_FORMAT_YV12          == IA_CSS_FRAME_FORMAT_YV12);
+  OP___assert(FRAME_FORMAT_YV16          == IA_CSS_FRAME_FORMAT_YV16);
+  OP___assert(FRAME_FORMAT_YUV420        == IA_CSS_FRAME_FORMAT_YUV420);
+  OP___assert(FRAME_FORMAT_YUV420_16     == IA_CSS_FRAME_FORMAT_YUV420_16);
+  OP___assert(FRAME_FORMAT_YUV422        == IA_CSS_FRAME_FORMAT_YUV422);
+  OP___assert(FRAME_FORMAT_YUV422_16     == IA_CSS_FRAME_FORMAT_YUV422_16);
+  OP___assert(FRAME_FORMAT_UYVY          == IA_CSS_FRAME_FORMAT_UYVY);
+  OP___assert(FRAME_FORMAT_YUYV          == IA_CSS_FRAME_FORMAT_YUYV);
+  OP___assert(FRAME_FORMAT_YUV444        == IA_CSS_FRAME_FORMAT_YUV444);
+  OP___assert(FRAME_FORMAT_YUV_LINE      == IA_CSS_FRAME_FORMAT_YUV_LINE);
+  OP___assert(FRAME_FORMAT_RAW           == IA_CSS_FRAME_FORMAT_RAW);
+  OP___assert(FRAME_FORMAT_RGB565        == IA_CSS_FRAME_FORMAT_RGB565);
+  OP___assert(FRAME_FORMAT_PLANAR_RGB888 == IA_CSS_FRAME_FORMAT_PLANAR_RGB888);
+  OP___assert(FRAME_FORMAT_RGBA888       == IA_CSS_FRAME_FORMAT_RGBA888);
+  OP___assert(FRAME_FORMAT_QPLANE6       == IA_CSS_FRAME_FORMAT_QPLANE6);
+  OP___assert(FRAME_FORMAT_BINARY_8      == IA_CSS_FRAME_FORMAT_BINARY_8);
+  OP___assert(FRAME_FORMAT_MIPI          == IA_CSS_FRAME_FORMAT_MIPI);
+  return (enum ia_css_frame_format)internal_fmt;
+}
+#endif
+
+#endif /* _ISP_FORMATS_ISP_H */
diff --git a/drivers/media/atomisp2/css2400/isp/modes/interface/isp_globals.hive.h b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_globals.hive.h
new file mode 100644
index 0000000..7075a0f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_globals.hive.h
@@ -0,0 +1,281 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2013 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef _isp_globals_hive_h_
+#define _isp_globals_hive_h_
+
+#ifndef SYNC_WITH
+#define SYNC_WITH(x)
+#endif
+#ifndef MEM
+#define MEM(x)
+#endif
+#ifndef NO_SYNC
+#define NO_SYNC
+#endif
+#ifndef NO_HOIST
+#define NO_HOIST
+#endif
+
+#include "isp_types.h"
+#include <sh_css_internal.h>
+#if !defined(__HOST)
+#include "dma_proxy.common.h"
+#endif
+#include "input_buf.isp.h"
+
+#include "uds/uds_1.0/ia_css_uds_param.h" /* sh_css_sp_uds_params */
+
+/* Initialized by the SP: binary dependent */
+/* Some of these globals are used inside dma transfer/configure commands.
+   Therefore, their load will get a sync attribute. NO_SYNC prevents that.
+*/
+typedef struct s_isp_globals {
+  unsigned input_width_not_padded;
+  unsigned input_width;
+  unsigned input_height;
+  unsigned internal_width;
+  unsigned internal_height;
+  unsigned output_width;
+  unsigned output_height;
+  unsigned envelope_width;
+  unsigned envelope_height;
+  unsigned bits_per_pixel;
+  unsigned deinterleaved;
+  unsigned isp2ppc;
+  unsigned copy_vf;
+  unsigned copy_output;
+  enum sh_stream_format    input_stream_format;
+  enum ia_css_frame_format input_image_format;
+  enum ia_css_frame_format output_image_format;
+  enum ia_css_frame_format vf_image_format;
+
+  int dp_threshold_single;
+  int dp_threshold_2adjacent;
+
+  unsigned vf_crop_pos_x;  /* Cropping for ViewFinder image */
+  unsigned vf_crop_pos_y;  /* Cropping for ViewFinder image */
+
+  unsigned dma_crop_skip_words;
+  unsigned dma_crop_cropping_a;
+  unsigned dma_crop_block_width_a;
+  unsigned dma_crop_block_width_b;
+
+/* DMA settings for output image */
+  unsigned dma_output_skip_vecs;
+  unsigned dma_output_block_width_a;
+  unsigned dma_output_block_width_b;
+
+  unsigned dma_c_skip_vecs;
+  unsigned dma_c_block_width_a;
+  unsigned dma_c_block_width_b;
+} s_isp_globals;
+
+#ifdef __SP
+#define ISP_DMEM MEM(SP_XMEM)
+#define PVECTOR short MEM(SP_XMEM) *
+#else
+#define ISP_DMEM
+#define PVECTOR tmemvectoru MEM(VMEM) *
+#endif
+
+typedef void *pipeline_param_h;
+
+typedef struct s_isp_addresses {
+  struct {
+    struct sh_css_sp_uds_params     ISP_DMEM *uds_params;
+    unsigned                        ISP_DMEM *isp_deci_log_factor;
+    struct s_isp_frames             ISP_DMEM *isp_frames;
+    struct s_isp_globals            ISP_DMEM *isp_globals;
+    unsigned                        ISP_DMEM *isp_online;
+    struct s_output_dma_info        ISP_DMEM *output_dma_info;
+    unsigned                        ISP_DMEM *vertical_upsampled;
+    struct sh_css_ddr_address_map   ISP_DMEM *xmem_base;
+    struct ia_css_isp_3a_statistics ISP_DMEM *s3a_data;
+    sh_dma_cmd*                     ISP_DMEM *sh_dma_cmd_ptr;
+    unsigned                        ISP_DMEM *g_isp_do_zoom;
+    struct isp_uds_config           ISP_DMEM *uds_config;
+    int                             ISP_DMEM *g_sdis_horiproj_tbl;
+    int                             ISP_DMEM *g_sdis_vertproj_tbl;
+    unsigned                        ISP_DMEM *isp_enable_xnr;
+    struct s_isp_gdcac_config       ISP_DMEM *isp_gdcac_config;
+    unsigned                        ISP_DMEM *stripe_id;
+    unsigned                        ISP_DMEM *stripe_row_id;
+    unsigned                        ISP_DMEM *isp_continuous;
+    unsigned                        ISP_DMEM *required_bds_factor;
+    unsigned                        ISP_DMEM *isp_raw_stride_b;
+	unsigned			            ISP_DMEM *isp_raw_block_width_b;
+	unsigned			            ISP_DMEM *isp_raw_line_width_b;
+	unsigned			            ISP_DMEM *isp_raw_stripe_offset_b;
+  } dmem;
+  struct {
+    PVECTOR  input_buf;
+    PVECTOR  g_macc_coef;
+    PVECTOR  g_sdis_horicoef_tbl;
+    PVECTOR  g_sdis_vertcoef_tbl; /* Can be vmem or dmem */
+    PVECTOR  vf_tmp;
+    PVECTOR  uds_data_via_sp;
+    PVECTOR  uds_ipxs_via_sp;
+    PVECTOR  uds_ibuf_via_sp;
+    PVECTOR  uds_obuf_via_sp;
+    PVECTOR  aa_buf;
+    PVECTOR  raw_fir_buf;
+    PVECTOR  raw_fir1_buf;
+    PVECTOR  raw_fir2_buf;
+  } vmem;
+  struct {
+    unsigned uds_params;
+    unsigned g_sdis_horiproj_tbl;
+    unsigned g_sdis_vertproj_tbl;
+    unsigned vf_tmp;
+    unsigned aa_buf;
+    unsigned raw_fir_buf;
+    unsigned raw_fir1_buf;
+    unsigned raw_fir2_buf;
+  } sizes;
+} s_isp_addresses;
+
+extern s_isp_globals   NO_SYNC NO_HOIST isp_globals;
+extern s_isp_addresses NO_SYNC NO_HOIST isp_addresses;
+
+#ifdef __ISP
+#define isp_input_width            isp_globals.input_width
+#define isp_input_height           isp_globals.input_height
+#define isp_internal_width         isp_globals.internal_width
+#define isp_internal_height        isp_globals.internal_height
+#define isp_output_width           isp_globals.output_width
+#define isp_output_height          isp_globals.output_height
+#define isp_envelope_width         isp_globals.envelope_width
+#define isp_envelope_height        isp_globals.envelope_height
+#define isp_bits_per_pixel         isp_globals.bits_per_pixel
+#define isp_deinterleaved          isp_globals.deinterleaved
+#define isp_2ppc                   isp_globals.isp2ppc
+#define isp_copy_vf                isp_globals.copy_vf
+#define isp_copy_output            isp_globals.copy_output
+#define isp_vectors_per_line       iterator_config.vectors_per_line
+#define isp_vectors_per_input_line iterator_config.vectors_per_input_line
+#define isp_uv_internal_width_vecs iterator_config.uv_internal_width_vecs
+#define isp_input_stream_format    isp_globals.input_stream_format
+#define isp_output_image_format    isp_globals.output_image_format
+#define isp_vf_image_format        isp_globals.vf_image_format
+
+#define g_dp_threshold_single      isp_globals.dp_threshold_single
+#define g_dp_threshold_2adjacent   isp_globals.dp_threshold_2adjacent
+
+#define g_out_crop_pos_x           output_config.crop_pos_x
+#define g_out_crop_pos_y           output_config.crop_pos_y
+#define g_vf_crop_pos_x            isp_globals.vf_crop_pos_x
+#define g_vf_crop_pos_y            isp_globals.vf_crop_pos_y
+
+#define isp_vf_output_width_vecs   vf_config.output_width_vecs
+#define g_dma_vfout_skip_vecs      vf_config.dma_skip_vecs
+#define g_dma_vfout_cropping_a     vf_config.dma_cropping_a
+#define g_dma_vfout_block_width_a  vf_config.dma_block_width_a
+
+#define g_dma_crop_skip_words      isp_globals.dma_crop_skip_words
+#define g_dma_crop_cropping_a      isp_globals.dma_crop_cropping_a
+#define g_dma_crop_block_width_a   isp_globals.dma_crop_block_width_a
+#define g_dma_crop_block_width_b   isp_globals.dma_crop_block_width_b
+
+#define g_dma_output_skip_vecs     isp_globals.dma_output_skip_vecs
+#define g_dma_output_block_width_a isp_globals.dma_output_block_width_a
+#define g_dma_output_block_width_b isp_globals.dma_output_block_width_b
+#define g_dma_c_skip_vecs          isp_globals.dma_c_skip_vecs
+#define g_dma_c_block_width_a      isp_globals.dma_c_block_width_a
+#define g_dma_c_block_width_b      isp_globals.dma_c_block_width_b
+
+#if ENABLE_VF_VECEVEN
+#define isp_vf_downscale_bits      isp_dmem_configurations.vf.vf_downscale_bits
+#else
+#define isp_vf_downscale_bits      0
+#endif
+
+#endif /* __ISP */
+
+extern unsigned isp_deci_log_factor;
+extern unsigned isp_online;
+
+extern struct sh_css_ddr_address_map xmem_base;
+extern struct ia_css_isp_3a_statistics s3a_data;
+extern struct s_isp_frames isp_frames;
+extern struct isp_uds_config uds_config;
+
+/* *****************************************************************
+ * 		uds parameters
+ * *****************************************************************/
+extern NO_HOIST struct sh_css_sp_uds_params uds_params[SH_CSS_MAX_STAGES];
+
+/* DMA settings for viewfinder image */
+
+#define isp_do_zoom (ENABLE_DVS_ENVELOPE ? 1 : g_isp_do_zoom)
+extern unsigned g_isp_do_zoom;
+
+#if defined(__ISP)
+#if MODE != IA_CSS_BINARY_MODE_COPY
+
+typedef struct {
+  tmemvectoru raw[INPUT_BUF_HEIGHT][RAW_BUF_LINES][RAW_BUF_STRIDE]; /* 2 bayer lines */
+} raw_line_type;
+
+#if ENABLE_CONTINUOUS
+#define OUTPUT_BUF_LINES 4
+#else
+#define OUTPUT_BUF_LINES 2
+#endif
+
+typedef struct {
+  tmemvectoru raw[OUTPUT_BUF_HEIGHT][OUTPUT_BUF_LINES][MAX_VECTORS_PER_LINE]; /* 2 bayer lines */
+} output_line_type;
+
+extern input_line_type SYNC_WITH (INPUT_BUF) MEM (VMEM) input_buf;
+extern output_line_type SYNC_WITH (OUTPUT_BUF) MEM (VMEM) raw_output_buf;
+
+#endif /* MODE != IA_CSS_BINARY_MODE_COPY */
+#endif /* __ISP */
+
+/* DMA proxy buffer */
+#if !defined(__HOST)
+extern unsigned     NO_SYNC sh_dma_cmd_buffer_idx;
+extern unsigned     NO_SYNC sh_dma_cmd_buffer_cnt;
+extern unsigned     NO_SYNC sh_dma_cmd_buffer_need_ack;
+extern unsigned     NO_SYNC sh_dma_cmd_buffer_enabled;
+#if defined(__ISP) && defined(__HIVECC)
+extern sh_dma_cmd SYNC_WITH(DMA_PROXY_BUF) * NO_SYNC sh_dma_cmd_ptr;
+#else
+extern sh_dma_cmd *sh_dma_cmd_ptr;
+#endif
+#endif
+
+/* striped-ISP information */
+extern unsigned stripe_id;
+extern unsigned stripe_row_id;
+
+extern unsigned isp_continuous;
+extern unsigned required_bds_factor;
+extern unsigned isp_raw_stride_b;
+extern unsigned isp_raw_block_width_b;
+extern unsigned isp_raw_line_width_b;
+extern unsigned isp_raw_stripe_offset_b;
+
+#endif /* _isp_globals_hive_h_ */
diff --git a/drivers/media/atomisp2/css2400/isp/modes/interface/isp_types.h b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_types.h
new file mode 100644
index 0000000..ecd7f24
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/isp/modes/interface/isp_types.h
@@ -0,0 +1,138 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2013 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef _ISP_TYPES_H_
+#define _ISP_TYPES_H_
+
+/* Workaround: hivecc complains about "tag "sh_css_3a_output" already declared"
+   without this extra decl. */
+struct ia_css_3a_output;
+
+/* Binary independent types */
+//#include <ia_css_binary.h>
+#include "isp_const.h"
+
+//-------------------
+
+#if defined(__ISP) || defined(__SP)
+struct isp_uds_config {
+	int      hive_dx;
+	int      hive_dy;
+	unsigned hive_woix;
+	unsigned hive_bpp; /* gdc_bits_per_pixel */
+	unsigned hive_bci;
+};
+
+struct s_isp_gdcac_config {
+	unsigned nbx;
+	unsigned nby;
+};
+
+/* output.hive.c request information */
+typedef enum {
+  output_y_channel,
+  output_c_channel,
+  OUTPUT_NUM_CHANNELS
+} output_channel_type;
+
+typedef struct s_output_dma_info {
+  unsigned            cond;		/* Condition for transfer */
+  output_channel_type channel_type;
+  dma_channel         channel;
+  unsigned            width_a;
+  unsigned            width_b;
+  unsigned            stride;
+  unsigned            v_delta;	        /* Offset for v address to do cropping */
+  char               *x_base;           /* X base address */
+} output_dma_info_type;
+#endif
+
+/* Input stream formats, these correspond to the MIPI formats and the way
+ * the CSS receiver sends these to the input formatter.
+ * The bit depth of each pixel element is stored in the global variable
+ * isp_bits_per_pixel.
+ * NOTE: for rgb565, we set isp_bits_per_pixel to 565, for all other rgb
+ * formats it's the actual depth (4, for 444, 8 for 888 etc).
+ */
+enum sh_stream_format {
+	sh_stream_format_yuv420_legacy,
+	sh_stream_format_yuv420,
+	sh_stream_format_yuv422,
+	sh_stream_format_rgb,
+	sh_stream_format_raw,
+	sh_stream_format_binary,	/* bytestream such as jpeg */
+};
+
+struct s_isp_frames {
+	/* global variables that are written to by either the SP or the host,
+	   every ISP binary needs these. */
+	/* output frame */
+	char *xmem_base_addr_y;
+	char *xmem_base_addr_uv;
+	char *xmem_base_addr_u;
+	char *xmem_base_addr_v;
+	/* 2nd output frame */
+	char *xmem_base_addr_second_out_y;
+	char *xmem_base_addr_second_out_u;
+	char *xmem_base_addr_second_out_v;
+	/* input yuv frame */
+	char *xmem_base_addr_y_in;
+	char *xmem_base_addr_u_in;
+	char *xmem_base_addr_v_in;
+	/* input raw frame */
+	char *xmem_base_addr_raw;
+	/* output raw frame */
+	char *xmem_base_addr_raw_out;
+	/* reference input frame */
+	char *xmem_base_addr_ref_in_y;
+	char *xmem_base_addr_ref_in_uv;
+	/* reference output frame */
+	char *xmem_base_addr_ref_out_y;
+	char *xmem_base_addr_ref_out_uv;
+	/* tnr input frame */
+	char *xmem_base_addr_tnr_in;
+	/* tnr output frame */
+	char *xmem_base_addr_tnr_out;
+	/* viewfinder output (vf_veceven) */
+	char *xmem_base_addr_vfout_y;
+	char *xmem_base_addr_vfout_u;
+	char *xmem_base_addr_vfout_v;
+	/* overlay frame (for vf_pp) */
+	char *xmem_base_addr_overlay_y;
+	char *xmem_base_addr_overlay_u;
+	char *xmem_base_addr_overlay_v;
+	/* pre-gdc output frame (gdc input) */
+	char *xmem_base_addr_qplane_r;
+	char *xmem_base_addr_qplane_ratb;
+	char *xmem_base_addr_qplane_gr;
+	char *xmem_base_addr_qplane_gb;
+	char *xmem_base_addr_qplane_b;
+	char *xmem_base_addr_qplane_batr;
+	/* YUV as input, used by postisp binary */
+	char *xmem_base_addr_yuv_16_y;
+	char *xmem_base_addr_yuv_16_u;
+	char *xmem_base_addr_yuv_16_v;
+};
+
+#endif /* _ISP_TYPES_H_ */
diff --git a/drivers/media/atomisp2/css2400/runtime/binary/interface/ia_css_binary.h b/drivers/media/atomisp2/css2400/runtime/binary/interface/ia_css_binary.h
new file mode 100644
index 0000000..eb91019
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/binary/interface/ia_css_binary.h
@@ -0,0 +1,238 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_BINARY_H_
+#define _IA_CSS_BINARY_H_
+
+/* The binary mode is used in pre-processor expressions so we cannot
+ * use an enum here. */
+#define IA_CSS_BINARY_MODE_COPY       0
+#define IA_CSS_BINARY_MODE_PREVIEW    1
+#define IA_CSS_BINARY_MODE_PRIMARY    2
+#define IA_CSS_BINARY_MODE_VIDEO      3
+#define IA_CSS_BINARY_MODE_PRE_ISP    4
+#define IA_CSS_BINARY_MODE_GDC        5
+#define IA_CSS_BINARY_MODE_POST_ISP   6
+#define IA_CSS_BINARY_MODE_ANR        7
+#define IA_CSS_BINARY_MODE_CAPTURE_PP 8
+#define IA_CSS_BINARY_MODE_VF_PP      9
+#define IA_CSS_BINARY_MODE_PRE_DE     10
+#define IA_CSS_BINARY_NUM_MODES       11
+
+/* Indicate where binaries can read input from */
+#define IA_CSS_BINARY_INPUT_SENSOR   0
+#define IA_CSS_BINARY_INPUT_MEMORY   1
+#define IA_CSS_BINARY_INPUT_VARIABLE 2
+
+/* now these ports only include output ports but not vf output ports */
+#define IA_CSS_BINARY_OUTPUT_PORT_0 	0
+#define IA_CSS_BINARY_OUTPUT_PORT_1 	1
+#define IA_CSS_BINARY_MAX_OUTPUT_PORTS 	2
+
+#include "ia_css.h"
+#include "sh_css_metrics.h"
+#include "isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h"
+
+/* Should be included without the path.
+   However, that requires adding the path to numerous makefiles
+   that have nothing to do with isp parameters.
+ */
+#include "runtime/isp_param/interface/ia_css_isp_param_types.h"
+
+struct ia_css_cas_binary_descr {
+	unsigned int num_stage;
+	unsigned int num_output_stage;
+	struct ia_css_frame_info *in_info;
+	struct ia_css_frame_info *internal_out_info;
+	struct ia_css_frame_info *out_info;
+	struct ia_css_frame_info *vf_info;
+	bool *is_output_stage;
+};
+
+#define IA_CSS_DEFAULT_CAS_BINARY_DESCR \
+{ \
+	0,		\
+	0,		\
+	NULL,		\
+	NULL,		\
+	NULL,		\
+	NULL,		\
+	NULL,		\
+}
+
+struct ia_css_binary_descr {
+	int mode;
+	bool online;
+	bool continuous;
+	bool two_ppc;
+	bool enable_yuv_ds;
+	bool enable_high_speed;
+	bool enable_dvs_6axis;
+	bool enable_reduced_pipe;
+	bool enable_dz;
+	bool enable_xnr;
+	bool enable_fractional_ds;
+	struct ia_css_resolution dvs_env;
+	enum ia_css_stream_format stream_format;
+	struct ia_css_frame_info *in_info;
+	struct ia_css_frame_info *bds_out_info;
+	struct ia_css_frame_info *out_info[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_frame_info *vf_info;
+	unsigned int isp_pipe_version;
+	unsigned int required_bds_factor;
+	int stream_config_left_padding;
+};
+
+struct ia_css_binary {
+	const struct ia_css_binary_xinfo *info;
+	enum ia_css_stream_format input_format;
+	struct ia_css_frame_info in_frame_info;
+	struct ia_css_frame_info internal_frame_info;
+	struct ia_css_frame_info out_frame_info[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_resolution effective_in_frame_res;
+	struct ia_css_frame_info vf_frame_info;
+	int                      input_buf_vectors;
+	int                      deci_factor_log2;
+	int                      dis_deci_factor_log2;
+	int                      vf_downscale_log2;
+	int                      s3atbl_width;
+	int                      s3atbl_height;
+	int                      s3atbl_isp_width;
+	int                      s3atbl_isp_height;
+	unsigned int             morph_tbl_width;
+	unsigned int             morph_tbl_aligned_width;
+	unsigned int             morph_tbl_height;
+	int                      sctbl_width_per_color;
+	int                      sctbl_aligned_width_per_color;
+	int                      sctbl_height;
+	int                      dis_hor_grid_num_3a;
+	int                      dis_ver_grid_num_3a;
+	int                      dis_hor_grid_num_isp;
+	int                      dis_ver_grid_num_isp;
+	int                      dis_hor_coef_num_3a;
+	int                      dis_ver_coef_num_3a;
+	int                      dis_hor_coef_num_isp;
+	int                      dis_ver_coef_num_isp;
+	int                      dis_hor_proj_num_3a;
+	int                      dis_ver_proj_num_3a;
+	int                      dis_hor_proj_num_isp;
+	int                      dis_ver_proj_num_isp;
+	struct ia_css_resolution dvs_envelope;
+	bool                     online;
+	unsigned int             uds_xc;
+	unsigned int             uds_yc;
+	unsigned int             left_padding;
+	struct sh_css_binary_metrics metrics;
+	struct ia_css_isp_param_host_segments mem_params;
+	struct ia_css_isp_param_css_segments  css_params;
+};
+
+
+struct persistent_binary_info{
+    ia_css_ptr *backup_addr;
+    short num_binary;
+};
+
+
+#define IA_CSS_BINARY_DEFAULT_SETTINGS \
+{ \
+	NULL, \
+	IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY, \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
+	{IA_CSS_BINARY_DEFAULT_FRAME_INFO}, \
+	{ 0,0 },/* effective_in_frame_res */ \
+	IA_CSS_BINARY_DEFAULT_FRAME_INFO, \
+	0,	/* input_buf_vectors */ \
+	0,	/* deci_factor_log2 */ \
+	0,	/* dis_deci_factor_log2 */ \
+	0,	/* vf_downscale_log2 */ \
+	0,	/* s3atbl_width */ \
+	0,	/* s3atbl_height */ \
+	0,	/* s3atbl_isp_width */ \
+	0,	/* s3atbl_isp_height */ \
+	0,	/* morph_tbl_width */ \
+	0,	/* morph_tbl_aligned_width */ \
+	0,	/* morph_tbl_height */ \
+	0,	/* sctbl_width_per_color */ \
+	0,	/* sctbl_aligned_width_per_color */ \
+	0,	/* sctbl_height */ \
+	0,	/* dis_hor_grid_num_3a */ \
+	0,	/* dis_ver_grid_num_3a */ \
+	0,	/* dis_hor_grid_num_isp */ \
+	0,	/* dis_ver_grid_num_isp */ \
+	0,	/* dis_hor_coef_num_3a */ \
+	0,	/* dis_ver_coef_num_3a */ \
+	0,	/* dis_hor_coef_num_isp */ \
+	0,	/* dis_ver_coef_num_isp */ \
+	0,	/* dis_hor_proj_num_3a */ \
+	0,	/* dis_ver_proj_num_3a */ \
+	0,	/* dis_hor_proj_num_isp */ \
+	0,	/* dis_ver_proj_num_isp */ \
+	{ 0, 0 },/* dvs_envelope_info */ \
+	false,	/* online */ \
+	0,	/* uds_xc */ \
+	0,	/* uds_yc */ \
+	0,	/* left_padding */ \
+	DEFAULT_BINARY_METRICS,	/* metrics */ \
+	IA_CSS_DEFAULT_ISP_MEM_PARAMS, /* mem_params */ \
+	IA_CSS_DEFAULT_ISP_CSS_PARAMS, /* css_params */ \
+}
+
+enum ia_css_err
+ia_css_binary_init_infos(void);
+
+enum ia_css_err
+ia_css_binary_uninit(bool forced);
+
+enum ia_css_err
+ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
+		 bool online,
+		 bool two_ppc,
+		 enum ia_css_stream_format stream_format,
+		 const struct ia_css_frame_info *in_info,
+		 const struct ia_css_frame_info *bds_out_info,
+		 const struct ia_css_frame_info *out_info[],
+		 const struct ia_css_frame_info *vf_info,
+		 struct ia_css_binary *binary,
+		 struct ia_css_resolution *dvs_env,
+		 int stream_config_left_padding,
+		 bool accelerator);
+
+enum ia_css_err
+ia_css_binary_find(struct ia_css_binary_descr *descr,
+		   struct ia_css_binary *binary);
+
+void
+ia_css_binary_grid_info(const struct ia_css_binary *binary,
+			struct ia_css_grid_info *info);
+
+unsigned
+ia_css_binary_max_vf_width(void);
+
+void
+ia_css_binary_destroy_isp_parameters(struct ia_css_binary *binary);
+
+void
+ia_css_binary_get_isp_binaries(struct ia_css_binary_xinfo **binaries,
+	uint32_t *num_isp_binaries);
+
+#endif /* _IA_CSS_BINARY_H_ */
diff --git a/drivers/media/atomisp2/css2400/runtime/binary/src/binary.c b/drivers/media/atomisp2/css2400/runtime/binary/src/binary.c
new file mode 100644
index 0000000..75ad46a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/binary/src/binary.c
@@ -0,0 +1,1023 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <gdc_device.h>	/* HR_GDC_N */
+
+#include <linux/slab.h>
+
+#include "ia_css_binary.h"
+#include "ia_css.h"
+#include "ia_css_debug.h"
+#include "ia_css_util.h"
+#include "ia_css_isp_param.h"
+#include "sh_css_internal.h"
+#include "sh_css_sp.h"
+#include "sh_css_firmware.h"
+#include "sh_css_defs.h"
+#include "sh_css_legacy.h"
+#include "vf/vf_1.0/ia_css_vf.host.h"
+
+#include "memory_access.h"
+
+#include "assert_support.h"
+
+static struct persistent_binary_info backup={NULL,0};
+static struct ia_css_binary_xinfo *all_binaries; /* ISP binaries only (no SP) */
+static struct ia_css_binary_xinfo
+	*binary_infos[IA_CSS_BINARY_NUM_MODES] = { NULL, };
+
+static void
+ia_css_binary_dvs_env(const struct ia_css_binary_info *info,
+                      const struct ia_css_resolution *dvs_env,
+                      struct ia_css_resolution *binary_dvs_env)
+{
+	if (info->enable.dvs_envelope) {
+		assert(dvs_env != NULL);
+		binary_dvs_env->width  = max(dvs_env->width, SH_CSS_MIN_DVS_ENVELOPE);
+		binary_dvs_env->height = max(dvs_env->height, SH_CSS_MIN_DVS_ENVELOPE);
+	}
+}
+
+static void
+ia_css_binary_internal_res(const struct ia_css_frame_info *in_info,
+                           const struct ia_css_frame_info *bds_out_info,
+                           const struct ia_css_frame_info *out_info,
+                           const struct ia_css_resolution *dvs_env,
+                           const struct ia_css_binary_info *info,
+                           struct ia_css_resolution *internal_res)
+{
+	unsigned int isp_tmp_internal_width = 0,
+		     isp_tmp_internal_height = 0;
+	bool binary_supports_yuv_ds = info->enable.ds & 2;
+	struct ia_css_resolution binary_dvs_env;
+
+	binary_dvs_env.width = 0;
+	binary_dvs_env.height = 0;
+	ia_css_binary_dvs_env(info, dvs_env, &binary_dvs_env);
+
+	if (binary_supports_yuv_ds) {
+		if (in_info != NULL) {
+			isp_tmp_internal_width = in_info->res.width
+				+ info->left_cropping + binary_dvs_env.width;
+			isp_tmp_internal_height = in_info->res.height
+				+ info->top_cropping + binary_dvs_env.height;
+		}
+	} else if ((bds_out_info != NULL) && (out_info != NULL) &&
+				/* TODO: hack to make video_us case work. this should be reverted after
+				a nice solution in ISP */
+				(bds_out_info->res.width >= out_info->res.width)) {
+			isp_tmp_internal_width = bds_out_info->padded_width;
+			isp_tmp_internal_height = bds_out_info->res.height;
+	} else {
+		if (out_info != NULL) {
+			isp_tmp_internal_width = out_info->padded_width;
+			isp_tmp_internal_height = out_info->res.height;
+		}
+	}
+
+	/* We first calculate the resolutions used by the ISP. After that,
+	 * we use those resolutions to compute sizes for tables etc. */
+	internal_res->width = __ISP_INTERNAL_WIDTH(isp_tmp_internal_width,
+		(int)binary_dvs_env.width,
+		info->left_cropping, info->mode,
+		info->c_subsampling,
+		info->output_num_chunks, info->pipelining);
+	internal_res->height = __ISP_INTERNAL_HEIGHT(isp_tmp_internal_height,
+		info->top_cropping,
+		binary_dvs_env.height);
+}
+
+void
+ia_css_binary_grid_info(const struct ia_css_binary *binary,
+			struct ia_css_grid_info *info)
+{
+	struct ia_css_3a_grid_info *s3a_info;
+	struct ia_css_dvs_grid_info *dvs_info;
+
+	assert(binary != NULL);
+	assert(info != NULL);
+	s3a_info = &info->s3a_grid;
+	dvs_info = &info->dvs_grid;
+
+	info->isp_in_width = binary->internal_frame_info.res.width;
+	info->isp_in_height = binary->internal_frame_info.res.height;
+
+	/* for DIS, we use a division instead of a ceil_div. If this is smaller
+	 * than the 3a grid size, it indicates that the outer values are not
+	 * valid for DIS.
+	 */
+	dvs_info->enable            = binary->info->sp.enable.dis;
+	dvs_info->width             = binary->dis_hor_grid_num_3a;
+	dvs_info->height            = binary->dis_ver_grid_num_3a;
+	dvs_info->aligned_width     = binary->dis_hor_grid_num_isp;
+	dvs_info->aligned_height    = binary->dis_ver_grid_num_isp;
+	dvs_info->bqs_per_grid_cell = 1 << binary->dis_deci_factor_log2;
+	dvs_info->num_hor_coefs     = binary->dis_hor_coef_num_3a;
+	dvs_info->num_ver_coefs     = binary->dis_ver_coef_num_3a;
+
+#if !(defined(SYSTEM_css_skycam_a0t_system) || defined(SYSTEM_css_skycam_c0_system))
+	/* 3A statistics grid */
+	s3a_info->enable            = binary->info->sp.enable.s3a;
+	s3a_info->width             = binary->s3atbl_width;
+	s3a_info->height            = binary->s3atbl_height;
+	s3a_info->aligned_width     = binary->s3atbl_isp_width;
+	s3a_info->aligned_height    = binary->s3atbl_isp_height;
+	s3a_info->bqs_per_grid_cell = (1 << binary->deci_factor_log2);
+	s3a_info->deci_factor_log2  = binary->deci_factor_log2;
+	s3a_info->elem_bit_depth    = SH_CSS_BAYER_BITS;
+	s3a_info->use_dmem          = binary->info->sp.s3atbl_use_dmem;
+#if defined(HAS_NO_HMEM)
+	s3a_info->has_histogram     = 1;
+#else
+	s3a_info->has_histogram     = 0;
+#endif
+#else	//SYSTEM_css_skycam_a0t_system defined
+	s3a_info->ae_enable         = binary->info->sp.enable.ae;
+	s3a_info->af_enable         = binary->info->sp.enable.af;
+	s3a_info->awb_fr_enable     = binary->info->sp.enable.awb_fr_acc;
+	s3a_info->awb_enable        = binary->info->sp.enable.awb_acc;
+	s3a_info->elem_bit_depth    = SH_CSS_BAYER_BITS;
+	//todo grid config
+#endif
+#if defined(HAS_VAMEM_VERSION_2)
+	info->vamem_type = IA_CSS_VAMEM_TYPE_2;
+#elif defined(HAS_VAMEM_VERSION_1)
+	info->vamem_type = IA_CSS_VAMEM_TYPE_1;
+#else
+#error "Unknown VAMEM version"
+#endif
+}
+
+static void
+binary_init_pc_histogram(struct sh_css_pc_histogram *histo)
+{
+	assert(histo != NULL);
+
+	histo->length = 0;
+	histo->run = NULL;
+	histo->stall = NULL;
+}
+
+static void
+binary_init_metrics(struct sh_css_binary_metrics *metrics,
+	     const struct ia_css_binary_info *info)
+{
+	assert(metrics != NULL);
+	assert(info != NULL);
+
+	metrics->mode = info->mode;
+	metrics->id   = info->id;
+	metrics->next = NULL;
+	binary_init_pc_histogram(&metrics->isp_histogram);
+	binary_init_pc_histogram(&metrics->sp_histogram);
+}
+
+/* move to host part of output module */
+static bool
+binary_supports_output_format(const struct ia_css_binary_xinfo *info,
+		       enum ia_css_frame_format format)
+{
+	int i;
+
+	assert(info != NULL);
+
+	for (i = 0; i < info->num_output_formats; i++) {
+		if (info->output_formats[i] == format)
+			return true;
+	}
+	return false;
+}
+
+/* move to host part of bds module */
+static bool
+supports_bds_factor(uint32_t supported_factors,
+		       uint32_t bds_factor)
+{
+  return ((supported_factors & PACK_BDS_FACTOR(bds_factor)) != 0);
+}
+
+static enum ia_css_err
+binary_init_info(struct ia_css_binary_xinfo *info, unsigned int i,
+		 bool *binary_found, bool use_backup)
+{
+	const unsigned char *blob = sh_css_blob_info[i].blob;
+	unsigned size = sh_css_blob_info[i].header.blob.size;
+
+	assert(info != NULL);
+	assert(binary_found != NULL);
+
+	*info = sh_css_blob_info[i].header.info.isp;
+	*binary_found = blob != NULL;
+	info->blob_index = i;
+	/* we don't have this binary, skip it */
+	if (!size)
+		return IA_CSS_SUCCESS;
+
+        if (use_backup == true) info->xmem_addr = backup.backup_addr[i];    /*Map to backed up binaries*/
+        else  {                                             /*load binaries and store backup*/
+      		info->xmem_addr = sh_css_load_blob(blob, size);
+        	backup.backup_addr[i] = info->xmem_addr;
+        }
+
+	if (!info->xmem_addr)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	return IA_CSS_SUCCESS;
+}
+
+/* When binaries are put at the beginning, they will only
+ * be selected if no other primary matches.
+ */
+enum ia_css_err
+ia_css_binary_init_infos(void)
+{
+	unsigned int i;
+	unsigned int num_of_isp_binaries = sh_css_num_binaries - NUM_OF_SPS;
+	bool use_backup = true;
+
+	all_binaries = sh_css_malloc(num_of_isp_binaries *
+						sizeof(*all_binaries));
+	if (all_binaries == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+        if (backup.backup_addr == NULL) {
+  		backup.backup_addr = kzalloc(num_of_isp_binaries * sizeof(ia_css_ptr), GFP_KERNEL);
+       		backup.num_binary = num_of_isp_binaries;
+                use_backup = false;
+       }
+
+	for (i = 0; i < num_of_isp_binaries; i++) {
+		enum ia_css_err ret;
+		struct ia_css_binary_xinfo *binary = &all_binaries[i];
+		bool binary_found;
+
+		ret = binary_init_info(binary, i, &binary_found, use_backup);
+		if (ret != IA_CSS_SUCCESS)
+			return ret;
+		if (!binary_found)
+			continue;
+		/* Prepend new binary information */
+		binary->next = binary_infos[binary->sp.mode];
+		binary_infos[binary->sp.mode] = binary;
+		binary->blob = &sh_css_blob_info[i];
+		binary->mem_offsets = sh_css_blob_info[i].mem_offsets;
+	}
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_binary_uninit(bool forced)
+{
+	unsigned int i;
+
+        /*Flush backup*/
+	if (forced == true) {
+        	if (backup.backup_addr != NULL) {
+        	        for(i=0;i<backup.num_binary;i++){
+                	        mmgr_free(backup.backup_addr[i]);
+                        }
+            		kfree (backup.backup_addr);
+            		backup.backup_addr = NULL;
+         	}
+        }
+
+        for (i = 0; i < IA_CSS_BINARY_NUM_MODES; i++)
+               binary_infos[i] = NULL;
+
+        if (all_binaries != NULL) {
+		sh_css_free(all_binaries);
+                all_binaries = NULL;
+	}
+
+	return IA_CSS_SUCCESS;
+}
+
+static int
+binary_grid_deci_factor_log2(int width, int height)
+{
+	int fact, fact1;
+	fact = 5;
+	while (ISP_BQ_GRID_WIDTH(width, fact - 1) <= SH_CSS_MAX_BQ_GRID_WIDTH &&
+	       ISP_BQ_GRID_HEIGHT(height, fact - 1) <= SH_CSS_MAX_BQ_GRID_HEIGHT
+	       && fact > 3)
+		fact--;
+
+	/* fact1 satisfies the specification of grid size. fact and fact1 is
+	   not the same for some resolution (fact=4 and fact1=5 for 5mp). */
+	if (width >= 2560)
+		fact1 = 5;
+	else if (width >= 1280)
+		fact1 = 4;
+	else
+		fact1 = 3;
+	return max(fact, fact1);
+}
+
+static int
+binary_in_frame_padded_width(int in_frame_width,
+							int isp_internal_width,
+							int dvs_env_width,
+							int stream_config_left_padding,
+							int left_cropping,
+							bool need_scaling)
+{
+	int rval;
+	int nr_of_left_paddings;	/* number of paddings pixels on the left of an image line */
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* the output image line of Input System 2401 does not have the left paddings  */
+	nr_of_left_paddings = 0;
+#else
+	/* in other cases, the left padding pixels are always 128 */
+	nr_of_left_paddings = 2*ISP_VEC_NELEMS;
+#endif
+
+	if (need_scaling) {
+		/* In SDV use-case, we need to match left-padding of
+		 * primary and the video binary. */
+		if (stream_config_left_padding != -1) {
+			/* Different than before, we do left&right padding. */
+			rval =
+				CEIL_MUL(in_frame_width + nr_of_left_paddings,
+					2*ISP_VEC_NELEMS);
+		} else {
+			/* Different than before, we do left&right padding. */
+			rval =
+				CEIL_MUL(in_frame_width + dvs_env_width +
+					(left_cropping ? nr_of_left_paddings : 0),
+					2*ISP_VEC_NELEMS);
+		}
+	} else {
+		rval = isp_internal_width;
+	}
+
+	return rval;
+}
+
+
+enum ia_css_err
+ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
+		 bool online,
+		 bool two_ppc,
+		 enum ia_css_stream_format stream_format,
+		 const struct ia_css_frame_info *in_info, /* can be NULL */
+		 const struct ia_css_frame_info *bds_out_info, /* can be NULL */
+		 const struct ia_css_frame_info *out_info[], /* can be NULL */
+		 const struct ia_css_frame_info *vf_info, /* can be NULL */
+		 struct ia_css_binary *binary,
+		 struct ia_css_resolution *dvs_env,
+		 int stream_config_left_padding,
+		 bool accelerator)
+{
+	const struct ia_css_binary_info *info = &xinfo->sp;
+	unsigned int dvs_env_width = 0,
+		     dvs_env_height = 0,
+		     vf_log_ds = 0,
+		     s3a_log_deci = 0,
+		     bits_per_pixel = 0,
+		     /* Resolution at SC/3A/DIS kernel. */
+		     sc_3a_dis_width = 0,
+		     /* Resolution at SC/3A/DIS kernel. */
+		     sc_3a_dis_padded_width = 0,
+		     /* Resolution at SC/3A/DIS kernel. */
+		     sc_3a_dis_height = 0,
+		     isp_internal_width = 0,
+		     isp_internal_height = 0,
+		     s3a_isp_width = 0;
+
+	bool need_scaling = false;
+	struct ia_css_resolution binary_dvs_env, internal_res;
+	enum ia_css_err err;
+	unsigned int i;
+	const struct ia_css_frame_info *bin_out_info = NULL;
+
+	assert(info != NULL);
+	assert(binary != NULL);
+
+	binary->info = xinfo;
+	if (!accelerator) {
+		/* binary->css_params has been filled by accelerator itself. */
+		ia_css_isp_param_allocate_isp_parameters(
+			&binary->mem_params, &binary->css_params,
+			&info->mem_initializers);
+	}
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		if (out_info[i] && (out_info[i]->res.width != 0)) {
+			bin_out_info = out_info[i];
+			break;
+		}
+	}
+	if (in_info != NULL && bin_out_info != NULL) {
+		need_scaling = (in_info->res.width != bin_out_info->res.width) ||
+			(in_info->res.height != bin_out_info->res.height);
+	}
+
+
+	/* binary_dvs_env has to be equal or larger than SH_CSS_MIN_DVS_ENVELOPE */
+	binary_dvs_env.width = 0;
+	binary_dvs_env.height = 0;
+	ia_css_binary_dvs_env(info, dvs_env, &binary_dvs_env);
+	dvs_env_width = binary_dvs_env.width;
+	dvs_env_height = binary_dvs_env.height;
+	binary->dvs_envelope.width  = dvs_env_width;
+	binary->dvs_envelope.height = dvs_env_height;
+
+	/* internal resolution calculation */
+	internal_res.width = 0;
+	internal_res.height = 0;
+	ia_css_binary_internal_res(in_info, bds_out_info, bin_out_info, dvs_env,
+			 	   info, &internal_res);
+	isp_internal_width = internal_res.width;
+	isp_internal_height = internal_res.height;
+
+	/* internal frame info */
+	if (bin_out_info != NULL) /* { */
+		binary->internal_frame_info.format = bin_out_info->format;
+	/* } */
+	binary->internal_frame_info.res.width       = isp_internal_width;
+	binary->internal_frame_info.padded_width    = isp_internal_width;
+	binary->internal_frame_info.res.height      = isp_internal_height;
+	binary->internal_frame_info.raw_bit_depth   = bits_per_pixel;
+
+
+	if (in_info != NULL) {
+		binary->effective_in_frame_res.width = in_info->res.width;
+		binary->effective_in_frame_res.height = in_info->res.height;
+
+		bits_per_pixel = in_info->raw_bit_depth;
+
+		/* input info */
+		binary->in_frame_info.res.width = in_info->res.width
+			+ info->left_cropping + dvs_env_width;
+		binary->in_frame_info.res.height = in_info->res.height
+			+ info->top_cropping + dvs_env_height;
+
+		binary->in_frame_info.padded_width =
+			binary_in_frame_padded_width(in_info->res.width,
+										isp_internal_width,
+										dvs_env_width,
+										stream_config_left_padding,
+										info->left_cropping,
+										need_scaling);
+
+		binary->in_frame_info.format = in_info->format;
+	}
+
+	if (online) {
+		bits_per_pixel = ia_css_util_input_format_bpp(
+			stream_format, two_ppc);
+	}
+	binary->in_frame_info.raw_bit_depth = bits_per_pixel;
+
+
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		if (out_info[i] != NULL) {
+			binary->out_frame_info[i].res.width     = out_info[i]->res.width;
+			binary->out_frame_info[i].res.height    = out_info[i]->res.height;
+			binary->out_frame_info[i].padded_width  = out_info[i]->padded_width;
+			binary->out_frame_info[i].raw_bit_depth = bits_per_pixel;
+			binary->out_frame_info[i].format        = out_info[i]->format;
+		}
+	}
+
+#ifndef IS_ISP_2500_SYSTEM
+	if (vf_info && (vf_info->res.width != 0)) {
+		err = ia_css_vf_configure(binary, bin_out_info, (struct ia_css_frame_info *)vf_info, &vf_log_ds);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+#else
+	(void)err;
+#endif
+	binary->vf_downscale_log2 = vf_log_ds;
+
+	binary->online            = online;
+	binary->input_format      = stream_format;
+
+	/* viewfinder output info */
+	if ((vf_info != NULL) && (vf_info->res.width != 0)) {
+		unsigned int vf_out_vecs, vf_out_width, vf_out_height;
+
+		binary->vf_frame_info.format = IA_CSS_FRAME_FORMAT_YUV_LINE;
+		if (bin_out_info == NULL)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		vf_out_vecs = __ISP_VF_OUTPUT_WIDTH_VECS(bin_out_info->padded_width,
+			vf_log_ds);
+		vf_out_width = _ISP_VF_OUTPUT_WIDTH(vf_out_vecs);
+		vf_out_height = _ISP_VF_OUTPUT_HEIGHT(bin_out_info->res.height,
+			vf_log_ds);
+
+		/* For preview mode, output pin is used instead of vf. */
+		if (info->mode == IA_CSS_BINARY_MODE_PREVIEW) {
+			binary->out_frame_info[0].res.width =
+				(bin_out_info->res.width >> vf_log_ds);
+			binary->out_frame_info[0].padded_width = vf_out_width;
+			binary->out_frame_info[0].res.height   = vf_out_height;
+
+			binary->vf_frame_info.res.width    = 0;
+			binary->vf_frame_info.padded_width = 0;
+			binary->vf_frame_info.res.height   = 0;
+		} else {
+			/* we also store the raw downscaled width. This is
+			 * used for digital zoom in preview to zoom only on
+			 * the width that we actually want to keep, not on
+			 * the aligned width. */
+			binary->vf_frame_info.res.width =
+				(bin_out_info->res.width >> vf_log_ds);
+			binary->vf_frame_info.padded_width = vf_out_width;
+			binary->vf_frame_info.res.height   = vf_out_height;
+		}
+	} else {
+		binary->vf_frame_info.res.width    = 0;
+		binary->vf_frame_info.padded_width = 0;
+		binary->vf_frame_info.res.height   = 0;
+	}
+
+	if (info->enable.ca_gdc) {
+		binary->morph_tbl_width =
+			_ISP_MORPH_TABLE_WIDTH(isp_internal_width);
+		binary->morph_tbl_aligned_width  =
+			_ISP_MORPH_TABLE_ALIGNED_WIDTH(isp_internal_width);
+		binary->morph_tbl_height =
+			_ISP_MORPH_TABLE_HEIGHT(isp_internal_height);
+	} else {
+		binary->morph_tbl_width  = 0;
+		binary->morph_tbl_aligned_width  = 0;
+		binary->morph_tbl_height = 0;
+	}
+
+	sc_3a_dis_width = binary->in_frame_info.res.width;
+	sc_3a_dis_padded_width = binary->in_frame_info.padded_width;
+	sc_3a_dis_height = binary->in_frame_info.res.height;
+	if (bds_out_info != NULL && in_info != NULL &&
+			bds_out_info->res.width != in_info->res.width) {
+		/* TODO: Next, "internal_frame_info" should be derived from
+		 * bds_out. So this part will change once it is in place! */
+		sc_3a_dis_width = bds_out_info->res.width + info->left_cropping;
+		sc_3a_dis_padded_width = isp_internal_width;
+		sc_3a_dis_height = isp_internal_height;
+	}
+
+
+	s3a_isp_width = _ISP_S3A_ELEMS_ISP_WIDTH(sc_3a_dis_padded_width,
+		info->left_cropping);
+	if (info->fixed_s3a_deci_log) {
+		s3a_log_deci = info->fixed_s3a_deci_log;
+	} else {
+		s3a_log_deci = binary_grid_deci_factor_log2(s3a_isp_width,
+							    sc_3a_dis_height);
+	}
+	binary->deci_factor_log2  = s3a_log_deci;
+
+	if (info->enable.s3a) {
+		binary->s3atbl_width  =
+			_ISP_S3ATBL_WIDTH(sc_3a_dis_width,
+				s3a_log_deci);
+		binary->s3atbl_height =
+			_ISP_S3ATBL_HEIGHT(sc_3a_dis_height,
+				s3a_log_deci);
+		binary->s3atbl_isp_width =
+			_ISP_S3ATBL_ISP_WIDTH(s3a_isp_width,
+					s3a_log_deci);
+		binary->s3atbl_isp_height =
+			_ISP_S3ATBL_ISP_HEIGHT(sc_3a_dis_height,
+				s3a_log_deci);
+	} else {
+		binary->s3atbl_width  = 0;
+		binary->s3atbl_height = 0;
+		binary->s3atbl_isp_width  = 0;
+		binary->s3atbl_isp_height = 0;
+	}
+
+	if (info->enable.sc) {
+		binary->sctbl_width_per_color  =
+			_ISP_SCTBL_WIDTH_PER_COLOR(sc_3a_dis_padded_width,
+				s3a_log_deci);
+		binary->sctbl_aligned_width_per_color =
+			SH_CSS_MAX_SCTBL_ALIGNED_WIDTH_PER_COLOR;
+		binary->sctbl_height =
+			_ISP_SCTBL_HEIGHT(sc_3a_dis_height, s3a_log_deci);
+	} else {
+		binary->sctbl_width_per_color         = 0;
+		binary->sctbl_aligned_width_per_color = 0;
+		binary->sctbl_height                  = 0;
+	}
+	if (info->enable.dis) {
+		binary->dis_deci_factor_log2 = SH_CSS_DIS_DECI_FACTOR_LOG2;
+
+		binary->dis_hor_grid_num_3a  =
+			_ISP_SDIS_HOR_GRID_NUM_3A(sc_3a_dis_width,
+						  SH_CSS_DIS_DECI_FACTOR_LOG2);
+		binary->dis_ver_grid_num_3a  =
+			_ISP_SDIS_VER_GRID_NUM_3A(sc_3a_dis_height,
+						  SH_CSS_DIS_DECI_FACTOR_LOG2);
+		binary->dis_hor_grid_num_isp =
+			_ISP_SDIS_HOR_GRID_NUM_ISP(sc_3a_dis_padded_width,
+						SH_CSS_DIS_DECI_FACTOR_LOG2);
+		binary->dis_ver_grid_num_isp =
+			_ISP_SDIS_VER_GRID_NUM_ISP(sc_3a_dis_height,
+						SH_CSS_DIS_DECI_FACTOR_LOG2);
+
+		binary->dis_hor_coef_num_3a  =
+			_ISP_SDIS_HOR_COEF_NUM_3A(sc_3a_dis_width,
+						  SH_CSS_DIS_DECI_FACTOR_LOG2);
+		binary->dis_ver_coef_num_3a  =
+			_ISP_SDIS_VER_COEF_NUM_3A(sc_3a_dis_height,
+						  SH_CSS_DIS_DECI_FACTOR_LOG2);
+		binary->dis_hor_coef_num_isp =
+			_ISP_SDIS_HOR_COEF_NUM_ISP(sc_3a_dis_padded_width);
+		binary->dis_ver_coef_num_isp =
+			_ISP_SDIS_VER_COEF_NUM_ISP(sc_3a_dis_height);
+		binary->dis_hor_proj_num_3a  =
+			_ISP_SDIS_HOR_PROJ_NUM_3A(
+				sc_3a_dis_width,
+				sc_3a_dis_height,
+				SH_CSS_DIS_DECI_FACTOR_LOG2,
+				info->isp_pipe_version);
+		binary->dis_ver_proj_num_3a  =
+			_ISP_SDIS_VER_PROJ_NUM_3A(
+				sc_3a_dis_width,
+				sc_3a_dis_height,
+				SH_CSS_DIS_DECI_FACTOR_LOG2,
+				info->isp_pipe_version);
+		binary->dis_hor_proj_num_isp =
+			__ISP_SDIS_HOR_PROJ_NUM_ISP(sc_3a_dis_padded_width,
+				sc_3a_dis_height,
+				SH_CSS_DIS_DECI_FACTOR_LOG2,
+				info->isp_pipe_version);
+		binary->dis_ver_proj_num_isp =
+			__ISP_SDIS_VER_PROJ_NUM_ISP(sc_3a_dis_padded_width,
+				sc_3a_dis_height,
+				SH_CSS_DIS_DECI_FACTOR_LOG2,
+				info->isp_pipe_version);
+	} else {
+		binary->dis_deci_factor_log2 = 0;
+		binary->dis_hor_coef_num_3a  = 0;
+		binary->dis_ver_coef_num_3a  = 0;
+		binary->dis_hor_coef_num_isp = 0;
+		binary->dis_ver_coef_num_isp = 0;
+		binary->dis_hor_proj_num_3a  = 0;
+		binary->dis_ver_proj_num_3a  = 0;
+		binary->dis_hor_proj_num_isp = 0;
+		binary->dis_ver_proj_num_isp = 0;
+	}
+	if (info->left_cropping)
+		binary->left_padding = 2 * ISP_VEC_NELEMS - info->left_cropping;
+	else
+		binary->left_padding = 0;
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_binary_find(struct ia_css_binary_descr *descr,
+		   struct ia_css_binary *binary)
+{
+	int mode;
+	bool online;
+	bool two_ppc;
+	enum ia_css_stream_format stream_format;
+	const struct ia_css_frame_info *req_in_info,
+				       *req_bds_out_info,
+				       *req_out_info[IA_CSS_BINARY_MAX_OUTPUT_PORTS],
+					   *req_bin_out_info = NULL,
+				       *req_vf_info;
+
+	struct ia_css_binary_xinfo *xcandidate;
+	bool need_ds, need_dz, need_dvs, need_xnr;
+	bool enable_yuv_ds;
+	bool enable_high_speed;
+	bool enable_dvs_6axis;
+	bool enable_reduced_pipe;
+	enum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;
+	bool continuous;
+	unsigned int isp_pipe_version;
+	struct ia_css_resolution dvs_env, internal_res;
+	unsigned int i;
+
+	assert(descr != NULL);
+/* MW: used after an error check, may accept NULL, but doubtfull */
+	assert(binary != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_binary_find() enter: "
+		"descr=%p, (mode=%d), "
+		"binary=%p\n",
+		descr, descr->mode,
+		binary);
+
+	mode = descr->mode;
+	online = descr->online;
+	two_ppc = descr->two_ppc;
+	stream_format = descr->stream_format;
+	req_in_info = descr->in_info;
+	req_bds_out_info = descr->bds_out_info;
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		req_out_info[i] = descr->out_info[i];
+		if (req_out_info[i] && (req_out_info[i]->res.width != 0))
+			req_bin_out_info = req_out_info[i];
+	}
+	if (req_bin_out_info == NULL)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	req_vf_info = descr->vf_info;
+
+	need_xnr = descr->enable_xnr;
+	need_ds = descr->enable_fractional_ds;
+	need_dz = false;
+	need_dvs = false;
+	enable_yuv_ds = descr->enable_yuv_ds;
+	enable_high_speed = descr->enable_high_speed;
+	enable_dvs_6axis  = descr->enable_dvs_6axis;
+	enable_reduced_pipe = descr->enable_reduced_pipe;
+	continuous = descr->continuous;
+	isp_pipe_version = descr->isp_pipe_version;
+
+	dvs_env.width = 0;
+	dvs_env.height = 0;
+	internal_res.width = 0;
+	internal_res.height = 0;
+
+
+	if (mode == IA_CSS_BINARY_MODE_VIDEO) {
+		dvs_env = descr->dvs_env;
+		need_dz = descr->enable_dz;
+		/* Video is the only mode that has a nodz variant. */
+		need_dvs = dvs_env.width || dvs_env.height;
+	}
+
+	/* printf("sh_css_binary_find: pipe version %d\n", isp_pipe_version); */
+	for (xcandidate = binary_infos[mode]; xcandidate;
+	     xcandidate = xcandidate->next) {
+		struct ia_css_binary_info *candidate = &xcandidate->sp;
+		/* printf("sh_css_binary_find: evaluating candidate:
+		 * %d\n",candidate->id); */
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_binary_find() candidate = %p, mode = %d ID = %d\n",
+			candidate, candidate->mode, candidate->id);
+
+		/*
+		 * MW: Only a limited set of jointly configured binaries can
+		 * be used in a continuous preview/video mode unless it is
+		 * the copy mode and runs on SP.
+		*/
+		if (!candidate->enable.continuous &&
+		    continuous && (mode != IA_CSS_BINARY_MODE_COPY)) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: !%d && %d && (%d != %d)\n",
+					__LINE__, candidate->enable.continuous,
+					continuous, mode,
+					IA_CSS_BINARY_MODE_COPY);
+			continue;
+		}
+
+		if (candidate->isp_pipe_version != isp_pipe_version &&
+		    (mode != IA_CSS_BINARY_MODE_COPY) &&
+		    (mode != IA_CSS_BINARY_MODE_CAPTURE_PP) &&
+		    (mode != IA_CSS_BINARY_MODE_VF_PP)) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: (%d != %d)\n",
+				__LINE__,
+				candidate->isp_pipe_version, isp_pipe_version);
+			continue;
+		}
+		if (!candidate->enable.reduced_pipe && enable_reduced_pipe) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
+				__LINE__,
+				candidate->enable.reduced_pipe,
+				enable_reduced_pipe);
+			continue;
+		}
+		if (!candidate->enable.dvs_6axis && enable_dvs_6axis) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
+				__LINE__,
+				candidate->enable.dvs_6axis,
+				enable_dvs_6axis);
+			continue;
+		}
+		if (candidate->enable.high_speed && !enable_high_speed) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: %d && !%d\n",
+				__LINE__,
+				candidate->enable.high_speed,
+				enable_high_speed);
+			continue;
+		}
+		if (!candidate->enable.xnr && need_xnr) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: %d && !%d\n",
+				__LINE__,
+				candidate->enable.xnr,
+				need_xnr);
+			continue;
+		}
+		if (!(candidate->enable.ds & 2) && enable_yuv_ds) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
+				__LINE__,
+				((candidate->enable.ds & 2) != 0),
+				enable_yuv_ds);
+			continue;
+		}
+		if ((candidate->enable.ds & 2) && !enable_yuv_ds) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: %d && !%d\n",
+				__LINE__,
+				((candidate->enable.ds & 2) != 0),
+				enable_yuv_ds);
+			continue;
+		}
+
+		if (mode == IA_CSS_BINARY_MODE_VIDEO &&
+			candidate->enable.ds && need_ds)
+			need_dz = false;
+
+		/* when we require vf output, we need to have vf_veceven */
+		if ((req_vf_info != NULL) && !(candidate->enable.vf_veceven ||
+				/* or variable vf vec even */
+				candidate->variable_vf_veceven ||
+				/* or more than one output pin. */
+				xcandidate->num_output_pins > 1)) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: (%p != NULL) && !(%d || %d || (%d >%d))\n",
+				__LINE__, req_vf_info,
+				candidate->enable.vf_veceven,
+				candidate->variable_vf_veceven,
+				xcandidate->num_output_pins, 1);
+			continue;
+		}
+		if (!candidate->enable.dvs_envelope && need_dvs) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
+				__LINE__,
+				candidate->enable.dvs_envelope, (int)need_dvs);
+			continue;
+		}
+		/* internal_res check considers input, output, and dvs envelope sizes */
+		ia_css_binary_internal_res(req_in_info, req_bds_out_info,
+					   req_bin_out_info, &dvs_env, candidate, &internal_res);
+		if (internal_res.width > candidate->max_internal_width) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_binary_find() [%d] continue: (%d > %d)\n",
+			__LINE__, internal_res.width,
+			candidate->max_internal_width);
+			continue;
+		}
+		if (internal_res.height > candidate->max_internal_height) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_binary_find() [%d] continue: (%d > %d)\n",
+			__LINE__, internal_res.height,
+			candidate->max_internal_height);
+			continue;
+		}
+		if (!candidate->enable.ds && need_ds) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
+				__LINE__, candidate->enable.ds, (int)need_ds);
+			continue;
+		}
+		if (!candidate->enable.uds && need_dz) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: !%d && %d\n",
+				__LINE__, candidate->enable.uds, (int)need_dz);
+			continue;
+		}
+		if (online && candidate->input == IA_CSS_BINARY_INPUT_MEMORY) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: %d && (%d == %d)\n",
+				__LINE__, online, candidate->input,
+				IA_CSS_BINARY_INPUT_MEMORY);
+			continue;
+		}
+		if (!online && candidate->input == IA_CSS_BINARY_INPUT_SENSOR) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: !%d && (%d == %d)\n",
+				__LINE__, online, candidate->input,
+				IA_CSS_BINARY_INPUT_SENSOR);
+			continue;
+		}
+		if (req_bin_out_info->res.width < candidate->min_output_width ||
+		    req_bin_out_info->res.width > candidate->max_output_width) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: (%d > %d) || (%d < %d)\n",
+				__LINE__,
+				req_bin_out_info->padded_width,
+				candidate->min_output_width,
+				req_bin_out_info->padded_width,
+				candidate->max_output_width);
+			continue;
+		}
+		if (req_in_info->padded_width > candidate->max_input_width) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: (%d > %d)\n",
+				__LINE__, req_in_info->padded_width,
+				candidate->max_input_width);
+			continue;
+		}
+		if (!binary_supports_output_format(xcandidate, req_bin_out_info->format)) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: !%d\n",
+				__LINE__,
+				binary_supports_output_format(xcandidate, req_bin_out_info->format));
+			continue;
+		}
+
+		if (xcandidate->num_output_pins > 1 && /* in case we have a second output pin, */
+		     req_vf_info                   && /* and we need vf output. */
+						      /* check if the required vf format
+							 is supported. */
+			!binary_supports_output_format(xcandidate, req_vf_info->format)) {
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: (%d > %d) && (%p != NULL) && !%d\n",
+				__LINE__, xcandidate->num_output_pins, 1,
+				req_vf_info,
+				binary_supports_output_format(xcandidate, req_vf_info->format));
+			continue;
+		}
+
+		if (!supports_bds_factor(candidate->supported_bds_factors,
+		    descr->required_bds_factor)) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: 0x%x & 0x%x)\n",
+				__LINE__, candidate->supported_bds_factors,
+				descr->required_bds_factor);
+			continue;
+		}
+
+
+		/* reconfigure any variable properties of the binary */
+		err = ia_css_binary_fill_info(xcandidate, online, two_ppc,
+				       stream_format, req_in_info,
+				       req_bds_out_info,
+				       req_out_info, req_vf_info,
+				       binary, &dvs_env,
+				       descr->stream_config_left_padding,
+				       false);
+
+		if (err)
+			break;
+		binary_init_metrics(&binary->metrics, &binary->info->sp);
+		break;
+	}
+	/* MW: In case we haven't found a binary and hence the binary_info
+	 * is uninitialised */
+	assert(xcandidate != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_binary_find() selected = %p, mode = %d ID = %d\n",
+		xcandidate, xcandidate ? xcandidate->sp.mode : 0, xcandidate ? xcandidate->sp.id : 0);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_binary_find() leave: return_err=%d\n", err);
+
+	return err;
+}
+
+unsigned
+ia_css_binary_max_vf_width(void)
+{
+  return binary_infos[IA_CSS_BINARY_MODE_VF_PP]->sp.max_output_width;
+}
+
+void
+ia_css_binary_destroy_isp_parameters(struct ia_css_binary *binary)
+{
+	ia_css_isp_param_destroy_isp_parameters(
+		&binary->mem_params,
+		&binary->css_params);
+}
+
+void
+ia_css_binary_get_isp_binaries(struct ia_css_binary_xinfo **binaries,
+	uint32_t *num_isp_binaries)
+{
+	assert(binaries != NULL);
+
+	if(num_isp_binaries)
+		*num_isp_binaries = 0;
+
+	*binaries = all_binaries;
+	if(all_binaries && num_isp_binaries) {
+		/* -1 to account for sp binary which is not stored in all_binaries */
+		if(sh_css_num_binaries > 0)
+			*num_isp_binaries = sh_css_num_binaries - 1;
+	}
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/bufq/interface/ia_css_bufq.h b/drivers/media/atomisp2/css2400/runtime/bufq/interface/ia_css_bufq.h
new file mode 100644
index 0000000..c3f7804
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/bufq/interface/ia_css_bufq.h
@@ -0,0 +1,162 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_BUFQ_H
+#define _IA_CSS_BUFQ_H
+
+#include <type_support.h>
+#include "ia_css_bufq_comm.h"
+#include "ia_css_err.h"
+#define BUFQ_EVENT_SIZE 4
+
+
+/**
+ * @brief Query the internal frame ID.
+ *
+ * @param[in]	key	The query key.
+ * @param[out]	val	The query value.
+ *
+ * @return
+ *	true, if the query succeeds;
+ *	false, if the query fails.
+ */
+bool ia_css_query_internal_queue_id(
+	enum ia_css_buffer_type buf_type,
+	unsigned int thread_id,
+	enum sh_css_queue_id *val
+	);
+
+
+/**
+ * @brief  Map buffer type to a internal queue id.
+ *
+ * @param[in] thread id		Thread in which the buffer type has to be mapped or unmapped
+ * @param[in] buf_type		buffer type.
+ * @param[in] map		boolean flag to specify map or unmap
+ * @return none
+ */
+void ia_css_queue_map(
+	unsigned int thread_id,
+	enum ia_css_buffer_type buf_type,
+	bool map
+	);
+
+
+/**
+ * @brief  Initilize buffer type to a queue id mapping
+ * @return none
+ */
+void ia_css_queue_map_init(void);
+
+
+/**
+ * @brief initializes bufq module
+ * It create instances of
+ * -host to SP buffer queue  which is a list with predefined size,
+ *	MxN queues where M is the number threads and N is the number queues per thread
+ *-SP to host buffer queue , is a list with N queues
+ *-host to SP event communication queue
+ * -SP to host event communication queue
+ * -queue for tagger commands
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ */
+enum ia_css_err ia_css_bufq_init(void);
+
+
+/**
+* @brief Enqueues an item into host to SP buffer queue
+ *
+ * @param thread_index[in]	Thread in which the item to be enqueued
+ *
+ * @param queue_id[in]		Index of the queue in the specified thread
+ * @param item[in]		Object to enqueue.
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+*/
+enum ia_css_err ia_css_bufq_enqueue_buffer(
+	int thread_index,
+	int queue_id,
+	uint32_t item);
+
+/**
+* @brief Dequeues an item from SP to host buffer queue.
+ *
+ * @param queue_id[in]		Specifies  the index of the queue in the list where
+ *				the item has to be read.
+ * @paramitem [out]		Object to be dequeued into this item.
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+*/
+enum  ia_css_err ia_css_bufq_dequeue_buffer(
+	int queue_id,
+	uint32_t *item);
+
+/**
+* @brief  Enqueue an event item into host to SP communication event queue.
+ *
+ * @param[in]	evt_id		      The event ID.
+ * @param[in]	evt_payload_0	The event payload.
+ * @param[in]	evt_payload_1	The event payload.
+ * @param[in]	evt_payload_2	The event payload.
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+*/
+enum ia_css_err ia_css_bufq_enqueue_event(
+	uint8_t evt_id,
+	uint8_t evt_payload_0,
+	uint8_t evt_payload_1,
+	uint8_t evt_payload_2
+	);
+
+/**
+* @brief   Dequeue an item from  SP to host communication event queue.
+
+ *
+ * @param item	Object to be dequeued into this item.
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+*/
+enum  ia_css_err ia_css_bufq_dequeue_event(
+	uint8_t item[BUFQ_EVENT_SIZE]
+	);
+
+
+/**
+* @brief   Enqueue a tagger command item into tagger command queue..
+ *
+ * @param item	Object to be enqueue.
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+*/
+enum ia_css_err ia_css_bufq_enqueue_tag_cmd(
+	uint32_t item);
+
+
+/**
+* @brief  Uninitializes bufq module.
+ *
+ * @return	IA_CSS_SUCCESS or error code upon error.
+ *
+*/
+enum ia_css_err ia_css_bufq_deinit(void);
+
+
+#endif	/* _IA_CSS_BUFQ_H */
diff --git a/drivers/media/atomisp2/css2400/runtime/bufq/interface/ia_css_bufq_comm.h b/drivers/media/atomisp2/css2400/runtime/bufq/interface/ia_css_bufq_comm.h
new file mode 100644
index 0000000..7330b6a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/bufq/interface/ia_css_bufq_comm.h
@@ -0,0 +1,104 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_BUFQ_COMM_H
+#define _IA_CSS_BUFQ_COMM_H
+
+#include "system_global.h"
+
+/** Enumeration of buffer types. Buffers can be queued and de-queued
+ *  to hand them over between IA and ISP.
+ */
+/*
+ * The first frames (with comment Dynamic) can be dynamic or static
+ * The other frames (ref_in and below) can only be static
+ * Static means that the data addres will not change during the life time
+ * of the associated pipe. Dynamic means that the data address can
+ * change with every (frame) iteration of the associated pipe
+ *
+ * s3a and dis are now also dynamic but (stil) handled seperately
+ */
+enum ia_css_buffer_type {
+	IA_CSS_BUFFER_TYPE_INVALID = -1,
+	IA_CSS_BUFFER_TYPE_3A_STATISTICS = 0,
+	IA_CSS_BUFFER_TYPE_DIS_STATISTICS,
+	IA_CSS_BUFFER_TYPE_LACE_STATISTICS,
+	IA_CSS_BUFFER_TYPE_INPUT_FRAME,
+	IA_CSS_BUFFER_TYPE_OUTPUT_FRAME,
+	IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME,
+	IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME,
+	IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME,
+	IA_CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME,
+	IA_CSS_BUFFER_TYPE_CUSTOM_INPUT,
+	IA_CSS_BUFFER_TYPE_CUSTOM_OUTPUT,
+	IA_CSS_BUFFER_TYPE_METADATA,
+	IA_CSS_BUFFER_TYPE_PARAMETER_SET,
+	IA_CSS_NUM_DYNAMIC_BUFFER_TYPE,
+	IA_CSS_BUFFER_TYPE_VIDEO_DELAY_0,
+	IA_CSS_BUFFER_TYPE_VIDEO_DELAY_1,
+	IA_CSS_BUFFER_TYPE_VIDEO_DELAY_2,
+	IA_CSS_BUFFER_TYPE_EXTRA,
+	IA_CSS_NUM_BUFFER_TYPE
+};
+
+#if 0
+enum sh_css_queue_id {
+	SH_CSS_INVALID_BUFFER_QUEUE_ID     = -1,
+	SH_CSS_INPUT_BUFFER_QUEUE_ID       = 0,
+	SH_CSS_OUTPUT_BUFFER_QUEUE_ID      = 1,
+	SH_CSS_VF_OUTPUT_BUFFER_QUEUE_ID   = 2,
+	SH_CSS_S3A_BUFFER_QUEUE_ID         = 3,
+	SH_CSS_DIS_BUFFER_QUEUE_ID         = 4,
+	SH_CSS_PARAM_BUFFER_QUEUE_ID       = 5,
+	SH_CSS_TAG_CMD_QUEUE_ID            = 6,
+#if !defined (SH_CSS_ENABLE_METADATA)
+	SH_CSS_NUM_BUFFER_QUEUE_ID         = SH_CSS_TAG_CMD_QUEUE_ID,
+#else
+	SH_CSS_METADATA_BUFFER_QUEUE_ID    = 7,
+	SH_CSS_NUM_BUFFER_QUEUE_ID         = SH_CSS_METADATA_BUFFER_QUEUE_ID,
+#endif
+};
+#endif
+
+enum sh_css_queue_id {
+	SH_CSS_INVALID_QUEUE_ID     = -1,
+	SH_CSS_QUEUE_A_ID = 0,
+	SH_CSS_QUEUE_B_ID,
+	SH_CSS_QUEUE_C_ID,
+	SH_CSS_QUEUE_D_ID,
+	SH_CSS_QUEUE_E_ID,
+	SH_CSS_QUEUE_F_ID,
+#if defined(HAS_NO_INPUT_SYSTEM) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* input frame queue for skycam */
+	SH_CSS_QUEUE_G_ID,
+	SH_CSS_QUEUE_H_ID, /* for metadata */
+#endif
+	SH_CSS_MAX_NUM_QUEUES
+};
+
+#define SH_CSS_MAX_DYNAMIC_BUFFERS_PER_THREAD SH_CSS_MAX_NUM_QUEUES
+/* for now we staticaly assign queue 0 to parameter */
+#define IA_CSS_PARAMETER_SET_QUEUE_ID SH_CSS_QUEUE_A_ID
+//#define SH_CSS_MAX_NUM_QUEUES SH_CSS_MAX_DYNAMIC_BUFFERS_PER_THREAD
+
+
+
+#endif
diff --git a/drivers/media/atomisp2/css2400/runtime/bufq/src/bufq.c b/drivers/media/atomisp2/css2400/runtime/bufq/src/bufq.c
new file mode 100644
index 0000000..4ec0b90
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/bufq/src/bufq.c
@@ -0,0 +1,471 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "assert_support.h"		/* assert */
+#include "sp.h"
+#include "ia_css_bufq.h"		/* Bufq API's */
+#include "ia_css_queue.h"		/* ia_css_queue_t */
+#include "sw_event_global.h"		/* Event IDs.*/
+#include "ia_css_eventq.h"		/* ia_css_eventq_recv()*/
+#include "ia_css_debug.h"		/* ia_css_debug_dtrace*/
+#include "sh_css_internal.h"		/* sh_css_queue_type */
+#include "sp_local.h"			/* sp_address_of */
+#include "ia_css_util.h" 		/* ia_css_convert_errno()*/
+#include "sh_css_firmware.h"		/* sh_css_sp_fw*/
+
+
+
+
+/*********************************************************/
+/* Global Queue objects used by CSS                      */
+/*********************************************************/
+struct sh_css_queues {
+	/* Host2SP buffer queue */
+	ia_css_queue_t host2sp_buffer_queue_handles
+		[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES];
+	/* SP2Host buffer queue */
+	ia_css_queue_t sp2host_buffer_queue_handles
+		[SH_CSS_MAX_NUM_QUEUES];
+
+	/* Host2SP event queue */
+	ia_css_queue_t host2sp_event_queue_handle;
+
+	/* SP2Host event queue */
+	ia_css_queue_t sp2host_event_queue_handle;
+
+	/* Tagger command queue */
+	ia_css_queue_t host2sp_tag_cmd_queue_handle;
+};
+
+struct sh_css_queues  css_queues;
+
+
+/*******************************************************
+*** Static variables
+********************************************************/
+static int buffer_type_to_queue_id_map[SH_CSS_MAX_SP_THREADS][IA_CSS_NUM_DYNAMIC_BUFFER_TYPE];
+static bool queue_availability[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES];
+
+/*******************************************************
+*** Static functions
+********************************************************/
+static void map_buffer_type_to_queue_id(
+	unsigned int thread_id,
+	enum ia_css_buffer_type buf_type
+	);
+static void unmap_buffer_type_to_queue_id(
+	unsigned int thread_id,
+	enum ia_css_buffer_type buf_type
+	);
+
+static ia_css_queue_t *bufq_get_qhandle(
+	enum sh_css_queue_type type,
+	enum sh_css_queue_id id,
+	int thread
+	);
+
+/*******************************************************
+*** Public functions
+********************************************************/
+void ia_css_queue_map_init(void)
+{
+	unsigned int i, j;
+
+	for (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {
+		for (j = 0; j < SH_CSS_MAX_NUM_QUEUES; j++) {
+			queue_availability[i][j] = true;
+		}
+	}
+
+	for (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {
+		for (j = 0; j < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE; j++) {
+			buffer_type_to_queue_id_map[i][j] = SH_CSS_INVALID_QUEUE_ID;
+		}
+	}
+}
+
+void ia_css_queue_map(
+	unsigned int thread_id,
+	enum ia_css_buffer_type buf_type,
+	bool map)
+{
+	assert(buf_type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE);
+	assert(thread_id < SH_CSS_MAX_SP_THREADS);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_queue_map() enter: buf_type=%d, thread_id=%d\n", buf_type, thread_id);
+
+	if(map) {
+		map_buffer_type_to_queue_id(thread_id, buf_type);
+	} else {
+		unmap_buffer_type_to_queue_id(thread_id, buf_type);
+	}
+}
+
+/**
+ * @brief Query the internal queue ID.
+ */
+bool ia_css_query_internal_queue_id(
+	enum ia_css_buffer_type buf_type,
+	unsigned int thread_id,
+	enum sh_css_queue_id *val)
+{
+	assert(buf_type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE);
+	assert(thread_id < SH_CSS_MAX_SP_THREADS);
+	assert(val != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_query_internal_queue_id() enter: buf_type=%d, thread_id=%d\n", buf_type, thread_id);
+	*val = buffer_type_to_queue_id_map[thread_id][buf_type];
+	assert(*val != SH_CSS_INVALID_QUEUE_ID);
+	assert(*val < SH_CSS_MAX_NUM_QUEUES);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_query_internal_queue_id() leave: return_val=%d\n",
+		*val);
+	return true;
+}
+
+/*******************************************************
+*** Static functions
+********************************************************/
+static void map_buffer_type_to_queue_id(
+	unsigned int thread_id,
+	enum ia_css_buffer_type buf_type)
+{
+	unsigned int i;
+
+	assert(thread_id < SH_CSS_MAX_SP_THREADS);
+	assert(buf_type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE);
+	assert(buffer_type_to_queue_id_map[thread_id][buf_type] == SH_CSS_INVALID_QUEUE_ID);
+
+	//queue 0 is reserved for parameter because it doesn't depend on events
+	if (buf_type == IA_CSS_BUFFER_TYPE_PARAMETER_SET) {
+		assert(queue_availability[thread_id][0] == true);
+		queue_availability[thread_id][0] = false;
+		buffer_type_to_queue_id_map[thread_id][buf_type] = IA_CSS_PARAMETER_SET_QUEUE_ID;
+		return;
+	}
+
+	for (i = 1; i < SH_CSS_MAX_NUM_QUEUES; i++) {
+		if (queue_availability[thread_id][i] == true) {
+			queue_availability[thread_id][i] = false;
+			buffer_type_to_queue_id_map[thread_id][buf_type] = i;
+			break;
+		}
+	}
+
+	assert(i != SH_CSS_MAX_NUM_QUEUES);
+	return;
+}
+
+static void unmap_buffer_type_to_queue_id(
+	unsigned int thread_id,
+	enum ia_css_buffer_type buf_type)
+{
+	int queue_id;
+
+	assert(thread_id < SH_CSS_MAX_SP_THREADS);
+	assert(buf_type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE);
+	assert(buffer_type_to_queue_id_map[thread_id][buf_type] != SH_CSS_INVALID_QUEUE_ID);
+
+	queue_id = buffer_type_to_queue_id_map[thread_id][buf_type];
+	buffer_type_to_queue_id_map[thread_id][buf_type] = SH_CSS_INVALID_QUEUE_ID;
+	queue_availability[thread_id][queue_id] = true;
+}
+
+
+static ia_css_queue_t *bufq_get_qhandle(
+	enum sh_css_queue_type type,
+	enum sh_css_queue_id id,
+	int thread)
+{
+	ia_css_queue_t *q = 0;
+
+	switch (type) {
+	case sh_css_host2sp_buffer_queue:
+		if ((thread >= SH_CSS_MAX_SP_THREADS) || (thread < 0) ||
+			(id == SH_CSS_INVALID_QUEUE_ID))
+			break;
+		q = &css_queues.host2sp_buffer_queue_handles[thread][id];
+		break;
+	case sh_css_sp2host_buffer_queue:
+		if (id == SH_CSS_INVALID_QUEUE_ID)
+			break;
+		q = &css_queues.sp2host_buffer_queue_handles[id];
+		break;
+	case sh_css_host2sp_event_queue:
+		q = &css_queues.host2sp_event_queue_handle;
+		break;
+	case sh_css_sp2host_event_queue:
+		q = &css_queues.sp2host_event_queue_handle;
+		break;
+	case sh_css_host2sp_tag_cmd_queue:
+		q = &css_queues.host2sp_tag_cmd_queue_handle;
+		break;
+	default:
+		break;
+	}
+
+	return q;
+}
+
+
+enum ia_css_err ia_css_bufq_init(void)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_ia_css_bufq_host_sp_queue;
+	ia_css_queue_remote_t remoteq;
+	int i, j;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_bufq_init() enter:\n");
+	fw = &sh_css_sp_fw;
+
+#ifdef C_RUN
+	HIVE_ADDR_ia_css_bufq_host_sp_queue = (unsigned int)
+		sp_address_of(ia_css_bufq_host_sp_queue);
+#else
+	HIVE_ADDR_ia_css_bufq_host_sp_queue = fw->info.sp.host_sp_queue;
+#endif
+	/* Setup queue location as SP and proc id as SP0_ID*/
+	remoteq.location = IA_CSS_QUEUE_LOC_SP;
+	remoteq.proc_id = SP0_ID;
+
+	/* Setup all the local queue descriptors for Host2SP Buffer Queues */
+	for (i = 0; i < SH_CSS_MAX_SP_THREADS; i++)
+		for (j = 0; j < SH_CSS_MAX_NUM_QUEUES; j++) {
+			remoteq.cb_desc_addr =
+				HIVE_ADDR_ia_css_bufq_host_sp_queue
+					+ offsetof(struct host_sp_queues,
+					 host2sp_buffer_queues_desc[i][j]);
+
+			remoteq.cb_elems_addr =
+				HIVE_ADDR_ia_css_bufq_host_sp_queue
+					+ offsetof(struct host_sp_queues,
+					 host2sp_buffer_queues_elems[i][j]);
+
+			/* Initialize the queue instance and obtain handle */
+			ia_css_queue_remote_init(
+				&css_queues.host2sp_buffer_queue_handles[i][j],
+				&remoteq);
+		}
+
+	/* Setup all the local queue descriptors for SP2Host Buffer Queues */
+	for (i = 0; i < SH_CSS_MAX_NUM_QUEUES; i++) {
+		remoteq.cb_desc_addr = HIVE_ADDR_ia_css_bufq_host_sp_queue
+			+ offsetof(struct host_sp_queues,
+				 sp2host_buffer_queues_desc[i]);
+
+		remoteq.cb_elems_addr = HIVE_ADDR_ia_css_bufq_host_sp_queue
+			+ offsetof(struct host_sp_queues,
+				 sp2host_buffer_queues_elems[i]);
+
+		/* Initialize the queue instance and obtain handle */
+		ia_css_queue_remote_init(
+			&css_queues.sp2host_buffer_queue_handles[i],
+			&remoteq);
+	}
+
+	/* Host2SP queues event queue*/
+	remoteq.cb_desc_addr = HIVE_ADDR_ia_css_bufq_host_sp_queue +
+		offsetof(struct host_sp_queues, host2sp_event_queue_desc);
+	remoteq.cb_elems_addr = HIVE_ADDR_ia_css_bufq_host_sp_queue +
+		offsetof(struct host_sp_queues, host2sp_event_queue_elems);
+	/* Initialize the queue instance and obtain handle */
+	ia_css_queue_remote_init(&css_queues.host2sp_event_queue_handle,
+		&remoteq);
+
+	/* SP2Host queues event queue*/
+	remoteq.cb_desc_addr = HIVE_ADDR_ia_css_bufq_host_sp_queue +
+		offsetof(struct host_sp_queues, sp2host_event_queue_desc);
+	remoteq.cb_elems_addr = HIVE_ADDR_ia_css_bufq_host_sp_queue +
+		offsetof(struct host_sp_queues, sp2host_event_queue_elems);
+	/* Initialize the queue instance and obtain handle */
+	ia_css_queue_remote_init(&css_queues.sp2host_event_queue_handle,
+		&remoteq);
+
+	/* Host2SP tagger command queue */
+	remoteq.cb_desc_addr = HIVE_ADDR_ia_css_bufq_host_sp_queue +
+		offsetof(struct host_sp_queues, host2sp_tag_cmd_queue_desc);
+	remoteq.cb_elems_addr = HIVE_ADDR_ia_css_bufq_host_sp_queue +
+		offsetof(struct host_sp_queues, host2sp_tag_cmd_queue_elems);
+	/* Initialize the queue instance and obtain handle */
+	ia_css_queue_remote_init(&css_queues.host2sp_tag_cmd_queue_handle,
+		&remoteq);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_bufq_init() leave:\n");
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_bufq_enqueue_buffer(
+	int thread_index,
+	int queue_id,
+	uint32_t item)
+{
+	enum ia_css_err return_err = IA_CSS_SUCCESS;
+	ia_css_queue_t *q;
+	int error;
+
+	if ((thread_index >= SH_CSS_MAX_SP_THREADS) || (thread_index < 0) ||
+			(queue_id == SH_CSS_INVALID_QUEUE_ID))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_bufq_enqueue_buffer() enter: thread_index = %d, queue_id=%d\n",
+		thread_index,
+		queue_id);
+
+	/* Get the queue for communication */
+	q = bufq_get_qhandle(sh_css_host2sp_buffer_queue,
+		queue_id,
+		thread_index);
+	if (q != NULL) {
+		error = ia_css_queue_enqueue(q, item);
+		return_err = ia_css_convert_errno(error);
+	} else {
+		/* Error as the queue is not initialized */
+		return_err = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_bufq_enqueue_buffer() leave: return_err = %d\n", return_err);
+
+	return return_err;
+}
+
+enum ia_css_err ia_css_bufq_dequeue_buffer(
+	int queue_id,
+	uint32_t *item)
+{
+	enum ia_css_err return_err;
+	int error = 0;
+	ia_css_queue_t *q;
+
+	if ((item == NULL) || (queue_id == SH_CSS_INVALID_QUEUE_ID))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_bufq_dequeue_buffer() enter: queue_id = %d\n",
+		queue_id);
+
+	q = bufq_get_qhandle(sh_css_sp2host_buffer_queue,
+		queue_id,
+		-1);
+	if (q != NULL) {
+		error = ia_css_queue_dequeue(q, item);
+		return_err = ia_css_convert_errno(error);
+	} else {
+		/* Error as the queue is not initialized */
+		return_err = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_bufq_dequeue_buffer() leave: return_err = %d item = %p\n",
+		return_err,
+		item);
+	return return_err;
+}
+
+enum ia_css_err ia_css_bufq_enqueue_event(
+	uint8_t evt_id,
+	uint8_t evt_payload_0,
+	uint8_t evt_payload_1,
+	uint8_t evt_payload_2)
+{
+	enum ia_css_err return_err;
+	int error = 0;
+	ia_css_queue_t *q;
+
+	q = bufq_get_qhandle(sh_css_host2sp_event_queue, -1, -1);
+	if (NULL == q) {
+		/* Error as the queue is not initialized */
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_bufq_enqueue_event() leaving: queue not available\n");
+		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+
+	error = ia_css_eventq_send(q,
+			evt_id, evt_payload_0, evt_payload_1, evt_payload_2);
+
+	return_err = ia_css_convert_errno(error);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_bufq_enqueue_event() leave: return_err = %d\n", return_err);
+
+	return return_err;
+}
+
+enum  ia_css_err ia_css_bufq_dequeue_event(
+	uint8_t item[BUFQ_EVENT_SIZE])
+{
+	enum ia_css_err return_err;
+	int error = 0;
+	ia_css_queue_t *q;
+
+	if (item == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	q = bufq_get_qhandle(sh_css_sp2host_event_queue, -1, -1);
+	if (NULL == q) {
+		/* Error as the queue is not initialized */
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_dequeue_event() leaving: Not available\n");
+			return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+	error = ia_css_eventq_recv(q, item);
+
+	return_err = ia_css_convert_errno(error);
+
+	return return_err;
+
+}
+
+enum ia_css_err ia_css_bufq_enqueue_tag_cmd(
+	uint32_t item)
+{
+	enum ia_css_err return_err;
+	int error = 0;
+	ia_css_queue_t *q;
+
+	q = bufq_get_qhandle(sh_css_host2sp_tag_cmd_queue, -1, -1);
+	if (NULL == q) {
+		/* Error as the queue is not initialized */
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_bufq_enqueue_tag_cmd() leaving: queue not available\n");
+		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+	if (q != NULL) {
+		error = ia_css_queue_enqueue(q, item);
+		return_err = ia_css_convert_errno(error);
+	} else {
+		/* Error as the queue is not initialized */
+		return_err = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_bufq_enqueue_tag_cmd() leave: return_err = %d\n", return_err);
+
+	return return_err;
+}
+
+enum ia_css_err ia_css_bufq_deinit(void)
+{
+	return IA_CSS_SUCCESS;
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/debug/interface/ia_css_debug.h b/drivers/media/atomisp2/css2400/runtime/debug/interface/ia_css_debug.h
new file mode 100644
index 0000000..3b9f9cd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/debug/interface/ia_css_debug.h
@@ -0,0 +1,421 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_DEBUG_H_
+#define _IA_CSS_DEBUG_H_
+
+/*! \file */
+
+#ifndef __INLINE_INPUT_SYSTEM__
+#define __INLINE_INPUT_SYSTEM__
+#endif
+#ifndef __INLINE_IBUF_CTRL__
+#define __INLINE_IBUF_CTRL__
+#endif
+#ifndef __INLINE_CSI_RX__
+#define __INLINE_CSI_RX__
+#endif
+#ifndef __INLINE_PIXELGEN__
+#define __INLINE_PIXELGEN__
+#endif
+#ifndef __INLINE_STREAM2MMIO__
+#define __INLINE_STREAM2MMIO__
+#endif
+#include "ia_css.h"
+#include "sh_css_internal.h"
+
+/* available levels */
+/*! Level for tracing errors */
+#define IA_CSS_DEBUG_ERROR   1
+/*! Level for tracing warnings */
+#define IA_CSS_DEBUG_WARNING 3
+/*! Level for tracing debug messages */
+#define IA_CSS_DEBUG_VERBOSE   5
+/*! Level for tracing trace messages a.o. ia_css public function calls */
+#define IA_CSS_DEBUG_TRACE   6
+/*! Level for tracing trace messages a.o. ia_css private function calls */
+#define IA_CSS_DEBUG_TRACE_PRIVATE   7
+/*! Level for tracing parameter messages e.g. in and out params of functions */
+#define IA_CSS_DEBUG_PARAM   8
+/*! Level for tracing info messages */
+#define IA_CSS_DEBUG_INFO    9
+/* Global variable which controls the verbosity levels of the debug tracing */
+extern unsigned int ia_css_debug_trace_level;
+
+/*! \brief Enum defining the different isp parameters to dump.
+ *  Values can be combined to dump a combination of sets.
+ */
+enum ia_css_debug_enable_param_dump {
+	IA_CSS_DEBUG_DUMP_FPN = 1 << 0, /**< FPN table */
+	IA_CSS_DEBUG_DUMP_OB = 1 << 1,  /**< OB table */
+	IA_CSS_DEBUG_DUMP_SC = 1 << 2,  /**< Shading table */
+	IA_CSS_DEBUG_DUMP_WB = 1 << 3,  /**< White balance */
+	IA_CSS_DEBUG_DUMP_DP = 1 << 4,  /**< Defect Pixel */
+	IA_CSS_DEBUG_DUMP_BNR = 1 << 5,  /**< Bayer Noise Reductions */
+	IA_CSS_DEBUG_DUMP_S3A = 1 << 6,  /**< 3A Statistics */
+	IA_CSS_DEBUG_DUMP_DE = 1 << 7,  /**< De Mosaicing */
+	IA_CSS_DEBUG_DUMP_YNR = 1 << 8,  /**< Luma Noise Reduction */
+	IA_CSS_DEBUG_DUMP_CSC = 1 << 9,  /**< Color Space Conversion */
+	IA_CSS_DEBUG_DUMP_GC = 1 << 10,  /**< Gamma Correction */
+	IA_CSS_DEBUG_DUMP_TNR = 1 << 11,  /**< Temporal Noise Reduction */
+	IA_CSS_DEBUG_DUMP_ANR = 1 << 12,  /**< Advanced Noise Reduction */
+	IA_CSS_DEBUG_DUMP_CE = 1 << 13,  /**< Chroma Enhancement */
+	IA_CSS_DEBUG_DUMP_ALL = 1 << 14  /**< Dump all device parameters */
+};
+
+/*! \brief Function for tracing to the provided printf function in the
+ *	environment.
+ * \param[in]	level		Level of the message.
+ * \param[in]	fmt		printf like format string
+ * \param[in]	args		arguments for the format string
+ */
+#if 0
+STORAGE_CLASS_INLINE void
+ia_css_debug_vdtrace(unsigned int level, const char *fmt, va_list args)
+{
+	if (ia_css_debug_trace_level >= level)
+		sh_css_vprint(fmt, args);
+}
+
+STORAGE_CLASS_INLINE void
+ia_css_debug_dtrace(unsigned int level, const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	ia_css_debug_vdtrace(level, fmt, ap);
+	va_end(ap);
+}
+#else
+#define ia_css_debug_dtrace(level, format, args...)          \
+         do {                                           \
+                 if (ia_css_debug_trace_level >= level)       \
+                         printk(KERN_ALERT format, ## args); \
+         } while (0)
+
+#define ia_css_debug_vdtrace(level, format, args...)          \
+         if (ia_css_debug_trace_level >= level)       \
+                 sh_css_vprint(format, ## args);
+#endif
+/*! \brief Function to set the global dtrace verbosity level.
+ * \param[in]	trace_level	Maximum level of the messages to be traced.
+ * \return	None
+ */
+extern void ia_css_debug_set_dtrace_level(
+	const unsigned int	trace_level);
+
+/*! \brief Dump input formatter state.
+ * Dumps the input formatter state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_if_state(void);
+
+/*! \brief Dump isp hardware state.
+ * Dumps the isp hardware state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_isp_state(void);
+
+/*! \brief Dump sp hardware state.
+ * Dumps the sp hardware state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_sp_state(void);
+
+/*! \brief Dump dma controller state.
+ * Dumps the dma controller state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_dma_state(void);
+
+/*! \brief Dump internal sp software state.
+ * Dumps the sp software state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_sp_sw_debug_info(void);
+
+/*! \brief Dump all related hardware state to the trace output
+ * \param[in]  context	String to identify context in output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_debug_info(
+	const char	*context);
+
+#if SP_DEBUG != SP_DEBUG_NONE
+extern void ia_css_debug_print_sp_debug_state(
+	const struct sh_css_sp_debug_state *state);
+#endif
+
+/*! \brief Dump all related binary info data
+ * \param[in]  bi	Binary info struct.
+ * \return	None
+ */
+extern void ia_css_debug_binary_print(
+	const struct ia_css_binary *bi);
+
+extern void
+ia_css_debug_sp_dump_mipi_fifo_high_water(void);
+
+/*! \brief Dump isp gdc fifo state to the trace output
+ * Dumps the isp gdc fifo state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_isp_gdc_fifo_state(void);
+
+/*! \brief Dump dma isp fifo state
+ * Dumps the dma isp fifo state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_dma_isp_fifo_state(void);
+
+/*! \brief Dump dma sp fifo state
+ * Dumps the dma sp fifo state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_dma_sp_fifo_state(void);
+
+/*! \brief Dump pif isp fifo state
+ * Dumps the primary input formatter state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_pif_isp_fifo_state(void);
+
+/*! \brief Dump isp sp fifo state
+ * Dumps the isp sp fifo state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_isp_sp_fifo_state(void);
+
+/*! \brief Dump all fifo state info to the output
+ * Dumps all fifo state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_all_fifo_state(void);
+
+/*! \brief Dump the rx state to the output
+ * Dumps the rx state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_rx_state(void);
+
+/*! \brief Dump the input system state to the output
+ * Dumps the input system state to tracing output.
+ * \return	None
+ */
+extern void ia_css_debug_dump_isys_state(void);
+
+/*! \brief Dump the frame info to the trace output
+ * Dumps the frame info to tracing output.
+ * \param[in]	frame		pointer to struct ia_css_frame
+ * \param[in]	descr		description output along with the frame info
+ * \return	None
+ */
+extern void ia_css_debug_frame_print(
+	const struct ia_css_frame	*frame,
+	const char	*descr);
+
+/*! \brief Function to enable sp sleep mode.
+ * Function that enables sp sleep mode
+ * \param[in]	mode		indicates when to put sp to sleep
+ * \return	None
+ */
+extern void
+ia_css_debug_enable_sp_sleep_mode(enum ia_css_sp_sleep_mode mode);
+
+/*! \brief Function to wake up sp when in sleep mode.
+ * After sp has been put to sleep, use this function to let it continue
+ * to run again.
+ * \return	None
+ */
+extern void
+ia_css_debug_wake_up_sp(void);
+
+/*! \brief Function to dump isp parameters.
+ * Dump isp parameters to tracing output
+ * \param[in]	enable		flag indicating which parameters to dump.
+ * \return	None
+ */
+extern void
+ia_css_debug_dump_isp_params(struct ia_css_stream *stream, unsigned int enable);
+
+/*! \brief Function to dump some sp performance counters.
+ * Dump sp performance counters, currently input system errors.
+ * \return	None
+ */
+extern void
+ia_css_debug_dump_perf_counters(void);
+
+#ifdef HAS_WATCHDOG_SP_THREAD_DEBUG
+void sh_css_dump_thread_wait_info(void);
+void	sh_css_dump_pipe_stage_info(void);
+void	sh_css_dump_pipe_stripe_info(void);
+#endif
+
+extern void
+ia_css_debug_dump_isp_binary(void);
+
+extern void sh_css_dump_sp_raw_copy_linecount(bool reduced);
+
+/*! \brief Dump the resolution info to the trace output
+ * Dumps the resolution info to the trace output.
+ * \param[in]	res	pointer to struct ia_css_resolution
+ * \param[in]	label	description of resolution output
+ * \return	None
+ */
+extern void
+ia_css_debug_dump_resolution(
+	const struct ia_css_resolution *res,
+	const char *label);
+
+/*! \brief Dump the frame info to the trace output
+ * Dumps the frame info to the trace output.
+ * \param[in]	info	pointer to struct ia_css_frame_info
+ * \param[in]	label	description of frame_info output
+ * \return	None
+ */
+extern void
+ia_css_debug_dump_frame_info(
+	const struct ia_css_frame_info *info,
+	const char *label);
+
+/*! \brief Dump the capture config info to the trace output
+ * Dumps the capture config info to the trace output.
+ * \param[in]	info	pointer to struct ia_css_capture_config
+ * \return	None
+ */
+extern void
+ia_css_debug_dump_capture_config(
+	const struct ia_css_capture_config *config);
+
+/*! \brief Dump the pipe extra config info to the trace output
+ * Dumps the pipe extra config info to the trace output.
+ * \param[in]	info	pointer to struct ia_css_pipe_extra_config
+ * \return	None
+ */
+extern void
+ia_css_debug_dump_pipe_extra_config(
+	const struct ia_css_pipe_extra_config *extra_config);
+
+/*! \brief Dump the pipe config info to the trace output
+ * Dumps the pipe config info to the trace output.
+ * \param[in]	info	pointer to struct ia_css_pipe_config
+ * \return	None
+ */
+extern void
+ia_css_debug_dump_pipe_config(
+	const struct ia_css_pipe_config *config);
+
+extern void
+/*! \brief Dump the stream config source info to the trace output
+ * Dumps the stream config source info to the trace output.
+ * \param[in]	info	pointer to struct ia_css_stream_config
+ * \return	None
+ */
+ia_css_debug_dump_stream_config_source(
+	const struct ia_css_stream_config *config);
+
+/*! \brief Dump the mipi buffer config info to the trace output
+ * Dumps the mipi buffer config info to the trace output.
+ * \param[in]	info	pointer to struct ia_css_mipi_buffer_config
+ * \return	None
+ */
+extern void
+ia_css_debug_dump_mipi_buffer_config(
+	const struct ia_css_mipi_buffer_config *config);
+
+/*! \brief Dump the metadata config info to the trace output
+ * Dumps the metadata config info to the trace output.
+ * \param[in]	info	pointer to struct ia_css_metadata_config
+ * \return	None
+ */
+extern void
+ia_css_debug_dump_metadata_config(
+	const struct ia_css_metadata_config *config);
+
+/*! \brief Dump the stream config info to the trace output
+ * Dumps the stream config info to the trace output.
+ * \param[in]	info		pointer to struct ia_css_stream_config
+ * \param[in]	num_pipes	number of pipes for the stream
+ * \return	None
+ */
+extern void
+ia_css_debug_dump_stream_config(
+	const struct ia_css_stream_config *config,
+	int num_pipes);
+
+/*
+extern void sh_css_init_ddr_debug_queue(void);
+extern void sh_css_load_ddr_debug_queue(void);
+extern void sh_css_dump_ddr_debug_queue(void); */
+
+/**
+ * @brief Initialize the debug mode.
+ *
+ * WARNING:
+ * This API should be called ONLY once in the debug mode.
+ *
+ * @return
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool ia_css_debug_mode_init(void);
+
+/**
+ * @brief Disable the DMA channel.
+ *
+ * @param[in]	dma_ID		The ID of the target DMA.
+ * @param[in]	channel_id	The ID of the target DMA channel.
+ * @param[in]	request_type	The type of the DMA request.
+ *				For example:
+ *				- "0" indicates the writing request.
+ *				- "1" indicates the reading request.
+ *
+ * This is part of the DMA API -> dma.h
+ *
+ * @return
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool ia_css_debug_mode_disable_dma_channel(
+	int dma_ID,
+		int channel_id,
+		int request_type);
+/**
+ * @brief Enable the DMA channel.
+ *
+ * @param[in]	dma_id		The ID of the target DMA.
+ * @param[in]	channel_id	The ID of the target DMA channel.
+ * @param[in]	request_type	The type of the DMA request.
+ *				For example:
+ *				- "0" indicates the writing request.
+ *				- "1" indicates the reading request.
+ *
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool ia_css_debug_mode_enable_dma_channel(
+	int dma_ID,
+		int channel_id,
+		int request_type);
+
+
+
+#endif /* _IA_CSS_DEBUG_H_ */
diff --git a/drivers/media/atomisp2/css2400/runtime/debug/interface/ia_css_debug_internal.h b/drivers/media/atomisp2/css2400/runtime/debug/interface/ia_css_debug_internal.h
new file mode 100644
index 0000000..c310b6c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/debug/interface/ia_css_debug_internal.h
@@ -0,0 +1,22 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/* TO DO: Move debug related code from ia_css_internal.h in */
diff --git a/drivers/media/atomisp2/css2400/runtime/debug/interface/ia_css_debug_pipe.h b/drivers/media/atomisp2/css2400/runtime/debug/interface/ia_css_debug_pipe.h
new file mode 100644
index 0000000..5c67b39
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/debug/interface/ia_css_debug_pipe.h
@@ -0,0 +1,75 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_DEBUG_PIPE_H_
+#define _IA_CSS_DEBUG_PIPE_H_
+
+/*! \file */
+
+#include <ia_css_frame_public.h>
+#include <ia_css_stream_public.h>
+#include "ia_css_pipeline.h"
+
+/**
+ * @brief Internal debug support for constructing a pipe graph.
+ *
+ * @return	None
+ */
+extern void ia_css_debug_pipe_graph_dump_prologue(void);
+
+/**
+ * @brief Internal debug support for constructing a pipe graph.
+ *
+ * @return	None
+ */
+extern void ia_css_debug_pipe_graph_dump_epilogue(void);
+
+/**
+ * @brief Internal debug support for constructing a pipe graph.
+ * @param[in]	stage		Pipeline stage.
+ * @param[in]	id		Pipe id.
+ *
+ * @return	None
+ */
+extern void ia_css_debug_pipe_graph_dump_stage(
+		struct ia_css_pipeline_stage *stage,
+		enum ia_css_pipe_id id);
+
+/**
+ * @brief Internal debug support for constructing a pipe graph.
+ * @param[in]	cc_frame	Output frame of SP raw copy.
+ *
+ * @return	None
+ */
+extern void ia_css_debug_pipe_graph_dump_sp_raw_copy(
+		struct ia_css_frame *cc_frame);
+
+
+/**
+ * @brief Internal debug support for constructing a pipe graph.
+ * @param[in]	stream_config	info about sensor and input formatter.
+ *
+ * @return	None
+ */
+extern void ia_css_debug_pipe_graph_dump_stream_config(
+		const struct ia_css_stream_config *stream_config);
+
+#endif /* _IA_CSS_DEBUG_PIPE_H_ */
diff --git a/drivers/media/atomisp2/css2400/runtime/debug/src/ia_css_debug.c b/drivers/media/atomisp2/css2400/runtime/debug/src/ia_css_debug.c
new file mode 100644
index 0000000..5ce43ab
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/debug/src/ia_css_debug.c
@@ -0,0 +1,3034 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "debug.h"
+#include "memory_access.h"
+
+#include "ia_css_debug.h"
+#include "ia_css_debug_pipe.h"
+#include "ia_css_stream.h"
+#include "ia_css_pipeline.h"
+#include "ia_css_isp_param.h"
+#include "sh_css_params.h"
+
+#include "ia_css_isp_params.h"
+
+#include "assert_support.h"
+#include "print_support.h"
+#include "string_support.h"
+
+#include "fifo_monitor.h"
+#if !defined(HAS_NO_INPUT_FORMATTER)
+#include "input_formatter.h"
+#endif
+#include "dma.h"
+#include "irq.h"
+#include "gp_device.h"
+#include "sp.h"
+#include "isp.h"
+#include "type_support.h"
+#if defined(HAS_INPUT_FORMATTER_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+#include "input_system.h"	/* input_formatter_reg_load */
+#include "gp_device.h"		/* gp_device_reg_load */
+#endif
+
+#include "sh_css_internal.h"
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include "ia_css_isys.h"
+#endif
+#include "sh_css_sp.h"		/* sh_css_sp_get_debug_state() */
+
+/* Include all kernel host interfaces for ISP1 */
+#include "anr/anr_1.0/ia_css_anr.host.h"
+#include "cnr/cnr_1.0/ia_css_cnr.host.h"
+#include "csc/csc_1.0/ia_css_csc.host.h"
+#include "de/de_1.0/ia_css_de.host.h"
+#include "dp/dp_1.0/ia_css_dp.host.h"
+#include "bnr/bnr_1.0/ia_css_bnr.host.h"
+#include "fpn/fpn_1.0/ia_css_fpn.host.h"
+#include "gc/gc_1.0/ia_css_gc.host.h"
+#include "ob/ob_1.0/ia_css_ob.host.h"
+#include "s3a/s3a_1.0/ia_css_s3a.host.h"
+#include "sc/sc_1.0/ia_css_sc.host.h"
+#include "tnr/tnr_1.0/ia_css_tnr.host.h"
+#include "uds/uds_1.0/ia_css_uds.host.h"
+#include "wb/wb_1.0/ia_css_wb.host.h"
+#include "ynr/ynr_1.0/ia_css_ynr.host.h"
+
+/* Include additional kernel host interfaces for ISP2 */
+#include "aa/aa_2/ia_css_aa2.host.h"
+#include "anr/anr_2/ia_css_anr2.host.h"
+#include "cnr/cnr_2/ia_css_cnr2.host.h"
+#include "de/de_2/ia_css_de2.host.h"
+#include "gc/gc_2/ia_css_gc2.host.h"
+#include "ynr/ynr_2/ia_css_ynr2.host.h"
+
+/* snprintf is a C99 feature, MS visual studio defines _snprintf */
+#if defined(_MSC_VER)
+#include <stdio.h>
+#endif
+
+/* Global variable to store the dtrace verbosity level */
+unsigned int ia_css_debug_trace_level;
+
+static const char *format2str[] = {
+	/*[IA_CSS_FRAME_FORMAT_NV11]          = */ "NV11",
+	/*[IA_CSS_FRAME_FORMAT_NV12]          = */ "NV12",
+	/*[IA_CSS_FRAME_FORMAT_NV16]          = */ "NV16",
+	/*[IA_CSS_FRAME_FORMAT_NV21]          = */ "NV21",
+	/*[IA_CSS_FRAME_FORMAT_NV61]          = */ "NV61",
+	/*[IA_CSS_FRAME_FORMAT_YV12]          = */ "YV12",
+	/*[IA_CSS_FRAME_FORMAT_YV16]          = */ "YV16",
+	/*[IA_CSS_FRAME_FORMAT_YUV420]        = */ "YUV420",
+	/*[IA_CSS_FRAME_FORMAT_YUV420_16]     = */ "YUV420_16",
+	/*[IA_CSS_FRAME_FORMAT_YUV422]        = */ "YUV422",
+	/*[IA_CSS_FRAME_FORMAT_YUV422_16]     = */ "YUV422_16",
+	/*[IA_CSS_FRAME_FORMAT_UYVY]          = */ "UYVY",
+	/*[IA_CSS_FRAME_FORMAT_YUYV]          = */ "YUYV",
+	/*[IA_CSS_FRAME_FORMAT_YUV444]        = */ "YUV444",
+	/*[IA_CSS_FRAME_FORMAT_YUV_LINE]      = */ "YUV_LINE",
+	/*[IA_CSS_FRAME_FORMAT_RAW]           = */ "RAW",
+	/*[IA_CSS_FRAME_FORMAT_RGB565]        = */ "RGB565",
+	/*[IA_CSS_FRAME_FORMAT_PLANAR_RGB888] = */ "PLANAR_RGB888",
+	/*[IA_CSS_FRAME_FORMAT_RGBA888]       = */ "RGBA888",
+	/*[IA_CSS_FRAME_FORMAT_QPLANE6]       = */ "QPLANE6",
+	/*[IA_CSS_FRAME_FORMAT_BINARY_8]      = */ "BINARY_8",
+	/*[IA_CSS_FRAME_FORMAT_MIPI]          = */ "MIPI",
+	/*[IA_CSS_FRAME_FORMAT_RAW_PACKED]    = */ "RAW_PACKED",
+	/*[IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8]        = */ "CSI_MIPI_YUV420_8",
+	/*[IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8] = */ "CSI_MIPI_LEGACY_YUV420_8",
+	/*[IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_10]       = */ "CSI_MIPI_YUV420_10",
+	/*[N_IA_CSS_FRAME_FORMAT]             = */ "INVALID"
+};
+
+/* Assumes that IA_CSS_STREAM_FORMAT_BINARY_8 is last */
+#define N_IA_CSS_STREAM_FORMAT (IA_CSS_STREAM_FORMAT_BINARY_8+1)
+
+#define DPG_START "ia_css_debug_pipe_graph_dump_start "
+#define DPG_END   " ia_css_debug_pipe_graph_dump_end\n"
+
+#define ENABLE_LINE1_MAX_LENGHT1 (24)
+#define ENABLE_LINE2_MAX_LENGHT2 (22)
+
+static struct pipe_graph_class {
+	bool do_init;
+	int height;
+	int width;
+	int eff_height;
+	int eff_width;
+	enum ia_css_stream_format stream_format;
+} pg_inst = {true, 0, 0, 0, 0, N_IA_CSS_STREAM_FORMAT};
+
+static const char* stream_format2str[] = {
+	/*[IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY] =*/ "yuv420-8-legacy",
+	/*[IA_CSS_STREAM_FORMAT_YUV420_8]        =*/ "yuv420-8",
+	/*[IA_CSS_STREAM_FORMAT_YUV420_10]       =*/ "yuv420-10",
+	/*[IA_CSS_STREAM_FORMAT_YUV422_8]        =*/ "yuv422-8",
+	/*[IA_CSS_STREAM_FORMAT_YUV422_10]       =*/ "yuv422-10",
+	/*[IA_CSS_STREAM_FORMAT_RGB_444]         =*/ "rgb444",
+	/*[IA_CSS_STREAM_FORMAT_RGB_555]         =*/ "rgb555",
+	/*[IA_CSS_STREAM_FORMAT_RGB_565]         =*/ "rgb565",
+	/*[IA_CSS_STREAM_FORMAT_RGB_666]         =*/ "rgb666",
+	/*[IA_CSS_STREAM_FORMAT_RGB_888]         =*/ "rgb888",
+	/*[IA_CSS_STREAM_FORMAT_RAW_6]           =*/ "raw6",
+	/*[IA_CSS_STREAM_FORMAT_RAW_7]           =*/ "raw7",
+	/*[IA_CSS_STREAM_FORMAT_RAW_8]           =*/ "raw8",
+	/*[IA_CSS_STREAM_FORMAT_RAW_10]          =*/ "raw10",
+	/*[IA_CSS_STREAM_FORMAT_RAW_12]          =*/ "raw12",
+	/*[IA_CSS_STREAM_FORMAT_RAW_14]          =*/ "raw14",
+	/*[IA_CSS_STREAM_FORMAT_RAW_16]          =*/ "raw16",
+	/*[IA_CSS_STREAM_FORMAT_BINARY_8]        =*/ "binary8",
+	/*[IA_CSS_STREAM_FORMAT_GENERIC_SHORT1]  =*/ "generic-short1",
+	/*[IA_CSS_STREAM_FORMAT_GENERIC_SHORT2]  =*/ "generic-short2",
+	/*[IA_CSS_STREAM_FORMAT_GENERIC_SHORT3]  =*/ "generic-short3",
+	/*[IA_CSS_STREAM_FORMAT_GENERIC_SHORT4]  =*/ "generic-short4",
+	/*[IA_CSS_STREAM_FORMAT_GENERIC_SHORT5]  =*/ "generic-short5",
+	/*[IA_CSS_STREAM_FORMAT_GENERIC_SHORT6]  =*/ "generic-short6",
+	/*[IA_CSS_STREAM_FORMAT_GENERIC_SHORT7]  =*/ "generic-short7",
+	/*[IA_CSS_STREAM_FORMAT_GENERIC_SHORT8]  =*/ "generic-short8",
+	/*[IA_CSS_STREAM_FORMAT_YUV420_8_SHIFT]  =*/ "yuv420-8",
+	/*[IA_CSS_STREAM_FORMAT_YUV420_10_SHIFT] =*/ "yuv420-8",
+	/*[IA_CSS_STREAM_FORMAT_EMBEDDED]        =*/ "embedded-8",
+	/*[IA_CSS_STREAM_FORMAT_USER_DEF1]       =*/ "user-def-8-type-1",
+	/*[IA_CSS_STREAM_FORMAT_USER_DEF2]       =*/ "user-def-8-type-2",
+	/*[IA_CSS_STREAM_FORMAT_USER_DEF3]       =*/ "user-def-8-type-3",
+	/*[IA_CSS_STREAM_FORMAT_USER_DEF4]       =*/ "user-def-8-type-4",
+	/*[IA_CSS_STREAM_FORMAT_USER_DEF5]       =*/ "user-def-8-type-5",
+	/*[IA_CSS_STREAM_FORMAT_USER_DEF6]       =*/ "user-def-8-type-6",
+	/*[IA_CSS_STREAM_FORMAT_USER_DEF7]       =*/ "user-def-8-type-7",
+	/*[IA_CSS_STREAM_FORMAT_USER_DEF8]       =*/ "user-def-8-type-8",
+	/*[N_IA_CSS_STREAM_FORMAT]               =*/ "not_set"
+};
+
+static const char *qi2str[] = {
+	/*[sh_css_frame_in]     =*/ "in",
+	/*[sh_css_frame_out]    =*/ "out",
+	/*[sh_css_frame_out_vf] =*/ "out_vf",
+	/*[sh_css_frame_s3a]    =*/ "s3a",
+	/*[sh_css_frame_dis]    =*/ "dis"
+};
+
+static const char *pi2str[] = {
+	/*[IA_CSS_PIPE_ID_PREVIEW]     =*/ "preview",
+	/*[IA_CSS_PIPE_ID_COPY]        =*/ "copy",
+	/*[IA_CSS_PIPE_ID_VIDEO]       =*/ "video",
+	/*[IA_CSS_PIPE_ID_CAPTURE]     =*/ "capture",
+	/*[IA_CSS_PIPE_ID_ACC]         =*/ "accelerator"
+};
+
+static char dot_id_input_bin[20];
+static char ring_buffer[200];
+
+void ia_css_debug_set_dtrace_level(const unsigned int trace_level)
+{
+	ia_css_debug_trace_level = trace_level;
+	return;
+}
+
+static void debug_print_sp_state(const sp_state_t *state, const char *cell)
+{
+	assert(cell != NULL);
+	assert(state != NULL);
+
+	ia_css_debug_dtrace(2, "%s state:\n", cell);
+	ia_css_debug_dtrace(2, "\t%-32s: 0x%X\n", "PC", state->pc);
+	ia_css_debug_dtrace(2, "\t%-32s: 0x%X\n", "Status register",
+			    state->status_register);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "Is broken", state->is_broken);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "Is idle", state->is_idle);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "Is sleeping",
+			    state->is_sleeping);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "Is stalling",
+			    state->is_stalling);
+	return;
+}
+
+static void debug_print_isp_state(const isp_state_t *state, const char *cell)
+{
+	assert(state != NULL);
+	assert(cell != NULL);
+
+	ia_css_debug_dtrace(2, "%s state:\n", cell);
+	ia_css_debug_dtrace(2, "\t%-32s: 0x%X\n", "PC", state->pc);
+	ia_css_debug_dtrace(2, "\t%-32s: 0x%X\n", "Status register",
+			    state->status_register);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "Is broken", state->is_broken);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "Is idle", state->is_idle);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "Is sleeping",
+			    state->is_sleeping);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "Is stalling",
+			    state->is_stalling);
+	return;
+}
+
+void ia_css_debug_dump_isp_state(void)
+{
+	isp_state_t state;
+	isp_stall_t stall;
+
+	isp_get_state(ISP0_ID, &state, &stall);
+
+	debug_print_isp_state(&state, "ISP");
+
+	if (state.is_stalling) {
+#if !defined(HAS_NO_INPUT_FORMATTER)
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n",
+				    "[0] if_prim_a_FIFO stalled", stall.fifo0);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n",
+				    "[1] if_prim_b_FIFO stalled", stall.fifo1);
+#endif
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "[2] dma_FIFO stalled",
+				    stall.fifo2);
+#if defined(HAS_ISP_2400_MAMOIADA) || defined(HAS_ISP_2401_MAMOIADA) || \
+    defined(HAS_ISP_2500_SKYCAM)
+
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "[3] gdc0_FIFO stalled",
+				    stall.fifo3);
+#if !defined(IS_ISP_2500_SYSTEM)
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "[4] gdc1_FIFO stalled",
+				    stall.fifo4);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "[5] gpio_FIFO stalled",
+				    stall.fifo5);
+#endif
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "[6] sp_FIFO stalled",
+				    stall.fifo6);
+#else
+#error "ia_css_debug: ISP cell must be \
+	one of {2400_MAMOIADA,, 2401_MAMOIADA, 2500_SKYCAM}"
+#endif
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n",
+				    "status & control stalled",
+				    stall.stat_ctrl);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "dmem stalled",
+				    stall.dmem);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "vmem stalled",
+				    stall.vmem);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "vamem1 stalled",
+				    stall.vamem1);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "vamem2 stalled",
+				    stall.vamem2);
+#if defined(HAS_ISP_2400_MAMOIADA) || defined(HAS_ISP_2401_MAMOIADA)
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "vamem3 stalled",
+				    stall.vamem3);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "hmem stalled",
+				    stall.hmem);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "pmem stalled",
+				    stall.pmem);
+#endif
+	}
+	return;
+}
+
+void ia_css_debug_dump_sp_state(void)
+{
+	sp_state_t state;
+	sp_stall_t stall;
+	sp_get_state(SP0_ID, &state, &stall);
+	debug_print_sp_state(&state, "SP");
+	if (state.is_stalling) {
+#if defined(HAS_SP_2400) || defined(HAS_SP_2500)
+#if !defined(HAS_NO_INPUT_SYSTEM)
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "isys_FIFO stalled",
+				    stall.fifo0);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "if_sec_FIFO stalled",
+				    stall.fifo1);
+#endif
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n",
+				    "str_to_mem_FIFO stalled", stall.fifo2);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "dma_FIFO stalled",
+				    stall.fifo3);
+#if !defined(HAS_NO_INPUT_FORMATTER)
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n",
+				    "if_prim_a_FIFO stalled", stall.fifo4);
+#endif
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "isp_FIFO stalled",
+				    stall.fifo5);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "gp_FIFO stalled",
+				    stall.fifo6);
+#if !defined(HAS_NO_INPUT_FORMATTER)
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n",
+				    "if_prim_b_FIFO stalled", stall.fifo7);
+#endif
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "gdc0_FIFO stalled",
+				    stall.fifo8);
+#if !defined(IS_ISP2500_SYSTEM)
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "gdc1_FIFO stalled",
+				    stall.fifo9);
+#endif
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "irq FIFO stalled",
+				    stall.fifoa);
+#else
+#error "ia_css_debug: SP cell must be \
+	one of {SP2400, SP2500}"
+#endif
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "dmem stalled",
+				    stall.dmem);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n",
+				    "control master stalled",
+				    stall.control_master);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n",
+				    "i-cache master stalled",
+				    stall.icache_master);
+	}
+	return;
+}
+
+#if !defined(HAS_NO_INPUT_FORMATTER) && defined(USE_INPUT_SYSTEM_VERSION_2)
+static void debug_print_if_state(input_formatter_state_t *state)
+{
+	unsigned int val;
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_1)
+	const char *st_reset = (state->reset ? "Active" : "Not active");
+#endif
+	const char *st_vsync_active_low =
+	    (state->vsync_active_low ? "low" : "high");
+	const char *st_hsync_active_low =
+	    (state->hsync_active_low ? "low" : "high");
+
+	const char *fsm_sync_status_str = "unknown";
+	const char *fsm_crop_status_str = "unknown";
+	const char *fsm_padding_status_str = "unknown";
+
+	int st_stline = state->start_line;
+	int st_stcol = state->start_column;
+	int st_crpht = state->cropped_height;
+	int st_crpwd = state->cropped_width;
+	int st_verdcm = state->ver_decimation;
+	int st_hordcm = state->hor_decimation;
+	int st_ver_deinterleaving = state->ver_deinterleaving;
+	int st_hor_deinterleaving = state->hor_deinterleaving;
+	int st_leftpd = state->left_padding;
+	int st_eoloff = state->eol_offset;
+	int st_vmstartaddr = state->vmem_start_address;
+	int st_vmendaddr = state->vmem_end_address;
+	int st_vmincr = state->vmem_increment;
+	int st_yuv420 = state->is_yuv420;
+	int st_allow_fifo_overflow = state->allow_fifo_overflow;
+	int st_block_fifo_when_no_req = state->block_fifo_when_no_req;
+
+	assert(state != NULL);
+	ia_css_debug_dtrace(2, "InputFormatter State:\n");
+
+	ia_css_debug_dtrace(2, "\tConfiguration:\n");
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_1)
+	ia_css_debug_dtrace(2, "\t\t%-32s: %s\n", "Software reset", st_reset);
+#endif
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Start line", st_stline);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Start column", st_stcol);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Cropped height", st_crpht);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Cropped width", st_crpwd);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Ver decimation", st_verdcm);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Hor decimation", st_hordcm);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Ver deinterleaving", st_ver_deinterleaving);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Hor deinterleaving", st_hor_deinterleaving);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Left padding", st_leftpd);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "EOL offset (bytes)", st_eoloff);
+	ia_css_debug_dtrace(2, "\t\t%-32s: 0x%06X\n",
+			    "VMEM start address", st_vmstartaddr);
+	ia_css_debug_dtrace(2, "\t\t%-32s: 0x%06X\n",
+			    "VMEM end address", st_vmendaddr);
+	ia_css_debug_dtrace(2, "\t\t%-32s: 0x%06X\n",
+			    "VMEM increment", st_vmincr);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "YUV 420 format", st_yuv420);
+	ia_css_debug_dtrace(2, "\t\t%-32s: Active %s\n",
+			    "Vsync", st_vsync_active_low);
+	ia_css_debug_dtrace(2, "\t\t%-32s: Active %s\n",
+			    "Hsync", st_hsync_active_low);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Allow FIFO overflow", st_allow_fifo_overflow);
+/* Flag that tells whether the IF gives backpressure on frames */
+/*
+ * FYI, this is only on the frame request (indicate), when the IF has
+ * synch'd on a frame it will always give back pressure
+ */
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Block when no request", st_block_fifo_when_no_req);
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_2)
+	/***********************************************************
+	 * Hack for WHQL.
+	 *
+	 * AUTHOR: zhengjie.lu@intel.com
+	 * DATE: 2013-01-16
+	 * TIME: 12:35
+	 * LOCATION: Santa Clara
+	 * COMMENT: Print out the value of the register that tells
+	 * whehter the IF is set to the blocked mode (i.e. "1") or
+	 * not (i.e. "0").
+	 ***********************************************************/
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "IF_BLOCKED_FIFO_NO_REQ_ADDRESS",
+			    input_formatter_reg_load(INPUT_FORMATTER0_ID,
+			    HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS)
+	    );
+	/** End of hack for WHQL ***********************************/
+
+	/***********************************************************
+	 * Hack for WHQL.
+	 *
+	 * AUTHOR: zhengjie.lu@intel.com
+	 * DATE: 2013-01-23
+	 * TIME: 20:14
+	 * LOCATION: Santa Clara
+	 * COMMENT: Print out the input switch states.
+	 * not (i.e. "0").
+	 ***********************************************************/
+	ia_css_debug_dtrace(2, "\t%-32s:\n", "InputSwitch State");
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_input_switch_lut_reg0",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+			    _REG_GP_IFMT_input_switch_lut_reg0));
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_input_switch_lut_reg1",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+				_REG_GP_IFMT_input_switch_lut_reg1));
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_input_switch_lut_reg2",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+				_REG_GP_IFMT_input_switch_lut_reg2));
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_input_switch_lut_reg3",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+				_REG_GP_IFMT_input_switch_lut_reg3));
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_input_switch_lut_reg4",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+				_REG_GP_IFMT_input_switch_lut_reg4));
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_input_switch_lut_reg5",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+				_REG_GP_IFMT_input_switch_lut_reg5));
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_input_switch_lut_reg6",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+				_REG_GP_IFMT_input_switch_lut_reg6));
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_input_switch_lut_reg7",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+				_REG_GP_IFMT_input_switch_lut_reg7));
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_input_switch_fsync_lut",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+				_REG_GP_IFMT_input_switch_fsync_lut));
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_srst",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+				_REG_GP_IFMT_srst));
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "_REG_GP_IFMT_slv_reg_srst",
+			    gp_device_reg_load(GP_DEVICE0_ID,
+				 _REG_GP_IFMT_slv_reg_srst));
+	/** End of Hack for WHQL **********************************/
+
+#endif
+
+	ia_css_debug_dtrace(2, "\tFSM Status:\n");
+
+	val = state->fsm_sync_status;
+
+	if (val > 7)
+		fsm_sync_status_str = "ERROR";
+
+	switch (val & 0x7) {
+	case 0:
+		fsm_sync_status_str = "idle";
+		break;
+	case 1:
+		fsm_sync_status_str = "request frame";
+		break;
+	case 2:
+		fsm_sync_status_str = "request lines";
+		break;
+	case 3:
+		fsm_sync_status_str = "request vectors";
+		break;
+	case 4:
+		fsm_sync_status_str = "send acknowledge";
+		break;
+	default:
+		fsm_sync_status_str = "unknown";
+		break;
+	}
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: (0x%X: %s)\n",
+			    "FSM Synchronization Status", val,
+			    fsm_sync_status_str);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "FSM Synchronization Counter",
+			    state->fsm_sync_counter);
+
+	val = state->fsm_crop_status;
+
+	if (val > 7)
+		fsm_crop_status_str = "ERROR";
+
+	switch (val & 0x7) {
+	case 0:
+		fsm_crop_status_str = "idle";
+		break;
+	case 1:
+		fsm_crop_status_str = "wait line";
+		break;
+	case 2:
+		fsm_crop_status_str = "crop line";
+		break;
+	case 3:
+		fsm_crop_status_str = "crop pixel";
+		break;
+	case 4:
+		fsm_crop_status_str = "pass pixel";
+		break;
+	case 5:
+		fsm_crop_status_str = "pass line";
+		break;
+	case 6:
+		fsm_crop_status_str = "lost line";
+		break;
+	default:
+		fsm_crop_status_str = "unknown";
+		break;
+	}
+	ia_css_debug_dtrace(2, "\t\t%-32s: (0x%X: %s)\n",
+			    "FSM Crop Status", val, fsm_crop_status_str);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "FSM Crop Line Counter",
+			    state->fsm_crop_line_counter);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "FSM Crop Pixel Counter",
+			    state->fsm_crop_pixel_counter);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "FSM Deinterleaving idx buffer",
+			    state->fsm_deinterleaving_index);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "FSM H decimation counter",
+			    state->fsm_dec_h_counter);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "FSM V decimation counter",
+			    state->fsm_dec_v_counter);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "FSM block V decimation counter",
+			    state->fsm_dec_block_v_counter);
+
+	val = state->fsm_padding_status;
+
+	if (val > 7)
+		fsm_padding_status_str = "ERROR";
+
+	switch (val & 0x7) {
+	case 0:
+		fsm_padding_status_str = "idle";
+		break;
+	case 1:
+		fsm_padding_status_str = "left pad";
+		break;
+	case 2:
+		fsm_padding_status_str = "write";
+		break;
+	case 3:
+		fsm_padding_status_str = "right pad";
+		break;
+	case 4:
+		fsm_padding_status_str = "send end of line";
+		break;
+	default:
+		fsm_padding_status_str = "unknown";
+		break;
+	}
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: (0x%X: %s)\n", "FSM Padding Status",
+			    val, fsm_padding_status_str);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "FSM Padding element idx counter",
+			    state->fsm_padding_elem_counter);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Vector support error",
+			    state->fsm_vector_support_error);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Vector support buf full",
+			    state->fsm_vector_buffer_full);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Vector support",
+			    state->vector_support);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Fifo sensor data lost",
+			    state->sensor_data_lost);
+	return;
+}
+
+void ia_css_debug_dump_if_state(void)
+{
+	input_formatter_state_t state;
+	input_formatter_get_state(INPUT_FORMATTER0_ID, &state);
+	debug_print_if_state(&state);
+	ia_css_debug_dump_pif_isp_fifo_state();
+	return;
+}
+#endif
+
+void ia_css_debug_dump_dma_state(void)
+{
+	dma_state_t state;
+	int i, ch_id;
+
+	const char *fsm_cmd_st_lbl = "FSM Command flag state";
+	const char *fsm_ctl_st_lbl = "FSM Control flag state";
+	const char *fsm_ctl_state = NULL;
+	const char *fsm_ctl_flag = NULL;
+	const char *fsm_pack_st = NULL;
+	const char *fsm_read_st = NULL;
+	const char *fsm_write_st = NULL;
+	char last_cmd_str[64];
+
+	dma_get_state(DMA0_ID, &state);
+	/* Print header for DMA dump status */
+	ia_css_debug_dtrace(2, "DMA dump status:\n");
+
+	/* Print FSM command flag state */
+	if (state.fsm_command_idle)
+		ia_css_debug_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl, "IDLE");
+	if (state.fsm_command_run)
+		ia_css_debug_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl, "RUN");
+	if (state.fsm_command_stalling)
+		ia_css_debug_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl,
+				    "STALL");
+	if (state.fsm_command_error)
+		ia_css_debug_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl,
+				    "ERROR");
+
+	/* Print last command along with the channel */
+	ch_id = state.last_command_channel;
+
+	switch (state.last_command) {
+	case DMA_COMMAND_READ:
+		snprintf(last_cmd_str, 64,
+			 "Read 2D Block [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_WRITE:
+		snprintf(last_cmd_str, 64,
+			 "Write 2D Block [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_SET_CHANNEL:
+		snprintf(last_cmd_str, 64, "Set Channel [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_SET_PARAM:
+		snprintf(last_cmd_str, 64,
+			 "Set Param: %d [Channel: %d]",
+			 state.last_command_param, ch_id);
+		break;
+	case DMA_COMMAND_READ_SPECIFIC:
+		snprintf(last_cmd_str, 64,
+			 "Read Specific 2D Block [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_WRITE_SPECIFIC:
+		snprintf(last_cmd_str, 64,
+			 "Write Specific 2D Block [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_INIT:
+		snprintf(last_cmd_str, 64,
+			 "Init 2D Block on Device A [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_INIT_SPECIFIC:
+		snprintf(last_cmd_str, 64,
+			 "Init Specific 2D Block [Channel: %d]", ch_id);
+		break;
+	case DMA_COMMAND_RST:
+		snprintf(last_cmd_str, 64, "DMA SW Reset");
+		break;
+	case N_DMA_COMMANDS:
+		snprintf(last_cmd_str, 64, "UNKNOWN");
+		break;
+	default:
+		snprintf(last_cmd_str, 64,
+		  "unknown [Channel: %d]", ch_id);
+		break;
+	}
+	ia_css_debug_dtrace(2, "\t%-32s: (0x%X : %s)\n",
+			    "last command received", state.last_command,
+			    last_cmd_str);
+
+	/* Print DMA registers */
+	ia_css_debug_dtrace(2, "\t%-32s\n",
+			    "DMA registers, connection group 0");
+	ia_css_debug_dtrace(2, "\t\t%-32s: 0x%X\n", "Cmd Fifo Command",
+			    state.current_command);
+	ia_css_debug_dtrace(2, "\t\t%-32s: 0x%X\n", "Cmd Fifo Address A",
+			    state.current_addr_a);
+	ia_css_debug_dtrace(2, "\t\t%-32s: 0x%X\n", "Cmd Fifo Address B",
+			    state.current_addr_b);
+
+	if (state.fsm_ctrl_idle)
+		fsm_ctl_flag = "IDLE";
+	else if (state.fsm_ctrl_run)
+		fsm_ctl_flag = "RUN";
+	else if (state.fsm_ctrl_stalling)
+		fsm_ctl_flag = "STAL";
+	else if (state.fsm_ctrl_error)
+		fsm_ctl_flag = "ERROR";
+	else
+		fsm_ctl_flag = "UNKNOWN";
+
+	switch (state.fsm_ctrl_state) {
+	case DMA_CTRL_STATE_IDLE:
+		fsm_ctl_state = "Idle state";
+		break;
+	case DMA_CTRL_STATE_REQ_RCV:
+		fsm_ctl_state = "Req Rcv state";
+		break;
+	case DMA_CTRL_STATE_RCV:
+		fsm_ctl_state = "Rcv state";
+		break;
+	case DMA_CTRL_STATE_RCV_REQ:
+		fsm_ctl_state = "Rcv Req state";
+		break;
+	case DMA_CTRL_STATE_INIT:
+		fsm_ctl_state = "Init state";
+		break;
+	case N_DMA_CTRL_STATES:
+		fsm_ctl_state = "Unknown";
+		break;
+	}
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %s -> %s\n", fsm_ctl_st_lbl,
+			    fsm_ctl_flag, fsm_ctl_state);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl source dev",
+			    state.fsm_ctrl_source_dev);
+	ia_css_debug_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl source addr",
+			    state.fsm_ctrl_source_addr);
+	ia_css_debug_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl source stride",
+			    state.fsm_ctrl_source_stride);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl source width",
+			    state.fsm_ctrl_source_width);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl source height",
+			    state.fsm_ctrl_source_height);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack source dev",
+			    state.fsm_ctrl_pack_source_dev);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest dev",
+			    state.fsm_ctrl_pack_dest_dev);
+	ia_css_debug_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl dest addr",
+			    state.fsm_ctrl_dest_addr);
+	ia_css_debug_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl dest stride",
+			    state.fsm_ctrl_dest_stride);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack source width",
+			    state.fsm_ctrl_pack_source_width);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest height",
+			    state.fsm_ctrl_pack_dest_height);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest width",
+			    state.fsm_ctrl_pack_dest_width);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack source elems",
+			    state.fsm_ctrl_pack_source_elems);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest elems",
+			    state.fsm_ctrl_pack_dest_elems);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack extension",
+			    state.fsm_ctrl_pack_extension);
+
+	if (state.pack_idle)
+		fsm_pack_st = "IDLE";
+	if (state.pack_run)
+		fsm_pack_st = "RUN";
+	if (state.pack_stalling)
+		fsm_pack_st = "STALL";
+	if (state.pack_error)
+		fsm_pack_st = "ERROR";
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %s\n", "FSM Pack flag state",
+			    fsm_pack_st);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Pack cnt height",
+			    state.pack_cnt_height);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Pack src cnt width",
+			    state.pack_src_cnt_width);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Pack dest cnt width",
+			    state.pack_dest_cnt_width);
+
+	if (state.read_state == DMA_RW_STATE_IDLE)
+		fsm_read_st = "Idle state";
+	if (state.read_state == DMA_RW_STATE_REQ)
+		fsm_read_st = "Req state";
+	if (state.read_state == DMA_RW_STATE_NEXT_LINE)
+		fsm_read_st = "Next line";
+	if (state.read_state == DMA_RW_STATE_UNLOCK_CHANNEL)
+		fsm_read_st = "Unlock channel";
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %s\n", "FSM Read state",
+			    fsm_read_st);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Read cnt height",
+			    state.read_cnt_height);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Read cnt width",
+			    state.read_cnt_width);
+
+	if (state.write_state == DMA_RW_STATE_IDLE)
+		fsm_write_st = "Idle state";
+	if (state.write_state == DMA_RW_STATE_REQ)
+		fsm_write_st = "Req state";
+	if (state.write_state == DMA_RW_STATE_NEXT_LINE)
+		fsm_write_st = "Next line";
+	if (state.write_state == DMA_RW_STATE_UNLOCK_CHANNEL)
+		fsm_write_st = "Unlock channel";
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %s\n", "FSM Write state",
+			    fsm_write_st);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Write height",
+			    state.write_height);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "FSM Write width",
+			    state.write_width);
+
+	for (i = 0; i < HIVE_ISP_NUM_DMA_CONNS; i++) {
+		dma_port_state_t *port = &(state.port_states[i]);
+		ia_css_debug_dtrace(2, "\tDMA device interface %d\n", i);
+		ia_css_debug_dtrace(2, "\t\tDMA internal side state\n");
+		ia_css_debug_dtrace(2,
+				    "\t\t\tCS:%d - We_n:%d - Run:%d - Ack:%d\n",
+				    port->req_cs, port->req_we_n, port->req_run,
+				    port->req_ack);
+		ia_css_debug_dtrace(2, "\t\tMaster Output side state\n");
+		ia_css_debug_dtrace(2,
+				    "\t\t\tCS:%d - We_n:%d - Run:%d - Ack:%d\n",
+				    port->send_cs, port->send_we_n,
+				    port->send_run, port->send_ack);
+		ia_css_debug_dtrace(2, "\t\tFifo state\n");
+		if (port->fifo_state == DMA_FIFO_STATE_WILL_BE_FULL)
+			ia_css_debug_dtrace(2, "\t\t\tFiFo will be full\n");
+		else if (port->fifo_state == DMA_FIFO_STATE_FULL)
+			ia_css_debug_dtrace(2, "\t\t\tFifo Full\n");
+		else if (port->fifo_state == DMA_FIFO_STATE_EMPTY)
+			ia_css_debug_dtrace(2, "\t\t\tFifo Empty\n");
+		else
+			ia_css_debug_dtrace(2, "\t\t\tFifo state unknown\n");
+
+		ia_css_debug_dtrace(2, "\t\tFifo counter %d\n\n",
+				    port->fifo_counter);
+	}
+
+	for (i = 0; i < HIVE_DMA_NUM_CHANNELS; i++) {
+		dma_channel_state_t *ch = &(state.channel_states[i]);
+		ia_css_debug_dtrace(2, "\t%-32s: %d\n", "DMA channel register",
+				    i);
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Connection",
+				    ch->connection);
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Sign extend",
+				    ch->sign_extend);
+		ia_css_debug_dtrace(2, "\t\t%-32s: 0x%X\n", "Stride Dev A",
+				    ch->stride_a);
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Elems Dev A",
+				    ch->elems_a);
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Cropping Dev A",
+				    ch->cropping_a);
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Width Dev A",
+				    ch->width_a);
+		ia_css_debug_dtrace(2, "\t\t%-32s: 0x%X\n", "Stride Dev B",
+				    ch->stride_b);
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Elems Dev B",
+				    ch->elems_b);
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Cropping Dev B",
+				    ch->cropping_b);
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Width Dev B",
+				    ch->width_b);
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Height", ch->height);
+	}
+	ia_css_debug_dtrace(2, "\n");
+	return;
+}
+
+static void debug_print_fifo_channel_state(const fifo_channel_state_t *state,
+					   const char *descr)
+{
+	assert(state != NULL);
+	assert(descr != NULL);
+
+	ia_css_debug_dtrace(2, "FIFO channel: %s\n", descr);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "source valid",
+			    state->src_valid);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo accept",
+			    state->fifo_accept);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo valid",
+			    state->fifo_valid);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "sink accept",
+			    state->sink_accept);
+	return;
+}
+
+void ia_css_debug_dump_pif_isp_fifo_state(void)
+{
+	fifo_channel_state_t pif_to_isp, isp_to_pif;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);
+	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF A to ISP");
+	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF A)");
+	return;
+}
+
+void ia_css_debug_dump_dma_sp_fifo_state(void)
+{
+	fifo_channel_state_t dma_to_sp, sp_to_dma;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_DMA0_TO_SP0, &dma_to_sp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_SP0_TO_DMA0, &sp_to_dma);
+	debug_print_fifo_channel_state(&dma_to_sp, "DMA to SP");
+	debug_print_fifo_channel_state(&sp_to_dma, "SP to DMA");
+	return;
+}
+
+void ia_css_debug_dump_dma_isp_fifo_state(void)
+{
+	fifo_channel_state_t dma_to_isp, isp_to_dma;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_DMA0_TO_ISP0, &dma_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_ISP0_TO_DMA0, &isp_to_dma);
+	debug_print_fifo_channel_state(&dma_to_isp, "DMA to ISP");
+	debug_print_fifo_channel_state(&isp_to_dma, "ISP to DMA");
+	return;
+}
+
+void ia_css_debug_dump_isp_sp_fifo_state(void)
+{
+	fifo_channel_state_t sp_to_isp, isp_to_sp;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_SP0_TO_ISP0, &sp_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_ISP0_TO_SP0, &isp_to_sp);
+	debug_print_fifo_channel_state(&sp_to_isp, "SP to ISP");
+	debug_print_fifo_channel_state(&isp_to_sp, "ISP to SP");
+	return;
+}
+
+void ia_css_debug_dump_isp_gdc_fifo_state(void)
+{
+	fifo_channel_state_t gdc_to_isp, isp_to_gdc;
+
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_GDC0_TO_ISP0, &gdc_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_ISP0_TO_GDC0, &isp_to_gdc);
+	debug_print_fifo_channel_state(&gdc_to_isp, "GDC to ISP");
+	debug_print_fifo_channel_state(&isp_to_gdc, "ISP to GDC");
+	return;
+}
+
+void ia_css_debug_dump_all_fifo_state(void)
+{
+	int i;
+	fifo_monitor_state_t state;
+	fifo_monitor_get_state(FIFO_MONITOR0_ID, &state);
+
+	for (i = 0; i < N_FIFO_CHANNEL; i++)
+		debug_print_fifo_channel_state(&(state.fifo_channels[i]),
+					       "squepfstqkt");
+	return;
+}
+
+static void debug_binary_info_print(const struct ia_css_binary_xinfo *info)
+{
+	assert(info != NULL);
+	ia_css_debug_dtrace(2, "id = %d\n", info->sp.id);
+	ia_css_debug_dtrace(2, "mode = %d\n", info->sp.mode);
+	ia_css_debug_dtrace(2, "max_input_width = %d\n", info->sp.max_input_width);
+	ia_css_debug_dtrace(2, "min_output_width = %d\n",
+			    info->sp.min_output_width);
+	ia_css_debug_dtrace(2, "max_output_width = %d\n",
+			    info->sp.max_output_width);
+	ia_css_debug_dtrace(2, "top_cropping = %d\n", info->sp.top_cropping);
+	ia_css_debug_dtrace(2, "left_cropping = %d\n", info->sp.left_cropping);
+	ia_css_debug_dtrace(2, "xmem_addr = %d\n", info->xmem_addr);
+	ia_css_debug_dtrace(2, "enable_vf_veceven = %d\n",
+			    info->sp.enable.vf_veceven);
+	ia_css_debug_dtrace(2, "enable_dis = %d\n", info->sp.enable.dis);
+	ia_css_debug_dtrace(2, "enable_uds = %d\n", info->sp.enable.uds);
+	ia_css_debug_dtrace(2, "enable ds = %d\n", info->sp.enable.ds);
+	ia_css_debug_dtrace(2, "s3atbl_use_dmem = %d\n", info->sp.s3atbl_use_dmem);
+	return;
+}
+
+void ia_css_debug_binary_print(const struct ia_css_binary *bi)
+{
+	unsigned int i;
+	debug_binary_info_print(bi->info);
+	ia_css_debug_dtrace(2,
+			    "input:  %dx%d, format = %d, padded width = %d\n",
+			    bi->in_frame_info.res.width,
+			    bi->in_frame_info.res.height,
+			    bi->in_frame_info.format,
+			    bi->in_frame_info.padded_width);
+	ia_css_debug_dtrace(2,
+			    "internal :%dx%d, format = %d, padded width = %d\n",
+			    bi->internal_frame_info.res.width,
+			    bi->internal_frame_info.res.height,
+			    bi->internal_frame_info.format,
+			    bi->internal_frame_info.padded_width);
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		if (bi->out_frame_info[i].res.width != 0) {
+			ia_css_debug_dtrace(2,
+				    "out%d:    %dx%d, format = %d, padded width = %d\n",
+					i,
+				    bi->out_frame_info[i].res.width,
+				    bi->out_frame_info[i].res.height,
+				    bi->out_frame_info[i].format,
+				    bi->out_frame_info[i].padded_width);
+		}
+	}
+	ia_css_debug_dtrace(2,
+			    "vf out: %dx%d, format = %d, padded width = %d\n",
+			    bi->vf_frame_info.res.width,
+			    bi->vf_frame_info.res.height,
+			    bi->vf_frame_info.format,
+			    bi->vf_frame_info.padded_width);
+	ia_css_debug_dtrace(2, "online = %d\n", bi->online);
+	ia_css_debug_dtrace(2, "input_buf_vectors = %d\n",
+			    bi->input_buf_vectors);
+	ia_css_debug_dtrace(2, "deci_factor_log2 = %d\n", bi->deci_factor_log2);
+	ia_css_debug_dtrace(2, "vf_downscale_log2 = %d\n",
+			    bi->vf_downscale_log2);
+	ia_css_debug_dtrace(2, "dis_deci_factor_log2 = %d\n",
+			    bi->dis_deci_factor_log2);
+	ia_css_debug_dtrace(2, "dis hor coef num = %d\n",
+			    bi->dis_hor_coef_num_isp);
+	ia_css_debug_dtrace(2, "dis ver coef num = %d\n",
+			    bi->dis_ver_coef_num_isp);
+	ia_css_debug_dtrace(2, "dis hor proj num = %d\n",
+			    bi->dis_ver_proj_num_isp);
+	ia_css_debug_dtrace(2, "sctbl_width_per_color = %d\n",
+			    bi->sctbl_width_per_color);
+	ia_css_debug_dtrace(2, "s3atbl_width = %d\n", bi->s3atbl_width);
+	ia_css_debug_dtrace(2, "s3atbl_height = %d\n", bi->s3atbl_height);
+	return;
+}
+
+void ia_css_debug_frame_print(const struct ia_css_frame *frame,
+			      const char *descr)
+{
+	char *data = NULL;
+
+	assert(frame != NULL);
+	assert(descr != NULL);
+
+	data = (char *)HOST_ADDRESS(frame->data);
+	ia_css_debug_dtrace(2, "frame %s (%p):\n", descr, frame);
+	ia_css_debug_dtrace(2, "  resolution    = %dx%d\n",
+			    frame->info.res.width, frame->info.res.height);
+	ia_css_debug_dtrace(2, "  padded width  = %d\n",
+			    frame->info.padded_width);
+	ia_css_debug_dtrace(2, "  format        = %d\n", frame->info.format);
+	ia_css_debug_dtrace(2, "  is contiguous = %s\n",
+			    frame->contiguous ? "yes" : "no");
+	switch (frame->info.format) {
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV16:
+	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV61:
+		ia_css_debug_dtrace(2, "  Y = %p\n",
+				    data + frame->planes.nv.y.offset);
+		ia_css_debug_dtrace(2, "  UV = %p\n",
+				    data + frame->planes.nv.uv.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_UYVY:
+	case IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+		ia_css_debug_dtrace(2, "  YUYV = %p\n",
+				    data + frame->planes.yuyv.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YUV422:
+	case IA_CSS_FRAME_FORMAT_YUV444:
+	case IA_CSS_FRAME_FORMAT_YV12:
+	case IA_CSS_FRAME_FORMAT_YV16:
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+	case IA_CSS_FRAME_FORMAT_YUV422_16:
+		ia_css_debug_dtrace(2, "  Y = %p\n",
+				    data + frame->planes.yuv.y.offset);
+		ia_css_debug_dtrace(2, "  U = %p\n",
+				    data + frame->planes.yuv.u.offset);
+		ia_css_debug_dtrace(2, "  V = %p\n",
+				    data + frame->planes.yuv.v.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_RAW_PACKED:
+		ia_css_debug_dtrace(2, "  RAW PACKED = %p\n",
+				    data + frame->planes.raw.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_RAW:
+		ia_css_debug_dtrace(2, "  RAW = %p\n",
+				    data + frame->planes.raw.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_RGBA888:
+	case IA_CSS_FRAME_FORMAT_RGB565:
+		ia_css_debug_dtrace(2, "  RGB = %p\n",
+				    data + frame->planes.rgb.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+		ia_css_debug_dtrace(2, "  R    = %p\n",
+				    data + frame->planes.plane6.r.offset);
+		ia_css_debug_dtrace(2, "  RatB = %p\n",
+				    data + frame->planes.plane6.r_at_b.offset);
+		ia_css_debug_dtrace(2, "  Gr   = %p\n",
+				    data + frame->planes.plane6.gr.offset);
+		ia_css_debug_dtrace(2, "  Gb   = %p\n",
+				    data + frame->planes.plane6.gb.offset);
+		ia_css_debug_dtrace(2, "  B    = %p\n",
+				    data + frame->planes.plane6.b.offset);
+		ia_css_debug_dtrace(2, "  BatR = %p\n",
+				    data + frame->planes.plane6.b_at_r.offset);
+		break;
+	case IA_CSS_FRAME_FORMAT_BINARY_8:
+		ia_css_debug_dtrace(2, "  Binary data = %p\n",
+				    data + frame->planes.binary.data.offset);
+		break;
+	default:
+		ia_css_debug_dtrace(2, "  unknown frame type\n");
+		break;
+	}
+	return;
+}
+
+#if SP_DEBUG != SP_DEBUG_NONE
+
+void ia_css_debug_print_sp_debug_state(const struct sh_css_sp_debug_state
+				       *state)
+{
+
+#endif
+
+#if SP_DEBUG == SP_DEBUG_DUMP
+
+	assert(state != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "current SP software counter: %d\n",
+			    state->debug[0]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty output buffer queue head: 0x%x\n",
+			    state->debug[1]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty output buffer queue tail: 0x%x\n",
+			    state->debug[2]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty s3a buffer queue head: 0x%x\n",
+			    state->debug[3]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty s3a buffer queue tail: 0x%x\n",
+			    state->debug[4]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "full output buffer queue head: 0x%x\n",
+			    state->debug[5]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "full output buffer queue tail: 0x%x\n",
+			    state->debug[6]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "full s3a buffer queue head: 0x%x\n",
+			    state->debug[7]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "full s3a buffer queue tail: 0x%x\n",
+			    state->debug[8]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "event queue head: 0x%x\n",
+			    state->debug[9]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "event queue tail: 0x%x\n",
+			    state->debug[10]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "num of stages of current pipeline: 0x%x\n",
+			    state->debug[11]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "DDR address of stage 1: 0x%x\n",
+			    state->debug[12]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "DDR address of stage 2: 0x%x\n",
+			    state->debug[13]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "current stage out_vf buffer idx: 0x%x\n",
+			    state->debug[14]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "current stage output buffer idx: 0x%x\n",
+			    state->debug[15]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "current stage s3a buffer idx: 0x%x\n",
+			    state->debug[16]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "first char of current stage name: 0x%x\n",
+			    state->debug[17]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "current SP thread id: 0x%x\n",
+			    state->debug[18]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty output buffer address 1: 0x%x\n",
+			    state->debug[19]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty output buffer address 2: 0x%x\n",
+			    state->debug[20]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty out_vf buffer address 1: 0x%x\n",
+			    state->debug[21]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty out_vf buffer address 2: 0x%x\n",
+			    state->debug[22]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty s3a_hi buffer address 1: 0x%x\n",
+			    state->debug[23]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty s3a_hi buffer address 2: 0x%x\n",
+			    state->debug[24]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty s3a_lo buffer address 1: 0x%x\n",
+			    state->debug[25]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty s3a_lo buffer address 2: 0x%x\n",
+			    state->debug[26]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty dis_hor buffer address 1: 0x%x\n",
+			    state->debug[27]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty dis_hor buffer address 2: 0x%x\n",
+			    state->debug[28]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty dis_ver buffer address 1: 0x%x\n",
+			    state->debug[29]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty dis_ver buffer address 2: 0x%x\n",
+			    state->debug[30]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "empty param buffer address: 0x%x\n",
+			    state->debug[31]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "first incorrect frame address: 0x%x\n",
+			    state->debug[32]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "first incorrect frame container address: 0x%x\n",
+			    state->debug[33]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "first incorrect frame container payload: 0x%x\n",
+			    state->debug[34]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "first incorrect s3a_hi address: 0x%x\n",
+			    state->debug[35]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "first incorrect s3a_hi container address: 0x%x\n",
+			    state->debug[36]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "first incorrect s3a_hi container payload: 0x%x\n",
+			    state->debug[37]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "first incorrect s3a_lo address: 0x%x\n",
+			    state->debug[38]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "first incorrect s3a_lo container address: 0x%x\n",
+			    state->debug[39]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "first incorrect s3a_lo container payload: 0x%x\n",
+			    state->debug[40]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "number of calling flash start function: 0x%x\n",
+			    state->debug[41]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "number of calling flash close function: 0x%x\n",
+			    state->debug[42]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "number of flashed frame: 0x%x\n",
+			    state->debug[43]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "flash in use flag: 0x%x\n",
+			    state->debug[44]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "number of update frame flashed flag: 0x%x\n",
+			    state->debug[46]);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			    "number of active threads: 0x%x\n",
+			    state->debug[45]);
+
+#elif SP_DEBUG == SP_DEBUG_COPY
+
+	/* Remember last_index because we only want to print new entries */
+	static int last_index;
+	int sp_index = state->index;
+	int n;
+
+	assert(state != NULL);
+	if (sp_index < last_index) {
+		/* SP has been reset */
+		last_index = 0;
+	}
+
+	if (last_index == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+				    "copy-trace init: sp_dbg_if_start_line=%d, "
+				    "sp_dbg_if_start_column=%d, "
+				    "sp_dbg_if_cropped_height=%d, "
+				    "sp_debg_if_cropped_width=%d\n",
+				    state->if_start_line,
+				    state->if_start_column,
+				    state->if_cropped_height,
+				    state->if_cropped_width);
+	}
+
+	if ((last_index + SH_CSS_SP_DBG_TRACE_DEPTH) < sp_index) {
+		/* last index can be multiple rounds behind */
+		/* while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH */
+		last_index = sp_index - SH_CSS_SP_DBG_TRACE_DEPTH;
+	}
+
+	for (n = last_index; n < sp_index; n++) {
+		int i = n % SH_CSS_SP_DBG_TRACE_DEPTH;
+		if (state->trace[i].frame != 0) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+					    "copy-trace: frame=%d, line=%d, "
+					    "pixel_distance=%d, "
+					    "mipi_used_dword=%d, "
+					    "sp_index=%d\n",
+					    state->trace[i].frame,
+					    state->trace[i].line,
+					    state->trace[i].pixel_distance,
+					    state->trace[i].mipi_used_dword,
+					    state->trace[i].sp_index);
+		}
+	}
+
+	last_index = sp_index;
+
+#elif SP_DEBUG == SP_DEBUG_TRACE
+
+/**
+ * This is just an example how TRACE_FILE_ID (see ia_css_debug.sp.h) will
+ * me mapped on the file name string.
+ *
+ * Adjust this to your trace case!
+ */
+	static char const *id2filename[8] = {
+		"param_buffer.sp.c | tagger.sp.c | pipe_data.sp.c",
+		"isp_init.sp.c",
+		"sp_raw_copy.hive.c",
+		"dma_configure.sp.c",
+		"sp.hive.c",
+		"event_proxy_sp.hive.c",
+		"circular_buffer.sp.c",
+		"frame_buffer.sp.c"
+	};
+
+#if 1
+	/* Example SH_CSS_SP_DBG_NR_OF_TRACES==1 */
+	/* Adjust this to your trace case */
+	static char const *trace_name[SH_CSS_SP_DBG_NR_OF_TRACES] = {
+		"default"
+	};
+#else
+	/* Example SH_CSS_SP_DBG_NR_OF_TRACES==4 */
+	/* Adjust this to your trace case */
+	static char const *trace_name[SH_CSS_SP_DBG_NR_OF_TRACES] = {
+		"copy", "preview/video", "capture", "acceleration"
+	};
+#endif
+
+	/* Remember host_index_last because we only want to print new entries */
+	static int host_index_last[SH_CSS_SP_DBG_NR_OF_TRACES] = { 0 };
+	int t, n;
+
+	assert(state != NULL);
+
+	for (t = 0; t < SH_CSS_SP_DBG_NR_OF_TRACES; t++) {
+		int sp_index_last = state->index_last[t];
+
+		if (sp_index_last < host_index_last[t]) {
+			/* SP has been reset */
+			host_index_last[t] = 0;
+		}
+
+		if ((host_index_last[t] + SH_CSS_SP_DBG_TRACE_DEPTH) <
+		    sp_index_last) {
+			/* last index can be multiple rounds behind */
+			/* while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH */
+			ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+					    "Warning: trace %s has gap of %d "
+					    "traces\n",
+					    trace_name[t],
+					    (sp_index_last -
+					     (host_index_last[t] +
+					      SH_CSS_SP_DBG_TRACE_DEPTH)));
+
+			host_index_last[t] =
+			    sp_index_last - SH_CSS_SP_DBG_TRACE_DEPTH;
+		}
+
+		for (n = host_index_last[t]; n < sp_index_last; n++) {
+			int i = n % SH_CSS_SP_DBG_TRACE_DEPTH;
+			int l = state->trace[t][i].location &
+			    ((1 << SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS) - 1);
+			int fid = state->trace[t][i].location >>
+			    SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS;
+			int ts = state->trace[t][i].time_stamp;
+
+			if (ts) {
+				ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+						    "%05d trace=%s, file=%s:%d, "
+						    "data=0x%08x\n",
+						    ts,
+						    trace_name[t],
+						    id2filename[fid], l,
+						    state->trace[t][i].data);
+			}
+		}
+		host_index_last[t] = sp_index_last;
+	}
+
+#elif SP_DEBUG == SP_DEBUG_MINIMAL
+	int i;
+	int base = 0;
+	int limit = SH_CSS_NUM_SP_DEBUG;
+	int step = 1;
+
+	assert(state != NULL);
+
+	for (i = base; i < limit; i += step) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+				    "sp_dbg_trace[%d] = %d\n",
+				    i, state->debug[i]);
+	}
+#endif
+
+#if SP_DEBUG != SP_DEBUG_NONE
+
+	return;
+}
+#endif
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_2) && !defined(HAS_NO_INPUT_FORMATTER)
+static void debug_print_rx_mipi_port_state(mipi_port_state_t *state)
+{
+	int i;
+
+	assert(state != NULL);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "device_ready", state->device_ready);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "irq_status", state->irq_status);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "irq_enable", state->irq_enable);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "timeout_count", state->timeout_count);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "init_count", state->init_count);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "raw16_18", state->raw16_18);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "sync_count", state->sync_count);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "rx_count", state->rx_count);
+
+	for (i = 0; i < MIPI_4LANE_CFG; i++) {
+		ia_css_debug_dtrace(2, "\t\t%-32s%d%-32s: %d\n",
+				    "lane_sync_count[", i, "]",
+				    state->lane_sync_count[i]);
+	}
+
+	for (i = 0; i < MIPI_4LANE_CFG; i++) {
+		ia_css_debug_dtrace(2, "\t\t%-32s%d%-32s: %d\n",
+				    "lane_rx_count[", i, "]",
+				    state->lane_rx_count[i]);
+	}
+
+	return;
+}
+
+static void debug_print_rx_channel_state(rx_channel_state_t *state)
+{
+	int i;
+
+	assert(state != NULL);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "compression_scheme0", state->comp_scheme0);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "compression_scheme1", state->comp_scheme1);
+
+	for (i = 0; i < N_MIPI_FORMAT_CUSTOM; i++) {
+		ia_css_debug_dtrace(2, "\t\t%-32s%d: %d\n",
+				    "MIPI Predictor ", i, state->pred[i]);
+	}
+
+	for (i = 0; i < N_MIPI_FORMAT_CUSTOM; i++) {
+		ia_css_debug_dtrace(2, "\t\t%-32s%d: %d\n",
+				    "MIPI Compressor ", i, state->comp[i]);
+	}
+
+	return;
+}
+
+static void debug_print_rx_state(receiver_state_t *state)
+{
+	int i;
+
+	assert(state != NULL);
+	ia_css_debug_dtrace(2, "CSI Receiver State:\n");
+
+	ia_css_debug_dtrace(2, "\tConfiguration:\n");
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "fs_to_ls_delay", state->fs_to_ls_delay);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "ls_to_data_delay", state->ls_to_data_delay);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "data_to_le_delay", state->data_to_le_delay);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "le_to_fe_delay", state->le_to_fe_delay);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "fe_to_fs_delay", state->fe_to_fs_delay);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "le_to_fs_delay", state->le_to_fs_delay);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "is_two_ppc", state->is_two_ppc);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "backend_rst", state->backend_rst);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "raw18", state->raw18);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "force_raw8", state->force_raw8);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "raw16", state->raw16);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_gsp_acc_ovl", state->be_gsp_acc_ovl);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "be_srst", state->be_srst);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_is_two_ppc", state->be_is_two_ppc);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_comp_format0", state->be_comp_format0);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_comp_format1", state->be_comp_format1);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_comp_format2", state->be_comp_format2);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_comp_format3", state->be_comp_format3);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "be_sel", state->be_sel);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_raw16_config", state->be_raw16_config);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_raw18_config", state->be_raw18_config);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_force_raw8", state->be_force_raw8);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_irq_status", state->be_irq_status);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "be_irq_clear", state->be_irq_clear);
+
+	/* mipi port state */
+	for (i = 0; i < N_MIPI_PORT_ID; i++) {
+		ia_css_debug_dtrace(2, "\tMIPI Port %d State:\n", i);
+
+		debug_print_rx_mipi_port_state(&state->mipi_port_state[i]);
+	}
+	/* end of mipi port state */
+
+	/* rx channel state */
+	for (i = 0; i < N_RX_CHANNEL_ID; i++) {
+		ia_css_debug_dtrace(2, "\tRX Channel %d State:\n", i);
+
+		debug_print_rx_channel_state(&state->rx_channel_state[i]);
+	}
+	/* end of rx channel state */
+
+	return;
+}
+#endif
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+void ia_css_debug_dump_rx_state(void)
+{
+#if defined(HAS_INPUT_FORMATTER_VERSION_2)
+	receiver_state_t state;
+#endif
+	unsigned int infos = 0, bits;
+	bits = ia_css_isys_rx_get_interrupt_reg();
+	ia_css_rx_get_irq_info(&infos);
+
+	ia_css_debug_dtrace(2, "CSI Receiver errors: (irq reg = 0x%X)\n", bits);
+
+	if (infos & IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
+		ia_css_debug_dtrace(2, "\tbuffer overrun\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT)
+		ia_css_debug_dtrace(2, "\tstart-of-transmission error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)
+		ia_css_debug_dtrace(2, "\tstart-of-transmission sync error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_CONTROL)
+		ia_css_debug_dtrace(2, "\tcontrol error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)
+		ia_css_debug_dtrace(2, "\t2 or more ECC errors\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_CRC)
+		ia_css_debug_dtrace(2, "\tCRC mismatch\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)
+		ia_css_debug_dtrace(2, "\tunknown error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)
+		ia_css_debug_dtrace(2, "\tframe sync error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)
+		ia_css_debug_dtrace(2, "\tframe data error\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)
+		ia_css_debug_dtrace(2, "\tdata timeout\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)
+		ia_css_debug_dtrace(2, "\tunknown escape command entry\n");
+	if (infos & IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
+		ia_css_debug_dtrace(2, "\tline sync error\n");
+
+#if defined(HAS_INPUT_FORMATTER_VERSION_2) && !defined(HAS_NO_INPUT_FORMATTER)
+	receiver_get_state(RX0_ID, &state);
+	debug_print_rx_state(&state);
+#endif
+	return;
+}
+#endif
+
+void ia_css_debug_dump_sp_sw_debug_info(void)
+{
+#if SP_DEBUG != SP_DEBUG_NONE
+	struct sh_css_sp_debug_state state;
+
+	sh_css_sp_get_debug_state(&state);
+	ia_css_debug_print_sp_debug_state(&state);
+#endif
+	return;
+}
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2)
+static void debug_print_isys_capture_unit_state(capture_unit_state_t *state)
+{
+	assert(state != NULL);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Packet_Length", state->Packet_Length);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Received_Length", state->Received_Length);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Received_Short_Packets",
+			    state->Received_Short_Packets);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Received_Long_Packets",
+			    state->Received_Long_Packets);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Last_Command", state->Last_Command);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Next_Command", state->Next_Command);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Last_Acknowledge", state->Last_Acknowledge);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Next_Acknowledge", state->Next_Acknowledge);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "FSM_State_Info", state->FSM_State_Info);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "StartMode", state->StartMode);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Start_Addr", state->Start_Addr);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Mem_Region_Size", state->Mem_Region_Size);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Num_Mem_Regions", state->Num_Mem_Regions);
+#if 0
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Init", state->Init);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Start", state->Start);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Stop", state->Stop);
+#endif
+	return;
+}
+
+static void debug_print_isys_acquisition_unit_state(
+				acquisition_unit_state_t *state)
+{
+	assert(state != NULL);
+#if 0
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "Init", state->Init);
+#endif
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Received_Short_Packets",
+			    state->Received_Short_Packets);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Received_Long_Packets",
+			    state->Received_Long_Packets);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Last_Command", state->Last_Command);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Next_Command", state->Next_Command);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Last_Acknowledge", state->Last_Acknowledge);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Next_Acknowledge", state->Next_Acknowledge);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "FSM_State_Info", state->FSM_State_Info);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Int_Cntr_Info", state->Int_Cntr_Info);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Start_Addr", state->Start_Addr);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Mem_Region_Size", state->Mem_Region_Size);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "Num_Mem_Regions", state->Num_Mem_Regions);
+}
+
+static void debug_print_isys_ctrl_unit_state(ctrl_unit_state_t *state)
+{
+	assert(state != NULL);
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "last_cmd", state->last_cmd);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "next_cmd", state->next_cmd);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "last_ack", state->last_ack);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n", "next_ack", state->next_ack);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "top_fsm_state", state->top_fsm_state);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captA_fsm_state", state->captA_fsm_state);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captB_fsm_state", state->captB_fsm_state);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captC_fsm_state", state->captC_fsm_state);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "acq_fsm_state", state->acq_fsm_state);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captA_start_addr", state->captA_start_addr);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captB_start_addr", state->captB_start_addr);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captC_start_addr", state->captC_start_addr);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captA_mem_region_size",
+			    state->captA_mem_region_size);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captB_mem_region_size",
+			    state->captB_mem_region_size);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captC_mem_region_size",
+			    state->captC_mem_region_size);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captA_num_mem_regions",
+			    state->captA_num_mem_regions);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captB_num_mem_regions",
+			    state->captB_num_mem_regions);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "captC_num_mem_regions",
+			    state->captC_num_mem_regions);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "acq_start_addr", state->acq_start_addr);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "acq_mem_region_size", state->acq_mem_region_size);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "acq_num_mem_regions", state->acq_num_mem_regions);
+#if 0
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "ctrl_init", state->ctrl_init);
+#endif
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "capt_reserve_one_mem_region",
+			    state->capt_reserve_one_mem_region);
+
+	return;
+}
+
+static void debug_print_isys_state(input_system_state_t *state)
+{
+	int i;
+
+	assert(state != NULL);
+	ia_css_debug_dtrace(2, "InputSystem State:\n");
+
+	/* configuration */
+	ia_css_debug_dtrace(2, "\tConfiguration:\n");
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "str_multiCastA_sel", state->str_multicastA_sel);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "str_multicastB_sel", state->str_multicastB_sel);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "str_multicastC_sel", state->str_multicastC_sel);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "str_mux_sel", state->str_mux_sel);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "str_mon_status", state->str_mon_status);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "str_mon_irq_cond", state->str_mon_irq_cond);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "str_mon_irq_en", state->str_mon_irq_en);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "isys_srst", state->isys_srst);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "isys_slv_reg_srst", state->isys_slv_reg_srst);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "str_deint_portA_cnt", state->str_deint_portA_cnt);
+
+	ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+			    "str_deint_portB_cnd", state->str_deint_portB_cnt);
+	/* end of configuration */
+
+	/* capture unit state */
+	for (i = 0; i < N_CAPTURE_UNIT_ID; i++) {
+		capture_unit_state_t *capture_unit_state;
+
+		ia_css_debug_dtrace(2, "\tCaptureUnit %d State:\n", i);
+
+		capture_unit_state = &state->capture_unit[i];
+		debug_print_isys_capture_unit_state(capture_unit_state);
+	}
+	/* end of capture unit state */
+
+	/* acquisition unit state */
+	for (i = 0; i < N_ACQUISITION_UNIT_ID; i++) {
+		acquisition_unit_state_t *acquisition_unit_state;
+
+		ia_css_debug_dtrace(2, "\tAcquisitionUnit %d State:\n", i);
+
+		acquisition_unit_state = &state->acquisition_unit[i];
+		debug_print_isys_acquisition_unit_state(acquisition_unit_state);
+	}
+	/* end of acquisition unit state */
+
+	/* control unit state */
+	for (i = 0; i < N_CTRL_UNIT_ID; i++) {
+		ia_css_debug_dtrace(2, "\tControlUnit %d State:\n", i);
+
+		debug_print_isys_ctrl_unit_state(&state->ctrl_unit_state[i]);
+	}
+	/* end of control unit state */
+}
+
+void ia_css_debug_dump_isys_state(void)
+{
+	input_system_state_t state;
+
+	input_system_get_state(INPUT_SYSTEM0_ID, &state);
+	debug_print_isys_state(&state);
+
+	return;
+}
+#endif
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2401)
+void ia_css_debug_dump_isys_state(void)
+{
+	/* Android compilation fails if made a local variable
+	stack size on android is limited to 2k and this structure
+	is around 3.5K, in place of static malloc can be done but
+	if this call is made too often it will lead to fragment memory
+	versus a fixed allocation */
+	static input_system_state_t state;
+
+	input_system_get_state(INPUT_SYSTEM0_ID, &state);
+	input_system_dump_state(INPUT_SYSTEM0_ID, &state);
+}
+#endif
+
+void ia_css_debug_dump_debug_info(const char *context)
+{
+	if (context == NULL)
+		context = "No Context provided";
+
+	ia_css_debug_dtrace(2, "CSS Debug Info dump [Context = %s]\n", context);
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+	ia_css_debug_dump_rx_state();
+#endif
+#if !defined(HAS_NO_INPUT_FORMATTER) && defined(USE_INPUT_SYSTEM_VERSION_2)
+	ia_css_debug_dump_if_state();
+#endif
+	ia_css_debug_dump_isp_state();
+	ia_css_debug_dump_isp_sp_fifo_state();
+	ia_css_debug_dump_isp_gdc_fifo_state();
+	ia_css_debug_dump_sp_state();
+	ia_css_debug_dump_perf_counters();
+
+#ifdef HAS_WATCHDOG_SP_THREAD_DEBUG
+	sh_css_dump_thread_wait_info();
+	sh_css_dump_pipe_stage_info();
+	sh_css_dump_pipe_stripe_info();
+#endif
+	ia_css_debug_dump_dma_isp_fifo_state();
+	ia_css_debug_dump_dma_sp_fifo_state();
+	ia_css_debug_dump_dma_state();
+#if defined(USE_INPUT_SYSTEM_VERSION_2)
+	ia_css_debug_dump_isys_state();
+
+	{
+		irq_controller_state_t state;
+		irq_controller_get_state(IRQ2_ID, &state);
+
+		ia_css_debug_dtrace(2, "\t%-32s:\n",
+				    "Input System IRQ Controller State");
+
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+				    "irq_edge", state.irq_edge);
+
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+				    "irq_mask", state.irq_mask);
+
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+				    "irq_status", state.irq_status);
+
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+				    "irq_enable", state.irq_enable);
+
+		ia_css_debug_dtrace(2, "\t\t%-32s: %d\n",
+				    "irq_level_not_pulse",
+				    state.irq_level_not_pulse);
+	}
+#endif
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2401)
+	ia_css_debug_dump_isys_state();
+#endif
+	return;
+}
+
+/* this function is for debug use, it can make SP go to sleep
+  state after each frame, then user can dump the stable SP dmem.
+  this function can be called after sh_css_start()
+  and before sh_css_init_buffer_queues() */
+void ia_css_debug_enable_sp_sleep_mode(enum ia_css_sp_sleep_mode mode)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp_sleep_mode;
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_sp_sleep_mode = fw->info.sp.sleep_mode;
+
+	(void)HIVE_ADDR_sp_sleep_mode;	/* Suppres warnings in CRUN */
+
+	sp_dmem_store_uint32(SP0_ID,
+			     (unsigned int)sp_address_of(sp_sleep_mode),
+			     (uint32_t) mode);
+}
+
+void ia_css_debug_wake_up_sp(void)
+{
+	/*hrt_ctl_start(SP); */
+	sp_ctrl_setbit(SP0_ID, SP_SC_REG, SP_START_BIT);
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+#define FIND_DMEM_PARAMS_TYPE(stream, kernel, type) \
+  (struct HRTCAT(HRTCAT(sh_css_isp_,type),_params) *) \
+  findf_dmem_params(stream, offsetof(struct ia_css_memory_offsets, dmem.kernel))
+
+#define FIND_DMEM_PARAMS(stream, kernel) \
+  FIND_DMEM_PARAMS_TYPE(stream, kernel, kernel)
+
+/* Find a stage that support the kernel and return the parameters for that kernel */
+static char *
+findf_dmem_params(struct ia_css_stream *stream, short idx)
+{
+	int i;
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		struct ia_css_pipeline *pipeline = ia_css_pipe_get_pipeline(pipe);
+		struct ia_css_pipeline_stage *stage;
+		for (stage = pipeline->stages; stage; stage = stage->next) {
+			struct ia_css_binary *binary = stage->binary;
+			short *offsets = (short*)&binary->info->mem_offsets.offsets.param->dmem;
+			short dmem_offset = offsets[idx];
+			const struct ia_css_host_data *isp_data =
+				ia_css_isp_param_get_mem_init(&binary->mem_params, IA_CSS_PARAM_CLASS_PARAM, IA_CSS_ISP_DMEM0);
+			if (dmem_offset < 0) continue;
+			return &isp_data->address[dmem_offset];
+		}
+	}
+	return NULL;
+}
+#endif
+
+void ia_css_debug_dump_isp_params(struct ia_css_stream *stream,
+				  unsigned int enable)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "ISP PARAMETERS:\n");
+#if defined(IS_ISP_2500_SYSTEM)
+	(void)enable;
+	(void)stream;
+#else
+
+	assert(stream != NULL);
+	if ((enable & IA_CSS_DEBUG_DUMP_FPN)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_fpn_dump(FIND_DMEM_PARAMS(stream, fpn), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_OB)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_ob_dump(FIND_DMEM_PARAMS(stream, ob), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_SC)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_sc_dump(FIND_DMEM_PARAMS(stream, sc), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_WB)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_wb_dump(FIND_DMEM_PARAMS(stream, wb), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_DP)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_dp_dump(FIND_DMEM_PARAMS(stream, dp), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_BNR)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_bnr_dump(FIND_DMEM_PARAMS(stream, bnr), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_S3A)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_s3a_dump(FIND_DMEM_PARAMS(stream, s3a), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_DE)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_de_dump(FIND_DMEM_PARAMS(stream, de), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_YNR)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_nr_dump(FIND_DMEM_PARAMS_TYPE(stream, nr, ynr),  IA_CSS_DEBUG_VERBOSE);
+		ia_css_yee_dump(FIND_DMEM_PARAMS(stream, yee), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_CSC)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_csc_dump(FIND_DMEM_PARAMS(stream, csc), IA_CSS_DEBUG_VERBOSE);
+		ia_css_yuv2rgb_dump(FIND_DMEM_PARAMS_TYPE(stream, yuv2rgb, csc), IA_CSS_DEBUG_VERBOSE);
+		ia_css_rgb2yuv_dump(FIND_DMEM_PARAMS_TYPE(stream, rgb2yuv, csc), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_GC)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_gc_dump(FIND_DMEM_PARAMS(stream, gc), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_TNR)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_tnr_dump(FIND_DMEM_PARAMS(stream, tnr), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_ANR)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_anr_dump(FIND_DMEM_PARAMS(stream, anr), IA_CSS_DEBUG_VERBOSE);
+	}
+	if ((enable & IA_CSS_DEBUG_DUMP_CE)
+	    || (enable & IA_CSS_DEBUG_DUMP_ALL)) {
+		ia_css_ce_dump(FIND_DMEM_PARAMS(stream, ce), IA_CSS_DEBUG_VERBOSE);
+	}
+#endif
+}
+
+void sh_css_dump_sp_raw_copy_linecount(bool reduced)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_raw_copy_line_count;
+	int32_t raw_copy_line_count;
+	static int32_t prev_raw_copy_line_count = -1;
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_raw_copy_line_count =
+			fw->info.sp.raw_copy_line_count;
+
+	(void)HIVE_ADDR_raw_copy_line_count;
+
+	sp_dmem_load(SP0_ID,
+		(unsigned int)sp_address_of(raw_copy_line_count),
+		     &raw_copy_line_count,
+		     sizeof(raw_copy_line_count));
+
+	/* only indicate if copy loop is active */
+	if (reduced)
+		raw_copy_line_count = (raw_copy_line_count < 0)?raw_copy_line_count:1;
+	/* do the handling */
+	if (prev_raw_copy_line_count != raw_copy_line_count) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			"sh_css_dump_sp_raw_copy_linecount() "
+			"line_count=%d\n",
+			raw_copy_line_count);
+		prev_raw_copy_line_count = raw_copy_line_count;
+	}
+}
+
+void ia_css_debug_dump_isp_binary(void)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_pipeline_sp_curr_binary_id;
+	uint32_t curr_binary_id;
+	static uint32_t prev_binary_id = 0xFFFFFFFF;
+	static uint32_t sample_count = 0;
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_pipeline_sp_curr_binary_id = fw->info.sp.curr_binary_id;
+
+	(void)HIVE_ADDR_pipeline_sp_curr_binary_id;
+
+	sp_dmem_load(SP0_ID,
+		     (unsigned int)sp_address_of(pipeline_sp_curr_binary_id),
+		     &curr_binary_id,
+		     sizeof(curr_binary_id));
+
+	/* do the handling */
+	sample_count++;
+	if (prev_binary_id != curr_binary_id) {
+	    ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+				"sh_css_dump_isp_binary() "
+				"pipe_id=%d, binary_id=%d, sample_count=%d\n",
+				(curr_binary_id >> 16),
+				(curr_binary_id & 0x0ffff),
+				sample_count);
+	    sample_count = 0;
+	    prev_binary_id = curr_binary_id;
+	}
+}
+
+void ia_css_debug_dump_perf_counters(void)
+{
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+	const struct ia_css_fw_info *fw;
+	int i;
+	unsigned int HIVE_ADDR_ia_css_isys_sp_error_cnt;
+	int32_t ia_css_sp_input_system_error_cnt[N_MIPI_PORT_ID + 1]; // 3 Capture Units and 1 Acquire Unit.
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "Input System Error Counters:\n");
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_ia_css_isys_sp_error_cnt =
+	    fw->info.sp.perf_counter_input_system_error;
+
+	(void)HIVE_ADDR_ia_css_isys_sp_error_cnt;
+
+	sp_dmem_load(SP0_ID,
+		     (unsigned int)sp_address_of(ia_css_isys_sp_error_cnt),
+		     &ia_css_sp_input_system_error_cnt,
+		     sizeof(ia_css_sp_input_system_error_cnt));
+
+	for (i = 0; i < N_MIPI_PORT_ID + 1; i++) {
+	    ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "\tport[%d] = %d\n",
+				i, ia_css_sp_input_system_error_cnt[i]);
+	}
+#endif
+}
+
+/*
+
+void sh_css_init_ddr_debug_queue(void)
+{
+	hrt_vaddress ddr_debug_queue_addr =
+			mmgr_malloc(sizeof(debug_data_ddr_t));
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_debug_buffer_ddr_address;
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_debug_buffer_ddr_address =
+			fw->info.sp.debug_buffer_ddr_address;
+
+	(void)HIVE_ADDR_debug_buffer_ddr_address;
+
+	debug_buffer_ddr_init(ddr_debug_queue_addr);
+
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(debug_buffer_ddr_address),
+		(uint32_t)(ddr_debug_queue_addr));
+}
+
+void sh_css_load_ddr_debug_queue(void)
+{
+	debug_synch_queue_ddr();
+}
+
+void ia_css_debug_dump_ddr_debug_queue(void)
+{
+	int i;
+	sh_css_load_ddr_debug_queue();
+#ifdef __KERNEL__
+	for (i = 0; i < DEBUG_BUF_SIZE; i++)
+		printk(KERN_DEBUG, "ddr_debug_queue[%d] = 0x%x\n",
+				i, debug_data_ptr->buf[i]);
+#else
+	for (i = 0; i < DEBUG_BUF_SIZE; i++)
+		printf("ddr_debug_queue[%d] = 0x%x\n",
+				i, debug_data_ptr->buf[i]);
+#endif
+}
+*/
+
+/**
+ * @brief Initialize the debug mode.
+ * Refer to "ia_css_debug.h" for more details.
+ */
+bool ia_css_debug_mode_init(void)
+{
+	bool rc;
+	rc = sh_css_sp_init_dma_sw_reg(0);
+	return rc;
+}
+
+/**
+ * @brief Disable the DMA channel.
+ * Refer to "ia_css_debug.h" for more details.
+ */
+bool
+ia_css_debug_mode_disable_dma_channel(int dma_id,
+				      int channel_id, int request_type)
+{
+	bool rc;
+
+	rc = sh_css_sp_set_dma_sw_reg(dma_id, channel_id, request_type, false);
+
+	return rc;
+}
+
+/**
+ * @brief Enable the DMA channel.
+ * Refer to "ia_css_debug.h" for more details.
+ */
+bool
+ia_css_debug_mode_enable_dma_channel(int dma_id,
+				     int channel_id, int request_type)
+{
+	bool rc;
+
+	rc = sh_css_sp_set_dma_sw_reg(dma_id, channel_id, request_type, true);
+
+	return rc;
+}
+
+void dtrace_dot(const char *fmt, ...)
+{
+	va_list ap;
+#ifdef HRT_CSIM
+	va_list ap2;
+#endif
+
+	assert(fmt != NULL);
+	va_start(ap, fmt);
+#ifdef HRT_CSIM
+	va_copy(ap2, ap);
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_INFO, "%s", DPG_START);
+	ia_css_debug_vdtrace(IA_CSS_DEBUG_INFO, fmt, ap);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_INFO, "%s", DPG_END);
+#ifdef HRT_CSIM
+	/* For CSIM we print double because HSS log can mess up this output
+	 * As post processing, we remove incomplete lines and make lines uniq.
+	 **/
+	ia_css_debug_dtrace(IA_CSS_DEBUG_INFO, "%s", DPG_START);
+	ia_css_debug_vdtrace(IA_CSS_DEBUG_INFO, fmt, ap2);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_INFO, "%s", DPG_END);\
+
+	va_end(ap2);
+#endif
+	va_end(ap);
+}
+
+#ifdef HAS_WATCHDOG_SP_THREAD_DEBUG
+void sh_css_dump_thread_wait_info(void)
+{
+	const struct ia_css_fw_info *fw;
+	int i;
+	unsigned int HIVE_ADDR_sp_thread_wait;
+	int32_t sp_thread_wait[5];
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "SEM WAITS:\n");
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_sp_thread_wait =
+			fw->info.sp.debug_wait;
+
+	(void)HIVE_ADDR_sp_thread_wait;
+
+	sp_dmem_load(SP0_ID,
+		(unsigned int)sp_address_of(sp_thread_wait),
+		     &sp_thread_wait,
+		     sizeof(sp_thread_wait));
+	for (i=0; i < 5; i++) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			"\twait[%d] = 0x%X\n",
+			i, sp_thread_wait[i]);
+	}
+
+}
+
+void sh_css_dump_pipe_stage_info(void)
+{
+	const struct ia_css_fw_info *fw;
+	int i;
+	unsigned int HIVE_ADDR_sp_pipe_stage;
+	int32_t sp_pipe_stage[5];
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "PIPE STAGE:\n");
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_sp_pipe_stage =
+			fw->info.sp.debug_stage;
+
+	(void)HIVE_ADDR_sp_pipe_stage;
+
+	sp_dmem_load(SP0_ID,
+		(unsigned int)sp_address_of(sp_pipe_stage),
+		     &sp_pipe_stage,
+		     sizeof(sp_pipe_stage));
+	for (i=0; i < 5; i++) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			"\tstage[%d] = %d\n",
+			i, sp_pipe_stage[i]);
+	}
+
+}
+
+void sh_css_dump_pipe_stripe_info(void)
+{
+	const struct ia_css_fw_info *fw;
+	int i;
+	unsigned int HIVE_ADDR_sp_pipe_stripe;
+	int32_t sp_pipe_stripe[5];
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "PIPE STRIPE:\n");
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_sp_pipe_stripe =
+			fw->info.sp.debug_stripe;
+
+	(void)HIVE_ADDR_sp_pipe_stripe;
+
+	sp_dmem_load(SP0_ID,
+		(unsigned int)sp_address_of(sp_pipe_stripe),
+		     &sp_pipe_stripe,
+		     sizeof(sp_pipe_stripe));
+	for (i=0; i < 5; i++) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			"\tstripe[%d] = %d\n",
+			i, sp_pipe_stripe[i]);
+	}
+
+}
+#endif
+
+static void
+ia_css_debug_pipe_graph_dump_frame(
+	struct ia_css_frame *frame,
+	enum ia_css_pipe_id id,
+	char const *blob_name,
+	char const *frame_name,
+	bool in_frame)
+{
+	char bufinfo[100];
+
+	if (frame->dynamic_data_index == -1) {
+		snprintf(bufinfo, sizeof(bufinfo), "Internal");
+	} else {
+		snprintf(bufinfo, sizeof(bufinfo), "Queue: %s %s",
+			pi2str[id],
+			qi2str[frame->dynamic_data_index]);
+	}
+	dtrace_dot(
+		"node [shape = box, "
+		"fixedsize=true, width=2, height=0.7]; \"0x%08lx\" "
+		"[label = \"%s\\n%d(%d) x %d\\n%s\"];",
+		HOST_ADDRESS(frame),
+		format2str[frame->info.format],
+		frame->info.res.width,
+		frame->info.padded_width,
+		frame->info.res.height,
+		bufinfo);
+
+	if (in_frame){
+		dtrace_dot(
+			"\"0x%08lx\"->\"%s(pipe%d)\" "
+			"[label = %s_frame];",
+			HOST_ADDRESS(frame),
+			blob_name, id, frame_name);
+	} else {
+		dtrace_dot(
+			"\"%s(pipe%d)\"->\"0x%08lx\" "
+			"[label = %s_frame];",
+			blob_name, id,
+			HOST_ADDRESS(frame),
+			frame_name);
+	}
+}
+
+void
+ia_css_debug_pipe_graph_dump_prologue(void)
+{
+	dtrace_dot("digraph sh_css_pipe_graph {" );
+	dtrace_dot("rankdir=LR;" );
+
+	dtrace_dot("fontsize=9;");
+	dtrace_dot("label = \"\\nEnable options: rp=reduced pipe, vfve=vf_veceven, "
+		"dvse=dvs_envelope, dvs6=dvs_6axis, bo=block_out, "
+		"fbds=fixed_bayer_ds, bf6=bayer_fir_6db, "
+		"rawb=raw_binning, cont=continuous, disc=dis_crop\\n"
+		"dp2a=dp_2adjacent, outp=output, outt=out_table, "
+		"reff=ref_frame, par=params, gam=gamma, "
+		"cagdc=ca_gdc, ispa=isp_addresses, inf=in_frame, "
+		"outf=out_frame, hs=high_speed, inpc=input_chunking\"");
+}
+
+void ia_css_debug_pipe_graph_dump_epilogue(void)
+{
+
+	if (strlen(ring_buffer) > 0) {
+		dtrace_dot(ring_buffer);
+	}
+
+
+	if (pg_inst.stream_format != N_IA_CSS_STREAM_FORMAT) {
+		/* An input stream format has been set so assume we have
+		 * an input system and sensor
+		 */
+
+
+		dtrace_dot(
+			"node [shape = doublecircle, "
+			"fixedsize=true, width=2]; \"input_system\" "
+			"[label = \"Input system\"];");
+
+		dtrace_dot(
+			"\"input_system\"->\"%s\" "
+			"[label = \"%s\"];",
+			dot_id_input_bin, stream_format2str[pg_inst.stream_format]);
+
+		dtrace_dot(
+			"node [shape = doublecircle, "
+			"fixedsize=true, width=2]; \"sensor\" "
+			"[label = \"Sensor\"];");
+
+		dtrace_dot(
+			"\"sensor\"->\"input_system\" "
+			"[label = \"%s\\n%d x %d\\n(%d x %d)\"];",
+			stream_format2str[pg_inst.stream_format],
+			pg_inst.width, pg_inst.height,
+			pg_inst.eff_width, pg_inst.eff_height);
+	}
+
+	dtrace_dot("}");
+
+	/* Reset temp strings */
+	memset(dot_id_input_bin, 0, sizeof(dot_id_input_bin));
+	memset(ring_buffer, 0, sizeof(ring_buffer));
+
+	pg_inst.do_init = true;
+	pg_inst.width = 0;
+	pg_inst.height = 0;
+	pg_inst.eff_width = 0;
+	pg_inst.eff_height = 0;
+	pg_inst.stream_format = N_IA_CSS_STREAM_FORMAT;
+}
+
+void
+ia_css_debug_pipe_graph_dump_stage(
+	struct ia_css_pipeline_stage *stage,
+	enum ia_css_pipe_id id)
+{
+
+	char const *blob_name = "<unknow name>";
+	char const *bin_type = "<unknow type>";
+	int i;
+
+	assert(stage != NULL);
+	if (stage->sp_func != IA_CSS_PIPELINE_NO_FUNC)
+		return;
+
+	if (pg_inst.do_init) {
+		ia_css_debug_pipe_graph_dump_prologue();
+		pg_inst.do_init = false;
+	}
+
+	if (stage->binary) {
+		bin_type = "binary";
+		if (stage->binary->info->blob)
+			blob_name = stage->binary->info->blob->name;
+	} else if (stage->firmware) {
+		bin_type = "firmware";
+		blob_name =
+		    (char const *)IA_CSS_EXT_ISP_PROG_NAME(stage->firmware);
+	}
+
+	/* Guard in case of binaries that don't have any binary_info */
+	if (stage->binary_info != NULL) {
+		char enable_info1[100];
+		char enable_info2[100];
+		char enable_info3[100];
+		char enable_info[200];
+		struct ia_css_binary_info* bi = stage->binary_info;
+
+		/* Split it in 2 function-calls to keep the amount of
+		 * parameters per call "reasonable"
+		 */
+		snprintf( enable_info1, sizeof(enable_info1),
+			"%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+			bi->enable.reduced_pipe ?	"rp," : "",
+			bi->enable.vf_veceven ?		"vfve," : "",
+			bi->enable.dis ?		"dis," : "",
+			bi->enable.dvs_envelope ?	"dvse," : "",
+			bi->enable.uds ?		"uds," : "",
+			bi->enable.dvs_6axis ?		"dvs6," : "",
+			bi->enable.block_output ?	"bo," : "",
+			bi->enable.ds ?			"ds," : "",
+			bi->enable.bayer_fir_6db ?	"bf6," : "",
+			bi->enable.raw_binning ?	"rawb," : "",
+			bi->enable.continuous ?		"cont," : "",
+			bi->enable.s3a ?		"s3a," : "",
+			bi->enable.fpnr ?		"fpnr," : "",
+			bi->enable.sc ?			"sc," : ""
+			);
+
+		snprintf( enable_info2, sizeof(enable_info2),
+			"%s%s%s%s%s%s%s%s%s%s%s",
+			bi->enable.macc ?		"macc," : "",
+			bi->enable.output ?		"outp," : "",
+			bi->enable.ref_frame ?		"reff," : "",
+			bi->enable.tnr ?		"tnr," : "",
+			bi->enable.xnr ?		"xnr," : "",
+			bi->enable.params ?		"par," : "",
+			bi->enable.ca_gdc ?		"cagdc," : "",
+			bi->enable.isp_addresses ?	"ispa," : "",
+			bi->enable.in_frame ?		"inf," : "",
+			bi->enable.out_frame ?		"outf," : "",
+			bi->enable.high_speed ?		"hs," : ""
+			);
+
+		/* And merge them into one string */
+		snprintf(enable_info, sizeof(enable_info), "%s%s",
+						enable_info1, enable_info2);
+		{
+			int l, p;
+			char *ei=enable_info;
+
+			l=strlen(ei);
+
+			/* Replace last ',' with \0 if present */
+			if (l && enable_info[l-1] == ',')
+				enable_info[--l] = '\0';
+
+			if (l<=ENABLE_LINE1_MAX_LENGHT1) {
+				/* It fits on one line, copy string and init */
+				/* other helper strings with empty string */
+				strcpy_s(enable_info,
+					sizeof(enable_info),
+					ei);
+			} else {
+				/* Too big for one line, find last comma */
+				p=ENABLE_LINE1_MAX_LENGHT1;
+				while (ei[p] != ',')
+					p--;
+				/* Last comma found, copy till that comma */
+				strncpy_s(enable_info1,
+					sizeof(enable_info1),
+					ei, p);
+				enable_info1[p]='\0';
+
+				ei+=p+1;
+				l=strlen(ei);
+
+				if (l<=ENABLE_LINE2_MAX_LENGHT2) {
+					/* The 2nd line fits */
+					/* we cannot use ei as argument because
+					 * it is not guarenteed dword aligned
+					 */
+					strcpy_s(enable_info2,
+						sizeof(enable_info2),
+						ei);
+					snprintf(enable_info, 200, "%s\\n%s",
+						enable_info1, enable_info2);
+
+				} else {
+					/* 2nd line is still too long */
+					p=ENABLE_LINE2_MAX_LENGHT2;
+					while (ei[p] != ',')
+						p--;
+					strncpy_s(enable_info2,
+						sizeof(enable_info2),
+						ei, p);
+					enable_info2[p]='\0';
+					ei+=p+1;
+					strcpy_s(enable_info3,
+						sizeof(enable_info3), ei);
+					snprintf(enable_info, 200,
+						"%s\\n%s\\n%s",
+						enable_info1, enable_info2,
+						enable_info3);
+				}
+			}
+		}
+
+		dtrace_dot("node [shape = circle, fixedsize=true, width=2, "
+			"label=\"%s\\n%s\\n\\n%s\"]; \"%s(pipe%d)\"",
+			bin_type, blob_name, enable_info, blob_name, id);
+
+	}
+	else {
+		dtrace_dot("node [shape = circle, fixedsize=true, width=2, "
+			"label=\"%s\\n%s\\n\"]; \"%s(pipe%d)\"",
+			bin_type, blob_name, blob_name, id);
+	}
+
+	if (stage->stage_num == 0) {
+		/*
+		 * There are some implicite assumptions about which bin is the
+		 * input binary e.g. which one is connected to the input system
+		 * Priority:
+		 * 1) sp_raw_copy bin has highest priority
+		 * 2) First stage==0 binary of preview, video or capture
+		 */
+		if (strlen(dot_id_input_bin) == 0) {
+			snprintf(dot_id_input_bin, sizeof(dot_id_input_bin),
+				"%s(pipe%d)", blob_name, id);
+		}
+	}
+
+	/* CC is a bit of special case, it used to be the alternating IN */
+	/* when continuous capture was still used in a double buffer scheme. */
+	/* Now consider it just as another IN */
+	if (stage->args.cc_frame) {
+		ia_css_debug_pipe_graph_dump_frame(
+			stage->args.cc_frame, id, blob_name,
+			"in", true);
+	} else if (stage->args.in_frame) {
+		ia_css_debug_pipe_graph_dump_frame(
+			stage->args.in_frame, id, blob_name,
+			"in", true);
+	}
+
+	for (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++) {
+		if (stage->args.tnr_frames[i]) {
+			ia_css_debug_pipe_graph_dump_frame(
+					stage->args.tnr_frames[i], id,
+					blob_name, "tnr_frame", true);
+		}
+	}
+
+	for (i = 0; i < NUM_VIDEO_DELAY_FRAMES; i++) {
+		if (stage->args.delay_frames[i]) {
+			ia_css_debug_pipe_graph_dump_frame(
+					stage->args.delay_frames[i], id,
+					blob_name, "delay_frame", true);
+		}
+	}
+
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		if (stage->args.out_frame[i]) {
+			ia_css_debug_pipe_graph_dump_frame(
+				stage->args.out_frame[i], id, blob_name,
+				"out", false);
+		}
+	}
+
+	if (stage->args.out_vf_frame) {
+		ia_css_debug_pipe_graph_dump_frame(
+			stage->args.out_vf_frame, id, blob_name,
+			"out_vf", false);
+	}
+}
+
+void
+ia_css_debug_pipe_graph_dump_sp_raw_copy(
+	struct ia_css_frame *out_frame)
+{
+
+	assert(out_frame != NULL);
+	if (pg_inst.do_init) {
+		ia_css_debug_pipe_graph_dump_prologue();
+		pg_inst.do_init = false;
+	}
+
+	dtrace_dot("node [shape = circle, fixedsize=true, width=2, "
+		"label=\"%s\\n%s\"]; \"%s(pipe%d)\"",
+		"sp-binary", "sp_raw_copy", "sp_raw_copy", 1);
+
+	snprintf(ring_buffer, sizeof(ring_buffer),
+		"node [shape = box, "
+		"fixedsize=true, width=2, height=0.7]; \"0x%08lx\" "
+		"[label = \"%s\\n%d(%d) x %d\\nRingbuffer\"];",
+		HOST_ADDRESS(out_frame),
+		format2str[out_frame->info.format],
+		out_frame->info.res.width,
+		out_frame->info.padded_width,
+		out_frame->info.res.height);
+
+	dtrace_dot(ring_buffer);
+
+	dtrace_dot(
+		"\"%s(pipe%d)\"->\"0x%08lx\" "
+		"[label = out_frame];",
+		"sp_raw_copy", 1, HOST_ADDRESS(out_frame));
+
+	snprintf(dot_id_input_bin, sizeof(dot_id_input_bin), "%s(pipe%d)", "sp_raw_copy", 1);
+
+}
+
+void
+ia_css_debug_pipe_graph_dump_stream_config(
+	const struct ia_css_stream_config *stream_config)
+{
+	pg_inst.width = stream_config->input_res.width;
+	pg_inst.height = stream_config->input_res.height;
+	pg_inst.eff_width = stream_config->effective_res.width;
+	pg_inst.eff_height = stream_config->effective_res.height;
+	pg_inst.stream_format = stream_config->format;
+}
+
+void
+ia_css_debug_dump_resolution(
+	const struct ia_css_resolution *res,
+	const char *label)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s: =%d x =%d\n",
+			label, res->width, res->height);
+}
+
+void
+ia_css_debug_dump_frame_info(
+	const struct ia_css_frame_info *info,
+	const char *label)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s\n", label);
+	ia_css_debug_dump_resolution(&info->res, "res");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "padded_width: %d\n",
+			info->padded_width);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "format: %d\n", info->format);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "raw_bit_depth: %d\n",
+			info->raw_bit_depth);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "raw_bayer_order: %d\n",
+			info->raw_bayer_order);
+}
+
+void
+ia_css_debug_dump_capture_config(
+	const struct ia_css_capture_config *config)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s\n", __func__);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "mode: %d\n", config->mode);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "enable_xnr:  %d\n",
+			config->enable_xnr);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "enable_raw_output: %d\n",
+			config->enable_raw_output);
+}
+
+void
+ia_css_debug_dump_pipe_extra_config(
+	const struct ia_css_pipe_extra_config *extra_config)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s\n", __func__);
+	if (extra_config) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"enable_raw_binning: %d\n",
+				extra_config->enable_raw_binning);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "enable_yuv_ds: %d\n",
+				extra_config->enable_yuv_ds);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"enable_high_speed:  %d\n",
+				extra_config->enable_high_speed);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"enable_dvs_6axis: %d\n",
+				extra_config->enable_dvs_6axis);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"enable_reduced_pipe: %d\n",
+				extra_config->enable_reduced_pipe);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"enable_fractional_ds: %d\n",
+				extra_config->enable_fractional_ds);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "disable_vf_pp: %d\n",
+				extra_config->disable_vf_pp);
+	}
+}
+
+void
+ia_css_debug_dump_pipe_config(
+	const struct ia_css_pipe_config *config)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s()\n", __func__);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "mode: %d\n", config->mode);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "isp_pipe_version: %d\n",
+			config->isp_pipe_version);
+	ia_css_debug_dump_resolution(&config->bayer_ds_out_res,
+			"bayer_ds_out_res");
+	ia_css_debug_dump_resolution(&config->capt_pp_in_res,
+			"capt_pp_in_res");
+	ia_css_debug_dump_resolution(&config->vf_pp_in_res, "vf_pp_in_res");
+	ia_css_debug_dump_resolution(&config->dvs_crop_out_res,
+			"dvs_crop_out_res");
+	ia_css_debug_dump_frame_info(&config->output_info, "output_info");
+	ia_css_debug_dump_frame_info(&config->vf_output_info,
+			"vf_output_info");
+	ia_css_debug_dump_frame_info(&config->second_output_info,
+			"second_output_info");
+	ia_css_debug_dump_frame_info(&config->second_vf_output_info,
+			"second_vf_output_info");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "acc_extension: 0x%x\n",
+			config->acc_extension);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "num_acc_stages: %d\n",
+			config->num_acc_stages);
+	ia_css_debug_dump_capture_config(&config->default_capture_config);
+	ia_css_debug_dump_resolution(&config->dvs_envelope, "dvs_envelope");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "dvs_frame_delay: %d\n",
+			config->dvs_frame_delay);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "acc_num_execs: %d\n",
+			config->acc_num_execs);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "enable_dz: %d\n",
+			config->enable_dz);
+}
+
+void
+ia_css_debug_dump_stream_config_source(
+	const struct ia_css_stream_config *config)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s()\n", __func__);
+	switch (config->mode) {
+	case IA_CSS_INPUT_MODE_SENSOR:
+	case IA_CSS_INPUT_MODE_BUFFERED_SENSOR:
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "source.port\n");
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "port: %d\n",
+				config->source.port.port);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "num_lanes: %d\n",
+				config->source.port.num_lanes);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "timeout: %d\n",
+				config->source.port.timeout);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "compression: %d\n",
+				config->source.port.compression);
+		break;
+	case IA_CSS_INPUT_MODE_TPG:
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "source.tpg\n");
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "id: %d\n",
+				config->source.tpg.id);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "mode: %d\n",
+				config->source.tpg.mode);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "x_mask: 0x%x\n",
+				config->source.tpg.x_mask);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "x_delta: %d\n",
+				config->source.tpg.x_delta);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "y_mask: 0x%x\n",
+				config->source.tpg.y_mask);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "y_delta: %d\n",
+				config->source.tpg.y_delta);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "xy_mask: 0x%x\n",
+				config->source.tpg.xy_mask);
+		break;
+	case IA_CSS_INPUT_MODE_PRBS:
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "source.prbs\n");
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "id: %d\n",
+				config->source.prbs.id);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "h_blank: %d\n",
+				config->source.prbs.h_blank);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "v_blank: %d\n",
+				config->source.prbs.v_blank);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "seed: 0x%x\n",
+				config->source.prbs.seed);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "seed1: 0x%x\n",
+				config->source.prbs.seed1);
+		break;
+	default:
+	case IA_CSS_INPUT_MODE_FIFO:
+	case IA_CSS_INPUT_MODE_MEMORY:
+		break;
+	}
+}
+
+void
+ia_css_debug_dump_mipi_buffer_config(
+	const struct ia_css_mipi_buffer_config *config)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s()\n", __func__);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "size_mem_words: %d\n",
+			config->size_mem_words);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "continuous: %d\n",
+			config->contiguous);
+}
+
+void
+ia_css_debug_dump_metadata_config(
+	const struct ia_css_metadata_config *config)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s()\n", __func__);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "data_type: %d\n",
+			config->data_type);
+	ia_css_debug_dump_resolution(&config->resolution, "resolution");
+}
+
+void
+ia_css_debug_dump_stream_config(
+	const struct ia_css_stream_config *config,
+	int num_pipes)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s()\n", __func__);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "num_pipes: %d\n", num_pipes);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "mode: %d\n", config->mode);
+	ia_css_debug_dump_stream_config_source(config);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "channel_id: %d\n",
+			config->channel_id);
+	ia_css_debug_dump_resolution(&config->input_res, "input_res");
+	ia_css_debug_dump_resolution(&config->effective_res, "effective_res");
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "format: %d\n",
+			config->format);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "bayer_order: %d\n",
+			config->bayer_order);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sensor_binning_factor: %d\n",
+			config->sensor_binning_factor);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "two_pixels_per_clock: %d\n",
+			config->two_pixels_per_clock);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "pixels_per_clock: %d\n",
+			config->pixels_per_clock);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "online: %d\n",
+			config->online);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "init_num_cont_raw_buf: %d\n",
+			config->init_num_cont_raw_buf);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"target_num_cont_raw_buf: %d\n",
+			config->target_num_cont_raw_buf);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "pack_raw_pixels: %d\n",
+			config->pack_raw_pixels);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "continuous: %d\n",
+			config->continuous);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "flash_gpio_pin: %d\n",
+			config->flash_gpio_pin);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "left_padding: %d\n",
+			config->left_padding);
+	ia_css_debug_dump_mipi_buffer_config(&config->mipi_buffer_config);
+	ia_css_debug_dump_metadata_config(&config->metadata_config);
+}
+
+#if defined(HRT_SCHED) || defined(SH_CSS_DEBUG_SPMEM_DUMP_SUPPORT)
+#include "spmem_dump.c"
+#endif
diff --git a/drivers/media/atomisp2/css2400/runtime/event/interface/ia_css_event.h b/drivers/media/atomisp2/css2400/runtime/event/interface/ia_css_event.h
new file mode 100644
index 0000000..d5f4ffd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/event/interface/ia_css_event.h
@@ -0,0 +1,37 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_EVENT_H
+#define _IA_CSS_EVENT_H
+
+#include <type_support.h>
+#include "sw_event_global.h"    /*event macros.TODO : Change File Name..???*/
+
+bool ia_css_event_encode(
+	uint8_t	*in,
+	uint8_t	nr,
+	uint32_t	*out);
+
+void ia_css_event_decode(
+	uint32_t event,
+	uint8_t *payload);
+
+#endif /*_IA_CSS_EVENT_H*/
diff --git a/drivers/media/atomisp2/css2400/runtime/event/src/event.c b/drivers/media/atomisp2/css2400/runtime/event/src/event.c
new file mode 100644
index 0000000..18f505b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/event/src/event.c
@@ -0,0 +1,113 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "sh_css_sp.h"
+
+#include "dma.h"	/* N_DMA_CHANNEL_ID */
+
+#include <type_support.h>
+#include "ia_css_binary.h"
+#include "sh_css_hrt.h"
+#include "sh_css_defs.h"
+#include "sh_css_internal.h"
+#include "ia_css_debug.h"
+#include "ia_css_debug_internal.h"
+#include "sh_css_legacy.h"
+
+#include "gdc_device.h"				/* HRT_GDC_N */
+
+/*#include "sp.h"*/	/* host2sp_enqueue_frame_data() */
+
+#include "memory_access.h"
+
+#include "assert_support.h"
+#include "platform_support.h"	/* hrt_sleep() */
+
+#include "ia_css_queue.h"	/* host_sp_enqueue_XXX */
+#include "ia_css_event.h"	/* ia_css_event_encode */
+/**
+ * @brief Encode the information into the software-event.
+ * Refer to "sw_event_public.h" for details.
+ */
+bool ia_css_event_encode(
+	uint8_t	*in,
+	uint8_t	nr,
+	uint32_t	*out)
+{
+	bool ret;
+	uint32_t nr_of_bits;
+	uint32_t i;
+	assert(in != NULL);
+	assert(out != NULL);
+	OP___assert(nr > 0 && nr <= MAX_NR_OF_PAYLOADS_PER_SW_EVENT);
+
+	/* initialize the output */
+	*out = 0;
+
+	/* get the number of bits per information */
+	nr_of_bits = sizeof(uint32_t) * 8 / nr;
+
+	/* compress the all inputs into a signle output */
+	for (i = 0; i < nr; i++) {
+		*out <<= nr_of_bits;
+		*out |= in[i];
+	}
+
+	/* get the return value */
+	ret = (nr > 0 && nr <= MAX_NR_OF_PAYLOADS_PER_SW_EVENT);
+
+	return ret;
+}
+
+void ia_css_event_decode(
+	uint32_t event,
+	uint8_t *payload)
+{
+	assert(payload[1] == 0);
+	assert(payload[2] == 0);
+	assert(payload[3] == 0);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_event_decode() enter:\n");
+
+	/* First decode according to the common case
+	 * In case of a PORT_EOF event we overwrite with
+	 * the specific values
+	 * This is somewhat ugly but probably somewhat efficient
+	 * (and it avoids some code duplication)
+	 */
+	payload[0] = event & 0xff;  /*event_code */
+	payload[1] = (event >> 8) & 0xff;
+	payload[2] = (event >> 16) & 0xff;
+	payload[3] = 0;
+
+	switch (payload[0]) {
+	case SH_CSS_SP_EVENT_PORT_EOF:
+		payload[2] = 0;
+		payload[3] = (event >> 24) & 0xff;
+		break;
+
+	case SH_CSS_SP_EVENT_FRAME_TAGGED:
+		payload[3] = (event >> 24) & 0xff;
+		break;
+	default:
+		break;
+	}
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/eventq/interface/ia_css_eventq.h b/drivers/media/atomisp2/css2400/runtime/eventq/interface/ia_css_eventq.h
new file mode 100644
index 0000000..b16c3c0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/eventq/interface/ia_css_eventq.h
@@ -0,0 +1,60 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_EVENTQ_H
+#define _IA_CSS_EVENTQ_H
+
+#include "ia_css_queue.h"	/* queue APIs */
+
+/**
+ * @brief HOST receives event from SP.
+ *
+ * @param[in]	eventq_handle	eventq_handle.
+ * @param[in]	payload		The event payload.
+ * @return	0		- Successfully dequeue.
+ * @return	EINVAL		- Invalid argument.
+ * @return	ENODATA		- Queue is empty.
+ */
+int ia_css_eventq_recv(
+		ia_css_queue_t *eventq_handle,
+		uint8_t *payload);
+
+/**
+ * @brief The Host sends the event to SP.
+ * The caller of this API will be blocked until the event
+ * is sent.
+ *
+ * @param[in]	eventq_handle   eventq_handle.
+ * @param[in]	evt_id		The event ID.
+ * @param[in]	evt_payload_0	The event payload.
+ * @param[in]	evt_payload_1	The event payload.
+ * @param[in]	evt_payload_2	The event payload.
+ * @return	0		- Successfully enqueue.
+ * @return	EINVAL		- Invalid argument.
+ * @return	ENOBUFS		- Queue is full.
+ */
+int ia_css_eventq_send(
+		ia_css_queue_t *eventq_handle,
+		uint8_t evt_id,
+		uint8_t evt_payload_0,
+		uint8_t evt_payload_1,
+		uint8_t evt_payload_2);
+#endif /* _IA_CSS_EVENTQ_H */
diff --git a/drivers/media/atomisp2/css2400/runtime/eventq/src/eventq.c b/drivers/media/atomisp2/css2400/runtime/eventq/src/eventq.c
new file mode 100644
index 0000000..3f87734
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/eventq/src/eventq.c
@@ -0,0 +1,85 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "assert_support.h"
+#include "ia_css_queue.h" /* sp2host_dequeue_irq_event() */
+#include "ia_css_eventq.h"
+#include "ia_css_event.h"	/* ia_css_event_encode()
+				ia_css_event_decode()
+				*/
+#include "platform_support.h" /* hrt_sleep() */
+
+int ia_css_eventq_recv(
+		ia_css_queue_t *eventq_handle,
+		uint8_t *payload)
+{
+	uint32_t sp_event;
+	int error;
+
+	/* dequeue the IRQ event */
+	error = ia_css_queue_dequeue(eventq_handle, &sp_event);
+
+	/* check whether the IRQ event is available or not */
+	if (!error)
+		ia_css_event_decode(sp_event, payload);
+	return error;
+}
+
+/**
+ * @brief The Host sends the event to the SP.
+ * Refer to "sh_css_sp.h" for details.
+ */
+int ia_css_eventq_send(
+			ia_css_queue_t *eventq_handle,
+			uint8_t evt_id,
+			uint8_t evt_payload_0,
+			uint8_t evt_payload_1,
+			uint8_t evt_payload_2)
+{
+	uint8_t tmp[4];
+	uint32_t sw_event;
+	int error;
+
+	/*
+	 * Encode the queue type, the thread ID and
+	 * the queue ID into the event.
+	 */
+	tmp[0] = evt_id;
+	tmp[1] = evt_payload_0;
+	tmp[2] = evt_payload_1;
+	tmp[3] = evt_payload_2;
+	ia_css_event_encode(tmp, 4, &sw_event);
+
+	/* queue the software event (busy-waiting) */
+	do {
+		error = ia_css_queue_enqueue(eventq_handle, sw_event);
+		if (ENOBUFS != error ) {
+			/* We were able to successfully send the event
+			   or had a real failure. return the status*/
+			return error;
+		}
+		/* Wait for the queue to be not full and try again*/
+		hrt_sleep();
+	} while(1);
+
+	return ENOSYS;
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/frame/interface/ia_css_frame.h b/drivers/media/atomisp2/css2400/runtime/frame/interface/ia_css_frame.h
new file mode 100644
index 0000000..1154151
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/frame/interface/ia_css_frame.h
@@ -0,0 +1,148 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FRAME_H__
+#define __IA_CSS_FRAME_H__
+
+#include <ia_css_frame_format.h>
+#include <ia_css_frame_public.h>
+#include "dma.h"
+
+/*********************************************************************
+****	Frame INFO APIs
+**********************************************************************/
+/** @brief Sets the given width and alignment to the frame info
+ *
+ * @param
+ * @param[in]	info        The info to which parameters would set
+ * @param[in]	width       The width to be set to info
+ * @param[in]	aligned     The aligned to be set to info
+ * @return
+ */
+void ia_css_frame_info_set_width(struct ia_css_frame_info *info,
+	unsigned int width,
+	unsigned int min_padded_width);
+
+/** @brief Sets the given format to the frame info
+ *
+ * @param
+ * @param[in]	info        The info to which parameters would set
+ * @param[in]	format      The format to be set to info
+ * @return
+ */
+void ia_css_frame_info_set_format(struct ia_css_frame_info *info,
+	enum ia_css_frame_format format);
+
+/** @brief Sets the frame info with the given parameters
+ *
+ * @param
+ * @param[in]	info        The info to which parameters would set
+ * @param[in]	width       The width to be set to info
+ * @param[in]	height      The height to be set to info
+ * @param[in]	format      The format to be set to info
+ * @param[in]	aligned     The aligned to be set to info
+ * @return
+ */
+void ia_css_frame_info_init(struct ia_css_frame_info *info,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int aligned);
+
+/** @brief Checks whether 2 frame infos has the same resolution
+ *
+ * @param
+ * @param[in]	frame_a         The first frame to be compared
+ * @param[in]	frame_b         The second frame to be compared
+ * @return      Returns true if the frames are equal
+ */
+bool ia_css_frame_info_is_same_resolution(
+	const struct ia_css_frame_info *info_a,
+	const struct ia_css_frame_info *info_b);
+
+/** @brief Check the frame info is valid
+ *
+ * @param
+ * @param[in]	info       The frame attributes to be initialized
+ * @return	The error code.
+ */
+enum ia_css_err ia_css_frame_check_info(const struct ia_css_frame_info *info);
+
+/*********************************************************************
+****	Frame APIs
+**********************************************************************/
+
+/** @brief Initialize the plane depending on the frame type
+ *
+ * @param
+ * @param[in]	frame           The frame attributes to be initialized
+ * @return	The error code.
+ */
+enum ia_css_err ia_css_frame_init_planes(struct ia_css_frame *frame);
+
+/** @brief Free an array of frames
+ *
+ * @param
+ * @param[in]	num_frames      The number of frames to be freed in the array
+ * @param[in]   **frames_array  The array of frames to be removed
+ * @return
+ */
+void ia_css_frame_free_multiple(unsigned int num_frames,
+	struct ia_css_frame **frames_array);
+
+/** @brief Allocate a CSS frame structure of given size in bytes..
+ *
+ * @param	frame	The allocated frame.
+ * @param[in]	size_bytes	The frame size in bytes.
+ * @param[in]	contiguous	Allocate memory physically contiguously or not.
+ * @return	The error code.
+ *
+ * Allocate a frame using the given size in bytes.
+ * The frame structure is partially null initialized.
+ */
+enum ia_css_err ia_css_frame_allocate_with_buffer_size(
+	struct ia_css_frame **frame,
+	const unsigned int size_bytes,
+	const bool contiguous);
+
+/** @brief Check whether 2 frames are same type
+ *
+ * @param
+ * @param[in]	frame_a         The first frame to be compared
+ * @param[in]	frame_b         The second frame to be compared
+ * @return      Returns true if the frames are equal
+ */
+bool ia_css_frame_is_same_type(
+	const struct ia_css_frame *frame_a,
+	const struct ia_css_frame *frame_b);
+
+/** @brief Configure a dma port from frame info
+ *
+ * @param
+ * @param[in]	config         The DAM port configuration
+ * @param[in]	info           The frame info
+ * @return
+ */
+void ia_css_dma_configure_from_info(
+	struct dma_port_config *config,
+	const struct ia_css_frame_info *info);
+
+#endif /* __IA_CSS_FRAME_H__ */
diff --git a/drivers/media/atomisp2/css2400/runtime/frame/interface/ia_css_frame_comm.h b/drivers/media/atomisp2/css2400/runtime/frame/interface/ia_css_frame_comm.h
new file mode 100644
index 0000000..b7fd6dd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/frame/interface/ia_css_frame_comm.h
@@ -0,0 +1,114 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FRAME_COMM_H__
+#define __IA_CSS_FRAME_COMM_H__
+
+#include "type_support.h"
+#include "platform_support.h"
+#include <system_types.h>	 /* hrt_vaddress */
+
+/*
+ * These structs are derived from structs defined in ia_css_types.h
+ * (just take out the "_sp" from the struct name to get the "original")
+ * All the fields that are not needed by the SP are removed.
+ */
+struct ia_css_frame_sp_plane {
+	unsigned int offset;	/* offset in bytes to start of frame data */
+				/* offset is wrt data in sh_css_sp_sp_frame */
+};
+
+struct ia_css_frame_sp_binary_plane {
+	unsigned int size;
+	struct ia_css_frame_sp_plane data;
+};
+
+struct ia_css_frame_sp_yuv_planes {
+	struct ia_css_frame_sp_plane y;
+	struct ia_css_frame_sp_plane u;
+	struct ia_css_frame_sp_plane v;
+};
+
+struct ia_css_frame_sp_nv_planes {
+	struct ia_css_frame_sp_plane y;
+	struct ia_css_frame_sp_plane uv;
+};
+
+struct ia_css_frame_sp_rgb_planes {
+	struct ia_css_frame_sp_plane r;
+	struct ia_css_frame_sp_plane g;
+	struct ia_css_frame_sp_plane b;
+};
+
+struct ia_css_frame_sp_plane6 {
+	struct ia_css_frame_sp_plane r;
+	struct ia_css_frame_sp_plane r_at_b;
+	struct ia_css_frame_sp_plane gr;
+	struct ia_css_frame_sp_plane gb;
+	struct ia_css_frame_sp_plane b;
+	struct ia_css_frame_sp_plane b_at_r;
+};
+
+struct ia_css_sp_resolution {
+	uint16_t width;		/* width of valid data in pixels */
+	uint16_t height;	/* Height of valid data in lines */
+};
+
+/*
+ * Frame info struct. This describes the contents of an image frame buffer.
+ */
+struct ia_css_frame_sp_info {
+	struct ia_css_sp_resolution res;
+	uint16_t padded_width;		/* stride of line in memory
+					(in pixels) */
+	unsigned char format;		/* format of the frame data */
+	unsigned char raw_bit_depth;	/* number of valid bits per pixel,
+					only valid for RAW bayer frames */
+	unsigned char raw_bayer_order;	/* bayer order, only valid
+					for RAW bayer frames */
+	unsigned char padding[3];	/* Extend to 32 bit multiple */
+};
+
+
+struct ia_css_frame_sp {
+	struct ia_css_frame_sp_info info;
+	union {
+		struct ia_css_frame_sp_plane raw;
+		struct ia_css_frame_sp_plane rgb;
+		struct ia_css_frame_sp_rgb_planes planar_rgb;
+		struct ia_css_frame_sp_plane yuyv;
+		struct ia_css_frame_sp_yuv_planes yuv;
+		struct ia_css_frame_sp_nv_planes nv;
+		struct ia_css_frame_sp_plane6 plane6;
+		struct ia_css_frame_sp_binary_plane binary;
+	} planes;
+};
+
+void ia_css_frame_info_to_frame_sp_info(
+	struct ia_css_frame_sp_info *sp_info,
+	const struct ia_css_frame_info *info);
+
+void ia_css_resolution_to_sp_resolution(
+	struct ia_css_sp_resolution *sp_info,
+	const struct ia_css_resolution *info);
+
+#endif /*__IA_CSS_FRAME_COMM_H__*/
+
diff --git a/drivers/media/atomisp2/css2400/runtime/frame/src/frame.c b/drivers/media/atomisp2/css2400/runtime/frame/src/frame.c
new file mode 100644
index 0000000..e053650
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/frame/src/frame.c
@@ -0,0 +1,861 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_frame.h"
+#include "assert_support.h"
+#include "ia_css_debug.h"
+#include "isp.h"
+#include "sh_css_internal.h"
+#include "memory_access.h"
+
+/**************************************************************************
+**	Static functions declarations
+**************************************************************************/
+static void frame_init_plane(struct ia_css_frame_plane *plane,
+	unsigned int width,
+	unsigned int stride,
+	unsigned int height,
+	unsigned int offset);
+
+static void frame_init_single_plane(struct ia_css_frame *frame,
+	struct ia_css_frame_plane *plane,
+	unsigned int height,
+	unsigned int subpixels_per_line,
+	unsigned int bytes_per_pixel);
+
+static void frame_init_raw_single_plane(
+       struct ia_css_frame *frame,
+       struct ia_css_frame_plane *plane,
+       unsigned int height,
+       unsigned int subpixels_per_line,
+       unsigned int bits_per_pixel);
+
+static void frame_init_mipi_plane(struct ia_css_frame *frame,
+	struct ia_css_frame_plane *plane,
+	unsigned int height,
+	unsigned int subpixels_per_line,
+	unsigned int bytes_per_pixel);
+
+static void frame_init_nv_planes(struct ia_css_frame *frame,
+	unsigned int horizontal_decimation,
+	unsigned int vertical_decimation);
+
+static void frame_init_yuv_planes(struct ia_css_frame *frame,
+	unsigned int horizontal_decimation,
+	unsigned int vertical_decimation,
+	bool swap_uv,
+	unsigned int bytes_per_element);
+
+static void frame_init_rgb_planes(struct ia_css_frame *frame,
+	unsigned int bytes_per_element);
+
+static void frame_init_qplane6_planes(struct ia_css_frame *frame);
+
+static enum ia_css_err frame_allocate_buffer_data(struct ia_css_frame *frame);
+
+static enum ia_css_err frame_allocate_with_data(struct ia_css_frame **frame,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int padded_width,
+	unsigned int raw_bit_depth,
+	bool contiguous);
+
+static struct ia_css_frame *frame_create(unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int padded_width,
+	unsigned int raw_bit_depth,
+	bool contiguous,
+	bool valid);
+
+static unsigned
+ia_css_elems_bytes_from_info (
+	const struct ia_css_frame_info *info);
+
+/**************************************************************************
+**	CSS API functions, exposed by ia_css.h
+**************************************************************************/
+
+void ia_css_frame_zero(struct ia_css_frame *frame)
+{
+	assert(frame != NULL);
+	mmgr_clear(frame->data, frame->data_bytes);
+}
+
+enum ia_css_err ia_css_frame_allocate_from_info(struct ia_css_frame **frame,
+	const struct ia_css_frame_info *info)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	if (frame == NULL || info == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		      "ia_css_frame_allocate_from_info() enter:\n");
+	err =
+	    ia_css_frame_allocate(frame, info->res.width, info->res.height,
+				  info->format, info->padded_width,
+				  info->raw_bit_depth);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		      "ia_css_frame_allocate_from_info() leave:\n");
+	return err;
+}
+
+enum ia_css_err ia_css_frame_allocate(struct ia_css_frame **frame,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int padded_width,
+	unsigned int raw_bit_depth)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	if (frame == NULL || width == 0 || height == 0)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+	  "ia_css_frame_allocate() enter: width=%d, height=%d, format=%d\n",
+	  width, height, format);
+
+	err = frame_allocate_with_data(frame, width, height, format,
+				       padded_width, raw_bit_depth, false);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		      "ia_css_frame_allocate() leave: frame=%p\n",
+		      frame ? *frame : (void *)-1);
+
+	return err;
+}
+
+enum ia_css_err ia_css_frame_map(struct ia_css_frame **frame,
+	const struct ia_css_frame_info *info,
+	const void *data,
+	uint16_t attribute,
+	void *context)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame *me;
+	assert(frame != NULL);
+
+	/* Create the frame structure */
+	err = ia_css_frame_create_from_info(&me, info);
+
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	if (err == IA_CSS_SUCCESS) {
+		/* use mmgr_mmap to map */
+		me->data = (ia_css_ptr) mmgr_mmap(data,
+						  me->data_bytes,
+						  attribute, context);
+		if (me->data == mmgr_NULL)
+			err = IA_CSS_ERR_INVALID_ARGUMENTS;
+	};
+
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_free(me);
+		return err;
+	}
+
+	*frame = me;
+
+	return err;
+}
+
+enum ia_css_err ia_css_frame_create_from_info(struct ia_css_frame **frame,
+	const struct ia_css_frame_info *info)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame *me;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_create_from_info() enter:\n");
+	if (frame == NULL || info == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_frame_create_from_info() leave:"
+			" invalid arguments\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	me = frame_create(info->res.width,
+		info->res.height,
+		info->format,
+		info->padded_width,
+		info->raw_bit_depth,
+		false,
+		false);
+	if (me == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_frame_create_from_info() leave:"
+			" frame create failed\n");
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+
+	err = ia_css_frame_init_planes(me);
+
+	if (err == IA_CSS_SUCCESS)
+		*frame = me;
+	else
+		sh_css_free(me);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_frame_create_from_info() leave:\n");
+
+	return err;
+}
+
+enum ia_css_err ia_css_frame_set_data(struct ia_css_frame *frame,
+	const ia_css_ptr mapped_data,
+	size_t data_bytes)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_set_data() enter:\n");
+	if (frame == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_frame_set_data() leave: NULL frame\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	/* If we are setting a valid data.
+	 * Make sure that there is enough
+	 * room for the expected frame format
+	 */
+	if ((mapped_data != mmgr_NULL) && (frame->data_bytes > data_bytes)) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_frame_set_data() leave: invalid arguments\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	frame->data = mapped_data;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_frame_set_data() leave:\n");
+
+	return err;
+}
+
+enum ia_css_err ia_css_frame_allocate_contiguous(struct ia_css_frame **frame,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int padded_width,
+	unsigned int raw_bit_depth)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_allocate_contiguous() "
+		"enter: width=%d, height=%d, format=%d\n",
+		width, height, format);
+
+	err = frame_allocate_with_data(frame, width, height, format,
+			padded_width, raw_bit_depth, true);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_allocate_contiguous() leave: frame=%p\n",
+		frame ? *frame : (void *)-1);
+
+	return err;
+}
+
+enum ia_css_err ia_css_frame_allocate_contiguous_from_info(
+	struct ia_css_frame **frame,
+	const struct ia_css_frame_info *info)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	assert(frame != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_allocate_contiguous_from_info() enter:\n");
+	err = ia_css_frame_allocate_contiguous(frame,
+						info->res.width,
+						info->res.height,
+						info->format,
+						info->padded_width,
+						info->raw_bit_depth);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_allocate_contiguous_from_info() leave:\n");
+	return err;
+}
+
+void ia_css_frame_free(struct ia_css_frame *frame)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_free() enter: frame=%p\n", frame);
+
+	if (frame != NULL) {
+		mmgr_free(frame->data);
+		sh_css_free(frame);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_free() leave: return_void\n");
+}
+
+/**************************************************************************
+**	Module public functions
+**************************************************************************/
+
+enum ia_css_err ia_css_frame_check_info(const struct ia_css_frame_info *info)
+{
+	assert(info != NULL);
+	if (info->res.width == 0 || info->res.height == 0)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_frame_init_planes(struct ia_css_frame *frame)
+{
+	assert(frame != NULL);
+
+	switch (frame->info.format) {
+	case IA_CSS_FRAME_FORMAT_MIPI:
+		frame_init_mipi_plane(frame, &frame->planes.raw,
+			frame->info.res.height,
+			frame->info.padded_width,
+			frame->info.raw_bit_depth <= 8 ? 1 : 2);
+		break;
+	case IA_CSS_FRAME_FORMAT_RAW_PACKED:
+		frame_init_raw_single_plane(frame, &frame->planes.raw,
+			frame->info.res.height,
+			frame->info.padded_width,
+			frame->info.raw_bit_depth);
+		break;
+	case IA_CSS_FRAME_FORMAT_RAW:
+		frame_init_single_plane(frame, &frame->planes.raw,
+			frame->info.res.height,
+			frame->info.padded_width,
+			frame->info.raw_bit_depth <= 8 ? 1 : 2);
+		break;
+	case IA_CSS_FRAME_FORMAT_RGB565:
+		frame_init_single_plane(frame, &frame->planes.rgb,
+			frame->info.res.height,
+			frame->info.padded_width, 2);
+		break;
+	case IA_CSS_FRAME_FORMAT_RGBA888:
+		frame_init_single_plane(frame, &frame->planes.rgb,
+			frame->info.res.height,
+			frame->info.padded_width * 4, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_PLANAR_RGB888:
+		frame_init_rgb_planes(frame, 1);
+		break;
+		/* yuyv and uyvu have the same frame layout, only the data
+		 * positioning differs.
+		 */
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_UYVY:
+	case IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:
+		frame_init_single_plane(frame, &frame->planes.yuyv,
+			frame->info.res.height,
+			frame->info.padded_width * 2, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+		/* Needs 3 extra lines to allow vf_pp prefetching */
+		frame_init_single_plane(frame, &frame->planes.yuyv,
+			frame->info.res.height * 3 / 2 + 3,
+			frame->info.padded_width, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_NV11:
+		frame_init_nv_planes(frame, 4, 1);
+		break;
+		/* nv12 and nv21 have the same frame layout, only the data
+		 * positioning differs.
+		 */
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV21:
+		frame_init_nv_planes(frame, 2, 2);
+		break;
+		/* nv16 and nv61 have the same frame layout, only the data
+		 * positioning differs.
+		 */
+	case IA_CSS_FRAME_FORMAT_NV16:
+	case IA_CSS_FRAME_FORMAT_NV61:
+		frame_init_nv_planes(frame, 2, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV420:
+		frame_init_yuv_planes(frame, 2, 2, false, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV422:
+		frame_init_yuv_planes(frame, 2, 1, false, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV444:
+		frame_init_yuv_planes(frame, 1, 1, false, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+		frame_init_yuv_planes(frame, 2, 2, false, 2);
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV422_16:
+		frame_init_yuv_planes(frame, 2, 1, false, 2);
+		break;
+	case IA_CSS_FRAME_FORMAT_YV12:
+		frame_init_yuv_planes(frame, 2, 2, true, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_YV16:
+		frame_init_yuv_planes(frame, 2, 1, true, 1);
+		break;
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+		frame_init_qplane6_planes(frame);
+		break;
+	case IA_CSS_FRAME_FORMAT_BINARY_8:
+		frame_init_single_plane(frame, &frame->planes.binary.data,
+			frame->info.res.height,
+			frame->info.padded_width, 1);
+		frame->planes.binary.size = 0;
+		break;
+	default:
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	return IA_CSS_SUCCESS;
+}
+
+void ia_css_frame_info_set_width(struct ia_css_frame_info *info,
+	unsigned int width,
+	unsigned int min_padded_width)
+{
+	unsigned int align;
+
+	assert(info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_info_set_width() enter: "
+		"width=%d, min_padded_width=%d\n",
+		width, min_padded_width);
+
+	if (min_padded_width > width)
+		align = min_padded_width;
+	else
+		align = width;
+
+	info->res.width = width;
+	/* frames with a U and V plane of 8 bits per pixel need to have
+	   all planes aligned, this means double the alignment for the
+	   Y plane if the horizontal decimation is 2. */
+	if (info->format == IA_CSS_FRAME_FORMAT_YUV420 ||
+	    info->format == IA_CSS_FRAME_FORMAT_YV12)
+		info->padded_width =
+		    CEIL_MUL(align, 2 * HIVE_ISP_DDR_WORD_BYTES);
+	else if (info->format == IA_CSS_FRAME_FORMAT_YUV_LINE)
+		info->padded_width = CEIL_MUL(align, 2 * ISP_VEC_NELEMS);
+	else if (info->format == IA_CSS_FRAME_FORMAT_RAW ||
+		 info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED)
+		info->padded_width = CEIL_MUL(align, 2 * ISP_VEC_NELEMS);
+	else {
+		info->padded_width = CEIL_MUL(align, HIVE_ISP_DDR_WORD_BYTES);
+	}
+}
+
+void ia_css_frame_info_set_format(struct ia_css_frame_info *info,
+	enum ia_css_frame_format format)
+{
+	assert(info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_info_set_format() enter:\n");
+	/* yuv_line has 2*NWAY alignment */
+	info->format = format;
+	/* HACK: this resets the padded width incorrectly.
+	   Lex needs to fix this in the vf_veceven module. */
+	info->padded_width = CEIL_MUL(info->padded_width, 2 * ISP_VEC_NELEMS);
+}
+
+void ia_css_frame_info_init(struct ia_css_frame_info *info,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int aligned)
+{
+	assert(info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_info_init() enter: "
+		"width=%d, height=%d, format=%d, aligned=%d\n",
+		width, height, format, aligned);
+
+	info->res.height = height;
+	info->format     = format;
+	ia_css_frame_info_set_width(info, width, aligned);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_frame_info_init() leave: return_void\n");
+}
+
+void ia_css_frame_free_multiple(unsigned int num_frames,
+	struct ia_css_frame **frames_array)
+{
+	unsigned int i;
+	for (i = 0; i < num_frames; i++) {
+		if (frames_array[i]) {
+			ia_css_frame_free(frames_array[i]);
+			frames_array[i] = NULL;
+		}
+	}
+}
+
+enum ia_css_err ia_css_frame_allocate_with_buffer_size(
+	struct ia_css_frame **frame,
+	const unsigned int buffer_size_bytes,
+	const bool contiguous)
+{
+	/* AM: Body coppied from frame_allocate_with_data(). */
+	enum ia_css_err err;
+	struct ia_css_frame *me = frame_create(0, 0,
+		IA_CSS_FRAME_FORMAT_NUM,/* Not valid format yet */
+		0, 0, contiguous, false);
+
+	if (me == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	/* Get the data size */
+	me->data_bytes = buffer_size_bytes;
+
+	err = frame_allocate_buffer_data(me);
+
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_free(me);
+		return err;
+	}
+
+	*frame = me;
+
+	return err;
+}
+
+bool ia_css_frame_info_is_same_resolution(
+	const struct ia_css_frame_info *info_a,
+	const struct ia_css_frame_info *info_b)
+{
+	if (!info_a || !info_b)
+		return false;
+	return (info_a->res.width == info_b->res.width) &&
+	    (info_a->res.height == info_b->res.height);
+}
+
+bool ia_css_frame_is_same_type(const struct ia_css_frame *frame_a,
+	const struct ia_css_frame *frame_b)
+{
+	bool is_equal = false;
+	const struct ia_css_frame_info *info_a = &frame_a->info,
+	    *info_b = &frame_b->info;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		      "ia_css_frame_is_same_type() enter:\n");
+
+	if (!info_a || !info_b)
+		return false;
+	if (info_a->format != info_b->format)
+		return false;
+	if (info_a->padded_width != info_b->padded_width)
+		return false;
+	is_equal = ia_css_frame_info_is_same_resolution(info_a, info_b);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		      "ia_css_frame_is_same_type() leave:\n");
+
+	return is_equal;
+}
+
+void
+ia_css_dma_configure_from_info(
+	struct dma_port_config *config,
+	const struct ia_css_frame_info *info)
+{
+	unsigned elems_wb = ia_css_elems_bytes_from_info(info);
+	unsigned elems_b;
+	if (elems_wb == 0)
+		return;
+	elems_b = HIVE_ISP_DDR_WORD_BYTES / elems_wb;
+	config->elems  = elems_b;
+	config->stride = info->padded_width * elems_wb;
+	config->width  = info->res.width;
+	config->crop   = 0;
+	assert (config->width <= info->padded_width);
+}
+
+/**************************************************************************
+**	Static functions
+**************************************************************************/
+
+static void frame_init_plane(struct ia_css_frame_plane *plane,
+	unsigned int width,
+	unsigned int stride,
+	unsigned int height,
+	unsigned int offset)
+{
+	plane->height = height;
+	plane->width = width;
+	plane->stride = stride;
+	plane->offset = offset;
+}
+
+static void frame_init_single_plane(struct ia_css_frame *frame,
+	struct ia_css_frame_plane *plane,
+	unsigned int height,
+	unsigned int subpixels_per_line,
+	unsigned int bytes_per_pixel)
+{
+	unsigned int stride;
+
+	stride = subpixels_per_line * bytes_per_pixel;
+	/* Frame height needs to be even number - needed by hw ISYS2401
+	   In case of odd number, round up to even.
+	   Images won't be impacted by this round up,
+	   only needed by jpeg/embedded data.
+	   As long as buffer allocation and release are using data_bytes,
+	   there won't be memory leak. */
+	frame->data_bytes = stride * CEIL_MUL2(height, 2);
+	frame_init_plane(plane, subpixels_per_line, stride, height, 0);
+	return;
+}
+
+static void frame_init_raw_single_plane(
+       struct ia_css_frame *frame,
+       struct ia_css_frame_plane *plane,
+       unsigned int height,
+       unsigned int subpixels_per_line,
+       unsigned int bits_per_pixel)
+{
+	unsigned int stride;
+	assert(frame != NULL);
+
+	stride = HIVE_ISP_DDR_WORD_BYTES *
+			CEIL_DIV(subpixels_per_line,
+				HIVE_ISP_DDR_WORD_BITS / bits_per_pixel);
+	frame->data_bytes = stride * height;
+	frame_init_plane(plane, subpixels_per_line, stride, height, 0);
+	return;
+}
+
+static void frame_init_mipi_plane(struct ia_css_frame *frame,
+	struct ia_css_frame_plane *plane,
+	unsigned int height,
+	unsigned int subpixels_per_line,
+	unsigned int bytes_per_pixel)
+{
+	unsigned int stride;
+
+	stride = subpixels_per_line * bytes_per_pixel;
+	frame->data_bytes = 8388608;
+	frame->valid = false;
+	frame->contiguous = true;
+	frame_init_plane(plane, subpixels_per_line, stride, height, 0);
+	return;
+}
+
+static void frame_init_nv_planes(struct ia_css_frame *frame,
+	unsigned int horizontal_decimation,
+	unsigned int vertical_decimation)
+{
+	unsigned int y_width = frame->info.padded_width,
+	    y_height = frame->info.res.height,
+	    uv_width = 2 * (y_width / horizontal_decimation),
+	    uv_height = y_height / vertical_decimation, y_bytes, uv_bytes;
+
+	y_bytes = y_width * y_height;
+	uv_bytes = uv_width * uv_height;
+
+	frame->data_bytes = y_bytes + uv_bytes;
+	frame_init_plane(&frame->planes.nv.y, y_width, y_width, y_height, 0);
+	frame_init_plane(&frame->planes.nv.uv, uv_width,
+			 uv_width, uv_height, y_bytes);
+	return;
+}
+
+static void frame_init_yuv_planes(struct ia_css_frame *frame,
+	unsigned int horizontal_decimation,
+	unsigned int vertical_decimation,
+	bool swap_uv,
+	unsigned int bytes_per_element)
+{
+	unsigned int y_width = frame->info.padded_width,
+	    y_height = frame->info.res.height,
+	    uv_width = y_width / horizontal_decimation,
+	    uv_height = y_height / vertical_decimation,
+	    y_stride, y_bytes, uv_bytes, uv_stride;
+
+	y_stride = y_width * bytes_per_element;
+	uv_stride = uv_width * bytes_per_element;
+	y_bytes = y_stride * y_height;
+	uv_bytes = uv_stride * uv_height;
+
+	frame->data_bytes = y_bytes + 2 * uv_bytes;
+	frame_init_plane(&frame->planes.yuv.y, y_width, y_stride, y_height, 0);
+	if (swap_uv) {
+		frame_init_plane(&frame->planes.yuv.v, uv_width, uv_stride,
+				 uv_height, y_bytes);
+		frame_init_plane(&frame->planes.yuv.u, uv_width, uv_stride,
+				 uv_height, y_bytes + uv_bytes);
+	} else {
+		frame_init_plane(&frame->planes.yuv.u, uv_width, uv_stride,
+				 uv_height, y_bytes);
+		frame_init_plane(&frame->planes.yuv.v, uv_width, uv_stride,
+				 uv_height, y_bytes + uv_bytes);
+	}
+	return;
+}
+
+static void frame_init_rgb_planes(struct ia_css_frame *frame,
+	unsigned int bytes_per_element)
+{
+	unsigned int width = frame->info.res.width,
+	    height = frame->info.res.height, stride, bytes;
+
+	stride = width * bytes_per_element;
+	bytes = stride * height;
+	frame->data_bytes = 3 * bytes;
+	frame_init_plane(&frame->planes.planar_rgb.r, width, stride, height, 0);
+	frame_init_plane(&frame->planes.planar_rgb.g,
+			 width, stride, height, 1 * bytes);
+	frame_init_plane(&frame->planes.planar_rgb.b,
+			 width, stride, height, 2 * bytes);
+	return;
+}
+
+static void frame_init_qplane6_planes(struct ia_css_frame *frame)
+{
+	unsigned int width = frame->info.padded_width / 2,
+	    height = frame->info.res.height / 2, bytes, stride;
+
+	stride = width * 2;
+	bytes = stride * height;
+
+	frame->data_bytes = 6 * bytes;
+	frame_init_plane(&frame->planes.plane6.r,
+			 width, stride, height, 0 * bytes);
+	frame_init_plane(&frame->planes.plane6.r_at_b,
+			 width, stride, height, 1 * bytes);
+	frame_init_plane(&frame->planes.plane6.gr,
+			 width, stride, height, 2 * bytes);
+	frame_init_plane(&frame->planes.plane6.gb,
+			 width, stride, height, 3 * bytes);
+	frame_init_plane(&frame->planes.plane6.b,
+			 width, stride, height, 4 * bytes);
+	frame_init_plane(&frame->planes.plane6.b_at_r,
+			 width, stride, height, 5 * bytes);
+	return;
+}
+
+static enum ia_css_err frame_allocate_buffer_data(struct ia_css_frame *frame)
+{
+	frame->data = mmgr_alloc_attr(frame->data_bytes,
+				      frame->contiguous ?
+				      MMGR_ATTRIBUTE_CONTIGUOUS :
+				      MMGR_ATTRIBUTE_DEFAULT);
+
+	if (frame->data == mmgr_NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err frame_allocate_with_data(struct ia_css_frame **frame,
+	unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int padded_width,
+	unsigned int raw_bit_depth,
+	bool contiguous)
+{
+	enum ia_css_err err;
+	struct ia_css_frame *me = frame_create(width,
+		height,
+		format,
+		padded_width,
+		raw_bit_depth,
+		contiguous,
+		true);
+
+	if (me == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	err = ia_css_frame_init_planes(me);
+
+	if (err == IA_CSS_SUCCESS)
+		err = frame_allocate_buffer_data(me);
+
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_free(me);
+		return err;
+	}
+
+	*frame = me;
+
+	return err;
+}
+
+static struct ia_css_frame *frame_create(unsigned int width,
+	unsigned int height,
+	enum ia_css_frame_format format,
+	unsigned int padded_width,
+	unsigned int raw_bit_depth,
+	bool contiguous,
+	bool valid)
+{
+	struct ia_css_frame *me = sh_css_malloc(sizeof(*me));
+
+	if (me == NULL)
+		return NULL;
+
+	me->info.res.width = width;
+	me->info.res.height = height;
+	me->info.format = format;
+	me->info.padded_width = padded_width;
+	me->info.raw_bit_depth = raw_bit_depth;
+	me->contiguous = contiguous;
+	me->valid = valid;
+	me->data_bytes = 0;
+	me->data = mmgr_NULL;
+	/* To indicate it is not valid frame. */
+	me->dynamic_data_index = (int)SH_CSS_INVALID_QUEUE_ID;
+	me->buf_type = IA_CSS_BUFFER_TYPE_INVALID;
+
+	return me;
+}
+
+static unsigned
+ia_css_elems_bytes_from_info (const struct ia_css_frame_info *info)
+{
+	if (info->format == IA_CSS_FRAME_FORMAT_RGB565)
+		return 2; /* bytes per pixel */
+
+	if (info->raw_bit_depth)
+		return CEIL_DIV(info->raw_bit_depth,8);
+
+	if (info->format == IA_CSS_FRAME_FORMAT_RAW)
+		return 2; /* bytes per pixel */
+	if (info->format == IA_CSS_FRAME_FORMAT_PLANAR_RGB888)
+		return 3; /* bytes per pixel */
+	if (info->format == IA_CSS_FRAME_FORMAT_RGBA888)
+		return 4; /* bytes per pixel */
+	if (info->format == IA_CSS_FRAME_FORMAT_QPLANE6)
+		return 2; /* bytes per pixel */
+	return 1; /* Default is 1 byte per pixel */
+}
+
+void ia_css_frame_info_to_frame_sp_info(
+	struct ia_css_frame_sp_info *to,
+	const struct ia_css_frame_info *from)
+{
+	ia_css_resolution_to_sp_resolution(&to->res, &from->res);
+	to->padded_width = from->padded_width;
+	to->format = from->format;
+	to->raw_bit_depth = from->raw_bit_depth;
+	to->raw_bayer_order = from->raw_bayer_order;
+}
+
+void ia_css_resolution_to_sp_resolution(
+	struct ia_css_sp_resolution *to,
+	const struct ia_css_resolution *from)
+{
+	to->width  = from->width;
+	to->height = from->height;
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/ifmtr/interface/ia_css_ifmtr.h b/drivers/media/atomisp2/css2400/runtime/ifmtr/interface/ia_css_ifmtr.h
new file mode 100644
index 0000000..85d6deb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/ifmtr/interface/ia_css_ifmtr.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_IFMTR_H__
+#define __IA_CSS_IFMTR_H__
+
+#include <type_support.h>
+#include <ia_css_stream_public.h>
+#include <ia_css_binary.h>
+
+extern bool ifmtr_set_if_blocking_mode_reset;
+
+unsigned int ia_css_ifmtr_lines_needed_for_bayer_order(
+			const struct ia_css_stream_config *config);
+
+unsigned int ia_css_ifmtr_columns_needed_for_bayer_order(
+			const struct ia_css_stream_config *config);
+
+enum ia_css_err ia_css_ifmtr_configure(struct ia_css_stream_config *config,
+				       struct ia_css_binary *binary);
+
+#endif /* __IA_CSS_IFMTR_H__ */
diff --git a/drivers/media/atomisp2/css2400/runtime/ifmtr/src/ifmtr.c b/drivers/media/atomisp2/css2400/runtime/ifmtr/src/ifmtr.c
new file mode 100644
index 0000000..dd1a171
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/ifmtr/src/ifmtr.c
@@ -0,0 +1,544 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_ifmtr.h"
+#include "sh_css_internal.h"
+#include "input_formatter.h"
+#include "assert_support.h"
+#include "sh_css_sp.h"
+#include "isp/modes/interface/input_buf.isp.h"
+
+/************************************************************
+ * Static functions declarations
+ ************************************************************/
+static enum ia_css_err ifmtr_start_column(
+		const struct ia_css_stream_config *config,
+		unsigned int bin_in,
+		unsigned int *start_column);
+
+static enum ia_css_err ifmtr_input_start_line(
+		const struct ia_css_stream_config *config,
+		unsigned int bin_in,
+		unsigned int *start_line);
+
+static void ifmtr_set_if_blocking_mode(
+		const input_formatter_cfg_t * const config_a,
+		const input_formatter_cfg_t * const config_b);
+
+/************************************************************
+ * Public functions
+ ************************************************************/
+
+/* ISP expects GRBG bayer order, we skip one line and/or one row
+ * to correct in case the input bayer order is different.
+ */
+unsigned int ia_css_ifmtr_lines_needed_for_bayer_order(
+		const struct ia_css_stream_config *config)
+{
+	assert(config != NULL);
+	if ((IA_CSS_BAYER_ORDER_BGGR == config->bayer_order)
+	    || (IA_CSS_BAYER_ORDER_GBRG == config->bayer_order))
+		return 1;
+
+	return 0;
+}
+
+unsigned int ia_css_ifmtr_columns_needed_for_bayer_order(
+		const struct ia_css_stream_config *config)
+{
+	assert(config != NULL);
+	if ((IA_CSS_BAYER_ORDER_RGGB == config->bayer_order)
+	    || (IA_CSS_BAYER_ORDER_GBRG == config->bayer_order))
+		return 1;
+
+	return 0;
+}
+
+enum ia_css_err ia_css_ifmtr_configure(struct ia_css_stream_config *config,
+				       struct ia_css_binary *binary)
+{
+	unsigned int start_line, start_column = 0,
+	    cropped_height,
+	    cropped_width,
+	    num_vectors,
+	    buffer_height = 2,
+	    buffer_width,
+	    two_ppc,
+	    vmem_increment = 0,
+	    deinterleaving = 0,
+	    deinterleaving_b = 0,
+	    width_a = 0,
+	    width_b = 0,
+	    bits_per_pixel,
+	    vectors_per_buffer,
+	    vectors_per_line = 0,
+	    buffers_per_line = 0,
+	    buf_offset_a = 0,
+	    buf_offset_b = 0,
+	    line_width = 0,
+	    width_b_factor = 1, start_column_b,
+	    left_padding = 0;
+	input_formatter_cfg_t if_a_config, if_b_config;
+	enum ia_css_stream_format input_format;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	uint8_t if_config_index;
+
+	/* Determine which input formatter config set is targeted. */
+	/* Index is equal to the CSI-2 port used. */
+	enum ia_css_csi2_port port;
+
+	assert(binary != NULL);
+	cropped_height = binary->in_frame_info.res.height;
+	cropped_width = binary->in_frame_info.res.width;
+	/* This should correspond to the input buffer definition for ISP
+	 * binaries in input_buf.isp.h */
+	if (binary->info->sp.enable.continuous && binary->info->sp.mode != IA_CSS_BINARY_MODE_COPY)
+		buffer_width = MAX_VECTORS_PER_INPUT_LINE_CONT * ISP_VEC_NELEMS;
+	else
+		buffer_width = binary->info->sp.max_input_width;
+	input_format = binary->input_format;
+	two_ppc = config->pixels_per_clock == 2;
+
+
+	if (config->mode == IA_CSS_INPUT_MODE_SENSOR
+	    || config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+		port = config->source.port.port;
+		if_config_index = (uint8_t) (port - IA_CSS_CSI2_PORT0);
+	} else if (config->mode == IA_CSS_INPUT_MODE_MEMORY) {
+		if_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;
+	} else {
+		if_config_index = 0;
+	}
+
+	assert(if_config_index <= SH_CSS_MAX_IF_CONFIGS
+	       || if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED);
+
+	/* TODO: check to see if input is RAW and if current mode interprets
+	 * RAW data in any particular bayer order. copy binary with output
+	 * format other than raw should not result in dropping lines and/or
+	 * columns.
+	 */
+	err = ifmtr_input_start_line(config, cropped_height, &start_line);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = ifmtr_start_column(config, cropped_width, &start_column);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	if (config->left_padding == -1)
+		left_padding = binary->left_padding;
+	else
+		left_padding = 2*ISP_VEC_NELEMS - config->left_padding;
+
+
+	if (left_padding) {
+		num_vectors = CEIL_DIV(cropped_width + left_padding,
+				       ISP_VEC_NELEMS);
+	} else {
+		num_vectors = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);
+		num_vectors *= buffer_height;
+		/* todo: in case of left padding,
+		   num_vectors is vectors per line,
+		   otherwise vectors per line * buffer_height. */
+	}
+
+	start_column_b = start_column;
+
+	bits_per_pixel = input_formatter_get_alignment(INPUT_FORMATTER0_ID)
+	    * 8 / ISP_VEC_NELEMS;
+	switch (input_format) {
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+		if (two_ppc) {
+			vmem_increment = 1;
+			deinterleaving = 1;
+			deinterleaving_b = 1;
+			/* half lines */
+			width_a = cropped_width * deinterleaving / 2;
+			width_b_factor = 2;
+			/* full lines */
+			width_b = width_a * width_b_factor;
+			buffer_width *= deinterleaving * 2;
+			/* Patch from bayer to yuv */
+			num_vectors *= deinterleaving;
+			buf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;
+			vectors_per_line = num_vectors / buffer_height;
+			/* Even lines are half size */
+			line_width = vectors_per_line *
+			    input_formatter_get_alignment(INPUT_FORMATTER0_ID) /
+			    2;
+			start_column /= 2;
+		} else {
+			vmem_increment = 1;
+			deinterleaving = 3;
+			width_a = cropped_width * deinterleaving / 2;
+			buffer_width = buffer_width * deinterleaving / 2;
+			/* Patch from bayer to yuv */
+			num_vectors = num_vectors / 2 * deinterleaving;
+			start_column = start_column * deinterleaving / 2;
+		}
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+		if (two_ppc) {
+			vmem_increment = 1;
+			deinterleaving = 1;
+			width_a = width_b = cropped_width * deinterleaving / 2;
+			buffer_width *= deinterleaving * 2;
+			num_vectors *= deinterleaving;
+			buf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;
+			vectors_per_line = num_vectors / buffer_height;
+			/* Even lines are half size */
+			line_width = vectors_per_line *
+			    input_formatter_get_alignment(INPUT_FORMATTER0_ID) /
+			    2;
+			start_column *= deinterleaving;
+			start_column /= 2;
+			start_column_b = start_column;
+		} else {
+			vmem_increment = 1;
+			deinterleaving = 1;
+			width_a = cropped_width * deinterleaving;
+			buffer_width *= deinterleaving * 2;
+			num_vectors *= deinterleaving;
+			start_column *= deinterleaving;
+		}
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+		if (two_ppc) {
+			vmem_increment = 1;
+			deinterleaving = 1;
+			width_a = width_b = cropped_width * deinterleaving;
+			buffer_width *= deinterleaving * 2;
+			num_vectors *= deinterleaving;
+			start_column *= deinterleaving;
+			buf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;
+			start_column_b = start_column;
+		} else {
+			vmem_increment = 1;
+			deinterleaving = 2;
+			width_a = cropped_width * deinterleaving;
+			buffer_width *= deinterleaving;
+			num_vectors *= deinterleaving;
+			start_column *= deinterleaving;
+		}
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+		num_vectors *= 2;
+		if (two_ppc) {
+			deinterleaving = 2;	/* BR in if_a, G in if_b */
+			deinterleaving_b = 1;	/* BR in if_a, G in if_b */
+			buffers_per_line = 4;
+			start_column_b = start_column;
+			start_column *= deinterleaving;
+			start_column_b *= deinterleaving_b;
+		} else {
+			deinterleaving = 3;	/* BGR */
+			buffers_per_line = 3;
+			start_column *= deinterleaving;
+		}
+		vmem_increment = 1;
+		width_a = cropped_width * deinterleaving;
+		width_b = cropped_width * deinterleaving_b;
+		buffer_width *= buffers_per_line;
+		/* Patch from bayer to rgb */
+		num_vectors = num_vectors / 2 * deinterleaving;
+		buf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+		if (two_ppc) {
+			vmem_increment = 2;
+			deinterleaving = 1;
+			width_a = width_b = cropped_width / 2;
+
+			/* When two_ppc is enabled, if_a and if_b gets separate
+			 * bayer components. Therefore, it is not possible to
+			 * correct the bayer order to GRBG in horizontal direction
+			 * by shifting start_column.
+			 * Instead, if_a and if_b output (VMEM) addresses should be
+			 * swapped for this purpose.
+			 */
+			if ((start_column % 2) == 1) {
+				/* Swap buffer start address */
+				buf_offset_a = 1;
+				buf_offset_b = 0;
+			} else {
+				buf_offset_a = 0;
+				buf_offset_b = 1;
+			}
+			start_column /= 2;
+			start_column_b = start_column;
+		} else {
+			vmem_increment = 1;
+			deinterleaving = 2;
+			if (config->continuous &&
+			    binary->info->sp.mode == IA_CSS_BINARY_MODE_COPY) {
+				/* No deinterleaving for sp copy */
+				deinterleaving = 1;
+			}
+			width_a = cropped_width;
+			/* Must be multiple of deinterleaving */
+			num_vectors = CEIL_MUL(num_vectors, deinterleaving);
+		}
+		buffer_height *= 2;
+		if (config->continuous)
+			buffer_height *= 2;
+		vectors_per_line = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);
+		vectors_per_line = CEIL_MUL(vectors_per_line, deinterleaving);
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+		if (two_ppc) {
+			num_vectors *= 2;
+			vmem_increment = 1;
+			deinterleaving = 2;
+			width_a = width_b = cropped_width;
+			/* B buffer is one line further */
+			buf_offset_b = buffer_width / ISP_VEC_NELEMS;
+			bits_per_pixel *= 2;
+		} else {
+			vmem_increment = 1;
+			deinterleaving = 2;
+			width_a = cropped_width;
+			start_column /= deinterleaving;
+		}
+		buffer_height *= 2;
+		break;
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+	case IA_CSS_STREAM_FORMAT_GENERIC_SHORT1:
+	case IA_CSS_STREAM_FORMAT_GENERIC_SHORT2:
+	case IA_CSS_STREAM_FORMAT_GENERIC_SHORT3:
+	case IA_CSS_STREAM_FORMAT_GENERIC_SHORT4:
+	case IA_CSS_STREAM_FORMAT_GENERIC_SHORT5:
+	case IA_CSS_STREAM_FORMAT_GENERIC_SHORT6:
+	case IA_CSS_STREAM_FORMAT_GENERIC_SHORT7:
+	case IA_CSS_STREAM_FORMAT_GENERIC_SHORT8:
+	case IA_CSS_STREAM_FORMAT_YUV420_8_SHIFT:
+	case IA_CSS_STREAM_FORMAT_YUV420_10_SHIFT:
+	case IA_CSS_STREAM_FORMAT_EMBEDDED:
+	case IA_CSS_STREAM_FORMAT_USER_DEF1:
+	case IA_CSS_STREAM_FORMAT_USER_DEF2:
+	case IA_CSS_STREAM_FORMAT_USER_DEF3:
+	case IA_CSS_STREAM_FORMAT_USER_DEF4:
+	case IA_CSS_STREAM_FORMAT_USER_DEF5:
+	case IA_CSS_STREAM_FORMAT_USER_DEF6:
+	case IA_CSS_STREAM_FORMAT_USER_DEF7:
+	case IA_CSS_STREAM_FORMAT_USER_DEF8:
+		break;
+	}
+	if (width_a == 0)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (two_ppc)
+		left_padding /= 2;
+
+	/* Default values */
+	if (left_padding)
+		vectors_per_line = num_vectors;
+	if (!vectors_per_line) {
+		vectors_per_line = CEIL_MUL(num_vectors / buffer_height,
+					    deinterleaving);
+		line_width = 0;
+	}
+	if (!line_width)
+		line_width = vectors_per_line *
+		    input_formatter_get_alignment(INPUT_FORMATTER0_ID);
+	if (!buffers_per_line)
+		buffers_per_line = deinterleaving;
+	line_width = CEIL_MUL(line_width,
+			      input_formatter_get_alignment(INPUT_FORMATTER0_ID)
+			      * vmem_increment);
+
+	vectors_per_buffer = buffer_height * buffer_width / ISP_VEC_NELEMS;
+
+	if (config->mode == IA_CSS_INPUT_MODE_TPG &&
+	    binary->info->sp.mode == IA_CSS_BINARY_MODE_VIDEO) {
+		/* workaround for TPG in video mode */
+		start_line = 0;
+		start_column = 0;
+		cropped_height -= start_line;
+		width_a -= start_column;
+	}
+
+	if_a_config.start_line = start_line;
+	if_a_config.start_column = start_column;
+	if_a_config.left_padding = left_padding / deinterleaving;
+	if_a_config.cropped_height = cropped_height;
+	if_a_config.cropped_width = width_a;
+	if_a_config.deinterleaving = deinterleaving;
+	if_a_config.buf_vecs = vectors_per_buffer;
+	if_a_config.buf_start_index = buf_offset_a;
+	if_a_config.buf_increment = vmem_increment;
+	if_a_config.buf_eol_offset =
+	    buffer_width * bits_per_pixel / 8 - line_width;
+	if_a_config.is_yuv420_format =
+	    (input_format == IA_CSS_STREAM_FORMAT_YUV420_8)
+	    || (input_format == IA_CSS_STREAM_FORMAT_YUV420_10);
+	if_a_config.block_no_reqs = (config->mode != IA_CSS_INPUT_MODE_SENSOR);
+
+	if (two_ppc) {
+		if (deinterleaving_b) {
+			deinterleaving = deinterleaving_b;
+			width_b = cropped_width * deinterleaving;
+			buffer_width *= deinterleaving;
+			/* Patch from bayer to rgb */
+			num_vectors = num_vectors / 2 *
+			    deinterleaving * width_b_factor;
+			vectors_per_line = num_vectors / buffer_height;
+			line_width = vectors_per_line *
+			    input_formatter_get_alignment(INPUT_FORMATTER0_ID);
+		}
+		if_b_config.start_line = start_line;
+		if_b_config.start_column = start_column_b;
+		if_b_config.left_padding = left_padding / deinterleaving;
+		if_b_config.cropped_height = cropped_height;
+		if_b_config.cropped_width = width_b;
+		if_b_config.deinterleaving = deinterleaving;
+		if_b_config.buf_vecs = vectors_per_buffer;
+		if_b_config.buf_start_index = buf_offset_b;
+		if_b_config.buf_increment = vmem_increment;
+		if_b_config.buf_eol_offset =
+		    buffer_width * bits_per_pixel / 8 - line_width;
+		if_b_config.is_yuv420_format =
+		    input_format == IA_CSS_STREAM_FORMAT_YUV420_8
+		    || input_format == IA_CSS_STREAM_FORMAT_YUV420_10;
+		if_b_config.block_no_reqs =
+		    (config->mode != IA_CSS_INPUT_MODE_SENSOR);
+
+		if (SH_CSS_IF_CONFIG_NOT_NEEDED != if_config_index) {
+			assert(if_config_index <= SH_CSS_MAX_IF_CONFIGS);
+
+			ifmtr_set_if_blocking_mode(&if_a_config, &if_b_config);
+			/* Set the ifconfigs to SP group */
+			sh_css_sp_set_if_configs(&if_a_config, &if_b_config,
+						 if_config_index);
+		}
+	} else {
+		if (SH_CSS_IF_CONFIG_NOT_NEEDED != if_config_index) {
+			assert(if_config_index <= SH_CSS_MAX_IF_CONFIGS);
+
+			ifmtr_set_if_blocking_mode(&if_a_config, NULL);
+			/* Set the ifconfigs to SP group */
+			sh_css_sp_set_if_configs(&if_a_config, NULL,
+						 if_config_index);
+		}
+	}
+
+	return IA_CSS_SUCCESS;
+}
+
+bool ifmtr_set_if_blocking_mode_reset = true;
+
+/************************************************************
+ * Static functions
+ ************************************************************/
+static void ifmtr_set_if_blocking_mode(
+		const input_formatter_cfg_t * const config_a,
+		const input_formatter_cfg_t * const config_b)
+{
+	int i;
+	bool block[] = { false, false, false, false };
+	assert(N_INPUT_FORMATTER_ID <= (sizeof(block) / sizeof(block[0])));
+
+#if !defined(IS_ISP_2400_SYSTEM)
+#error "ifmtr_set_if_blocking_mode: ISP_SYSTEM must be one of \
+	{IS_ISP_2400_SYSTEM}"
+#endif
+
+	block[INPUT_FORMATTER0_ID] = (bool)config_a->block_no_reqs;
+	if (NULL != config_b)
+	  block[INPUT_FORMATTER1_ID] = (bool)config_b->block_no_reqs;
+
+	/* TODO: next could cause issues when streams are started after
+	 * eachother. */
+	/*IF should not be reconfigured/reset from host */
+	if (ifmtr_set_if_blocking_mode_reset) {
+		ifmtr_set_if_blocking_mode_reset = false;
+		for (i = 0; i < N_INPUT_FORMATTER_ID; i++) {
+			input_formatter_ID_t id = (input_formatter_ID_t) i;
+			input_formatter_rst(id);
+			input_formatter_set_fifo_blocking_mode(id, block[id]);
+		}
+	}
+
+	return;
+}
+
+static enum ia_css_err ifmtr_start_column(
+		const struct ia_css_stream_config *config,
+		unsigned int bin_in,
+		unsigned int *start_column)
+{
+	unsigned int in = config->input_res.width, start,
+	    for_bayer = ia_css_ifmtr_columns_needed_for_bayer_order(config);
+
+	if (bin_in + 2 * for_bayer > in)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	/* On the hardware, we want to use the middle of the input, so we
+	 * divide the start column by 2. */
+	start = (in - bin_in) / 2;
+	/* in case the number of extra columns is 2 or odd, we round the start
+	 * column down */
+	start &= ~0x1;
+
+	/* now we add the one column (if needed) to correct for the bayer
+	 * order).
+	 */
+	start += for_bayer;
+	*start_column = start;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err ifmtr_input_start_line(
+		const struct ia_css_stream_config *config,
+		unsigned int bin_in,
+		unsigned int *start_line)
+{
+	unsigned int in = config->input_res.height, start,
+	    for_bayer = ia_css_ifmtr_lines_needed_for_bayer_order(config);
+
+	if (bin_in + 2 * for_bayer > in)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	/* On the hardware, we want to use the middle of the input, so we
+	 * divide the start line by 2. On the simulator, we cannot handle extra
+	 * lines at the end of the frame.
+	 */
+	start = (in - bin_in) / 2;
+	/* in case the number of extra lines is 2 or odd, we round the start
+	 * line down.
+	 */
+	start &= ~0x1;
+
+	/* now we add the one line (if needed) to correct for the bayer order */
+	start += for_bayer;
+	*start_line = start;
+	return IA_CSS_SUCCESS;
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/inputfifo/interface/ia_css_inputfifo.h b/drivers/media/atomisp2/css2400/runtime/inputfifo/interface/ia_css_inputfifo.h
new file mode 100644
index 0000000..756a3c0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/inputfifo/interface/ia_css_inputfifo.h
@@ -0,0 +1,60 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_INPUTFIFO_H
+#define _IA_CSS_INPUTFIFO_H
+
+#include <sp.h>
+#include <isp.h>
+
+#include "ia_css.h"	/* enum ia_css_stream_format */
+
+/* SP access */
+void ia_css_inputfifo_send_input_frame(
+	const unsigned short	*data,
+	unsigned int	width,
+	unsigned int	height,
+	unsigned int	ch_id,
+	enum ia_css_stream_format	input_format,
+	bool			two_ppc);
+
+void ia_css_inputfifo_start_frame(
+	unsigned int	ch_id,
+	enum ia_css_stream_format	input_format,
+	bool			two_ppc);
+
+void ia_css_inputfifo_send_line(
+	unsigned int	ch_id,
+	const unsigned short	*data,
+	unsigned int	width,
+	const unsigned short	*data2,
+	unsigned int	width2);
+
+void ia_css_inputfifo_send_embedded_line(
+	unsigned int	ch_id,
+	enum ia_css_stream_format	data_type,
+	const unsigned short	*data,
+	unsigned int	width);
+
+void ia_css_inputfifo_end_frame(
+	unsigned int	ch_id);
+
+#endif /* _IA_CSS_INPUTFIFO_H */
diff --git a/drivers/media/atomisp2/css2400/runtime/inputfifo/src/inputfifo.c b/drivers/media/atomisp2/css2400/runtime/inputfifo/src/inputfifo.c
new file mode 100644
index 0000000..cc89c77
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/inputfifo/src/inputfifo.c
@@ -0,0 +1,649 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "platform_support.h"
+
+#include "ia_css_inputfifo.h"
+
+#include "device_access.h"
+
+#define __INLINE_SP__
+#include "sp.h"
+#define __INLINE_ISP__
+#include "isp.h"
+#define __INLINE_IRQ__
+#include "irq.h"
+#define __INLINE_FIFO_MONITOR__
+#include "fifo_monitor.h"
+
+#define __INLINE_EVENT__
+#include "event_fifo.h"
+#define __INLINE_SP__
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include "input_system.h"	/* MIPI_PREDICTOR_NONE,... */
+#endif
+
+#include "assert_support.h"
+
+/* System independent */
+#include "sh_css_internal.h"
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include "ia_css_isys.h"
+#endif
+
+#define HBLANK_CYCLES (187)
+#define MARKER_CYCLES (6)
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include <hive_isp_css_streaming_to_mipi_types_hrt.h>
+#endif
+
+/* The data type is used to send special cases:
+ * yuv420: odd lines (1, 3 etc) are twice as wide as even
+ *         lines (0, 2, 4 etc).
+ * rgb: for two pixels per clock, the R and B values are sent
+ *      to output_0 while only G is sent to output_1. This means
+ *      that output_1 only gets half the number of values of output_0.
+ *      WARNING: This type should also be used for Legacy YUV420.
+ * regular: used for all other data types (RAW, YUV422, etc)
+ */
+enum inputfifo_mipi_data_type {
+	inputfifo_mipi_data_type_regular,
+	inputfifo_mipi_data_type_yuv420,
+	inputfifo_mipi_data_type_yuv420_legacy,
+	inputfifo_mipi_data_type_rgb565,
+	inputfifo_mipi_data_type_rgb888,
+	inputfifo_mipi_data_type_yuv422,
+};
+#if !defined(HAS_NO_INPUT_SYSTEM)
+static unsigned int inputfifo_curr_ch_id, inputfifo_curr_fmt_type;
+#endif
+struct inputfifo_instance {
+	unsigned int				ch_id;
+	enum ia_css_stream_format	input_format;
+	bool						two_ppc;
+	bool						streaming;
+	unsigned int				hblank_cycles;
+	unsigned int				marker_cycles;
+	unsigned int				fmt_type;
+	enum inputfifo_mipi_data_type	type;
+};
+#if !defined(HAS_NO_INPUT_SYSTEM)
+/*
+ * Maintain a basic streaming to Mipi administration with ch_id as index
+ * ch_id maps on the "Mipi virtual channel ID" and can have value 0..3
+ */
+#define INPUTFIFO_NR_OF_S2M_CHANNELS	(4)
+static struct inputfifo_instance
+	inputfifo_inst_admin[INPUTFIFO_NR_OF_S2M_CHANNELS];
+
+/* Streaming to MIPI */
+static unsigned inputfifo_wrap_marker(
+/* STORAGE_CLASS_INLINE unsigned inputfifo_wrap_marker( */
+	unsigned marker)
+{
+	return marker |
+	(inputfifo_curr_ch_id << HIVE_STR_TO_MIPI_CH_ID_LSB) |
+	(inputfifo_curr_fmt_type << _HIVE_STR_TO_MIPI_FMT_TYPE_LSB);
+}
+
+STORAGE_CLASS_INLINE void
+_sh_css_fifo_snd(unsigned token)
+{
+	while (!can_event_send_token(STR2MIPI_EVENT_ID)) {
+		hrt_sleep();
+	}
+	event_send_token(STR2MIPI_EVENT_ID, token);
+    return;
+}
+
+static void inputfifo_send_data_a(
+/* STORAGE_CLASS_INLINE void inputfifo_send_data_a( */
+unsigned int data)
+{
+	unsigned int token = (1 << HIVE_STR_TO_MIPI_VALID_A_BIT) |
+			     (data << HIVE_STR_TO_MIPI_DATA_A_LSB);
+	_sh_css_fifo_snd(token);
+	return;
+}
+
+
+
+static void inputfifo_send_data_b(
+/* STORAGE_CLASS_INLINE void inputfifo_send_data_b( */
+	unsigned int data)
+{
+	unsigned int token = (1 << HIVE_STR_TO_MIPI_VALID_B_BIT) |
+			     (data << _HIVE_STR_TO_MIPI_DATA_B_LSB);
+	_sh_css_fifo_snd(token);
+	return;
+}
+
+
+
+static void inputfifo_send_data(
+/* STORAGE_CLASS_INLINE void inputfifo_send_data( */
+	unsigned int a,
+	unsigned int b)
+{
+	unsigned int token = ((1 << HIVE_STR_TO_MIPI_VALID_A_BIT) |
+			      (1 << HIVE_STR_TO_MIPI_VALID_B_BIT) |
+			      (a << HIVE_STR_TO_MIPI_DATA_A_LSB) |
+			      (b << _HIVE_STR_TO_MIPI_DATA_B_LSB));
+	_sh_css_fifo_snd(token);
+	return;
+}
+
+
+
+static void inputfifo_send_sol(void)
+/* STORAGE_CLASS_INLINE void inputfifo_send_sol(void) */
+{
+	hrt_data	token = inputfifo_wrap_marker(
+		1 << HIVE_STR_TO_MIPI_SOL_BIT);
+
+	_sh_css_fifo_snd(token);
+	return;
+}
+
+
+
+static void inputfifo_send_eol(void)
+/* STORAGE_CLASS_INLINE void inputfifo_send_eol(void) */
+{
+	hrt_data	token = inputfifo_wrap_marker(
+		1 << HIVE_STR_TO_MIPI_EOL_BIT);
+	_sh_css_fifo_snd(token);
+	return;
+}
+
+
+
+static void inputfifo_send_sof(void)
+/* STORAGE_CLASS_INLINE void inputfifo_send_sof(void) */
+{
+	hrt_data	token = inputfifo_wrap_marker(
+		1 << HIVE_STR_TO_MIPI_SOF_BIT);
+
+	_sh_css_fifo_snd(token);
+	return;
+}
+
+
+
+static void inputfifo_send_eof(void)
+/* STORAGE_CLASS_INLINE void inputfifo_send_eof(void) */
+{
+	hrt_data	token = inputfifo_wrap_marker(
+		1 << HIVE_STR_TO_MIPI_EOF_BIT);
+	_sh_css_fifo_snd(token);
+	return;
+}
+
+
+
+#ifdef __ON__
+static void inputfifo_send_ch_id(
+/* STORAGE_CLASS_INLINE void inputfifo_send_ch_id( */
+	unsigned int ch_id)
+{
+	hrt_data	token;
+	inputfifo_curr_ch_id = ch_id & _HIVE_ISP_CH_ID_MASK;
+	/* we send an zero marker, this will wrap the ch_id and
+	 * fmt_type automatically.
+	 */
+	token = inputfifo_wrap_marker(0);
+	_sh_css_fifo_snd(token);
+	return;
+}
+
+static void inputfifo_send_fmt_type(
+/* STORAGE_CLASS_INLINE void inputfifo_send_fmt_type( */
+	unsigned int fmt_type)
+{
+	hrt_data	token;
+	inputfifo_curr_fmt_type = fmt_type & _HIVE_ISP_FMT_TYPE_MASK;
+	/* we send an zero marker, this will wrap the ch_id and
+	 * fmt_type automatically.
+	 */
+	token = inputfifo_wrap_marker(0);
+	_sh_css_fifo_snd(token);
+	return;
+}
+#endif /*  __ON__ */
+
+
+
+static void inputfifo_send_ch_id_and_fmt_type(
+/* STORAGE_CLASS_INLINE
+void inputfifo_send_ch_id_and_fmt_type( */
+	unsigned int ch_id,
+	unsigned int fmt_type)
+{
+	hrt_data	token;
+	inputfifo_curr_ch_id = ch_id & _HIVE_ISP_CH_ID_MASK;
+	inputfifo_curr_fmt_type = fmt_type & _HIVE_ISP_FMT_TYPE_MASK;
+	/* we send an zero marker, this will wrap the ch_id and
+	 * fmt_type automatically.
+	 */
+	token = inputfifo_wrap_marker(0);
+	_sh_css_fifo_snd(token);
+	return;
+}
+
+
+
+static void inputfifo_send_empty_token(void)
+/* STORAGE_CLASS_INLINE void inputfifo_send_empty_token(void) */
+{
+	hrt_data	token = inputfifo_wrap_marker(0);
+	_sh_css_fifo_snd(token);
+	return;
+}
+
+
+
+static void inputfifo_start_frame(
+/* STORAGE_CLASS_INLINE void inputfifo_start_frame( */
+	unsigned int ch_id,
+	unsigned int fmt_type)
+{
+	inputfifo_send_ch_id_and_fmt_type(ch_id, fmt_type);
+	inputfifo_send_sof();
+	return;
+}
+
+
+
+static void inputfifo_end_frame(
+	unsigned int marker_cycles)
+{
+	unsigned int i;
+	for (i = 0; i < marker_cycles; i++)
+		inputfifo_send_empty_token();
+	inputfifo_send_eof();
+	return;
+}
+
+
+
+static void inputfifo_send_line2(
+	const unsigned short *data,
+	unsigned int width,
+	const unsigned short *data2,
+	unsigned int width2,
+	unsigned int hblank_cycles,
+	unsigned int marker_cycles,
+	unsigned int two_ppc,
+	enum inputfifo_mipi_data_type type)
+{
+	unsigned int i, is_rgb565 = 0, is_rgb888 = 0, is_legacy = 0, is_yuv422 = 0;
+	unsigned short tempA = 0, tempB = 0, tempC = 0;
+
+	assert(data != NULL);
+	assert((data2 != NULL) || (width2 == 0));
+
+        if (type == inputfifo_mipi_data_type_rgb565)
+                is_rgb565 = 1;
+        if (type == inputfifo_mipi_data_type_rgb888)
+                is_rgb888 = 1;
+        if (type == inputfifo_mipi_data_type_yuv422)
+                is_yuv422 = 1;
+	if (type == inputfifo_mipi_data_type_yuv420_legacy)
+		is_legacy = 1;
+
+	for (i = 0; i < hblank_cycles; i++)
+		inputfifo_send_empty_token();
+	inputfifo_send_sol();
+	for (i = 0; i < marker_cycles; i++)
+		inputfifo_send_empty_token();
+	for (i = 0; i < width; i++, data++) {
+		/* for RGB in two_ppc, we only actually send 2 pixels per
+		 * clock in the even pixels (0, 2 etc). In the other cycles,
+		 * we only send 1 pixel, to data[0].
+		 */
+		unsigned int send_two_pixels = two_ppc;
+		if ((is_rgb565 || is_legacy) && (i % 3 == 2))
+			send_two_pixels = 0;
+		if (send_two_pixels) {
+			if (i + 1 == width) {
+				/* for jpg (binary) copy, this can occur
+				 * if the file contains an odd number of bytes.
+				 */
+				inputfifo_send_data(
+							data[0], 0);
+			} else {
+				inputfifo_send_data(
+							data[0], data[1]);
+			}
+			/* Additional increment because we send 2 pixels */
+			data++;
+			i++;
+		} else if (two_ppc && is_legacy) {
+			inputfifo_send_data_b(data[0]);
+		} else if (is_yuv422){
+                        //Only support UYVY order for now
+                        tempA = data[0] &0x00FF;
+                        tempB = (data[0]>>8) &0x00FF;
+                        inputfifo_send_data_a(tempA);
+                        inputfifo_send_data_a(tempB);
+		} else if (is_rgb565 || is_rgb888){
+                        if (is_rgb565) {
+                                tempA = (data[0] &0xF800) >> 11; //red
+                                tempB = (data[0] &0x07E0) >> 5; //green
+                                tempC = data[0] &0x001F; //blue
+                        } else if (is_rgb888) {
+                                if (i%2==0) {  // First pixel and every other pixel
+                                        tempA = (data[1] & 0xFF); //red
+                                        tempB = (data[0] & 0xFF00) >> 8; // green
+                                        tempC = (data[0] & 0xFF); //blue
+                                } else {
+                                        tempA = (data[1] & 0xFF00) >> 8; //red
+                                        tempB = (data[1] & 0xFF); //green
+                                        tempC = (data[0] &  0xFF00) >> 8; //blue
+                                        data++; //extra increment to catch up
+                                }
+                        }
+                        inputfifo_send_data_a(tempC);
+                        inputfifo_send_data_a(tempB);
+                        inputfifo_send_data_a(tempA);
+		} else {
+			inputfifo_send_data_a(data[0]);
+		}
+	}
+
+	for (i = 0; i < width2; i++, data2++) {
+		/* for RGB in two_ppc, we only actually send 2 pixels per
+		 * clock in the even pixels (0, 2 etc). In the other cycles,
+		 * we only send 1 pixel, to data2[0].
+		 */
+		unsigned int send_two_pixels = two_ppc;
+		if ((is_rgb565 || is_legacy) && (i % 3 == 2))
+			send_two_pixels = 0;
+		if (send_two_pixels) {
+			if (i + 1 == width2) {
+				/* for jpg (binary) copy, this can occur
+				 * if the file contains an odd number of bytes.
+				 */
+				inputfifo_send_data(
+							data2[0], 0);
+			} else {
+				inputfifo_send_data(
+							data2[0], data2[1]);
+			}
+			/* Additional increment because we send 2 pixels */
+			data2++;
+			i++;
+		} else if (two_ppc && is_legacy) {
+			inputfifo_send_data_b(data2[0]);
+		} else {
+			inputfifo_send_data_a(data2[0]);
+		}
+	}
+	for (i = 0; i < hblank_cycles; i++)
+		inputfifo_send_empty_token();
+	inputfifo_send_eol();
+	return;
+}
+
+
+
+static void
+inputfifo_send_line(const unsigned short *data,
+			 unsigned int width,
+			 unsigned int hblank_cycles,
+			 unsigned int marker_cycles,
+			 unsigned int two_ppc,
+			 enum inputfifo_mipi_data_type type)
+{
+	assert(data != NULL);
+	inputfifo_send_line2(data, width, NULL, 0,
+					hblank_cycles,
+					marker_cycles,
+					two_ppc,
+					type);
+}
+
+
+/* Send a frame of data into the input network via the GP FIFO.
+ *  Parameters:
+ *   - data: array of 16 bit values that contains all data for the frame.
+ *   - width: width of a line in number of subpixels, for yuv420 it is the
+ *            number of Y components per line.
+ *   - height: height of the frame in number of lines.
+ *   - ch_id: channel ID.
+ *   - fmt_type: format type.
+ *   - hblank_cycles: length of horizontal blanking in cycles.
+ *   - marker_cycles: number of empty cycles after start-of-line and before
+ *                    end-of-frame.
+ *   - two_ppc: boolean, describes whether to send one or two pixels per clock
+ *              cycle. In this mode, we sent pixels N and N+1 in the same cycle,
+ *              to IF_PRIM_A and IF_PRIM_B respectively. The caller must make
+ *              sure the input data has been formatted correctly for this.
+ *              For example, for RGB formats this means that unused values
+ *              must be inserted.
+ *   - yuv420: boolean, describes whether (non-legacy) yuv420 data is used. In
+ *             this mode, the odd lines (1,3,5 etc) are half as long as the
+ *             even lines (2,4,6 etc).
+ *             Note that the first line is odd (1) and the second line is even
+ *             (2).
+ *
+ * This function does not do any reordering of pixels, the caller must make
+ * sure the data is in the righ format. Please refer to the CSS receiver
+ * documentation for details on the data formats.
+ */
+
+static void inputfifo_send_frame(
+	const unsigned short *data,
+	unsigned int width,
+	unsigned int height,
+	unsigned int ch_id,
+	unsigned int fmt_type,
+	unsigned int hblank_cycles,
+	unsigned int marker_cycles,
+	unsigned int two_ppc,
+	enum inputfifo_mipi_data_type type)
+{
+	unsigned int i;
+
+	assert(data != NULL);
+	inputfifo_start_frame(ch_id, fmt_type);
+
+	for (i = 0; i < height; i++) {
+		if ((type == inputfifo_mipi_data_type_yuv420) &&
+		    (i & 1) == 1) {
+			inputfifo_send_line(data, 2 * width,
+							   hblank_cycles,
+							   marker_cycles,
+							   two_ppc, type);
+			data += 2 * width;
+		} else if (type == inputfifo_mipi_data_type_rgb888) {
+			inputfifo_send_line(data, width,
+							   hblank_cycles,
+							   marker_cycles,
+							   two_ppc, type);
+				data += (3*width)/2;
+		} else {
+			inputfifo_send_line(data, width,
+							   hblank_cycles,
+							   marker_cycles,
+							   two_ppc, type);
+			data += width;
+		}
+	}
+	inputfifo_end_frame(marker_cycles);
+	return;
+}
+
+
+
+static enum inputfifo_mipi_data_type inputfifo_determine_type(
+	enum ia_css_stream_format input_format)
+{
+	enum inputfifo_mipi_data_type type;
+
+	type = inputfifo_mipi_data_type_regular;
+	if (input_format == IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY) {
+		type =
+			inputfifo_mipi_data_type_yuv420_legacy;
+	} else if (input_format == IA_CSS_STREAM_FORMAT_YUV420_8 ||
+		   input_format == IA_CSS_STREAM_FORMAT_YUV420_10) {
+		type =
+			inputfifo_mipi_data_type_yuv420;
+	} else if (input_format >= IA_CSS_STREAM_FORMAT_RGB_444 &&
+                   input_format <= IA_CSS_STREAM_FORMAT_RGB_565) {
+                type = inputfifo_mipi_data_type_rgb565;
+        } else if (input_format == IA_CSS_STREAM_FORMAT_RGB_888) {
+                type = inputfifo_mipi_data_type_rgb888;
+        } else if (input_format == IA_CSS_STREAM_FORMAT_YUV422_8 ||
+                   input_format == IA_CSS_STREAM_FORMAT_YUV422_10) {
+                type =
+                        inputfifo_mipi_data_type_yuv422;
+        }
+
+	return type;
+}
+
+
+
+static struct inputfifo_instance *inputfifo_get_inst(
+	unsigned int ch_id)
+{
+	return &inputfifo_inst_admin[ch_id];
+}
+
+void ia_css_inputfifo_send_input_frame(
+	const unsigned short *data,
+	unsigned int width,
+	unsigned int height,
+	unsigned int ch_id,
+	enum ia_css_stream_format input_format,
+	bool two_ppc)
+{
+	unsigned int fmt_type, hblank_cycles, marker_cycles;
+	enum inputfifo_mipi_data_type type;
+
+	assert(data != NULL);
+	hblank_cycles = HBLANK_CYCLES;
+	marker_cycles = MARKER_CYCLES;
+	ia_css_isys_convert_stream_format_to_mipi_format(input_format,
+				 MIPI_PREDICTOR_NONE,
+				 &fmt_type);
+
+	type = inputfifo_determine_type(input_format);
+
+	inputfifo_send_frame(data, width, height,
+			ch_id, fmt_type, hblank_cycles, marker_cycles,
+			two_ppc, type);
+}
+
+
+
+void ia_css_inputfifo_start_frame(
+	unsigned int ch_id,
+	enum ia_css_stream_format input_format,
+	bool two_ppc)
+{
+	struct inputfifo_instance *s2mi;
+	s2mi = inputfifo_get_inst(ch_id);
+
+	s2mi->ch_id = ch_id;
+	ia_css_isys_convert_stream_format_to_mipi_format(input_format,
+				MIPI_PREDICTOR_NONE,
+				&s2mi->fmt_type);
+	s2mi->two_ppc = two_ppc;
+	s2mi->type = inputfifo_determine_type(input_format);
+	s2mi->hblank_cycles = HBLANK_CYCLES;
+	s2mi->marker_cycles = MARKER_CYCLES;
+	s2mi->streaming = true;
+
+	inputfifo_start_frame(ch_id, s2mi->fmt_type);
+	return;
+}
+
+
+
+void ia_css_inputfifo_send_line(
+	unsigned int ch_id,
+	const unsigned short *data,
+	unsigned int width,
+	const unsigned short *data2,
+	unsigned int width2)
+{
+	struct inputfifo_instance *s2mi;
+
+	assert(data != NULL);
+	assert((data2 != NULL) || (width2 == 0));
+	s2mi = inputfifo_get_inst(ch_id);
+
+
+	/* Set global variables that indicate channel_id and format_type */
+	inputfifo_curr_ch_id = (s2mi->ch_id) & _HIVE_ISP_CH_ID_MASK;
+	inputfifo_curr_fmt_type = (s2mi->fmt_type) & _HIVE_ISP_FMT_TYPE_MASK;
+
+	inputfifo_send_line2(data, width, data2, width2,
+					s2mi->hblank_cycles,
+					s2mi->marker_cycles,
+					s2mi->two_ppc,
+					s2mi->type);
+}
+
+
+void ia_css_inputfifo_send_embedded_line(
+	unsigned int	ch_id,
+	enum ia_css_stream_format	data_type,
+	const unsigned short	*data,
+	unsigned int	width)
+{
+	struct inputfifo_instance *s2mi;
+	unsigned int fmt_type;
+
+	assert(data != NULL);
+	s2mi = inputfifo_get_inst(ch_id);
+	ia_css_isys_convert_stream_format_to_mipi_format(data_type,
+			MIPI_PREDICTOR_NONE, &fmt_type);
+
+	/* Set format_type for metadata line. */
+	inputfifo_curr_fmt_type = fmt_type & _HIVE_ISP_FMT_TYPE_MASK;
+
+	inputfifo_send_line(data, width, s2mi->hblank_cycles, s2mi->marker_cycles,
+			s2mi->two_ppc, inputfifo_mipi_data_type_regular);
+}
+
+
+void ia_css_inputfifo_end_frame(
+	unsigned int	ch_id)
+{
+	struct inputfifo_instance *s2mi;
+	s2mi = inputfifo_get_inst(ch_id);
+
+	/* Set global variables that indicate channel_id and format_type */
+	inputfifo_curr_ch_id = (s2mi->ch_id) & _HIVE_ISP_CH_ID_MASK;
+	inputfifo_curr_fmt_type = (s2mi->fmt_type) & _HIVE_ISP_FMT_TYPE_MASK;
+
+	/* Call existing HRT function */
+	inputfifo_end_frame(s2mi->marker_cycles);
+
+	s2mi->streaming = false;
+	return;
+}
+#endif /* #if !defined(HAS_NO_INPUT_SYSTEM) */
diff --git a/drivers/media/atomisp2/css2400/runtime/isp_param/interface/ia_css_isp_param.h b/drivers/media/atomisp2/css2400/runtime/isp_param/interface/ia_css_isp_param.h
new file mode 100644
index 0000000..cf029c2
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/isp_param/interface/ia_css_isp_param.h
@@ -0,0 +1,109 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_ISP_PARAM_H_
+#define _IA_CSS_ISP_PARAM_H_
+
+#include <ia_css_err.h>
+#include "ia_css_isp_param_types.h"
+
+/* Set functions for parameter memory descriptors */
+void
+ia_css_isp_param_set_mem_init(
+	struct ia_css_isp_param_host_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem,
+	char *address, size_t size);
+
+void
+ia_css_isp_param_set_css_mem_init(
+	struct ia_css_isp_param_css_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem,
+	hrt_vaddress address, size_t size);
+
+void
+ia_css_isp_param_set_isp_mem_init(
+	struct ia_css_isp_param_isp_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem,
+	uint32_t address, size_t size);
+
+/* Get functions for parameter memory descriptors */
+const struct ia_css_host_data*
+ia_css_isp_param_get_mem_init(
+	const struct ia_css_isp_param_host_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem);
+
+const struct ia_css_data*
+ia_css_isp_param_get_css_mem_init(
+	const struct ia_css_isp_param_css_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem);
+
+const struct ia_css_isp_data*
+ia_css_isp_param_get_isp_mem_init(
+	const struct ia_css_isp_param_isp_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem);
+
+/* Initialize the memory interface sizes and addresses */
+void
+ia_css_init_memory_interface(
+	struct ia_css_isp_param_css_segments *isp_mem_if,
+	const struct ia_css_isp_param_host_segments *mem_params,
+	const struct ia_css_isp_param_css_segments *css_params);
+
+/* Allocate memory parameters */
+enum ia_css_err
+ia_css_isp_param_allocate_isp_parameters(
+	struct ia_css_isp_param_host_segments *mem_params,
+	struct ia_css_isp_param_css_segments *css_params,
+	const struct ia_css_isp_param_isp_segments *mem_initializers);
+
+/* Destroy memory parameters */
+void
+ia_css_isp_param_destroy_isp_parameters(
+	struct ia_css_isp_param_host_segments *mem_params,
+	struct ia_css_isp_param_css_segments *css_params);
+
+/* Load fw parameters */
+void
+ia_css_isp_param_load_fw_params(
+	const char *fw,
+	union ia_css_all_memory_offsets *mem_offsets,
+	const struct ia_css_isp_param_memory_offsets *memory_offsets,
+	bool init);
+
+/* Copy host parameter images to ddr */
+enum ia_css_err
+ia_css_isp_param_copy_isp_mem_if_to_ddr(
+	struct ia_css_isp_param_css_segments *ddr,
+	const struct ia_css_isp_param_host_segments *host,
+	enum ia_css_param_class pclass);
+
+/* Enable a pipeline by setting the control field in the isp dmem parameters */
+void
+ia_css_isp_param_enable_pipeline(
+	const struct ia_css_isp_param_host_segments *mem_params);
+
+#endif /* _IA_CSS_ISP_PARAM_H_ */
diff --git a/drivers/media/atomisp2/css2400/runtime/isp_param/interface/ia_css_isp_param_types.h b/drivers/media/atomisp2/css2400/runtime/isp_param/interface/ia_css_isp_param_types.h
new file mode 100644
index 0000000..0ba90e7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/isp_param/interface/ia_css_isp_param_types.h
@@ -0,0 +1,90 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_ISP_PARAM_TYPES_H_
+#define _IA_CSS_ISP_PARAM_TYPES_H_
+
+#include "ia_css_types.h"
+
+/* Short hands */
+#define IA_CSS_ISP_DMEM IA_CSS_ISP_DMEM0
+#define IA_CSS_ISP_VMEM IA_CSS_ISP_VMEM0
+
+/* The driver depends on this, to be removed later. */
+#define IA_CSS_NUM_ISP_MEMORIES IA_CSS_NUM_MEMORIES
+
+/* Explicit member numbering to avoid fish type checker bug */
+enum ia_css_param_class {
+	IA_CSS_PARAM_CLASS_PARAM  = 0,	/* Late binding parameters, like 3A */
+	IA_CSS_PARAM_CLASS_CONFIG = 1,	/* Pipe config time parameters, like resolution */
+	IA_CSS_PARAM_CLASS_STATE  = 2,    // State parameters, like tnr buffer index
+	/* Not yet implemented
+	IA_CSS_PARAM_CLASS_FRAME	  = 3,    // Frame time parameters, like output buffer
+	*/
+};
+#define IA_CSS_NUM_PARAM_CLASSES (IA_CSS_PARAM_CLASS_STATE + 1)
+
+
+/* Address/size of each parameter class in each isp memory, host memory pointers */
+struct ia_css_isp_param_host_segments {
+	struct ia_css_host_data params[IA_CSS_NUM_PARAM_CLASSES][IA_CSS_NUM_MEMORIES];
+};
+
+/* Address/size of each parameter class in each isp memory, css memory pointers */
+struct ia_css_isp_param_css_segments {
+	struct ia_css_data      params[IA_CSS_NUM_PARAM_CLASSES][IA_CSS_NUM_MEMORIES];
+};
+
+/* Address/size of each parameter class in each isp memory, isp memory pointers */
+struct ia_css_isp_param_isp_segments {
+	struct ia_css_isp_data  params[IA_CSS_NUM_PARAM_CLASSES][IA_CSS_NUM_MEMORIES];
+};
+
+/* Memory offsets in binary info */
+struct ia_css_isp_param_memory_offsets {
+	uint32_t offsets[IA_CSS_NUM_PARAM_CLASSES];  /**< offset wrt hdr in bytes */
+};
+
+/** Offsets for ISP kernel parameters per isp memory.
+ * Only relevant for standard ISP binaries, not ACC or SP.
+ */
+union ia_css_all_memory_offsets {
+	struct {
+		CSS_ALIGN(struct ia_css_memory_offsets	      *param, 8);
+		CSS_ALIGN(struct ia_css_config_memory_offsets *config, 8);
+		CSS_ALIGN(struct ia_css_state_memory_offsets  *state, 8);
+	} offsets;
+	struct {
+		CSS_ALIGN(void *ptr, 8);
+	} array[IA_CSS_NUM_PARAM_CLASSES];
+};
+
+#define IA_CSS_DEFAULT_ISP_MEM_PARAMS \
+		{ { { { 0, 0 } } } }
+
+#define IA_CSS_DEFAULT_ISP_CSS_PARAMS \
+		{ { { { 0, 0 } } } }
+
+#define IA_CSS_DEFAULT_ISP_ISP_PARAMS \
+		{ { { { 0, 0 } } } }
+
+#endif /* _IA_CSS_ISP_PARAM_TYPES_H_ */
+
diff --git a/drivers/media/atomisp2/css2400/runtime/isp_param/src/isp_param.c b/drivers/media/atomisp2/css2400/runtime/isp_param/src/isp_param.c
new file mode 100644
index 0000000..55ae639
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/isp_param/src/isp_param.c
@@ -0,0 +1,208 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "memory_access.h"
+#include "ia_css_pipeline.h"
+#include "ia_css_isp_param.h"
+
+/* Set functions for parameter memory descriptors */
+
+void
+ia_css_isp_param_set_mem_init(
+	struct ia_css_isp_param_host_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem,
+	char *address, size_t size)
+{
+	mem_init->params[pclass][mem].address = address;
+	mem_init->params[pclass][mem].size = size;
+}
+
+void
+ia_css_isp_param_set_css_mem_init(
+	struct ia_css_isp_param_css_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem,
+	hrt_vaddress address, size_t size)
+{
+	mem_init->params[pclass][mem].address = address;
+	mem_init->params[pclass][mem].size = size;
+}
+
+void
+ia_css_isp_param_set_isp_mem_init(
+	struct ia_css_isp_param_isp_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem,
+	uint32_t address, size_t size)
+{
+	mem_init->params[pclass][mem].address = address;
+	mem_init->params[pclass][mem].size = size;
+}
+
+/* Get functions for parameter memory descriptors */
+const struct ia_css_host_data*
+ia_css_isp_param_get_mem_init(
+	const struct ia_css_isp_param_host_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem)
+{
+	return &mem_init->params[pclass][mem];
+}
+
+const struct ia_css_data*
+ia_css_isp_param_get_css_mem_init(
+	const struct ia_css_isp_param_css_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem)
+{
+	return &mem_init->params[pclass][mem];
+}
+
+const struct ia_css_isp_data*
+ia_css_isp_param_get_isp_mem_init(
+	const struct ia_css_isp_param_isp_segments *mem_init,
+	enum ia_css_param_class pclass,
+	enum ia_css_isp_memories mem)
+{
+	return &mem_init->params[pclass][mem];
+}
+
+void
+ia_css_init_memory_interface(
+	struct ia_css_isp_param_css_segments *isp_mem_if,
+	const struct ia_css_isp_param_host_segments *mem_params,
+	const struct ia_css_isp_param_css_segments *css_params)
+{
+	unsigned pclass, mem;
+	for (pclass = 0; pclass < IA_CSS_NUM_PARAM_CLASSES; pclass++) {
+		memset(isp_mem_if->params[pclass], 0, sizeof(isp_mem_if->params[pclass]));
+		for (mem = 0; mem < IA_CSS_NUM_MEMORIES; mem++) {
+			if (!mem_params->params[pclass][mem].address) continue;
+			isp_mem_if->params[pclass][mem].size = mem_params->params[pclass][mem].size;
+			if (pclass != IA_CSS_PARAM_CLASS_PARAM)
+				isp_mem_if->params[pclass][mem].address = css_params->params[pclass][mem].address;
+		}
+	}
+}
+
+enum ia_css_err
+ia_css_isp_param_allocate_isp_parameters(
+	struct ia_css_isp_param_host_segments *mem_params,
+	struct ia_css_isp_param_css_segments *css_params,
+	const struct ia_css_isp_param_isp_segments *mem_initializers)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	unsigned mem, pclass;
+
+	pclass = IA_CSS_PARAM_CLASS_PARAM;
+	for (mem = 0; mem < IA_CSS_NUM_MEMORIES; mem++) {
+		for (pclass = 0; pclass < IA_CSS_NUM_PARAM_CLASSES; pclass++) {
+			size_t size = 0;
+			if (mem_initializers)
+				size = mem_initializers->params[pclass][mem].size;
+			mem_params->params[pclass][mem].size = size;
+			mem_params->params[pclass][mem].address = NULL;
+			css_params->params[pclass][mem].size = size;
+			css_params->params[pclass][mem].address = 0x0;
+			if (size) {
+				mem_params->params[pclass][mem].address = sh_css_calloc(1, size);
+				if (!mem_params->params[pclass][mem].address)
+					return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+				if (pclass != IA_CSS_PARAM_CLASS_PARAM) {
+					css_params->params[pclass][mem].address = mmgr_malloc(size);
+					if (!css_params->params[pclass][mem].address)
+						return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+				}
+			}
+		}
+	}
+	return err;
+}
+
+void
+ia_css_isp_param_destroy_isp_parameters(
+	struct ia_css_isp_param_host_segments *mem_params,
+	struct ia_css_isp_param_css_segments *css_params)
+{
+	unsigned mem, pclass;
+
+	for (mem = 0; mem < IA_CSS_NUM_MEMORIES; mem++) {
+		for (pclass = 0; pclass < IA_CSS_NUM_PARAM_CLASSES; pclass++) {
+			if (mem_params->params[pclass][mem].address)
+				sh_css_free(mem_params->params[pclass][mem].address);
+			if (css_params->params[pclass][mem].address)
+				mmgr_free(css_params->params[pclass][mem].address);
+			mem_params->params[pclass][mem].address = NULL;
+			css_params->params[pclass][mem].address = 0x0;
+		}
+	}
+}
+
+void
+ia_css_isp_param_load_fw_params(
+	const char *fw,
+	union ia_css_all_memory_offsets *mem_offsets,
+	const struct ia_css_isp_param_memory_offsets *memory_offsets,
+	bool init)
+{
+	unsigned pclass;
+	for (pclass = 0; pclass < IA_CSS_NUM_PARAM_CLASSES; pclass++) {
+		mem_offsets->array[pclass].ptr = NULL;
+		if (init)
+			mem_offsets->array[pclass].ptr = (void *)(fw + memory_offsets->offsets[pclass]);
+	}
+}
+
+enum ia_css_err
+ia_css_isp_param_copy_isp_mem_if_to_ddr(
+	struct ia_css_isp_param_css_segments *ddr,
+	const struct ia_css_isp_param_host_segments *host,
+	enum ia_css_param_class pclass)
+{
+	unsigned mem;
+
+	for (mem = 0; mem < N_IA_CSS_ISP_MEMORIES; mem++) {
+		size_t       size	  = host->params[pclass][mem].size;
+		hrt_vaddress ddr_mem_ptr  = ddr->params[pclass][mem].address;
+		char	    *host_mem_ptr = host->params[pclass][mem].address;
+		if (size != ddr->params[pclass][mem].size)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		if (!size) continue;
+		mmgr_store(ddr_mem_ptr, host_mem_ptr, size);
+	}
+	return IA_CSS_SUCCESS;
+}
+
+void
+ia_css_isp_param_enable_pipeline(
+	const struct ia_css_isp_param_host_segments *mem_params)
+{
+	/* By protocol b0 of the mandatory uint32_t first field of the
+	   input parameter is a disable bit*/
+	short dmem_offset = 0;
+
+	if (mem_params->params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM0].size == 0) return;
+
+	*(uint32_t *)&mem_params->params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM0].address[dmem_offset] = 0x0;
+}
+
+
diff --git a/drivers/media/atomisp2/css2400/runtime/isys/interface/ia_css_isys.h b/drivers/media/atomisp2/css2400/runtime/isys/interface/ia_css_isys.h
new file mode 100644
index 0000000..37418a5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/isys/interface/ia_css_isys.h
@@ -0,0 +1,150 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ISYS_H__
+#define __IA_CSS_ISYS_H__
+
+#include "input_system.h"
+#include "ia_css.h"
+#include "ia_css_isys_comm.h"
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+/**
+ * Virtual Input System. (Input System 2401)
+ */
+typedef input_system_cfg_t	ia_css_isys_descr_t;
+/** end of Virtual Input System */
+#endif
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+input_system_error_t ia_css_isys_init(void);
+void ia_css_isys_uninit(void);
+#endif
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+enum ia_css_err ia_css_isys_csi_rx_register_stream(
+	enum ia_css_csi2_port port,
+	uint32_t sp_thread_id);
+
+enum ia_css_err ia_css_isys_csi_rx_unregister_stream(
+	enum ia_css_csi2_port port,
+	uint32_t sp_thread_id);
+#endif
+
+#if !defined(USE_INPUT_SYSTEM_VERSION_2401)
+/* CSS Receiver */
+void ia_css_isys_rx_configure(
+	const rx_cfg_t *config,
+	const enum ia_css_input_mode input_mode);
+
+void ia_css_isys_rx_disable(void);
+
+void ia_css_isys_rx_enable_all_interrupts(void);
+
+unsigned int ia_css_isys_rx_get_interrupt_reg(void);
+#endif /* #if !defined(USE_INPUT_SYSTEM_VERSION_2401) */
+
+/** @brief Translate format and compression to format type.
+ *
+ * @param[in]	input_format	The input format.
+ * @param[in]	compression	The compression scheme.
+ * @param[out]	fmt_type	Pointer to the resulting format type.
+ * @return			Error code.
+ *
+ * Translate an input format and mipi compression pair to the fmt_type.
+ * This is normally done by the sensor, but when using the input fifo, this
+ * format type must be sumitted correctly by the application.
+ */
+enum ia_css_err ia_css_isys_convert_stream_format_to_mipi_format(
+		enum ia_css_stream_format input_format,
+		mipi_predictor_t compression,
+		unsigned int *fmt_type);
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+/**
+ * Virtual Input System. (Input System 2401)
+ */
+extern ia_css_isys_error_t ia_css_isys_stream_create(
+		ia_css_isys_descr_t	*isys_stream_descr,
+		ia_css_isys_stream_h	isys_stream);
+
+extern void ia_css_isys_stream_destroy(
+		ia_css_isys_stream_h	isys_stream);
+
+extern ia_css_isys_error_t ia_css_isys_stream_calculate_cfg(
+		ia_css_isys_stream_h		isys_stream,
+		ia_css_isys_descr_t		*isys_stream_descr,
+		ia_css_isys_stream_cfg_t	*isys_stream_cfg);
+
+extern void ia_css_isys_csi_rx_lut_rmgr_init(void);
+
+extern void ia_css_isys_csi_rx_lut_rmgr_uninit(void);
+
+extern bool ia_css_isys_csi_rx_lut_rmgr_acquire(
+	csi_rx_backend_ID_t		backend,
+	csi_mipi_packet_type_t		packet_type,
+	csi_rx_backend_lut_entry_t	*entry);
+
+extern void ia_css_isys_csi_rx_lut_rmgr_release(
+	csi_rx_backend_ID_t		backend,
+	csi_mipi_packet_type_t		packet_type,
+	csi_rx_backend_lut_entry_t	*entry);
+
+
+extern void ia_css_isys_ibuf_rmgr_init(void);
+
+extern void ia_css_isys_ibuf_rmgr_uninit(void);
+
+extern bool ia_css_isys_ibuf_rmgr_acquire(
+	uint32_t	size,
+	uint32_t	*start_addr);
+
+extern void ia_css_isys_ibuf_rmgr_release(
+	uint32_t	*start_addr);
+
+extern void ia_css_isys_dma_channel_rmgr_init(void);
+
+extern void ia_css_isys_dma_channel_rmgr_uninit(void);
+
+extern bool ia_css_isys_dma_channel_rmgr_acquire(
+	isys2401_dma_ID_t	dma_id,
+	isys2401_dma_channel	*channel);
+
+extern void ia_css_isys_dma_channel_rmgr_release(
+	isys2401_dma_ID_t	dma_id,
+	isys2401_dma_channel	*channel);
+
+extern void ia_css_isys_stream2mmio_sid_rmgr_init(void);
+
+extern void ia_css_isys_stream2mmio_sid_rmgr_uninit(void);
+
+extern bool ia_css_isys_stream2mmio_sid_rmgr_acquire(
+	stream2mmio_ID_t	stream2mmio,
+	stream2mmio_sid_ID_t	*sid);
+
+extern void ia_css_isys_stream2mmio_sid_rmgr_release(
+	stream2mmio_ID_t	stream2mmio,
+	stream2mmio_sid_ID_t	*sid);
+
+/** end of Virtual Input System */
+#endif
+
+#endif				/* __IA_CSS_ISYS_H__ */
diff --git a/drivers/media/atomisp2/css2400/runtime/isys/interface/ia_css_isys_comm.h b/drivers/media/atomisp2/css2400/runtime/isys/interface/ia_css_isys_comm.h
new file mode 100644
index 0000000..1ce4fb1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/isys/interface/ia_css_isys_comm.h
@@ -0,0 +1,48 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_ISYS_COMM_H
+#define __IA_CSS_ISYS_COMM_H
+
+#include <type_support.h>
+#include <input_system.h>
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+#include <input_system_global.h>
+
+/*
+ * a) ia_css_isys_stream_h & ia_css_isys_stream_cfg_t come from host.
+ *
+ * b) Here it is better  to use actual structures for stream handle
+ * instead of opaque handles. Otherwise, we need to have another
+ * communication channel to interpret that opaque handle(this handle is
+ * maintained by host and needs to be populated to sp for every stream open)
+ * */
+typedef virtual_input_system_t*		ia_css_isys_stream_h;
+typedef virtual_input_system_cfg_t	ia_css_isys_stream_cfg_t;
+
+/*
+ * error check for ISYS APIs.
+ * */
+typedef bool ia_css_isys_error_t;
+
+#endif  /* USE_INPUT_SYSTEM_VERSION_2401*/
+#endif  /*_IA_CSS_ISYS_COMM_H */
diff --git a/drivers/media/atomisp2/css2400/runtime/isys/src/isys_init.c b/drivers/media/atomisp2/css2400/runtime/isys/src/isys_init.c
new file mode 100644
index 0000000..760769e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/isys/src/isys_init.c
@@ -0,0 +1,119 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "input_system.h"
+
+#ifdef HAS_INPUT_SYSTEM_VERSION_2
+#include "ia_css_isys.h"
+#include "platform_support.h"
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2)
+input_system_error_t ia_css_isys_init(void)
+{
+	backend_channel_cfg_t backend_ch0;
+	backend_channel_cfg_t backend_ch1;
+	target_cfg2400_t targetB;
+	target_cfg2400_t targetC;
+	uint32_t acq_mem_region_size = 24;
+	uint32_t acq_nof_mem_regions = 2;
+	input_system_error_t error = INPUT_SYSTEM_ERR_NO_ERROR;
+
+	memset(&backend_ch0, 0, sizeof(backend_channel_cfg_t));
+	memset(&backend_ch1, 0, sizeof(backend_channel_cfg_t));
+	memset(&targetB, 0, sizeof(targetB));
+	memset(&targetC, 0, sizeof(targetC));
+
+	error = input_system_configuration_reset();
+	if (error != INPUT_SYSTEM_ERR_NO_ERROR)
+		return error;
+
+	error = input_system_csi_xmem_channel_cfg(
+			0,			/*ch_id                 */
+			INPUT_SYSTEM_PORT_A,	/*port                  */
+			backend_ch0,		/*backend_ch            */
+			32,			/*mem_region_size       */
+			6,			/*nof_mem_regions       */
+			acq_mem_region_size,	/*acq_mem_region_size   */
+			acq_nof_mem_regions,	/*acq_nof_mem_regions   */
+			targetB,		/*target                */
+			3);			/*nof_xmem_buffers      */
+	if (error != INPUT_SYSTEM_ERR_NO_ERROR)
+		return error;
+
+	error = input_system_csi_xmem_channel_cfg(
+			1,			/*ch_id                 */
+			INPUT_SYSTEM_PORT_B,	/*port                  */
+			backend_ch0,		/*backend_ch            */
+			16,			/*mem_region_size       */
+			3,			/*nof_mem_regions       */
+			acq_mem_region_size,	/*acq_mem_region_size   */
+			acq_nof_mem_regions,	/*acq_nof_mem_regions   */
+			targetB,		/*target                */
+			3);			/*nof_xmem_buffers      */
+	if (error != INPUT_SYSTEM_ERR_NO_ERROR)
+		return error;
+
+	error = input_system_csi_xmem_channel_cfg(
+			2,			/*ch_id                 */
+			INPUT_SYSTEM_PORT_C,	/*port                  */
+			backend_ch1,		/*backend_ch            */
+			32,			/*mem_region_size       */
+			3,			/*nof_mem_regions       */
+			acq_mem_region_size,	/*acq_mem_region_size   */
+			acq_nof_mem_regions,	/*acq_nof_mem_regions   */
+			targetC,		/*target                */
+			2);			/*nof_xmem_buffers      */
+	if (error != INPUT_SYSTEM_ERR_NO_ERROR)
+		return error;
+
+	error = input_system_configuration_commit();
+
+	return error;
+}
+#elif defined(USE_INPUT_SYSTEM_VERSION_2401)
+input_system_error_t ia_css_isys_init(void)
+{
+	input_system_error_t error = INPUT_SYSTEM_ERR_NO_ERROR;
+
+	ia_css_isys_csi_rx_lut_rmgr_init();
+	ia_css_isys_ibuf_rmgr_init();
+	ia_css_isys_dma_channel_rmgr_init();
+	ia_css_isys_stream2mmio_sid_rmgr_init();
+
+	return error;
+}
+#endif
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2)
+void ia_css_isys_uninit(void)
+{
+}
+#elif defined(USE_INPUT_SYSTEM_VERSION_2401)
+void ia_css_isys_uninit(void)
+{
+	ia_css_isys_csi_rx_lut_rmgr_uninit();
+	ia_css_isys_ibuf_rmgr_uninit();
+	ia_css_isys_dma_channel_rmgr_uninit();
+	ia_css_isys_stream2mmio_sid_rmgr_uninit();
+}
+#endif
+
+#endif
diff --git a/drivers/media/atomisp2/css2400/runtime/isys/src/rx.c b/drivers/media/atomisp2/css2400/runtime/isys/src/rx.c
new file mode 100644
index 0000000..ffd3e5d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/isys/src/rx.c
@@ -0,0 +1,450 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#define __INLINE_INPUT_SYSTEM__
+#include "input_system.h"
+#include "assert_support.h"
+#include "ia_css_isys.h"
+#include "sh_css_internal.h"
+
+#if !defined(USE_INPUT_SYSTEM_VERSION_2401)
+void ia_css_isys_rx_enable_all_interrupts(void)
+{
+	hrt_data bits = receiver_port_reg_load(RX0_ID,
+				MIPI_PORT1_ID,
+				_HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
+
+	bits |= (1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT) |
+#if defined(HAS_RX_VERSION_2)
+	    (1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT) |
+#endif
+	    (1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT) |
+	    /*(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT) | */
+	    (1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT) |
+	    (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT);
+	/*(1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT); */
+
+	receiver_port_reg_store(RX0_ID,
+				MIPI_PORT1_ID,
+				_HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, bits);
+
+	/*
+	 * The CSI is nested into the Iunit IRQ's
+	 */
+	ia_css_irq_enable(IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR, true);
+
+	return;
+}
+
+unsigned int ia_css_isys_rx_get_interrupt_reg(void)
+{
+	return receiver_port_reg_load(RX0_ID,
+				      MIPI_PORT1_ID,
+				      _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
+}
+
+void ia_css_rx_get_irq_info(unsigned int *irq_infos)
+{
+	unsigned long infos = 0;
+
+
+	hrt_data bits = receiver_port_reg_load(RX0_ID,
+				MIPI_PORT1_ID,
+				_HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
+
+	assert(irq_infos != NULL);
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN;
+#if defined(HAS_RX_VERSION_2)
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_INIT_TIMEOUT;
+#endif
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ECC_CORRECTED;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_SOT;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_CONTROL;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_CRC;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC;
+	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT))
+		infos |= IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC;
+
+	*irq_infos = infos;
+}
+
+void ia_css_rx_clear_irq_info(unsigned int irq_infos)
+{
+	hrt_data bits = receiver_port_reg_load(RX0_ID,
+				MIPI_PORT1_ID,
+				_HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
+
+	/* MW: Why do we remap the receiver bitmap */
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT;
+#if defined(HAS_RX_VERSION_2)
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_INIT_TIMEOUT)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT;
+#endif
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ECC_CORRECTED)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_SOT)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_CONTROL)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_CRC)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT;
+	if (irq_infos & IA_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
+		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT;
+
+	receiver_port_reg_store(RX0_ID,
+				MIPI_PORT1_ID,
+				_HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, bits);
+
+	return;
+}
+#endif /* #if !defined(USE_INPUT_SYSTEM_VERSION_2401) */
+
+enum ia_css_err ia_css_isys_convert_stream_format_to_mipi_format(
+		enum ia_css_stream_format input_format,
+		mipi_predictor_t compression,
+		unsigned int *fmt_type)
+{
+	assert(fmt_type != NULL);
+	/*
+	 * Custom (user defined) modes. Used for compressed
+	 * MIPI transfers
+	 *
+	 * Checkpatch thinks the indent before "if" is suspect
+	 * I think the only suspect part is the missing "else"
+	 * because of the return.
+	 */
+	if (compression != MIPI_PREDICTOR_NONE) {
+		switch (input_format) {
+		case IA_CSS_STREAM_FORMAT_RAW_6:
+			*fmt_type = 6;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_7:
+			*fmt_type = 7;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_8:
+			*fmt_type = 8;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_10:
+			*fmt_type = 10;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_12:
+			*fmt_type = 12;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_14:
+			*fmt_type = 14;
+			break;
+		case IA_CSS_STREAM_FORMAT_RAW_16:
+			*fmt_type = 16;
+			break;
+		default:
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		}
+		return IA_CSS_SUCCESS;
+	}
+	/*
+	 * This mapping comes from the Arasan CSS function spec
+	 * (CSS_func_spec1.08_ahb_sep29_08.pdf).
+	 *
+	 * MW: For some reason the mapping is not 1-to-1
+	 */
+	switch (input_format) {
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+		*fmt_type = MIPI_FORMAT_RGB888;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+		*fmt_type = MIPI_FORMAT_RGB555;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+		*fmt_type = MIPI_FORMAT_RGB444;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+		*fmt_type = MIPI_FORMAT_RGB565;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+		*fmt_type = MIPI_FORMAT_RGB666;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+		*fmt_type = MIPI_FORMAT_RAW8;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+		*fmt_type = MIPI_FORMAT_RAW10;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+		*fmt_type = MIPI_FORMAT_RAW6;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+		*fmt_type = MIPI_FORMAT_RAW7;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+		*fmt_type = MIPI_FORMAT_RAW12;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+		*fmt_type = MIPI_FORMAT_RAW14;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+		*fmt_type = MIPI_FORMAT_YUV420_8;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+		*fmt_type = MIPI_FORMAT_YUV420_10;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+		*fmt_type = MIPI_FORMAT_YUV422_8;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+		*fmt_type = MIPI_FORMAT_YUV422_10;
+		break;
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+		*fmt_type = MIPI_FORMAT_BINARY_8;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+		*fmt_type = MIPI_FORMAT_YUV420_8_LEGACY;
+		break;
+	case IA_CSS_STREAM_FORMAT_EMBEDDED:
+		*fmt_type = MIPI_FORMAT_EMBEDDED;
+		break;
+#ifndef USE_INPUT_SYSTEM_VERSION_2401
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+		/* This is not specified by Arasan, so we use
+		 * 17 for now.
+		 */
+		*fmt_type = MIPI_FORMAT_RAW16;
+		break;
+#else
+	case IA_CSS_STREAM_FORMAT_USER_DEF1:
+		*fmt_type = MIPI_FORMAT_CUSTOM0;
+		break;
+	case IA_CSS_STREAM_FORMAT_USER_DEF2:
+		*fmt_type = MIPI_FORMAT_CUSTOM1;
+		break;
+	case IA_CSS_STREAM_FORMAT_USER_DEF3:
+		*fmt_type = MIPI_FORMAT_CUSTOM2;
+		break;
+	case IA_CSS_STREAM_FORMAT_USER_DEF4:
+		*fmt_type = MIPI_FORMAT_CUSTOM3;
+		break;
+	case IA_CSS_STREAM_FORMAT_USER_DEF5:
+		*fmt_type = MIPI_FORMAT_CUSTOM4;
+		break;
+	case IA_CSS_STREAM_FORMAT_USER_DEF6:
+		*fmt_type = MIPI_FORMAT_CUSTOM5;
+		break;
+	case IA_CSS_STREAM_FORMAT_USER_DEF7:
+		*fmt_type = MIPI_FORMAT_CUSTOM6;
+		break;
+	case IA_CSS_STREAM_FORMAT_USER_DEF8:
+		*fmt_type = MIPI_FORMAT_CUSTOM7;
+		break;
+#endif
+#if defined(HAS_RX_VERSION_2)
+	default:
+		if (input_format > (enum ia_css_stream_format)N_MIPI_FORMAT)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		*fmt_type = input_format;
+		break;
+#else
+	default:
+		return IA_CSS_ERR_INTERNAL_ERROR;
+#endif
+	}
+	return IA_CSS_SUCCESS;
+}
+
+#if !defined(USE_INPUT_SYSTEM_VERSION_2401)
+void ia_css_isys_rx_configure(const rx_cfg_t *config,
+			      const enum ia_css_input_mode input_mode)
+{
+#if defined(HAS_RX_VERSION_2)
+	bool port_enabled[N_MIPI_PORT_ID];
+	bool any_port_enabled = false;
+	mipi_port_ID_t port;
+
+	assert(config != NULL);
+	for (port = (mipi_port_ID_t) 0; port < N_MIPI_PORT_ID; port++) {
+		if (is_receiver_port_enabled(RX0_ID, port))
+			any_port_enabled = true;
+	}
+	/* AM: Check whether this is a problem with multiple
+	 * streams. MS: This is the case. */
+
+	/* Must turn off all ports because of the 2ppc setting */
+#ifdef THIS_CODE_IS_NO_LONGER_NEEDED_FOR_DUAL_STREAM
+	for (port = (mipi_port_ID_t) 0; port < N_MIPI_PORT_ID; port++) {
+		port_enabled[port] = is_receiver_port_enabled(RX0_ID, port);
+		receiver_port_enable(RX0_ID, port, false);
+	}
+#else
+	port = config->port;
+	receiver_port_enable(RX0_ID, port, false);
+#endif
+
+	port = config->port;
+
+	/* AM: Check whether this is a problem with multiple streams. */
+	if (MIPI_PORT_LANES[config->mode][port] != MIPI_0LANE_CFG) {
+		receiver_port_reg_store(RX0_ID, port,
+				_HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX,
+				config->timeout);
+		receiver_port_reg_store(RX0_ID, port,
+				_HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX,
+				config->initcount);
+		receiver_port_reg_store(RX0_ID, port,
+				_HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX,
+				config->synccount);
+		receiver_port_reg_store(RX0_ID, port,
+				_HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX,
+				config->rxcount);
+
+		port_enabled[port] = true;
+
+		if (input_mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+
+			/* MW: A bit of a hack, straight wiring of the capture
+			 * units,assuming they are linearly enumerated. */
+			input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
+					GPREGS_UNIT0_ID,
+					HIVE_ISYS_GPREG_MULTICAST_A_IDX
+						+ (unsigned int)port,
+					INPUT_SYSTEM_CSI_BACKEND);
+			/* MW: Like the integration test example we overwite,
+			 * the GPREG_MUX register */
+			input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
+					GPREGS_UNIT0_ID,
+					HIVE_ISYS_GPREG_MUX_IDX,
+					(input_system_multiplex_t) port);
+		} else {
+			/*
+			 * AM: A bit of a hack, wiring the input system.
+			 */
+			input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
+					GPREGS_UNIT0_ID,
+					HIVE_ISYS_GPREG_MULTICAST_A_IDX
+						+ (unsigned int)port,
+					INPUT_SYSTEM_INPUT_BUFFER);
+			input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
+					GPREGS_UNIT0_ID,
+					HIVE_ISYS_GPREG_MUX_IDX,
+					INPUT_SYSTEM_ACQUISITION_UNIT);
+		}
+	}
+	/*
+	 * The 2ppc is shared for all ports, so we cannot
+	 * disable->configure->enable individual ports
+	 */
+	/* AM: Check whether this is a problem with multiple streams. */
+	/* MS: 2ppc should be a property per binary and should be
+	 * enabled/disabled per binary.
+	 * Currently it is implemented as a system wide setting due
+	 * to effort and risks. */
+	if (!any_port_enabled) {
+		receiver_reg_store(RX0_ID,
+				   _HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX,
+				   config->is_two_ppc);
+		receiver_reg_store(RX0_ID, _HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX,
+				   config->is_two_ppc);
+	}
+#ifdef THIS_CODE_IS_NO_LONGER_NEEDED_FOR_DUAL_STREAM
+	/* enable the selected port(s) */
+	for (port = (mipi_port_ID_t) 0; port < N_MIPI_PORT_ID; port++)
+		receiver_port_enable(RX0_ID, port, port_enabled[port]);
+#else
+	receiver_port_enable(RX0_ID, port, true);
+#endif
+	/* TODO: JB: need to add the beneath used define to mizuchi */
+	/* sh_css_sw_hive_isp_css_2400_system_20121224_0125\css
+	 *                      \hrt\input_system_defs.h
+	 * #define INPUT_SYSTEM_CSI_RECEIVER_SELECT_BACKENG 0X207
+	 */
+	/* TODO: need better name for define
+	 * input_system_reg_store(INPUT_SYSTEM0_ID,
+	 *                INPUT_SYSTEM_CSI_RECEIVER_SELECT_BACKENG, 1);
+	 */
+	input_system_reg_store(INPUT_SYSTEM0_ID, 0x207, 1);
+#else
+#error "rx.c: RX version must be one of {RX_VERSION_2}"
+#endif
+
+	return;
+}
+
+void ia_css_isys_rx_disable(void)
+{
+	mipi_port_ID_t port;
+	for (port = (mipi_port_ID_t) 0; port < N_MIPI_PORT_ID; port++) {
+		receiver_port_reg_store(RX0_ID, port,
+					_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX,
+					false);
+	}
+	return;
+}
+#endif /* if !defined(USE_INPUT_SYSTEM_VERSION_2401) */
+
diff --git a/drivers/media/atomisp2/css2400/runtime/pipeline/interface/ia_css_pipeline.h b/drivers/media/atomisp2/css2400/runtime/pipeline/interface/ia_css_pipeline.h
new file mode 100644
index 0000000..9bc1ef0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/pipeline/interface/ia_css_pipeline.h
@@ -0,0 +1,249 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_PIPELINE_H__
+#define __IA_CSS_PIPELINE_H__
+
+#include "sh_css_internal.h"
+#include "ia_css_pipe_public.h"
+#include "ia_css_pipeline_common.h"
+
+#define IA_CSS_PIPELINE_NUM_MAX		(20)
+
+
+/* Pipeline stage to be executed on SP/ISP */
+struct ia_css_pipeline_stage {
+	unsigned int stage_num;
+	struct ia_css_binary *binary;	/* built-in binary */
+	struct ia_css_binary_info *binary_info;
+	const struct ia_css_fw_info *firmware;	/* acceleration binary */
+	/* SP function for SP stage */
+	enum ia_css_pipeline_stage_sp_func sp_func;
+	unsigned max_input_width;	/* For SP raw copy */
+	struct sh_css_binary_args args;
+	int mode;
+	bool out_frame_allocated[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	bool vf_frame_allocated;
+	struct ia_css_pipeline_stage *next;
+};
+
+/* Pipeline of n stages to be executed on SP/ISP per stage */
+struct ia_css_pipeline {
+	enum ia_css_pipe_id pipe_id;
+	uint8_t pipe_num;
+	bool stop_requested;
+	struct ia_css_pipeline_stage *stages;
+	struct ia_css_pipeline_stage *current_stage;
+	unsigned num_stages;
+	struct ia_css_frame in_frame;
+	struct ia_css_frame out_frame[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_frame vf_frame[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	enum ia_css_frame_delay dvs_frame_delay;
+	unsigned inout_port_config;
+	int num_execs;
+	bool acquire_isp_each_stage;
+};
+
+#define DEFAULT_PIPELINE \
+{ \
+	IA_CSS_PIPE_ID_PREVIEW, /* pipe_id */ \
+	0,			/* pipe_num */ \
+	false,			/* stop_requested */ \
+	NULL,                   /* stages */ \
+	NULL,                   /* current_stage */ \
+	0,                      /* num_stages */ \
+	DEFAULT_FRAME,          /* in_frame */ \
+	{DEFAULT_FRAME},          /* out_frame */ \
+	{DEFAULT_FRAME},          /* vf_frame */ \
+	IA_CSS_FRAME_DELAY_1,   /* frame_delay */ \
+	0,                      /* inout_port_config */ \
+	-1,                     /* num_execs */ \
+	true					/* acquire_isp_each_stage */\
+}
+
+/* Stage descriptor used to create a new stage in the pipeline */
+struct ia_css_pipeline_stage_desc {
+	struct ia_css_binary *binary;
+	const struct ia_css_fw_info *firmware;
+	enum ia_css_pipeline_stage_sp_func sp_func;
+	unsigned max_input_width;
+	unsigned int mode;
+	struct ia_css_frame *cc_frame;
+	struct ia_css_frame *in_frame;
+	struct ia_css_frame *out_frame[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_frame *vf_frame;
+};
+
+/** @brief initialize the pipeline module
+ *
+ * @return    None
+ *
+ * Initializes the pipeline module. This API has to be called
+ * before any operation on the pipeline module is done
+ */
+void ia_css_pipeline_init(void);
+
+/** @brief initialize the pipeline structure with default values
+ *
+ * @param[out] pipeline  structure to be initialized with defaults
+ * @param[in] pipe_id
+ * @param[in] pipe_num Number that uniquely identifies a pipeline.
+ * @return                     IA_CSS_SUCCESS or error code upon error.
+ *
+ * Initializes the pipeline structure with a set of default values.
+ * This API is expected to be used when a pipeline structure is allocated
+ * externally and needs sane defaults
+ */
+enum ia_css_err ia_css_pipeline_create(
+	struct ia_css_pipeline *pipeline,
+	enum ia_css_pipe_id pipe_id,
+	unsigned int pipe_num);
+
+/** @brief destroy a pipeline
+ *
+ * @param[in] pipeline
+ * @return    None
+ *
+ */
+void ia_css_pipeline_destroy(struct ia_css_pipeline *pipeline);
+
+
+/** @brief Starts a pipeline
+ *
+ * @param[in] pipe_id
+ * @param[in] pipeline
+ * @return    None
+ *
+ */
+void ia_css_pipeline_start(enum ia_css_pipe_id pipe_id,
+			   struct ia_css_pipeline *pipeline);
+
+/** @brief Request to stop a pipeline
+ *
+ * @param[in] pipeline
+ * @return                     IA_CSS_SUCCESS or error code upon error.
+ *
+ */
+enum ia_css_err ia_css_pipeline_request_stop(struct ia_css_pipeline *pipeline);
+
+/** @brief Check whether pipeline has stopped
+ *
+ * @param[in] pipeline
+ * @return    true if the pipeline has stopped
+ *
+ */
+bool ia_css_pipeline_has_stopped(struct ia_css_pipeline *pipe);
+
+/** @brief clean all the stages pipeline and make it as new
+ *
+ * @param[in] pipeline
+ * @return    None
+ *
+ */
+void ia_css_pipeline_clean(struct ia_css_pipeline *pipeline);
+
+/** @brief Add a stage to pipeline.
+ *
+ * @param     pipeline               Pointer to the pipeline to be added to.
+ * @param[in] stage_desc       The description of the stage
+ * @param[out] stage            The successor of the stage.
+ * @return                     IA_CSS_SUCCESS or error code upon error.
+ *
+ * Add a new stage to a non-NULL pipeline.
+ * The stage consists of an ISP binary or firmware and input and output
+ * arguments.
+*/
+enum ia_css_err ia_css_pipeline_create_and_add_stage(
+			struct ia_css_pipeline *pipeline,
+			struct ia_css_pipeline_stage_desc *stage_desc,
+			struct ia_css_pipeline_stage **stage);
+
+/** @brief Finalize the stages in a pipeline
+ *
+ * @param     pipeline               Pointer to the pipeline to be added to.
+ * @return                     None
+ *
+ * This API is expected to be called after adding all stages
+*/
+void ia_css_pipeline_finalize_stages(struct ia_css_pipeline *pipeline);
+
+/** @brief gets a stage from the pipeline
+ *
+ * @param[in] pipeline
+ * @return                     IA_CSS_SUCCESS or error code upon error.
+ *
+ */
+enum ia_css_err ia_css_pipeline_get_stage(struct ia_css_pipeline *pipeline,
+			  int mode,
+			  struct ia_css_pipeline_stage **stage);
+
+/** @brief gets the output stage from the pipeline
+ *
+ * @param[in] pipeline
+ * @return                     IA_CSS_SUCCESS or error code upon error.
+ *
+ */
+enum ia_css_err ia_css_pipeline_get_output_stage(
+			struct ia_css_pipeline *pipeline,
+			int mode,
+			struct ia_css_pipeline_stage **stage);
+
+/** @brief Checks whether the pipeline uses params
+ *
+ * @param[in] pipeline
+ * @return    true if the pipeline uses params
+ *
+ */
+bool ia_css_pipeline_uses_params(struct ia_css_pipeline *pipeline);
+
+/**
+ * @brief get the SP thread ID.
+ *
+ * @param[in]	key	The query key, typical use is pipe_num.
+ * @param[out]	val	The query value.
+ *
+ * @return
+ *	true, if the query succeeds;
+ *	false, if the query fails.
+ */
+bool ia_css_pipeline_get_sp_thread_id(unsigned int key, unsigned int *val);
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+/**
+ * @brief Get the pipeline io status
+ *
+ * @param[in] None
+ * @return
+ *	Pointer to pipe_io_status
+ */
+struct sh_css_sp_pipeline_io_status *ia_css_pipeline_get_pipe_io_status(void);
+#endif
+
+/**
+ * @brief Map an SP thread to this pipeline
+ *
+ * @param[in]	pipe_num
+ * @param[in]	map true for mapping and false for unmapping sp threads.
+ *
+ */
+void ia_css_pipeline_map(unsigned int pipe_num, bool map);
+
+#endif /*__IA_CSS_PIPELINE_H__*/
diff --git a/drivers/media/atomisp2/css2400/runtime/pipeline/interface/ia_css_pipeline_common.h b/drivers/media/atomisp2/css2400/runtime/pipeline/interface/ia_css_pipeline_common.h
new file mode 100644
index 0000000..59d50c6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/pipeline/interface/ia_css_pipeline_common.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_PIPELINE_COMMON_H__
+#define __IA_CSS_PIPELINE_COMMON_H__
+
+enum ia_css_pipeline_stage_sp_func {
+	IA_CSS_PIPELINE_RAW_COPY = 0,
+	IA_CSS_PIPELINE_BIN_COPY = 1,
+	IA_CSS_PIPELINE_ISYS_COPY = 2,
+	IA_CSS_PIPELINE_NO_FUNC = 3,
+};
+#define IA_CSS_PIPELINE_NUM_STAGE_FUNCS 3
+
+#endif /*__IA_CSS_PIPELINE_COMMON_H__*/
diff --git a/drivers/media/atomisp2/css2400/runtime/pipeline/src/pipeline.c b/drivers/media/atomisp2/css2400/runtime/pipeline/src/pipeline.c
new file mode 100644
index 0000000..09182d1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/pipeline/src/pipeline.c
@@ -0,0 +1,598 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css.h"
+#include "ia_css_debug.h"
+#include "sw_event_global.h"		/* encode_sw_event */
+#include "sp.h"			/* cnd_sp_irq_enable() */
+#include "assert_support.h"
+#include "memory_access.h"
+#include "sh_css_sp.h"
+#include "ia_css_pipeline.h"
+#include "ia_css_isp_param.h"
+#include "ia_css_bufq.h"
+
+#define PIPELINE_NUM_UNMAPPED                   (~0)
+#define PIPELINE_SP_THREAD_EMPTY_TOKEN          (0x0)
+#define PIPELINE_SP_THREAD_RESERVED_TOKEN       (0x1)
+
+
+/*******************************************************
+*** Static variables
+********************************************************/
+static unsigned int pipeline_num_to_sp_thread_map[IA_CSS_PIPELINE_NUM_MAX];
+static unsigned int pipeline_sp_thread_list[SH_CSS_MAX_SP_THREADS];
+
+/*******************************************************
+*** Static functions
+********************************************************/
+static void pipeline_init_sp_thread_map(void);
+static void pipeline_map_num_to_sp_thread(unsigned int pipe_num);
+static void pipeline_unmap_num_to_sp_thread(unsigned int pipe_num);
+static void pipeline_init_defaults(
+	struct ia_css_pipeline *pipeline,
+	enum ia_css_pipe_id pipe_id,
+	unsigned int pipe_num);
+
+static void pipeline_stage_destroy(struct ia_css_pipeline_stage *stage);
+static enum ia_css_err pipeline_stage_create(
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_pipeline_stage **new_stage);
+
+/*******************************************************
+*** Public functions
+********************************************************/
+void ia_css_pipeline_init(void)
+{
+	pipeline_init_sp_thread_map();
+}
+
+enum ia_css_err ia_css_pipeline_create(
+	struct ia_css_pipeline *pipeline,
+	enum ia_css_pipe_id pipe_id,
+	unsigned int pipe_num)
+{
+	assert(pipeline != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_create() enter:\n");
+
+	pipeline_init_defaults(pipeline, pipe_id, pipe_num);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_create() exit: pipe_num=%d\n",
+		pipeline->pipe_num);
+
+	return IA_CSS_SUCCESS;
+}
+
+void ia_css_pipeline_map(unsigned int pipe_num, bool map)
+{
+	assert(pipe_num < IA_CSS_PIPELINE_NUM_MAX);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_map() enter: pipe_num=%d\n", pipe_num);
+
+	if(map) {
+		pipeline_map_num_to_sp_thread(pipe_num);
+	} else {
+		pipeline_unmap_num_to_sp_thread(pipe_num);
+	}
+}
+
+/** @brief destroy a pipeline
+ *
+ * @param[in] pipeline
+ * @return    None
+ *
+ */
+void ia_css_pipeline_destroy(struct ia_css_pipeline *pipeline)
+{
+	assert(pipeline != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_destroy() enter: pipe_num=%d\n",
+		pipeline->pipe_num);
+
+	/* Free the pipeline number */
+	ia_css_pipeline_clean(pipeline);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_destroy() exit:");
+}
+
+/* Run a pipeline and wait till it completes. */
+void ia_css_pipeline_start(enum ia_css_pipe_id pipe_id,
+			   struct ia_css_pipeline *pipeline)
+{
+	uint8_t pipe_num = 0;
+	unsigned int thread_id;
+
+	assert(pipeline != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+	      "ia_css_pipeline_start() enter: pipe_id=%d, pipeline=%p\n",
+	      pipe_id, pipeline);
+	pipeline->pipe_id = pipe_id;
+	sh_css_sp_init_pipeline(pipeline, pipe_id, pipe_num,
+				false, false, false, true, SH_CSS_BDS_FACTOR_1_00,
+				SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD,
+				IA_CSS_INPUT_MODE_MEMORY, NULL, NULL
+#if !defined(HAS_NO_INPUT_SYSTEM)
+				, (mipi_port_ID_t) 0
+#endif
+				);
+	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+	if (!sh_css_sp_is_running())
+	{
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_start() error,leaving  \n");
+		/* queues are invalid*/
+		return;
+	}
+	ia_css_bufq_enqueue_event(SP_SW_EVENT_ID_4,
+				(uint8_t)thread_id,
+				0,
+				0);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+	      "ia_css_pipeline_start() leave: return_void\n");
+}
+
+/**
+ * @brief Query the SP thread ID.
+ * Refer to "sh_css_internal.h" for details.
+ */
+bool ia_css_pipeline_get_sp_thread_id(unsigned int key, unsigned int *val)
+{
+	assert(key < IA_CSS_PIPELINE_NUM_MAX);
+	assert(key < IA_CSS_PIPE_ID_NUM);
+	assert(val != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+	      "ia_css_pipeline_get_sp_thread_id() enter: key=%d\n",
+	      key);
+	*val = pipeline_num_to_sp_thread_map[key];
+
+	assert(*val != (unsigned)PIPELINE_NUM_UNMAPPED);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+	      "ia_css_pipeline_get_sp_thread_id() leave: return_val=%d\n",
+	      *val);
+	return true;
+}
+
+enum ia_css_err ia_css_pipeline_request_stop(struct ia_css_pipeline *pipeline)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	unsigned int thread_id;
+
+	assert(pipeline != NULL);
+
+	if (pipeline == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_request_stop() enter: pipeline=%p\n",
+		pipeline);
+	pipeline->stop_requested = true;
+
+	/* Send stop event to the sp*/
+	/* This needs improvement, stop on all the pipes available
+	 * in the stream*/
+	ia_css_pipeline_get_sp_thread_id(pipeline->pipe_num, &thread_id);
+	if (!sh_css_sp_is_running())
+	{
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_request_stop() leaving \n");
+		/* queues are invalid */
+		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+	ia_css_bufq_enqueue_event(SP_SW_EVENT_ID_5,
+				(uint8_t)thread_id,
+				0,
+				0);
+	sh_css_sp_uninit_pipeline(pipeline->pipe_num);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		      "ia_css_pipeline_request_stop() leave: return_err=%d\n",
+		      err);
+	return err;
+}
+
+void ia_css_pipeline_clean(struct ia_css_pipeline *pipeline)
+{
+	struct ia_css_pipeline_stage *s;
+
+	assert(pipeline != NULL);
+	s = pipeline->stages;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_clean() enter:\n");
+
+	while (s) {
+		struct ia_css_pipeline_stage *next = s->next;
+		pipeline_stage_destroy(s);
+		s = next;
+	}
+	pipeline_init_defaults(pipeline, pipeline->pipe_id, pipeline->pipe_num);
+}
+
+/** @brief Add a stage to pipeline.
+ *
+ * @param       pipeline      Pointer to the pipeline to be added to.
+ * @param[in]   stage_desc    The description of the stage
+ * @param[out]	stage         The successor of the stage.
+ * @return      IA_CSS_SUCCESS or error code upon error.
+ *
+ * Add a new stage to a non-NULL pipeline.
+ * The stage consists of an ISP binary or firmware and input and
+ * output arguments.
+*/
+enum ia_css_err ia_css_pipeline_create_and_add_stage(
+		struct ia_css_pipeline *pipeline,
+		struct ia_css_pipeline_stage_desc *stage_desc,
+		struct ia_css_pipeline_stage **stage)
+{
+	struct ia_css_pipeline_stage *last, *new_stage = NULL;
+	enum ia_css_err err;
+
+	/* other arguments can be NULL */
+	assert(pipeline != NULL);
+	assert(stage_desc != NULL);
+	last = pipeline->stages;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		      "ia_css_pipeline_create_and_add_stage() enter:\n");
+	if (!stage_desc->binary && !stage_desc->firmware
+	    && (stage_desc->sp_func == IA_CSS_PIPELINE_NO_FUNC)) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			      "ia_css_pipeline_create_and_add_stage() done:"
+			      " Invalid args\n");
+
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+
+	/* Find the last stage */
+	while (last && last->next)
+		last = last->next;
+
+	/* if in_frame is not set, we use the out_frame from the previous
+	 * stage, if no previous stage, it's an error.
+	 */
+	if ((stage_desc->sp_func == IA_CSS_PIPELINE_NO_FUNC)
+		&& (!stage_desc->in_frame)
+		&& (!stage_desc->firmware)
+		&& (!stage_desc->binary->online)) {
+
+		/* Do this only for ISP stages*/
+		if (last && last->args.out_frame[0])
+			stage_desc->in_frame = last->args.out_frame[0];
+
+		if (!stage_desc->in_frame)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+
+	/* Create the new stage */
+	err = pipeline_stage_create(stage_desc, &new_stage);
+	if (err != IA_CSS_SUCCESS) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			      "ia_css_pipeline_create_and_add_stage() done:"
+			      " stage_create_failed\n");
+		return err;
+	}
+
+	if (last)
+		last->next = new_stage;
+	else
+		pipeline->stages = new_stage;
+
+	/* Output the new stage */
+	if (stage)
+		*stage = new_stage;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		      "ia_css_pipeline_create_and_add_stage() done:");
+	return IA_CSS_SUCCESS;
+}
+
+void ia_css_pipeline_finalize_stages(struct ia_css_pipeline *pipeline)
+{
+	unsigned i = 0;
+	struct ia_css_pipeline_stage *stage;
+
+	assert(pipeline != NULL);
+	for (stage = pipeline->stages; stage; stage = stage->next) {
+		stage->stage_num = i;
+		i++;
+	}
+	pipeline->num_stages = i;
+}
+
+enum ia_css_err ia_css_pipeline_get_stage(struct ia_css_pipeline *pipeline,
+					  int mode,
+					  struct ia_css_pipeline_stage **stage)
+{
+	struct ia_css_pipeline_stage *s;
+	assert(pipeline != NULL);
+	assert(stage != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		      "ia_css_pipeline_get_stage() enter:\n");
+	for (s = pipeline->stages; s; s = s->next) {
+		if (s->mode == mode) {
+			*stage = s;
+			return IA_CSS_SUCCESS;
+		}
+	}
+	return IA_CSS_ERR_INTERNAL_ERROR;
+}
+
+enum ia_css_err ia_css_pipeline_get_output_stage(
+		struct ia_css_pipeline *pipeline,
+		int mode,
+		struct ia_css_pipeline_stage **stage)
+{
+	struct ia_css_pipeline_stage *s;
+	assert(pipeline != NULL);
+	assert(stage != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		      "ia_css_pipeline_get_output_stage() enter:\n");
+
+	*stage = NULL;
+	/* First find acceleration firmware at end of pipe */
+	for (s = pipeline->stages; s; s = s->next) {
+		if (s->firmware && s->mode == mode &&
+		    s->firmware->info.isp.sp.enable.output)
+			*stage = s;
+	}
+	if (*stage)
+		return IA_CSS_SUCCESS;
+	/* If no firmware, find binary in pipe */
+	return ia_css_pipeline_get_stage(pipeline, mode, stage);
+}
+
+bool ia_css_pipeline_has_stopped(struct ia_css_pipeline *pipeline)
+{
+	/* Android compilation files if made an local variable
+	stack size on android is limited to 2k and this structure
+	is around 2.5K, in place of static malloc can be done but
+	if this call is made too often it will lead to fragment memory
+	versus a fixed allocation */
+	static struct sh_css_sp_group sp_group;
+	unsigned int thread_id;
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp_group;
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_sp_group = fw->info.sp.group;
+
+	ia_css_pipeline_get_sp_thread_id(pipeline->pipe_num, &thread_id);
+	sp_dmem_load(SP0_ID,
+		     (unsigned int)sp_address_of(sp_group),
+		     &sp_group, sizeof(struct sh_css_sp_group));
+	return sp_group.pipe[thread_id].num_stages == 0;
+}
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+struct sh_css_sp_pipeline_io_status *ia_css_pipeline_get_pipe_io_status(void)
+{
+	return(&sh_css_sp_group.pipe_io_status);
+}
+#endif
+
+/*******************************************************
+*** Static functions
+********************************************************/
+
+/* Pipeline:
+ * To organize the several different binaries for each type of mode,
+ * we use a pipeline. A pipeline contains a number of stages, each with
+ * their own binary and frame pointers.
+ * When stages are added to a pipeline, output frames that are not passed
+ * from outside are automatically allocated.
+ * When input frames are not passed from outside, each stage will use the
+ * output frame of the previous stage as input (the full resolution output,
+ * not the viewfinder output).
+ * Pipelines must be cleaned and re-created when settings of the binaries
+ * change.
+ */
+static void pipeline_stage_destroy(struct ia_css_pipeline_stage *stage)
+{
+	unsigned int i;
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		if (stage->out_frame_allocated[i]) {
+			ia_css_frame_free(stage->args.out_frame[i]);
+			stage->args.out_frame[i] = NULL;
+		}
+	}
+	if (stage->vf_frame_allocated) {
+		ia_css_frame_free(stage->args.out_vf_frame);
+		stage->args.out_vf_frame = NULL;
+	}
+	sh_css_free(stage);
+}
+
+static void pipeline_init_sp_thread_map(void)
+{
+	unsigned int i;
+
+	for (i = 1; i < SH_CSS_MAX_SP_THREADS; i++)
+		pipeline_sp_thread_list[i] = PIPELINE_SP_THREAD_EMPTY_TOKEN;
+
+	for (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++)
+		pipeline_num_to_sp_thread_map[i] = PIPELINE_NUM_UNMAPPED;
+}
+
+static void pipeline_map_num_to_sp_thread(unsigned int pipe_num)
+{
+	unsigned int i;
+	bool found_sp_thread = false;
+
+	/* pipe is not mapped to any thread */
+	assert(pipeline_num_to_sp_thread_map[pipe_num]
+		== (unsigned)PIPELINE_NUM_UNMAPPED);
+
+	for (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {
+		if (pipeline_sp_thread_list[i] ==
+		    PIPELINE_SP_THREAD_EMPTY_TOKEN) {
+			pipeline_sp_thread_list[i] =
+			    PIPELINE_SP_THREAD_RESERVED_TOKEN;
+			pipeline_num_to_sp_thread_map[pipe_num] = i;
+			found_sp_thread = true;
+			break;
+		}
+	}
+
+	/* Make sure a mapping is found */
+	/* I could do:
+		assert(i < SH_CSS_MAX_SP_THREADS);
+
+		But the below is more descriptive.
+	*/
+	assert(found_sp_thread != false);
+}
+
+static void pipeline_unmap_num_to_sp_thread(unsigned int pipe_num)
+{
+	unsigned int thread_id;
+	assert(pipeline_num_to_sp_thread_map[pipe_num]
+		!= (unsigned)PIPELINE_NUM_UNMAPPED);
+
+	thread_id = pipeline_num_to_sp_thread_map[pipe_num];
+	pipeline_num_to_sp_thread_map[pipe_num] = PIPELINE_NUM_UNMAPPED;
+	pipeline_sp_thread_list[thread_id] = PIPELINE_SP_THREAD_EMPTY_TOKEN;
+}
+
+static enum ia_css_err pipeline_stage_create(
+	struct ia_css_pipeline_stage_desc *stage_desc,
+	struct ia_css_pipeline_stage **new_stage)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_pipeline_stage *stage = NULL;
+	struct ia_css_binary *binary;
+	struct ia_css_frame *vf_frame;
+	struct ia_css_frame *out_frame[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	const struct ia_css_fw_info *firmware;
+	unsigned int i;
+
+	/* Verify input parameters*/
+	if (!(stage_desc->in_frame) && !(stage_desc->firmware)
+	    && (stage_desc->binary) && !(stage_desc->binary->online)) {
+	    err = IA_CSS_ERR_INTERNAL_ERROR;
+		goto ERR;
+	}
+
+	binary = stage_desc->binary;
+	firmware = stage_desc->firmware;
+	vf_frame = stage_desc->vf_frame;
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		out_frame[i] = stage_desc->out_frame[i];
+	}
+
+	stage = sh_css_malloc(sizeof(*stage));
+	if (stage == NULL) {
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		goto ERR;
+	}
+	memset(stage, 0, sizeof(*stage));
+
+	if (firmware) {
+		stage->binary = NULL;
+		stage->binary_info =
+		    (struct ia_css_binary_info *)&firmware->info.isp;
+	} else {
+		stage->binary = binary;
+		if (binary)
+			stage->binary_info =
+			    (struct ia_css_binary_info *)binary->info;
+		else
+			stage->binary_info = NULL;
+	}
+
+	stage->firmware = firmware;
+	stage->sp_func = stage_desc->sp_func;
+	stage->max_input_width = stage_desc->max_input_width;
+	stage->mode = stage_desc->mode;
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
+		stage->out_frame_allocated[i] = false;
+	stage->vf_frame_allocated = false;
+	stage->next = NULL;
+	sh_css_binary_args_reset(&stage->args);
+
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		if (!(out_frame[i]) && (binary)
+			&& (binary->out_frame_info[i].res.width)) {
+			err = ia_css_frame_allocate_from_info(&out_frame[i],
+							&binary->out_frame_info[i]);
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+			stage->out_frame_allocated[i] = true;
+		}
+	}
+	/* VF frame is not needed in case of need_pp
+	   However, the capture binary needs a vf frame to write to.
+	 */
+	if (!vf_frame) {
+		if ((binary && binary->vf_frame_info.res.width) ||
+		    (firmware && firmware->info.isp.sp.enable.vf_veceven)
+		    ) {
+			err = ia_css_frame_allocate_from_info(&vf_frame,
+							&binary->vf_frame_info);
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+			stage->vf_frame_allocated = true;
+		}
+	} else if (vf_frame && binary && binary->vf_frame_info.res.width) {
+		/* only mark as allocated if buffer pointer available */
+		if (vf_frame->data != mmgr_NULL)
+			stage->vf_frame_allocated = true;
+	}
+
+	stage->args.cc_frame = stage_desc->cc_frame;
+	stage->args.in_frame = stage_desc->in_frame;
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
+		stage->args.out_frame[i] = out_frame[i];
+	stage->args.out_vf_frame = vf_frame;
+	*new_stage = stage;
+	return err;
+ERR:
+	if (stage != NULL)
+		pipeline_stage_destroy(stage);
+	return err;
+}
+
+static void pipeline_init_defaults(
+	struct ia_css_pipeline *pipeline,
+	enum ia_css_pipe_id pipe_id,
+	unsigned int pipe_num)
+{
+	struct ia_css_frame init_frame = DEFAULT_FRAME;
+	unsigned int i;
+
+	pipeline->pipe_id = pipe_id;
+	pipeline->stages = NULL;
+	pipeline->stop_requested = false;
+	pipeline->current_stage = NULL;
+	pipeline->in_frame = init_frame;
+	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
+		pipeline->out_frame[i] = init_frame;
+		pipeline->vf_frame[i] = init_frame;
+	}
+	pipeline->num_execs = -1;
+	pipeline->acquire_isp_each_stage = true;
+	pipeline->pipe_num = pipe_num;
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/queue/interface/ia_css_queue.h b/drivers/media/atomisp2/css2400/runtime/queue/interface/ia_css_queue.h
new file mode 100644
index 0000000..292aedd
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/queue/interface/ia_css_queue.h
@@ -0,0 +1,183 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_QUEUE_H
+#define __IA_CSS_QUEUE_H
+
+#include <platform_support.h>
+#include <type_support.h>
+
+#include "ia_css_queue_comm.h"
+#include "../src/queue_access.h"
+
+/* Local Queue object descriptor */
+struct ia_css_queue_local {
+	ia_css_circbuf_desc_t *cb_desc; /*Circbuf desc for local queues*/
+	ia_css_circbuf_elem_t *cb_elems; /*Circbuf elements*/
+};
+typedef struct ia_css_queue_local ia_css_queue_local_t;
+
+/* Handle for queue object*/
+typedef struct ia_css_queue ia_css_queue_t;
+
+
+/*****************************************************************************
+ * Queue Public APIs
+ *****************************************************************************/
+/** @brief Initialize a local queue instance.
+ *
+ * @param[out] qhandle. Handle to queue instance for use with API
+ * @param[in]  desc.   Descriptor with queue properties filled-in
+ * @return     0      - Successful init of local queue instance.
+ * @return     EINVAL - Invalid argument.
+ *
+ */
+extern int ia_css_queue_local_init(
+			ia_css_queue_t *qhandle,
+			ia_css_queue_local_t *desc);
+
+/** @brief Initialize a remote queue instance
+ *
+ * @param[out] qhandle. Handle to queue instance for use with API
+ * @param[in]  desc.   Descriptor with queue properties filled-in
+ * @return     0      - Successful init of remote queue instance.
+ * @return     EINVAL - Invalid argument.
+ */
+extern int ia_css_queue_remote_init(
+			ia_css_queue_t *qhandle,
+			ia_css_queue_remote_t *desc);
+
+/** @brief Uninitialize a queue instance
+ *
+ * @param[in]  qhandle. Handle to queue instance
+ * @return     0 - Successful uninit.
+ *
+ */
+extern int ia_css_queue_uninit(
+			ia_css_queue_t *qhandle);
+
+/** @brief Enqueue an item in the queue instance
+ *
+ * @param[in]  qhandle. Handle to queue instance
+ * @param[in]  item.    Object to be enqueued.
+ * @return     0       - Successful enqueue.
+ * @return     EINVAL  - Invalid argument.
+ * @return     ENOBUFS - Queue is full.
+ *
+ */
+extern int ia_css_queue_enqueue(
+			ia_css_queue_t *qhandle,
+			uint32_t item);
+
+/** @brief Dequeue an item from the queue instance
+ *
+ * @param[in]  qhandle. Handle to queue instance
+ * @param[out] item.    Object to be dequeued into this item.
+
+ * @return     0       - Successful dequeue.
+ * @return     EINVAL  - Invalid argument.
+ * @return     ENODATA - Queue is empty.
+ *
+ */
+extern int ia_css_queue_dequeue(
+			ia_css_queue_t *qhandle,
+			uint32_t *item);
+
+/** @brief Check if the queue is empty
+ *
+ * @param[in]  qhandle.  Handle to queue instance
+ * @param[in]  is_empty  True if empty, False if not.
+ * @return     0       - Successful access state.
+ * @return     EINVAL  - Invalid argument.
+ * @return     ENOSYS  - Function not implemented.
+ *
+ */
+extern int ia_css_queue_is_empty(
+			ia_css_queue_t *qhandle,
+			bool *is_empty);
+
+/** @brief Check if the queue is full
+ *
+ * @param[in]  qhandle.  Handle to queue instance
+ * @param[in]  is_full   True if Full, False if not.
+ * @return     0       - Successfully access state.
+ * @return     EINVAL  - Invalid argument.
+ * @return     ENOSYS  - Function not implemented.
+ *
+ */
+extern int ia_css_queue_is_full(
+			ia_css_queue_t *qhandle,
+			bool *is_full);
+
+/** @brief Get used space in the queue
+ *
+ * @param[in]  qhandle.  Handle to queue instance
+ * @param[in]  size      Number of available elements in the queue
+ * @return     0       - Successfully access state.
+ * @return     EINVAL  - Invalid argument.
+ *
+ */
+extern int ia_css_queue_get_used_space(
+			ia_css_queue_t *qhandle,
+			uint32_t *size);
+
+/** @brief Get free space in the queue
+ *
+ * @param[in]  qhandle.  Handle to queue instance
+ * @param[in]  size      Number of free elements in the queue
+ * @return     0       - Successfully access state.
+ * @return     EINVAL  - Invalid argument.
+ *
+ */
+extern int ia_css_queue_get_free_space(
+			ia_css_queue_t *qhandle,
+			uint32_t *size);
+
+/** @brief Peek at an element in the queue
+ *
+ * @param[in]  qhandle.  Handle to queue instance
+ * @param[in]  offset    Offset of element to peek,
+ * 			 starting from begining of queue
+ * @param[in]  element   Value of element returned
+ * @return     0       - Successfully access state.
+ * @return     EINVAL  - Invalid argument.
+ *
+ */
+extern int ia_css_queue_peek(
+		ia_css_queue_t *qhandle,
+		uint32_t offset,
+		uint32_t *element);
+
+/** @brief Get the usable size for the queue
+ *
+ * @param[in]  qhandle. Handle to queue instance
+ * @param[out] size     Size value to be returned here.
+ * @return     0       - Successful get size.
+ * @return     EINVAL  - Invalid argument.
+ * @return     ENOSYS  - Function not implemented.
+ *
+ */
+extern int ia_css_queue_get_size(
+		ia_css_queue_t *qhandle,
+		uint32_t *size);
+
+#endif /* __IA_CSS_QUEUE_H */
+
diff --git a/drivers/media/atomisp2/css2400/runtime/queue/interface/ia_css_queue_comm.h b/drivers/media/atomisp2/css2400/runtime/queue/interface/ia_css_queue_comm.h
new file mode 100644
index 0000000..0adde1e
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/queue/interface/ia_css_queue_comm.h
@@ -0,0 +1,60 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_QUEUE_COMM_H
+#define __IA_CSS_QUEUE_COMM_H
+
+#include "type_support.h"
+#include "ia_css_circbuf.h"
+/*****************************************************************************
+ * Queue Public Data Structures
+ *****************************************************************************/
+
+/* Queue location specifier */
+/* Avoiding enums to save space */
+#define IA_CSS_QUEUE_LOC_HOST 0
+#define IA_CSS_QUEUE_LOC_SP   1
+#define IA_CSS_QUEUE_LOC_ISP  2
+
+/* Queue type specifier */
+/* Avoiding enums to save space */
+#define IA_CSS_QUEUE_TYPE_LOCAL  0
+#define IA_CSS_QUEUE_TYPE_REMOTE 1
+
+/* for DDR Allocated queues,
+allocate minimum these many elements.
+DDR->SP' DMEM DMA transfer needs 32byte aligned address.
+Since each element size is 4 bytes, 8 elements need to be
+DMAed to access single element.*/
+#define IA_CSS_MIN_ELEM_COUNT    8
+#define IA_CSS_DMA_XFER_MASK (IA_CSS_MIN_ELEM_COUNT - 1)
+
+/* Remote Queue object descriptor */
+struct ia_css_queue_remote {
+	uint32_t cb_desc_addr; /*Circbuf desc address for remote queues*/
+	uint32_t cb_elems_addr; /*Circbuf elements addr for remote queue*/
+	uint8_t location;    /* Cell location for queue */
+	uint8_t proc_id;     /* Processor id for queue access */
+};
+typedef struct ia_css_queue_remote ia_css_queue_remote_t;
+
+
+#endif /* __IA_CSS_QUEUE_COMM_H */
diff --git a/drivers/media/atomisp2/css2400/runtime/queue/src/queue.c b/drivers/media/atomisp2/css2400/runtime/queue/src/queue.c
new file mode 100644
index 0000000..94e74ee
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/queue/src/queue.c
@@ -0,0 +1,417 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_queue.h"
+#include <ia_css_circbuf.h>
+#include <ia_css_circbuf_desc.h>
+#include "queue_access.h"
+
+/*****************************************************************************
+ * Queue Public APIs
+ *****************************************************************************/
+int ia_css_queue_local_init(
+			ia_css_queue_t *qhandle,
+			ia_css_queue_local_t *desc)
+{
+	if (NULL == qhandle || NULL == desc
+		|| NULL == desc->cb_elems || NULL == desc->cb_desc) {
+		/* Invalid parameters, return error*/
+		return EINVAL ;
+	}
+
+	/* Mark the queue as Local */
+	qhandle->type = IA_CSS_QUEUE_TYPE_LOCAL;
+
+	/* Create a local circular buffer queue*/
+	ia_css_circbuf_create(&qhandle->desc.cb_local,
+	      desc->cb_elems,
+	      desc->cb_desc);
+
+	return 0;
+}
+
+int ia_css_queue_remote_init(
+			ia_css_queue_t *qhandle,
+			ia_css_queue_remote_t *desc)
+{
+	if (NULL == qhandle || NULL == desc) {
+		/* Invalid parameters, return error*/
+		return EINVAL;
+	}
+
+	/* Mark the queue as remote*/
+	qhandle->type = IA_CSS_QUEUE_TYPE_REMOTE;
+
+	/* Copy over the local queue descriptor*/
+	qhandle->location = desc->location;
+	qhandle->proc_id = desc->proc_id;
+	qhandle->desc.remote.cb_desc_addr = desc->cb_desc_addr;
+	qhandle->desc.remote.cb_elems_addr = desc->cb_elems_addr;
+
+	/* If queue is remote, we let the local processor
+	 * do its init, before using it. This is just to get us
+	 * started, we can remove this restriction as we go ahead
+	 */
+
+	return 0;
+}
+
+int ia_css_queue_uninit(
+			ia_css_queue_t *qhandle)
+{
+	if (!qhandle)
+		return EINVAL;
+
+	/* Load the required queue object */
+	if (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {
+		/* Local queues are created. Destroy it*/
+		ia_css_circbuf_destroy(&qhandle->desc.cb_local);
+	}
+
+	return 0;
+}
+
+int ia_css_queue_enqueue(
+			ia_css_queue_t *qhandle,
+			uint32_t item)
+{
+	int error = 0;
+	if (0 == qhandle)
+		return EINVAL;
+
+	/* 1. Load the required queue object */
+	if (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {
+		/* Directly de-ref the object and
+		 * operate on the queue
+		 */
+		if (ia_css_circbuf_is_full(&qhandle->desc.cb_local)) {
+			/* Cannot push the element. Return*/
+			return ENOBUFS;
+		}
+
+		/* Push the element*/
+		ia_css_circbuf_push(&qhandle->desc.cb_local, item);
+	} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {
+		ia_css_circbuf_desc_t cb_desc;
+		ia_css_circbuf_elem_t cb_elem;
+		uint32_t ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;
+
+		/* a. Load the queue cb_desc from remote */
+		QUEUE_CB_DESC_INIT(&cb_desc);
+		error = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);
+		if(error !=0)
+			return error;
+
+		/* b. Operate on the queue */
+		if (ia_css_circbuf_desc_is_full(&cb_desc))
+			return ENOBUFS;
+
+		cb_elem.val = item;
+
+		error = ia_css_queue_item_store(qhandle, cb_desc.end, &cb_elem);
+		if(error != 0)
+			return error;
+
+		cb_desc.end = (cb_desc.end + 1) % cb_desc.size;
+
+		/* c. Store the queue object */
+		/* Set only fields requiring update with
+		 * valid value. Avoids uncessary calls
+		 * to load/store functions
+		 */
+		ignore_desc_flags = QUEUE_IGNORE_SIZE_START_STEP_FLAGS;
+
+		error = ia_css_queue_store(qhandle, &cb_desc, ignore_desc_flags);
+		if(error != 0)
+			return error;
+	}
+
+	return 0;
+}
+
+int ia_css_queue_dequeue(
+			ia_css_queue_t *qhandle,
+			uint32_t *item)
+{
+	int error = 0;
+	if (qhandle == 0 || NULL == item)
+		return EINVAL;
+
+	/* 1. Load the required queue object */
+	if (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {
+		/* Directly de-ref the object and
+		 * operate on the queue
+		 */
+		if (ia_css_circbuf_is_empty(&qhandle->desc.cb_local)) {
+			/* Nothing to pop. Return empty queue*/
+			return ENODATA;
+		}
+
+		*item = ia_css_circbuf_pop(&qhandle->desc.cb_local);
+	} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {
+		/* a. Load the queue from remote */
+		ia_css_circbuf_desc_t cb_desc;
+		ia_css_circbuf_elem_t cb_elem;
+		uint32_t ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;
+
+		QUEUE_CB_DESC_INIT(&cb_desc);
+
+		error = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);
+		if(error != 0)
+			return error;
+
+		/* b. Operate on the queue */
+		if (ia_css_circbuf_desc_is_empty(&cb_desc))
+			return ENODATA;
+
+		error = ia_css_queue_item_load(qhandle, cb_desc.start, &cb_elem);
+		if(error != 0)
+			return error;
+
+		*item = cb_elem.val;
+
+		cb_desc.start = OP_std_modadd(cb_desc.start, 1, cb_desc.size);
+
+		/* c. Store the queue object */
+		/* Set only fields requiring update with
+		 * valid value. Avoids uncessary calls
+		 * to load/store functions
+		 */
+		ignore_desc_flags = QUEUE_IGNORE_SIZE_END_STEP_FLAGS;
+		error = ia_css_queue_store(qhandle, &cb_desc, ignore_desc_flags);
+		if(error != 0)
+			return error;
+	}
+	return 0;
+}
+
+int ia_css_queue_is_full(
+			ia_css_queue_t *qhandle,
+			bool *is_full)
+{
+	int error = 0;
+	if ((qhandle == NULL) || (is_full == NULL))
+		return EINVAL;
+
+	/* 1. Load the required queue object */
+	if (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {
+		/* Directly de-ref the object and
+		 * operate on the queue
+		 */
+		*is_full = ia_css_circbuf_is_full(&qhandle->desc.cb_local);
+		return 0;
+	} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {
+		/* a. Load the queue from remote */
+		ia_css_circbuf_desc_t cb_desc;
+		uint32_t ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;
+		QUEUE_CB_DESC_INIT(&cb_desc);
+		error = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);
+		if(error != 0)
+			return error;
+
+		/* b. Operate on the queue */
+		*is_full = ia_css_circbuf_desc_is_full(&cb_desc);
+		return 0;
+	}
+
+	return EINVAL;
+}
+
+int ia_css_queue_get_free_space(
+			ia_css_queue_t *qhandle,
+			uint32_t *size)
+{
+	int error = 0;
+	if ((qhandle == NULL) || (size == NULL))
+		return EINVAL;
+
+	/* 1. Load the required queue object */
+	if (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {
+		/* Directly de-ref the object and
+		 * operate on the queue
+		 */
+		*size = ia_css_circbuf_get_free_elems(&qhandle->desc.cb_local);
+		return 0;
+	} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {
+		/* a. Load the queue from remote */
+		ia_css_circbuf_desc_t cb_desc;
+		uint32_t ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;
+		QUEUE_CB_DESC_INIT(&cb_desc);
+		error = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);
+		if(error != 0)
+			return error;
+
+		/* b. Operate on the queue */
+		*size = ia_css_circbuf_desc_get_free_elems(&cb_desc);
+		return 0;
+	}
+
+	return EINVAL;
+}
+
+int ia_css_queue_get_used_space(
+			ia_css_queue_t *qhandle,
+			uint32_t *size)
+{
+	int error = 0;
+	if ((qhandle == NULL) || (size == NULL))
+		return EINVAL;
+
+	/* 1. Load the required queue object */
+	if (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {
+		/* Directly de-ref the object and
+		 * operate on the queue
+		 */
+		*size = ia_css_circbuf_get_num_elems(&qhandle->desc.cb_local);
+		return 0;
+	} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {
+		/* a. Load the queue from remote */
+		ia_css_circbuf_desc_t cb_desc;
+		uint32_t ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;
+		QUEUE_CB_DESC_INIT(&cb_desc);
+		error = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);
+		if(error != 0)
+			return error;
+
+		/* b. Operate on the queue */
+		*size = ia_css_circbuf_desc_get_num_elems(&cb_desc);
+		return 0;
+	}
+
+	return EINVAL;
+}
+
+int ia_css_queue_peek(
+		ia_css_queue_t *qhandle,
+		uint32_t offset,
+		uint32_t *element)
+{
+	uint32_t num_elems = 0;
+	int error = 0;
+
+	if ((qhandle == NULL) || (element == NULL))
+		return EINVAL;
+
+	/* 1. Load the required queue object */
+	if (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {
+		/* Directly de-ref the object and
+		 * operate on the queue
+		 */
+		/* Check if offset is valid */
+		num_elems = ia_css_circbuf_get_num_elems(&qhandle->desc.cb_local);
+		if (offset > num_elems)
+			return EINVAL;
+
+		*element = ia_css_circbuf_peek(&qhandle->desc.cb_local, offset);
+		return 0;
+	} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {
+		/* a. Load the queue from remote */
+		ia_css_circbuf_desc_t cb_desc;
+		ia_css_circbuf_elem_t cb_elem;
+		uint32_t ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;
+
+		QUEUE_CB_DESC_INIT(&cb_desc);
+
+		error =  ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);
+		if(error != 0)
+			return error;
+
+		/* Check if offset is valid */
+		num_elems = ia_css_circbuf_desc_get_num_elems(&cb_desc);
+		if (offset > num_elems)
+			return EINVAL;
+
+		error = ia_css_queue_item_load(qhandle, offset, &cb_elem);
+		if(error != 0)
+			return error;
+
+		*element = cb_elem.val;
+		return 0;
+	}
+
+	return EINVAL;
+}
+
+int ia_css_queue_is_empty(
+			ia_css_queue_t *qhandle,
+			bool *is_empty)
+{
+	int error = 0;
+	if ((qhandle == NULL) || (is_empty == NULL))
+		return EINVAL;
+
+	/* 1. Load the required queue object */
+	if (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {
+		/* Directly de-ref the object and
+		 * operate on the queue
+		 */
+		*is_empty = ia_css_circbuf_is_empty(&qhandle->desc.cb_local);
+		return 0;
+	} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {
+		/* a. Load the queue from remote */
+		ia_css_circbuf_desc_t cb_desc;
+		uint32_t ignore_desc_flags = QUEUE_IGNORE_STEP_FLAG;
+
+		QUEUE_CB_DESC_INIT(&cb_desc);
+		error = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);
+		if(error != 0)
+			return error;
+
+		/* b. Operate on the queue */
+		*is_empty = ia_css_circbuf_desc_is_empty(&cb_desc);
+		return 0;
+	}
+
+	return EINVAL;
+}
+
+int ia_css_queue_get_size(
+			ia_css_queue_t *qhandle,
+			uint32_t *size)
+{
+	int error = 0;
+	if ((qhandle == 0) || (size == NULL))
+		return EINVAL;
+
+	/* 1. Load the required queue object */
+	if (qhandle->type == IA_CSS_QUEUE_TYPE_LOCAL) {
+		/* Directly de-ref the object and
+		 * operate on the queue
+		 */
+		/* Return maximum usable capacity */
+		*size = ia_css_circbuf_get_size(&qhandle->desc.cb_local);
+	} else if (qhandle->type == IA_CSS_QUEUE_TYPE_REMOTE) {
+		/* a. Load the queue from remote */
+		ia_css_circbuf_desc_t cb_desc;
+		uint32_t ignore_desc_flags = QUEUE_IGNORE_START_END_STEP_FLAGS;
+
+		QUEUE_CB_DESC_INIT(&cb_desc);
+
+		error = ia_css_queue_load(qhandle, &cb_desc, ignore_desc_flags);
+		if(error != 0)
+			return error;
+
+		/* Return maximum usable capacity */
+		*size = cb_desc.size;
+	}
+
+	return 0;
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/queue/src/queue_access.c b/drivers/media/atomisp2/css2400/runtime/queue/src/queue_access.c
new file mode 100644
index 0000000..949e2d6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/queue/src/queue_access.c
@@ -0,0 +1,183 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "type_support.h"
+#include "queue_access.h"
+#include "ia_css_circbuf.h"
+#include "sp.h"
+#include "memory_access.h"
+#include "assert_support.h"
+
+int ia_css_queue_load(
+		struct ia_css_queue *rdesc,
+		ia_css_circbuf_desc_t *cb_desc,
+		uint32_t ignore_desc_flags)
+{
+	if (rdesc == NULL || cb_desc == NULL)
+		return EINVAL;
+
+	if (rdesc->location == IA_CSS_QUEUE_LOC_SP) {
+		assert(ignore_desc_flags <= QUEUE_IGNORE_DESC_FLAGS_MAX);
+
+		if (0 == (ignore_desc_flags & QUEUE_IGNORE_SIZE_FLAG)) {
+			cb_desc->size = sp_dmem_load_uint8(rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr
+				+ offsetof(ia_css_circbuf_desc_t, size));
+
+			if ( 0 == cb_desc->size ) {
+				/* Adding back the workaround which was removed
+				   while refactoring queues. When reading size
+				   through sp_dmem_load_*, sometimes we get back
+				   the value as zero. This causes division by 0
+				   exception as the size is used in a modular
+				   division operation. */
+				return EDOM;
+			}
+		}
+
+		if (0 == (ignore_desc_flags & QUEUE_IGNORE_START_FLAG))
+			cb_desc->start = sp_dmem_load_uint8(rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr
+				+ offsetof(ia_css_circbuf_desc_t, start));
+
+		if (0 == (ignore_desc_flags & QUEUE_IGNORE_END_FLAG))
+			cb_desc->end = sp_dmem_load_uint8(rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr
+				+ offsetof(ia_css_circbuf_desc_t, end));
+
+		if (0 == (ignore_desc_flags & QUEUE_IGNORE_STEP_FLAG))
+			cb_desc->step = sp_dmem_load_uint8(rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr
+				+ offsetof(ia_css_circbuf_desc_t, step));
+
+	} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {
+		/* doing DMA transfer of entire structure */
+		mmgr_load(rdesc->desc.remote.cb_desc_addr,
+			(void *)cb_desc,
+			sizeof(ia_css_circbuf_desc_t));
+	} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {
+		/* Not supported yet */
+		return ENOTSUP;
+	}
+
+	return 0;
+}
+
+int ia_css_queue_store(
+		struct ia_css_queue *rdesc,
+		ia_css_circbuf_desc_t *cb_desc,
+		uint32_t ignore_desc_flags)
+{
+	if (rdesc == NULL || cb_desc == NULL)
+		return EINVAL;
+
+	if (rdesc->location == IA_CSS_QUEUE_LOC_SP) {
+		assert(ignore_desc_flags <= QUEUE_IGNORE_DESC_FLAGS_MAX);
+
+		if (0 == (ignore_desc_flags & QUEUE_IGNORE_SIZE_FLAG))
+			sp_dmem_store_uint8(rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr
+				+ offsetof(ia_css_circbuf_desc_t, size),
+				cb_desc->size);
+
+		if (0 == (ignore_desc_flags & QUEUE_IGNORE_START_FLAG))
+			sp_dmem_store_uint8(rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr
+				+ offsetof(ia_css_circbuf_desc_t, start),
+				cb_desc->start);
+
+		if (0 == (ignore_desc_flags & QUEUE_IGNORE_END_FLAG))
+			sp_dmem_store_uint8(rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr
+				+ offsetof(ia_css_circbuf_desc_t, end),
+				cb_desc->end);
+
+		if (0 == (ignore_desc_flags & QUEUE_IGNORE_STEP_FLAG))
+			sp_dmem_store_uint8(rdesc->proc_id,
+				rdesc->desc.remote.cb_desc_addr
+				+ offsetof(ia_css_circbuf_desc_t, step),
+				cb_desc->step);
+	} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {
+		/* doing DMA transfer of entire structure */
+		mmgr_store(rdesc->desc.remote.cb_desc_addr,
+			(void *)cb_desc,
+			sizeof(ia_css_circbuf_desc_t));
+	} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {
+		/* Not supported yet */
+		return ENOTSUP;
+	}
+
+	return 0;
+}
+
+int ia_css_queue_item_load(
+		struct ia_css_queue *rdesc,
+		uint8_t position,
+		ia_css_circbuf_elem_t *item)
+{
+	if (rdesc == NULL || item == NULL)
+		return EINVAL;
+
+	if (rdesc->location == IA_CSS_QUEUE_LOC_SP) {
+		sp_dmem_load(rdesc->proc_id,
+			rdesc->desc.remote.cb_elems_addr
+			+ position * sizeof(ia_css_circbuf_elem_t),
+			item,
+			sizeof(ia_css_circbuf_elem_t));
+	} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {
+		mmgr_load(rdesc->desc.remote.cb_elems_addr
+			+ position * sizeof(ia_css_circbuf_elem_t),
+			(void *)item,
+			sizeof(ia_css_circbuf_elem_t));
+	} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {
+		/* Not supported yet */
+		return ENOTSUP;
+	}
+
+	return 0;
+}
+
+int ia_css_queue_item_store(
+		struct ia_css_queue *rdesc,
+		uint8_t position,
+		ia_css_circbuf_elem_t *item)
+{
+	if (rdesc == NULL || item == NULL)
+		return EINVAL;
+
+	if (rdesc->location == IA_CSS_QUEUE_LOC_SP) {
+		sp_dmem_store(rdesc->proc_id,
+			rdesc->desc.remote.cb_elems_addr
+			+ position * sizeof(ia_css_circbuf_elem_t),
+			item,
+			sizeof(ia_css_circbuf_elem_t));
+	} else if (rdesc->location == IA_CSS_QUEUE_LOC_HOST) {
+		mmgr_store(rdesc->desc.remote.cb_elems_addr
+			+ position * sizeof(ia_css_circbuf_elem_t),
+			(void *)item,
+			sizeof(ia_css_circbuf_elem_t));
+	} else if (rdesc->location == IA_CSS_QUEUE_LOC_ISP) {
+		/* Not supported yet */
+		return ENOTSUP;
+	}
+
+	return 0;
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/queue/src/queue_access.h b/drivers/media/atomisp2/css2400/runtime/queue/src/queue_access.h
new file mode 100644
index 0000000..9ba8243
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/queue/src/queue_access.h
@@ -0,0 +1,92 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __QUEUE_ACCESS_H
+#define __QUEUE_ACCESS_H
+
+#include <type_support.h>
+#include <ia_css_queue_comm.h>
+#include <ia_css_circbuf.h>
+#include <error_support.h>
+
+#define QUEUE_IGNORE_START_FLAG	0x0001
+#define QUEUE_IGNORE_END_FLAG	0x0002
+#define QUEUE_IGNORE_SIZE_FLAG	0x0004
+#define QUEUE_IGNORE_STEP_FLAG	0x0008
+#define QUEUE_IGNORE_DESC_FLAGS_MAX 0x000f
+
+#define QUEUE_IGNORE_SIZE_START_STEP_FLAGS \
+	(QUEUE_IGNORE_SIZE_FLAG | \
+	QUEUE_IGNORE_START_FLAG | \
+	QUEUE_IGNORE_STEP_FLAG)
+
+#define QUEUE_IGNORE_SIZE_END_STEP_FLAGS \
+	(QUEUE_IGNORE_SIZE_FLAG | \
+	QUEUE_IGNORE_END_FLAG   | \
+	QUEUE_IGNORE_STEP_FLAG)
+
+#define QUEUE_IGNORE_START_END_STEP_FLAGS \
+	(QUEUE_IGNORE_START_FLAG | \
+	QUEUE_IGNORE_END_FLAG	  | \
+	QUEUE_IGNORE_STEP_FLAG)
+
+#define QUEUE_CB_DESC_INIT(cb_desc) \
+	do { \
+		(cb_desc)->size = 0;		\
+		(cb_desc)->step = 0;		\
+		(cb_desc)->start = 0;		\
+		(cb_desc)->end = 0;		\
+	} while (0)
+
+struct ia_css_queue {
+	uint8_t type;        /* Specify remote/local type of access */
+	uint8_t location;    /* Cell location for queue */
+	uint8_t proc_id;     /* Processor id for queue access */
+	union {
+		ia_css_circbuf_t cb_local;
+		struct {
+			uint32_t cb_desc_addr; /*Circbuf desc address for remote queues*/
+			uint32_t cb_elems_addr; /*Circbuf elements addr for remote queue*/
+		}	remote;
+	} desc;
+};
+
+extern int ia_css_queue_load(
+		struct ia_css_queue *rdesc,
+		ia_css_circbuf_desc_t *cb_desc,
+		uint32_t ignore_desc_flags);
+
+extern int ia_css_queue_store(
+		struct ia_css_queue *rdesc,
+		ia_css_circbuf_desc_t *cb_desc,
+		uint32_t ignore_desc_flags);
+
+extern int ia_css_queue_item_load(
+		struct ia_css_queue *rdesc,
+		uint8_t position,
+		ia_css_circbuf_elem_t *item);
+
+extern int ia_css_queue_item_store(
+		struct ia_css_queue *rdesc,
+		uint8_t position,
+		ia_css_circbuf_elem_t *item);
+
+#endif /* __QUEUE_ACCESS_H */
diff --git a/drivers/media/atomisp2/css2400/runtime/rmgr/interface/ia_css_rmgr.h b/drivers/media/atomisp2/css2400/runtime/rmgr/interface/ia_css_rmgr.h
new file mode 100644
index 0000000..577546b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/rmgr/interface/ia_css_rmgr.h
@@ -0,0 +1,79 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_RMGR_H
+#define _IA_CSS_RMGR_H
+
+#include "storage_class.h"
+
+#ifndef __INLINE_RMGR__
+#define STORAGE_CLASS_RMGR_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_RMGR_C
+#else				/* __INLINE_RMGR__ */
+#define STORAGE_CLASS_RMGR_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_RMGR_C STORAGE_CLASS_INLINE
+#endif				/* __INLINE_RMGR__ */
+
+/**
+ * @brief Initialize resource manager (host/common)
+ */
+enum ia_css_err ia_css_rmgr_init(void);
+
+/**
+ * @brief Uninitialize resource manager (host/common)
+ */
+void ia_css_rmgr_uninit(void);
+
+/*****************************************************************
+ * Interface definition - resource type (host/common)
+ *****************************************************************
+ *
+ * struct ia_css_rmgr_<type>_pool;
+ * struct ia_css_rmgr_<type>_handle;
+ *
+ * STORAGE_CLASS_RMGR_H void ia_css_rmgr_init_<type>(
+ *	struct ia_css_rmgr_<type>_pool *pool);
+ *
+ * STORAGE_CLASS_RMGR_H void ia_css_rmgr_uninit_<type>(
+ *	struct ia_css_rmgr_<type>_pool *pool);
+ *
+ * STORAGE_CLASS_RMGR_H void ia_css_rmgr_acq_<type>(
+ *	struct ia_css_rmgr_<type>_pool *pool,
+ *	struct ia_css_rmgr_<type>_handle **handle);
+ *
+ * STORAGE_CLASS_RMGR_H void ia_css_rmgr_rel_<type>(
+ *	struct ia_css_rmgr_<type>_pool *pool,
+ *	struct ia_css_rmgr_<type>_handle **handle);
+ *
+ *****************************************************************
+ * Interface definition - refcounting (host/common)
+ *****************************************************************
+ *
+ * void ia_css_rmgr_refcount_retain_<type>(
+ *	struct ia_css_rmgr_<type>_handle **handle);
+ *
+ * void ia_css_rmgr_refcount_release_<type>(
+ *	struct ia_css_rmgr_<type>_handle **handle);
+ */
+
+#include "ia_css_rmgr_vbuf.h"
+
+#endif	/* _IA_CSS_RMGR_H */
diff --git a/drivers/media/atomisp2/css2400/runtime/rmgr/interface/ia_css_rmgr_vbuf.h b/drivers/media/atomisp2/css2400/runtime/rmgr/interface/ia_css_rmgr_vbuf.h
new file mode 100644
index 0000000..93348e6
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/rmgr/interface/ia_css_rmgr_vbuf.h
@@ -0,0 +1,106 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _IA_CSS_RMGR_VBUF_H
+#define _IA_CSS_RMGR_VBUF_H
+
+#include "ia_css_rmgr.h"
+#include <type_support.h>
+#include <ia_css.h>
+
+/**
+ * @brief Data structure for the resource handle (host, vbuf)
+ */
+struct ia_css_rmgr_vbuf_handle {
+	hrt_vaddress vptr;
+	uint8_t count;
+	uint32_t size;
+};
+
+/**
+ * @brief Data structure for the resource pool (host, vbuf)
+ */
+struct ia_css_rmgr_vbuf_pool {
+	uint8_t copy_on_write;
+	uint8_t recycle;
+	uint32_t size;
+	uint32_t index;
+	struct ia_css_rmgr_vbuf_handle **handles;
+};
+
+/**
+ * @brief VBUF resource pools
+ */
+extern struct ia_css_rmgr_vbuf_pool *vbuf_ref;
+extern struct ia_css_rmgr_vbuf_pool *vbuf_write;
+extern struct ia_css_rmgr_vbuf_pool *hmm_buffer_pool;
+
+/**
+ * @brief Initialize the resource pool (host, vbuf)
+ *
+ * @param pool	The pointer to the pool
+ */
+STORAGE_CLASS_RMGR_H enum ia_css_err ia_css_rmgr_init_vbuf(
+	struct ia_css_rmgr_vbuf_pool *pool);
+
+/**
+ * @brief Uninitialize the resource pool (host, vbuf)
+ *
+ * @param pool	The pointer to the pool
+ */
+STORAGE_CLASS_RMGR_H void ia_css_rmgr_uninit_vbuf(
+	struct ia_css_rmgr_vbuf_pool *pool);
+
+/**
+ * @brief Acquire a handle from the pool (host, vbuf)
+ *
+ * @param pool		The pointer to the pool
+ * @param handle	The pointer to the handle
+ */
+STORAGE_CLASS_RMGR_H void ia_css_rmgr_acq_vbuf(
+	struct ia_css_rmgr_vbuf_pool *pool,
+	struct ia_css_rmgr_vbuf_handle **handle);
+
+/**
+ * @brief Release a handle to the pool (host, vbuf)
+ *
+ * @param pool		The pointer to the pool
+ * @param handle	The pointer to the handle
+ */
+STORAGE_CLASS_RMGR_H void ia_css_rmgr_rel_vbuf(
+	struct ia_css_rmgr_vbuf_pool *pool,
+	struct ia_css_rmgr_vbuf_handle **handle);
+
+/**
+ * @brief Retain the reference count for a handle (host, vbuf)
+ *
+ * @param handle	The pointer to the handle
+ */
+void ia_css_rmgr_refcount_retain_vbuf(struct ia_css_rmgr_vbuf_handle **handle);
+
+/**
+ * @brief Release the reference count for a handle (host, vbuf)
+ *
+ * @param handle	The pointer to the handle
+ */
+void ia_css_rmgr_refcount_release_vbuf(struct ia_css_rmgr_vbuf_handle **handle);
+
+#endif	/* _IA_CSS_RMGR_VBUF_H */
diff --git a/drivers/media/atomisp2/css2400/runtime/rmgr/src/rmgr.c b/drivers/media/atomisp2/css2400/runtime/rmgr/src/rmgr.c
new file mode 100644
index 0000000..3d1d58c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/rmgr/src/rmgr.c
@@ -0,0 +1,46 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_rmgr.h"
+
+enum ia_css_err ia_css_rmgr_init(void)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	err = ia_css_rmgr_init_vbuf(vbuf_ref);
+	if (err == IA_CSS_SUCCESS)
+		err = ia_css_rmgr_init_vbuf(vbuf_write);
+	if (err == IA_CSS_SUCCESS)
+		err = ia_css_rmgr_init_vbuf(hmm_buffer_pool);
+	if (err != IA_CSS_SUCCESS)
+		ia_css_rmgr_uninit();
+	return err;
+}
+
+/**
+ * @brief Uninitialize resource pool (host)
+ */
+void ia_css_rmgr_uninit(void)
+{
+	ia_css_rmgr_uninit_vbuf(hmm_buffer_pool);
+	ia_css_rmgr_uninit_vbuf(vbuf_write);
+	ia_css_rmgr_uninit_vbuf(vbuf_ref);
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/rmgr/src/rmgr_vbuf.c b/drivers/media/atomisp2/css2400/runtime/rmgr/src/rmgr_vbuf.c
new file mode 100644
index 0000000..4655dd7
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/rmgr/src/rmgr_vbuf.c
@@ -0,0 +1,342 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_rmgr.h"
+
+#include <type_support.h>
+#include <assert_support.h>
+#include <platform_support.h> /* memset */
+#include <memory_access.h>    /* mmmgr_malloc, mmmgr_free */
+#include <ia_css_debug.h>
+
+/**
+ * @brief VBUF resource handles
+ */
+#define NUM_HANDLES 1000
+struct ia_css_rmgr_vbuf_handle handle_table[NUM_HANDLES];
+
+/**
+ * @brief VBUF resource pool - refpool
+ */
+struct ia_css_rmgr_vbuf_pool refpool = {
+	false,			/* copy_on_write */
+	false,			/* recycle */
+	0,			/* size */
+	0,			/* index */
+	NULL,			/* handles */
+};
+
+/**
+ * @brief VBUF resource pool - writepool
+ */
+struct ia_css_rmgr_vbuf_pool writepool = {
+	true,			/* copy_on_write */
+	false,			/* recycle */
+	0,			/* size */
+	0,			/* index */
+	NULL,			/* handles */
+};
+
+/**
+ * @brief VBUF resource pool - hmmbufferpool
+ */
+struct ia_css_rmgr_vbuf_pool hmmbufferpool = {
+	true,			/* copy_on_write */
+	true,			/* recycle */
+	32,			/* size */
+	0,			/* index */
+	NULL,			/* handles */
+};
+
+struct ia_css_rmgr_vbuf_pool *vbuf_ref = &refpool;
+struct ia_css_rmgr_vbuf_pool *vbuf_write = &writepool;
+struct ia_css_rmgr_vbuf_pool *hmm_buffer_pool = &hmmbufferpool;
+
+/**
+ * @brief Initialize the reference count (host, vbuf)
+ */
+static void rmgr_refcount_init_vbuf(void)
+{
+	/* initialize the refcount table */
+	memset(&handle_table, 0, sizeof(handle_table));
+}
+
+/**
+ * @brief Retain the reference count for a handle (host, vbuf)
+ *
+ * @param handle	The pointer to the handle
+ */
+void ia_css_rmgr_refcount_retain_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
+{
+	int i;
+	struct ia_css_rmgr_vbuf_handle *h;
+	assert(handle != NULL);
+	assert(*handle != NULL);
+	/* new vbuf to count on */
+	if ((*handle)->count == 0) {
+		h = *handle;
+		*handle = NULL;
+		for (i = 0; i < NUM_HANDLES; i++) {
+			if (handle_table[i].count == 0) {
+				*handle = &handle_table[i];
+				break;
+			}
+		}
+		/* if the loop dus not break and *handle == NULL
+		   this is an error handle and report it.
+		 */
+		if (*handle == NULL) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				"ia_css_i_host_refcount_retain_vbuf() failed to find empty slot!\n");
+			return;
+		}
+		(*handle)->vptr = h->vptr;
+		(*handle)->size = h->size;
+	}
+	(*handle)->count++;
+}
+
+/**
+ * @brief Release the reference count for a handle (host, vbuf)
+ *
+ * @param handle	The pointer to the handle
+ */
+void ia_css_rmgr_refcount_release_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
+{
+	assert(handle != NULL);
+	assert(*handle != NULL);
+	assert((*handle)->count != 0);
+	/* decrease reference count */
+	(*handle)->count--;
+	/* remove from admin */
+	if ((*handle)->count == 0) {
+		(*handle)->vptr = 0x0;
+		(*handle)->size = 0;
+		*handle = NULL;
+	}
+}
+
+/**
+ * @brief Initialize the resource pool (host, vbuf)
+ *
+ * @param pool	The pointer to the pool
+ */
+enum ia_css_err ia_css_rmgr_init_vbuf(struct ia_css_rmgr_vbuf_pool *pool)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	size_t bytes_needed;
+	rmgr_refcount_init_vbuf();
+	assert(pool != NULL);
+	if (pool == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	/* initialize the recycle pool if used */
+	if (pool->recycle && pool->size) {
+		/* allocate memory for storing the handles */
+		bytes_needed =
+		    sizeof(void *) *
+		    pool->size;
+		pool->handles = sh_css_malloc(bytes_needed);
+		if (pool->handles != NULL)
+			memset(pool->handles, 0, bytes_needed);
+		else
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	} else {
+		/* just in case, set the size to 0 */
+		pool->size = 0;
+		pool->handles = NULL;
+	}
+	return err;
+}
+
+/**
+ * @brief Uninitialize the resource pool (host, vbuf)
+ *
+ * @param pool	The pointer to the pool
+ */
+void ia_css_rmgr_uninit_vbuf(struct ia_css_rmgr_vbuf_pool *pool)
+{
+	uint32_t i;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_rmgr_uninit_vbuf()\n");
+	assert(pool != NULL);
+	if (pool->handles != NULL) {
+		/* free the hmm buffers */
+		for (i = 0; i < pool->size; i++) {
+			if (pool->handles[i] != NULL) {
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				      "   freeing/releasing %x (count=%d)\n",
+				      pool->handles[i]->vptr,
+				      pool->handles[i]->count);
+				/* free memory */
+				mmgr_free(pool->handles[i]->vptr);
+				/* remove from refcount admin */
+				ia_css_rmgr_refcount_release_vbuf(
+					&pool->handles[i]);
+			}
+		}
+		/* now free the pool handles list */
+		sh_css_free(pool->handles);
+		pool->handles = NULL;
+	}
+}
+
+/**
+ * @brief Push a handle to the pool
+ *
+ * @param pool		The pointer to the pool
+ * @param handle	The pointer to the handle
+ */
+static
+void rmgr_push_handle(struct ia_css_rmgr_vbuf_pool *pool,
+		      struct ia_css_rmgr_vbuf_handle **handle)
+{
+	uint32_t i;
+	bool succes = false;
+	assert(pool != NULL);
+	assert(pool->recycle);
+	assert(pool->handles != NULL);
+	assert(handle != NULL);
+	for (i = 0; i < pool->size; i++) {
+		if (pool->handles[i] == NULL) {
+			ia_css_rmgr_refcount_retain_vbuf(handle);
+			pool->handles[i] = *handle;
+			succes = true;
+			break;
+		}
+	}
+	assert(succes);
+}
+
+/**
+ * @brief Pop a handle from the pool
+ *
+ * @param pool		The pointer to the pool
+ * @param handle	The pointer to the handle
+ */
+static
+void rmgr_pop_handle(struct ia_css_rmgr_vbuf_pool *pool,
+		     struct ia_css_rmgr_vbuf_handle **handle)
+{
+	uint32_t i;
+	bool succes = false;
+	assert(pool != NULL);
+	assert(pool->recycle);
+	assert(pool->handles != NULL);
+	assert(handle != NULL);
+	assert(*handle != NULL);
+	for (i = 0; i < pool->size; i++) {
+		if ((pool->handles[i] != NULL) &&
+		    (pool->handles[i]->size == (*handle)->size)) {
+			*handle = pool->handles[i];
+			pool->handles[i] = NULL;
+			/* dont release, we are returning it...
+			   ia_css_rmgr_refcount_release_vbuf(handle); */
+			succes = true;
+			break;
+		}
+	}
+}
+
+/**
+ * @brief Acquire a handle from the pool (host, vbuf)
+ *
+ * @param pool		The pointer to the pool
+ * @param handle	The pointer to the handle
+ */
+void ia_css_rmgr_acq_vbuf(struct ia_css_rmgr_vbuf_pool *pool,
+			  struct ia_css_rmgr_vbuf_handle **handle)
+{
+#ifdef __KLOCWORK__
+	/* KW sees the *handle = h; assignment about 20 lines down
+	   and thinks that we are assigning a local to a global.
+	   What it does not see is that in ia_css_i_host_rmgr_pop_handle
+	   a new value is assigned to handle.
+	   So this is a false positive KW issue.
+	   To fix that we make the struct static for KW so it will
+	   think that h remains alive; we do not want this in our
+	   production code though as it breaks reentrancy of the code
+	 */
+
+	static struct ia_css_rmgr_vbuf_handle h;
+#else /* __KLOCWORK__ */
+	struct ia_css_rmgr_vbuf_handle h;
+#endif /* __KLOCWORK__ */
+
+	assert(pool != NULL);
+	assert(handle != NULL);
+	assert(*handle != NULL);
+
+	if (pool->copy_on_write) {
+		/* only one reference, reuse (no new retain) */
+		if ((*handle)->count == 1)
+			return;
+		/* more than one reference, release current buffer */
+		if ((*handle)->count > 1) {
+			/* store current values */
+			h.vptr = 0x0;
+			h.size = (*handle)->size;
+			/* release ref to current buffer */
+			ia_css_rmgr_refcount_release_vbuf(handle);
+			*handle = &h;
+		}
+		/* get new buffer for needed size */
+		if ((*handle)->vptr == 0x0) {
+			if (pool->recycle) {
+				/* try and pop from pool */
+				rmgr_pop_handle(pool, handle);
+			}
+			if ((*handle)->vptr == 0x0) {
+				/* we need to allocate */
+				(*handle)->vptr = mmgr_malloc((*handle)->size);
+			} else {
+				/* we popped a buffer */
+				return;
+			}
+		}
+	}
+	/* Note that handle will change to an internally maintained one */
+	ia_css_rmgr_refcount_retain_vbuf(handle);
+}
+
+/**
+ * @brief Release a handle to the pool (host, vbuf)
+ *
+ * @param pool		The pointer to the pool
+ * @param handle	The pointer to the handle
+ */
+void ia_css_rmgr_rel_vbuf(struct ia_css_rmgr_vbuf_pool *pool,
+			  struct ia_css_rmgr_vbuf_handle **handle)
+{
+	assert(pool != NULL);
+	assert(handle != NULL);
+	assert(*handle != NULL);
+	/* release the handle */
+	if ((*handle)->count == 1) {
+		if (!pool->recycle) {
+			/* non recycling pool, free mem */
+			mmgr_free((*handle)->vptr);
+		} else {
+			/* recycle to pool */
+			rmgr_push_handle(pool, handle);
+		}
+	}
+	ia_css_rmgr_refcount_release_vbuf(handle);
+	*handle = NULL;
+}
diff --git a/drivers/media/atomisp2/css2400/runtime/spctrl/interface/ia_css_spctrl.h b/drivers/media/atomisp2/css2400/runtime/spctrl/interface/ia_css_spctrl.h
new file mode 100644
index 0000000..082b4655
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/spctrl/interface/ia_css_spctrl.h
@@ -0,0 +1,79 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_SPCTRL_H__
+#define __IA_CSS_SPCTRL_H__
+
+#include <system_global.h>
+#include <ia_css_err.h>
+#include "ia_css_spctrl_comm.h"
+
+
+typedef struct {
+	uint32_t        ddr_data_offset;       /**<  posistion of data in DDR */
+	uint32_t        dmem_data_addr;        /**< data segment address in dmem */
+	uint32_t        dmem_bss_addr;         /**< bss segment address in dmem  */
+	uint32_t        data_size;             /**< data segment size            */
+	uint32_t        bss_size;              /**< bss segment size             */
+	uint32_t        spctrl_config_dmem_addr; /** <location of dmem_cfg  in SP dmem */
+	uint32_t        spctrl_state_dmem_addr;  /** < location of state  in SP dmem */
+	unsigned int    sp_entry;                /** < entry function ptr on SP */
+	const void      *code;                   /**< location of firmware */
+	uint32_t         code_size;
+	char      *program_name;    /**< not used on hardware, only for simulation */
+} ia_css_spctrl_cfg;
+
+
+/* ! Load firmware on to specfied SP
+*/
+enum ia_css_err ia_css_spctrl_load_fw(sp_ID_t sp_id,
+			ia_css_spctrl_cfg *spctrl_cfg);
+
+#if defined(IS_ISP_2500_SYSTEM)
+enum ia_css_err ia_css_sp1ctrl_load_fw(sp_ID_t sp_id,
+			ia_css_spctrl_cfg *spctrl_cfg);
+#endif
+
+/*!  Unload/release any memory allocated to hold the firmware
+*/
+enum ia_css_err ia_css_spctrl_unload_fw(sp_ID_t sp_id);
+
+
+/*! Intilaize dmem_cfg in SP dmem  and  start SP program
+*/
+enum ia_css_err ia_css_spctrl_start(sp_ID_t sp_id);
+#if defined(IS_ISP_2500_SYSTEM)
+enum ia_css_err ia_css_spctrl_start_sp1(sp_ID_t sp_id);
+#endif
+
+/*! stop spctrl
+*/
+enum ia_css_err ia_css_spctrl_stop(sp_ID_t sp_id);
+
+/*! Query the state of SP
+*/
+ia_css_spctrl_sp_sw_state ia_css_spctrl_get_state(sp_ID_t sp_id);
+
+/*! Query the state of SP1
+*/
+ia_css_spctrl_sp_sw_state ia_css_sp1ctrl_get_state(sp_ID_t sp_id);
+
+#endif /* __IA_CSS_SPCTRL_H__ */
diff --git a/drivers/media/atomisp2/css2400/runtime/spctrl/interface/ia_css_spctrl_comm.h b/drivers/media/atomisp2/css2400/runtime/spctrl/interface/ia_css_spctrl_comm.h
new file mode 100644
index 0000000..19d54cf
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/spctrl/interface/ia_css_spctrl_comm.h
@@ -0,0 +1,50 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_SPCTRL_COMM_H__
+#define __IA_CSS_SPCTRL_COMM_H__
+
+/* state of SP */
+typedef enum {
+	IA_CSS_SP_SW_TERMINATED = 0,
+	IA_CSS_SP_SW_INITIALIZED,
+	IA_CSS_SP_SW_CONNECTED,
+	IA_CSS_SP_SW_RUNNING
+} ia_css_spctrl_sp_sw_state;
+
+/** Structure to encapsulate required arguments for
+ * initialization of SP DMEM using the SP itself
+ */
+struct ia_css_sp_init_dmem_cfg {
+	ia_css_ptr      ddr_data_addr;  /**< data segment address in ddr  */
+	uint32_t        dmem_data_addr; /**< data segment address in dmem */
+	uint32_t        dmem_bss_addr;  /**< bss segment address in dmem  */
+	uint32_t        data_size;      /**< data segment size            */
+	uint32_t        bss_size;       /**< bss segment size             */
+	sp_ID_t         sp_id;          /** <sp Id */
+};
+
+#define SIZE_OF_IA_CSS_SP_INIT_DMEM_CFG_STRUCT    \
+        (1 * SIZE_OF_IA_CSS_PTR) +                \
+        (4 * sizeof(uint32_t)) +                  \
+        (1 * sizeof(sp_ID_t))
+
+#endif /* __IA_CSS_SPCTRL_COMM_H__ */
diff --git a/drivers/media/atomisp2/css2400/runtime/spctrl/src/spctrl.c b/drivers/media/atomisp2/css2400/runtime/spctrl/src/spctrl.c
new file mode 100644
index 0000000..4c0f83d
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/runtime/spctrl/src/spctrl.c
@@ -0,0 +1,310 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_acc_types.h"
+#define __INLINE_SP__
+#include "sp.h"
+
+#ifdef HRT_CSIM
+#include <hive_isp_css_sp_hrt.h>
+#endif
+
+#include "memory_access.h"
+#include "assert_support.h"
+#include "ia_css_spctrl.h"
+
+typedef struct {
+	struct ia_css_sp_init_dmem_cfg dmem_config;
+	uint32_t        spctrl_config_dmem_addr; /** location of dmem_cfg  in SP dmem */
+	uint32_t        spctrl_state_dmem_addr;
+	unsigned int    sp_entry;           /* entry function ptr on SP */
+	hrt_vaddress    code_addr;          /* sp firmware location in host mem-DDR*/
+	uint32_t        code_size;
+	char           *program_name;       /* used in case of PLATFORM_SIM */
+} spctrl_context_info;
+
+static spctrl_context_info spctrl_cofig_info[N_SP_ID];
+static bool spctrl_loaded[N_SP_ID] = {0};
+
+/* Load firmware */
+enum ia_css_err ia_css_spctrl_load_fw(sp_ID_t sp_id,
+				ia_css_spctrl_cfg *spctrl_cfg)
+{
+	hrt_vaddress code_addr = mmgr_NULL;
+	struct ia_css_sp_init_dmem_cfg *init_dmem_cfg;
+
+	if ((sp_id >= N_SP_ID) || (spctrl_cfg == 0))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	spctrl_cofig_info[sp_id].code_addr = mmgr_NULL;
+
+#if defined(C_RUN) || defined(HRT_UNSCHED)
+	(void)init_dmem_cfg;
+	code_addr = mmgr_malloc(1);
+	if (code_addr == mmgr_NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+#else
+	init_dmem_cfg = &spctrl_cofig_info[sp_id].dmem_config;
+	init_dmem_cfg->dmem_data_addr = spctrl_cfg->dmem_data_addr;
+	init_dmem_cfg->dmem_bss_addr  = spctrl_cfg->dmem_bss_addr;
+	init_dmem_cfg->data_size      = spctrl_cfg->data_size;
+	init_dmem_cfg->bss_size       = spctrl_cfg->bss_size;
+	init_dmem_cfg->sp_id          = sp_id;
+
+	spctrl_cofig_info[sp_id].spctrl_config_dmem_addr = spctrl_cfg->spctrl_config_dmem_addr;
+	spctrl_cofig_info[sp_id].spctrl_state_dmem_addr = spctrl_cfg->spctrl_state_dmem_addr;
+
+	/* store code (text + icache) and data to DDR
+	 *
+	 * Data used to be stored separately, because of access alignment constraints,
+	 * fix the FW generation instead
+	 */
+	code_addr = mmgr_malloc(spctrl_cfg->code_size);
+	if (code_addr == mmgr_NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	mmgr_store(code_addr, spctrl_cfg->code, spctrl_cfg->code_size);
+
+	assert(sizeof(hrt_vaddress) <= sizeof(hrt_data));
+
+	init_dmem_cfg->ddr_data_addr  = code_addr + spctrl_cfg->ddr_data_offset;
+	assert((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) == 0);
+#endif
+	spctrl_cofig_info[sp_id].sp_entry = spctrl_cfg->sp_entry;
+	spctrl_cofig_info[sp_id].code_addr = code_addr;
+	spctrl_cofig_info[sp_id].program_name = spctrl_cfg->program_name;
+
+#ifdef HRT_CSIM
+	hrt_cell_set_icache_base_address(SP, spctrl_cofig_info[sp_id].code_addr);
+	hrt_cell_invalidate_icache(SP);
+	hrt_cell_load_program(SP, spctrl_cofig_info[sp_id].program_name);
+#else
+	/* now we program the base address into the icache and
+	 * invalidate the cache.
+	 */
+	sp_ctrl_store(sp_id, SP_ICACHE_ADDR_REG, (hrt_data)spctrl_cofig_info[sp_id].code_addr);
+	sp_ctrl_setbit(sp_id, SP_ICACHE_INV_REG, SP_ICACHE_INV_BIT);
+#endif
+	spctrl_loaded[sp_id] = true;
+	return IA_CSS_SUCCESS;
+}
+
+#if defined(IS_ISP_2500_SYSTEM)
+/* Load firmware */
+enum ia_css_err ia_css_sp1ctrl_load_fw(sp_ID_t sp_id,
+				ia_css_spctrl_cfg *spctrl_cfg)
+{
+	hrt_vaddress code_addr = mmgr_NULL;
+	struct ia_css_sp_init_dmem_cfg *init_dmem_cfg;
+
+	if ((sp_id >= N_SP_ID) || (spctrl_cfg == 0))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	spctrl_cofig_info[sp_id].code_addr = mmgr_NULL;
+
+#if defined(C_RUN) || defined(HRT_UNSCHED)
+	(void)init_dmem_cfg;
+	code_addr = mmgr_malloc(1);
+	if (code_addr == mmgr_NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+#else
+	init_dmem_cfg = &spctrl_cofig_info[sp_id].dmem_config;
+	init_dmem_cfg->dmem_data_addr = spctrl_cfg->dmem_data_addr;
+	init_dmem_cfg->dmem_bss_addr  = spctrl_cfg->dmem_bss_addr;
+	init_dmem_cfg->data_size      = spctrl_cfg->data_size;
+	init_dmem_cfg->bss_size       = spctrl_cfg->bss_size;
+	init_dmem_cfg->sp_id          = sp_id;
+
+	spctrl_cofig_info[sp_id].spctrl_config_dmem_addr = spctrl_cfg->spctrl_config_dmem_addr;
+	spctrl_cofig_info[sp_id].spctrl_state_dmem_addr = spctrl_cfg->spctrl_state_dmem_addr;
+
+	/* store code (text + icache) and data to DDR
+	 *
+	 * Data used to be stored separately, because of access alignment constraints,
+	 * fix the FW generation instead
+	 */
+	code_addr = mmgr_malloc(spctrl_cfg->code_size);
+	if (code_addr == mmgr_NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	mmgr_store(code_addr, spctrl_cfg->code, spctrl_cfg->code_size);
+
+	assert(sizeof(hrt_vaddress) <= sizeof(hrt_data));
+
+	init_dmem_cfg->ddr_data_addr  = code_addr + spctrl_cfg->ddr_data_offset;
+	assert((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) == 0);
+#endif
+	spctrl_cofig_info[sp_id].sp_entry = spctrl_cfg->sp_entry;
+	spctrl_cofig_info[sp_id].code_addr = code_addr;
+	spctrl_cofig_info[sp_id].program_name = spctrl_cfg->program_name;
+
+#ifdef HRT_CSIM
+	hrt_cell_set_icache_base_address(SP2, spctrl_cofig_info[sp_id].code_addr);
+	hrt_cell_invalidate_icache(SP2);
+	hrt_cell_load_program(SP2, spctrl_cofig_info[sp_id].program_name);
+#else
+	/* now we program the base address into the icache and
+	 * invalidate the cache.
+	 */
+	sp_ctrl_store(sp_id, SP_ICACHE_ADDR_REG, (hrt_data)spctrl_cofig_info[sp_id].code_addr);
+	sp_ctrl_setbit(sp_id, SP_ICACHE_INV_REG, SP_ICACHE_INV_BIT);
+#endif
+	spctrl_loaded[sp_id] = true;
+	return IA_CSS_SUCCESS;
+}
+#endif
+
+
+enum ia_css_err ia_css_spctrl_unload_fw(sp_ID_t sp_id)
+{
+	if ((sp_id >= N_SP_ID) || ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	/*  freeup the resource */
+	if (spctrl_cofig_info[sp_id].code_addr)
+		mmgr_free(spctrl_cofig_info[sp_id].code_addr);
+	spctrl_loaded[sp_id] = false;
+	return IA_CSS_SUCCESS;
+}
+
+#ifdef HRT_CSIM
+enum ia_css_err ia_css_spctrl_start(sp_ID_t sp_id)
+{
+	unsigned int HIVE_ADDR_sp_start_isp_entry;
+	if ((sp_id >= N_SP_ID) || ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	HIVE_ADDR_sp_start_isp_entry = spctrl_cofig_info[sp_id].sp_entry;
+
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+	sp_dmem_store(sp_id,
+		spctrl_cofig_info[sp_id].spctrl_config_dmem_addr,
+		&spctrl_cofig_info[sp_id].dmem_config,
+		sizeof(spctrl_cofig_info[sp_id].dmem_config));
+#endif
+	hrt_cell_start_function(SP, sp_start_isp);
+	return IA_CSS_SUCCESS;
+}
+#if defined(IS_ISP_2500_SYSTEM)
+enum ia_css_err ia_css_spctrl_start_sp1(sp_ID_t sp_id)
+{
+	unsigned int HIVE_ADDR_sp1_start_entry;
+	if ((sp_id >= N_SP_ID) || ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	HIVE_ADDR_sp1_start_entry = spctrl_cofig_info[sp_id].sp_entry;
+
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+	sp_dmem_store(sp_id,
+		spctrl_cofig_info[sp_id].spctrl_config_dmem_addr,
+		&spctrl_cofig_info[sp_id].dmem_config,
+		sizeof(spctrl_cofig_info[sp_id].dmem_config));
+#endif
+/* Secondary SP is named as sp1 in the firmware however in SDK secondary SP is named as SP2 */
+	hrt_cell_start_function(SP2, sp1_start);
+
+	return IA_CSS_SUCCESS;
+}
+#endif
+#else
+
+/* Initialize dmem_cfg in SP dmem  and  start SP program*/
+enum ia_css_err ia_css_spctrl_start(sp_ID_t sp_id)
+{
+	if ((sp_id >= N_SP_ID) || ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	/* Set descr in the SP to initialize the SP DMEM */
+	/*
+	 * The FW stores user-space pointers to the FW, the ISP pointer
+	 * is only available here
+	 *
+	 */
+	assert(sizeof(unsigned int) <= sizeof(hrt_data));
+
+	sp_dmem_store(sp_id,
+		spctrl_cofig_info[sp_id].spctrl_config_dmem_addr,
+		&spctrl_cofig_info[sp_id].dmem_config,
+		sizeof(spctrl_cofig_info[sp_id].dmem_config));
+	/* set the start address */
+	sp_ctrl_store(sp_id, SP_START_ADDR_REG, (hrt_data)spctrl_cofig_info[sp_id].sp_entry);
+	sp_ctrl_setbit(sp_id, SP_SC_REG, SP_RUN_BIT);
+	sp_ctrl_setbit(sp_id, SP_SC_REG, SP_START_BIT);
+	return IA_CSS_SUCCESS;
+}
+#if defined(IS_ISP_2500_SYSTEM)
+/* Initialize dmem_cfg in SP dmem  and  start SP1 program */
+enum ia_css_err ia_css_spctrl_start_sp1(sp_ID_t sp_id)
+{
+	if ((sp_id >= N_SP_ID) || ((sp_id < N_SP_ID) && (!spctrl_loaded[sp_id])))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	/* Set descr in the SP to initialize the SP DMEM */
+	/*
+	 * The FW stores user-space pointers to the FW, the ISP pointer
+	 * is only available here
+	 *
+	 */
+	assert(sizeof(unsigned int) <= sizeof(hrt_data));
+
+	sp_dmem_store(sp_id,
+		spctrl_cofig_info[sp_id].spctrl_config_dmem_addr,
+		&spctrl_cofig_info[sp_id].dmem_config,
+		sizeof(spctrl_cofig_info[sp_id].dmem_config));
+	/* set the start address */
+	sp_ctrl_store(sp_id, SP_START_ADDR_REG, (hrt_data)spctrl_cofig_info[sp_id].sp_entry);
+	sp_ctrl_setbit(sp_id, SP_SC_REG, SP_RUN_BIT);
+	sp_ctrl_setbit(sp_id, SP_SC_REG, SP_START_BIT);
+	return IA_CSS_SUCCESS;
+}
+#endif
+#endif
+
+#if defined(IS_ISP_2500_SYSTEM)
+/* Query the state of SP1 */
+ia_css_spctrl_sp_sw_state ia_css_sp1ctrl_get_state(sp_ID_t sp_id)
+{
+	ia_css_spctrl_sp_sw_state state = 0;
+	unsigned int HIVE_ADDR_sp1_sw_state;
+
+	if (sp_id >= N_SP_ID)
+		return IA_CSS_SP_SW_TERMINATED;
+
+	HIVE_ADDR_sp1_sw_state = spctrl_cofig_info[sp_id].spctrl_state_dmem_addr;
+	(void)HIVE_ADDR_sp1_sw_state; /* Suppres warnings in CRUN */
+	state = sp_dmem_load_uint32(sp_id, (unsigned)sp1_address_of(sp1_sw_state));
+
+	return state;
+}
+#endif
+/* Query the state of SP */
+ia_css_spctrl_sp_sw_state ia_css_spctrl_get_state(sp_ID_t sp_id)
+{
+	ia_css_spctrl_sp_sw_state state;
+	unsigned int HIVE_ADDR_sp_sw_state;
+
+	if (sp_id >= N_SP_ID)
+		return IA_CSS_SP_SW_TERMINATED;
+
+	HIVE_ADDR_sp_sw_state = spctrl_cofig_info[sp_id].spctrl_state_dmem_addr;
+	(void)HIVE_ADDR_sp_sw_state; /* Suppres warnings in CRUN */
+	state = sp_dmem_load_uint32(sp_id, (unsigned)sp_address_of(sp_sw_state));
+
+	return state;
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css.c b/drivers/media/atomisp2/css2400/sh_css.c
new file mode 100644
index 0000000..a347752
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css.c
@@ -0,0 +1,9201 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/*! \file */
+//#include "stdio.h"
+#include "ia_css.h"
+#include "sh_css_hrt.h"		/* only for file 2 MIPI */
+#include "ia_css_binary.h"
+#include "sh_css_internal.h"
+#include "sh_css_sp.h"		/* sh_css_sp_group */
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include "ia_css_isys.h"
+#endif
+#include "ia_css_frame.h"
+#include "sh_css_defs.h"
+#include "sh_css_firmware.h"
+#include "sh_css_params.h"
+#include "sh_css_params_internal.h"
+#include "sh_css_param_shading.h"
+#include "ia_css_refcount.h"
+#include "ia_css_rmgr.h"
+#include "ia_css_debug.h"
+#include "ia_css_debug_pipe.h"
+#include "ia_css_memory_access.h"
+#include "ia_css_device_access.h"
+#include "sh_css_legacy.h"
+#include "ia_css_pipeline.h"
+#include "ia_css_stream.h"
+#include "ia_css_pipe.h"
+#include "ia_css_util.h"
+#include "ia_css_pipe_util.h"
+#include "ia_css_pipe_binarydesc.h"
+#include "ia_css_pipe_stagedesc.h"
+//#include "ia_css_stream_manager.h"
+/* #include "ia_css_rmgr_gen.h" */
+
+#include "memory_access.h"
+#include "tag.h"
+#include "assert_support.h"
+#include "math_support.h"
+#include "sw_event_global.h"			/* Event IDs.*/
+#if !defined(HAS_NO_INPUT_FORMATTER)
+#include "ia_css_ifmtr.h"
+#endif
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include "input_system.h"
+#endif
+#include "mmu_device.h"		/* mmu_set_page_table_base_index(), ... */
+#include "gdc_device.h"		/* HRT_GDC_N */
+#include "irq.h"			/* virq */
+#include "sp.h"				/* cnd_sp_irq_enable() */
+#include "isp.h"			/* cnd_isp_irq_enable, ISP_VEC_NELEMS */
+#include "gp_device.h"		/* gp_device_reg_store() */
+#if !defined(HAS_NO_GPIO)
+#define __INLINE_GPIO__
+#include "gpio.h"
+#endif
+#include "timed_ctrl.h"
+#include "platform_support.h" /* hrt_sleep() */
+#include "ia_css_inputfifo.h"
+#define WITH_PC_MONITORING  0
+
+#define SH_CSS_VIDEO_BUFFER_ALIGNMENT 0
+
+#if WITH_PC_MONITORING
+#define MULTIPLE_SAMPLES 1
+#define NOF_SAMPLES      60
+#include "linux/kthread.h"
+#include "linux/sched.h"
+#include "linux/delay.h"
+#include "sh_css_metrics.h"
+static int thread_alive;
+#endif /* WITH_PC_MONITORING */
+
+#define DVS_REF_TESTING 0
+#if DVS_REF_TESTING
+#include <stdio.h>
+#endif
+#include"ia_css_spctrl.h"
+#include "ia_css_version_data.h"
+#include "sh_css_struct.h"
+#include "ia_css_bufq.h"
+
+/* Name of the sp program: should not be built-in */
+#define SP_PROG_NAME "sp"
+#if defined(IS_ISP_2500_SYSTEM)
+#define SP1_PROG_NAME "sp1"
+#endif
+/* Size of Refcount List */
+#define REFCOUNT_SIZE 1000
+
+/* for JPEG, we don't know the length of the image upfront,
+ * but since we support sensor upto 16MP, we take this as
+ * upper limit.
+ */
+#define JPEG_BYTES (16 * 1024 * 1024)
+
+#if defined(IS_ISP_2500_SYSTEM)
+#define STATS_ENABLED(stage) (stage && stage->binary && stage->binary->info && \
+	(stage->binary->info->sp.enable.s3a || stage->binary->info->sp.enable.dvs_stats || \
+	stage->binary->info->sp.enable.lace_stats))
+#else
+#define STATS_ENABLED(stage) (stage && stage->binary && stage->binary->info && \
+        (stage->binary->info->sp.enable.s3a || stage->binary->info->sp.enable.dis))
+#endif
+
+#define PIPE_ENTRY_EMPTY_TOKEN                (~0)
+#define PIPE_ENTRY_RESERVED_TOKEN             (0x1)
+
+
+#define DEFAULT_PLANES { {0, 0, 0, 0} }
+
+struct sh_css my_css = {
+	.mipi_frames = {NULL, NULL, NULL, NULL}
+};
+
+int (*sh_css_printf) (const char *fmt, va_list args) = NULL;
+
+/* modes of work: stream_create and stream_destroy will update the save/restore data
+   only when in working mode, not suspend/resume
+*/
+enum ia_sh_css_modes {
+	sh_css_mode_none = 0,
+	sh_css_mode_working,
+	sh_css_mode_suspend,
+	sh_css_mode_resume
+};
+
+#define SEED_NUM_PIPES	3
+
+/* a stream seed, to save and restore the stream data.
+   the stream seed contains all the data required to "grow" the seed again after it was closed.
+*/
+struct sh_css_stream_seed {
+	struct ia_css_stream 		**orig_stream;                /* pointer to restore the original handle */
+	struct ia_css_stream 		*stream;                      /* handle, used as ID too.*/
+	struct ia_css_stream_config 	stream_config;
+	int 				num_pipes;
+	struct ia_css_pipe 		*pipes[SEED_NUM_PIPES];
+	struct ia_css_pipe_config 	pipe_config[SEED_NUM_PIPES];
+};
+
+#define MAX_ACTIVE_STREAMS	5
+/* A global struct for save/restore to hold all the data that should sustain power-down:
+   MMU base, IRQ type, env for routines, binary loaded FW and the stream seeds.
+*/
+struct sh_css_save {
+	enum ia_sh_css_modes		mode;
+	uint32_t 		       mmu_base;				/* the last mmu_base */
+	enum ia_css_irq_type           irq_type;
+	struct sh_css_stream_seed      stream_seeds[MAX_ACTIVE_STREAMS];
+	struct ia_css_fw 	       *loaded_fw;				/* fw struct previously loaded */
+	struct ia_css_env 	       *driver_env;				/* driver-supplied env */
+};
+
+static bool my_css_save_initialized = false;		// if my_css_save was initialized
+static struct sh_css_save my_css_save;
+
+/* pqiao NOTICE: this is for css internal buffer recycling when stopping pipeline,
+   this array is temporary and will be replaced by resource manager*/
+/* Taking the biggest Size for number of Elements */
+#define MAX_HMM_BUFFER_NUM	\
+	(SH_CSS_MAX_NUM_QUEUES * (IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE + 2))
+
+static struct ia_css_rmgr_vbuf_handle *hmm_buffer_record_h[MAX_HMM_BUFFER_NUM];
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+static uint32_t ref_count_mipi_allocation = 0;
+#endif
+
+#define GPIO_FLASH_PIN_MASK (1 << HIVE_GPIO_STROBE_TRIGGER_PIN)
+
+static bool fw_explicitly_loaded = false;
+
+/**
+ * Local prototypes
+ */
+static enum ia_css_err
+sh_css_pipe_start(struct ia_css_stream *stream);
+
+static enum ia_css_err
+ia_css_pipe_load_extension(struct ia_css_pipe *pipe,
+			   struct ia_css_fw_info *firmware);
+
+static void
+ia_css_pipe_unload_extension(struct ia_css_pipe *pipe,
+			     struct ia_css_fw_info *firmware);
+static void
+ia_css_reset_defaults(struct sh_css* css);
+
+static void
+sh_css_init_host_sp_control_vars(void);
+
+static void
+sh_css_mmu_set_page_table_base_index(hrt_data base_index);
+
+static bool
+need_capture_pp(const struct ia_css_pipe *pipe);
+
+static bool
+need_yuv_scaler(const struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+sh_css_pipe_load_binaries(struct ia_css_pipe *pipe);
+
+static
+enum ia_css_err sh_css_pipe_get_viewfinder_frame_info(
+	struct ia_css_pipe *pipe,
+	struct ia_css_frame_info *info,
+	unsigned int idx);
+
+static enum ia_css_err
+sh_css_pipe_get_output_frame_info(struct ia_css_pipe *pipe,
+				  struct ia_css_frame_info *info,
+				  unsigned int idx);
+
+static enum ia_css_err
+capture_start(struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+video_start(struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+preview_start(struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+yuvpp_start(struct ia_css_pipe *pipe);
+
+static bool copy_on_sp(struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+init_vf_frameinfo_defaults(struct ia_css_pipe *pipe,
+	struct ia_css_frame *vf_frame, unsigned int idx);
+
+static enum ia_css_err
+init_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,
+	struct ia_css_frame *frame);
+
+static enum ia_css_err
+init_out_frameinfo_defaults(struct ia_css_pipe *pipe,
+	struct ia_css_frame *out_frame, unsigned int idx);
+
+static enum ia_css_err
+sh_css_pipeline_add_acc_stage(struct ia_css_pipeline *pipeline,
+			      const void *acc_fw);
+
+static enum ia_css_err
+alloc_continuous_frames(
+	struct ia_css_pipe *pipe, bool init_time);
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+static enum ia_css_err
+allocate_mipi_frames(struct ia_css_pipe *pipe);
+
+static void
+free_mipi_frames(struct ia_css_pipe *pipe, bool uninit);
+#endif
+
+static void
+pipe_global_init(void);
+
+static uint8_t
+pipe_generate_pipe_num(const struct ia_css_pipe *pipe);
+
+static void
+pipe_release_pipe_num(unsigned int pipe_num);
+
+static enum ia_css_err
+create_host_pipeline_structure(struct ia_css_stream *stream);
+
+static enum ia_css_err
+create_host_pipeline(struct ia_css_stream *stream);
+
+static enum ia_css_err
+create_host_preview_pipeline(struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+create_host_video_pipeline(struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+create_host_copy_pipeline(struct ia_css_pipe *pipe,
+    unsigned max_input_width,
+    struct ia_css_frame *out_frame);
+
+static enum ia_css_err
+create_host_isyscopy_capture_pipeline(struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+create_host_capture_pipeline(struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+create_host_yuvpp_pipeline(struct ia_css_pipe *pipe);
+
+static enum ia_css_err
+create_host_acc_pipeline(struct ia_css_pipe *pipe);
+
+static unsigned int
+sh_css_get_sw_interrupt_value(unsigned int irq);
+
+#if 0
+static enum ia_css_err
+sh_css_pipeline_stop(struct ia_css_pipe *pipe);
+#endif
+
+static struct ia_css_binary *
+ia_css_pipe_get_3a_binary (const struct ia_css_pipe *pipe);
+
+#if CONFIG_ON_FRAME_ENQUEUE()
+static enum ia_css_err set_config_on_frame_enqueue(struct ia_css_frame_info *info, struct frame_data_wrapper *frame);
+#endif
+
+static void
+sh_css_pipe_free_shading_table(struct ia_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+
+	if (pipe->shading_table)
+		ia_css_shading_table_free(pipe->shading_table);
+	pipe->shading_table = NULL;
+}
+
+static enum ia_css_frame_format yuv420_copy_formats[] = {
+	IA_CSS_FRAME_FORMAT_NV12,
+	IA_CSS_FRAME_FORMAT_NV21,
+	IA_CSS_FRAME_FORMAT_YV12,
+	IA_CSS_FRAME_FORMAT_YUV420,
+	IA_CSS_FRAME_FORMAT_YUV420_16,
+	IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8
+};
+
+static enum ia_css_frame_format yuv422_copy_formats[] = {
+	IA_CSS_FRAME_FORMAT_NV12,
+	IA_CSS_FRAME_FORMAT_NV16,
+	IA_CSS_FRAME_FORMAT_NV21,
+	IA_CSS_FRAME_FORMAT_NV61,
+	IA_CSS_FRAME_FORMAT_YV12,
+	IA_CSS_FRAME_FORMAT_YV16,
+	IA_CSS_FRAME_FORMAT_YUV420,
+	IA_CSS_FRAME_FORMAT_YUV420_16,
+	IA_CSS_FRAME_FORMAT_YUV422,
+	IA_CSS_FRAME_FORMAT_YUV422_16,
+	IA_CSS_FRAME_FORMAT_UYVY,
+	IA_CSS_FRAME_FORMAT_YUYV,
+	IA_CSS_FRAME_FORMAT_RGB565,
+	IA_CSS_FRAME_FORMAT_RGBA888
+};
+
+#define array_length(array) (sizeof(array)/sizeof(array[0]))
+
+
+/* Retrieve the CSS version and try to retrieve the FW version too.
+ */
+enum ia_css_err
+ia_css_get_version(char *version, int max_size)
+{
+	if (max_size <= (int)strlen(CSS_VERSION_STRING) + (int)strlen(sh_css_get_fw_version()) + 5)
+		return(IA_CSS_ERR_INVALID_ARGUMENTS);
+	assert(version != NULL);
+	strcpy(version, CSS_VERSION_STRING);
+	strcat(version, "FW:");
+	strcat(version, sh_css_get_fw_version());
+	strcat(version, "; ");
+	return(IA_CSS_SUCCESS);
+}
+
+
+/* Verify whether the selected output format is can be produced
+ * by the copy binary given the stream format.
+ * */
+static enum ia_css_err
+verify_copy_out_frame_format(struct ia_css_pipe *pipe)
+{
+	enum ia_css_frame_format out_fmt = pipe->output_info[0].format;
+	unsigned int i, found = 0;
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	switch (pipe->stream->config.format) {
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+		for (i=0; i<array_length(yuv420_copy_formats) && !found; i++)
+			found = (out_fmt == yuv420_copy_formats[i]);
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_YUV420_16);
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+		for (i=0; i<array_length(yuv422_copy_formats) && !found; i++)
+			found = (out_fmt == yuv422_copy_formats[i]);
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_YUV422_16 ||
+			 out_fmt == IA_CSS_FRAME_FORMAT_YUV420_16);
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_RGBA888 ||
+			 out_fmt == IA_CSS_FRAME_FORMAT_RGB565);
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_RGBA888);
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_RAW) ||
+			(out_fmt == IA_CSS_FRAME_FORMAT_RAW_PACKED);
+		break;
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+		found = (out_fmt == IA_CSS_FRAME_FORMAT_BINARY_8);
+		break;
+	default:
+		break;
+	}
+	if (!found)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return IA_CSS_SUCCESS;
+}
+
+/* next function takes care of getting the settings from kernel
+ * commited to hmm / isp
+ * TODO: see if needs to be made public
+ */
+static enum ia_css_err
+sh_css_commit_isp_config(struct ia_css_stream *stream,
+			 struct ia_css_pipeline *pipeline)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_pipeline_stage *stage;
+
+	if (pipeline) {
+		/* walk through pipeline and commit settings */
+		/* TODO: check if this is needed (s3a is handled through this */
+		for (stage = pipeline->stages; stage; stage = stage->next) {
+			if (stage && stage->binary) {
+				err = sh_css_params_write_to_ddr(stream,
+								 stage);
+				if (err != IA_CSS_SUCCESS)
+					return err;
+			}
+		}
+	}
+	return err;
+}
+
+static void
+configure_pipe_inout_port(struct ia_css_pipeline *me, bool continuous)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"configure_pipe_inout_port() enter: pipe_id(%d) continuous(%d)\n",
+			me->pipe_id, continuous);
+	switch(me->pipe_id) {
+		case IA_CSS_PIPE_ID_PREVIEW:
+		case IA_CSS_PIPE_ID_VIDEO:
+			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_INPUT,
+						   (uint8_t)(continuous ? SH_CSS_COPYSINK_TYPE : SH_CSS_HOST_TYPE),1);
+			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_OUTPUT,
+						   (uint8_t)SH_CSS_HOST_TYPE,1);
+			break;
+		case IA_CSS_PIPE_ID_COPY: /*Copy pipe ports configured to "offline" mode*/
+			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_INPUT,
+						   (uint8_t)SH_CSS_HOST_TYPE,1);
+			if (continuous) {
+				SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_OUTPUT,
+						   (uint8_t)SH_CSS_COPYSINK_TYPE,1);
+				SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_OUTPUT,
+						   (uint8_t)SH_CSS_TAGGERSINK_TYPE,1);
+			} else {
+				SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_OUTPUT,
+						   (uint8_t)SH_CSS_HOST_TYPE,1);
+			}
+			break;
+		case IA_CSS_PIPE_ID_CAPTURE:
+			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_INPUT,
+						   (uint8_t)(continuous ? SH_CSS_TAGGERSINK_TYPE : SH_CSS_HOST_TYPE),1);
+			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_OUTPUT,
+						   (uint8_t)SH_CSS_HOST_TYPE,1);
+			break;
+		case IA_CSS_PIPE_ID_YUVPP:
+			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_INPUT,
+						   (uint8_t)(SH_CSS_HOST_TYPE),1);
+			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_OUTPUT,
+						   (uint8_t)SH_CSS_HOST_TYPE,1);
+			break;
+		case IA_CSS_PIPE_ID_ACC:
+			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_INPUT,
+						   (uint8_t)SH_CSS_HOST_TYPE,1);
+			SH_CSS_PIPE_PORT_CONFIG_SET(me->inout_port_config,
+						   (uint8_t)SH_CSS_PORT_OUTPUT,
+						   (uint8_t)SH_CSS_HOST_TYPE,1);
+			break;
+		default:
+			break;
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"configure_pipe_inout_port() leave: inout_port_config(%x)\n",
+		me->inout_port_config);
+}
+
+unsigned int
+ia_css_stream_input_format_bits_per_pixel(struct ia_css_stream *stream)
+{
+	int bpp = 0;
+
+	if (stream != NULL)
+		bpp = ia_css_util_input_format_bpp(stream->config.format,
+						stream->config.pixels_per_clock == 2);
+
+	return bpp;
+}
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+static enum ia_css_err
+sh_css_config_input_network(struct ia_css_pipe *pipe,
+			    struct ia_css_binary *binary)
+{
+	unsigned int fmt_type;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_config_input_network() enter:\n");
+
+	if (pipe->pipeline.stages)
+		binary = pipe->pipeline.stages->binary;
+
+	err = ia_css_isys_convert_stream_format_to_mipi_format(
+				pipe->stream->config.format,
+				pipe->stream->csi_rx_config.comp,
+				&fmt_type);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	sh_css_sp_program_input_circuit(fmt_type,
+					pipe->stream->config.channel_id,
+					pipe->stream->config.mode);
+
+	if (binary && (binary->online || pipe->stream->config.continuous)) {
+		err = ia_css_ifmtr_configure(&pipe->stream->config,
+			binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	if (pipe->stream->config.mode == IA_CSS_INPUT_MODE_TPG ||
+	    pipe->stream->config.mode == IA_CSS_INPUT_MODE_PRBS) {
+		unsigned int hblank_cycles = 100,
+			     vblank_lines = 6,
+			     width,
+			     height,
+			     vblank_cycles;
+		width  = (pipe->stream->config.input_res.width) / (1 + (pipe->stream->config.pixels_per_clock == 2));
+		height = pipe->stream->config.input_res.height;
+		vblank_cycles = vblank_lines * (width + hblank_cycles);
+		sh_css_sp_configure_sync_gen(width, height, hblank_cycles,
+					     vblank_cycles);
+#if defined(IS_ISP_2400_SYSTEM)
+		if (pipe->stream->config.mode == IA_CSS_INPUT_MODE_TPG) {
+			/* TODO: move define to proper file in tools */
+			#define GP_ISEL_TPG_MODE 0x90058
+			ia_css_device_store_uint32(GP_ISEL_TPG_MODE, 0);
+		}
+#endif
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_config_input_network() leave:\n");
+	return IA_CSS_SUCCESS;
+}
+#elif !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2401)
+static mipi_predictor_t sh_css_csi2_compression_type_2_mipi_predictor(enum ia_css_csi2_compression_type type)
+{
+	mipi_predictor_t predictor = MIPI_PREDICTOR_NONE;
+
+	switch (type) {
+	case IA_CSS_CSI2_COMPRESSION_TYPE_NONE:
+		predictor = MIPI_PREDICTOR_NONE;
+		break;
+	case IA_CSS_CSI2_COMPRESSION_TYPE_1:
+		predictor = MIPI_PREDICTOR_TYPE1;
+		break;
+	case IA_CSS_CSI2_COMPRESSION_TYPE_2:
+		predictor = MIPI_PREDICTOR_TYPE2;
+	default:
+		break;
+	}
+	return predictor;
+}
+
+static unsigned int sh_css_stream_format_2_bits_per_subpixel(
+		enum ia_css_stream_format format)
+{
+	unsigned int rval;
+
+	switch (format) {
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+		rval = 4;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+		rval = 5;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+		rval = 6;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+		rval = 7;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+	case IA_CSS_STREAM_FORMAT_USER_DEF1:
+	case IA_CSS_STREAM_FORMAT_USER_DEF2:
+	case IA_CSS_STREAM_FORMAT_USER_DEF3:
+	case IA_CSS_STREAM_FORMAT_USER_DEF4:
+	case IA_CSS_STREAM_FORMAT_USER_DEF5:
+	case IA_CSS_STREAM_FORMAT_USER_DEF6:
+	case IA_CSS_STREAM_FORMAT_USER_DEF7:
+	case IA_CSS_STREAM_FORMAT_USER_DEF8:
+		rval = 8;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+		rval = 10;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+		rval = 12;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+		rval = 14;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+		rval = 16;
+		break;
+	default:
+		rval = 0;
+		break;
+	}
+
+	return rval;
+}
+
+static unsigned int csi2_protocol_calculate_max_subpixels_per_line(
+		enum ia_css_stream_format	format,
+		unsigned int			pixels_per_line)
+{
+	unsigned int rval;
+
+	switch (format) {
+	case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:
+		/*
+		 * The frame format layout is shown below.
+		 *
+		 *		Line	0:	UYY UYY ... UYY
+		 *		Line	1:	VYY VYY ... VYY
+		 *		Line	2:	UYY UYY ... UYY
+		 *		Line	3:	VYY VYY ... VYY
+		 *		...
+		 *		Line (n-2):	UYY UYY ... UYY
+		 *		Line (n-1):	VYY VYY ... VYY
+		 *
+		 *	In this frame format, the even-line is
+		 *	as wide as the odd-line.
+		 */
+		rval = pixels_per_line + pixels_per_line / 2;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV420_8:
+	case IA_CSS_STREAM_FORMAT_YUV420_10:
+		/*
+		 * The frame format layout is shown below.
+		 *
+		 *		Line	0:	YYYY YYYY ... YYYY
+		 *		Line	1:	UYVY UYVY ... UYVY UYVY
+		 *		Line	2:	YYYY YYYY ... YYYY
+		 *		Line	3:	UYVY UYVY ... UYVY UYVY
+		 *		...
+		 *		Line (n-2):	YYYY YYYY ... YYYY
+		 *		Line (n-1):	UYVY UYVY ... UYVY UYVY
+		 *
+		 * In this frame format, the odd-line is twice
+		 * wider than the even-line.
+		 */
+		rval = pixels_per_line * 2;
+		break;
+	case IA_CSS_STREAM_FORMAT_YUV422_8:
+	case IA_CSS_STREAM_FORMAT_YUV422_10:
+		/*
+		 * The frame format layout is shown below.
+		 *
+		 *		Line	0:	UYVY UYVY ... UYVY
+		 *		Line	1:	UYVY UYVY ... UYVY
+		 *		Line	2:	UYVY UYVY ... UYVY
+		 *		Line	3:	UYVY UYVY ... UYVY
+		 *		...
+		 *		Line (n-2):	UYVY UYVY ... UYVY
+		 *		Line (n-1):	UYVY UYVY ... UYVY
+		 *
+		 * In this frame format, the even-line is
+		 * as wide as the odd-line.
+		 */
+		rval = pixels_per_line * 2;
+		break;
+	case IA_CSS_STREAM_FORMAT_RGB_444:
+	case IA_CSS_STREAM_FORMAT_RGB_555:
+	case IA_CSS_STREAM_FORMAT_RGB_565:
+	case IA_CSS_STREAM_FORMAT_RGB_666:
+	case IA_CSS_STREAM_FORMAT_RGB_888:
+		/*
+		 * The frame format layout is shown below.
+		 *
+		 *		Line	0:	ABGR ABGR ... ABGR
+		 *		Line	1:	ABGR ABGR ... ABGR
+		 *		Line	2:	ABGR ABGR ... ABGR
+		 *		Line	3:	ABGR ABGR ... ABGR
+		 *		...
+		 *		Line (n-2):	ABGR ABGR ... ABGR
+		 *		Line (n-1):	ABGR ABGR ... ABGR
+		 *
+		 * In this frame format, the even-line is
+		 * as wide as the odd-line.
+		 */
+		rval = pixels_per_line * 4;
+		break;
+	case IA_CSS_STREAM_FORMAT_RAW_6:
+	case IA_CSS_STREAM_FORMAT_RAW_7:
+	case IA_CSS_STREAM_FORMAT_RAW_8:
+	case IA_CSS_STREAM_FORMAT_RAW_10:
+	case IA_CSS_STREAM_FORMAT_RAW_12:
+	case IA_CSS_STREAM_FORMAT_RAW_14:
+	case IA_CSS_STREAM_FORMAT_RAW_16:
+	case IA_CSS_STREAM_FORMAT_BINARY_8:
+	case IA_CSS_STREAM_FORMAT_USER_DEF1:
+	case IA_CSS_STREAM_FORMAT_USER_DEF2:
+	case IA_CSS_STREAM_FORMAT_USER_DEF3:
+	case IA_CSS_STREAM_FORMAT_USER_DEF4:
+	case IA_CSS_STREAM_FORMAT_USER_DEF5:
+	case IA_CSS_STREAM_FORMAT_USER_DEF6:
+	case IA_CSS_STREAM_FORMAT_USER_DEF7:
+	case IA_CSS_STREAM_FORMAT_USER_DEF8:
+		/*
+		 * The frame format layout is shown below.
+		 *
+		 *		Line	0:	Pixel Pixel ... Pixel
+		 *		Line	1:	Pixel Pixel ... Pixel
+		 *		Line	2:	Pixel Pixel ... Pixel
+		 *		Line	3:	Pixel Pixel ... Pixel
+		 *		...
+		 *		Line (n-2):	Pixel Pixel ... Pixel
+		 *		Line (n-1):	Pixel Pixel ... Pixel
+		 *
+		 * In this frame format, the even-line is
+		 * as wide as the odd-line.
+		 */
+		rval = pixels_per_line;
+		break;
+	default:
+		rval = 0;
+		break;
+	}
+
+	return rval;
+}
+
+static bool sh_css_translate_stream_cfg_to_input_system_input_port_id(
+		struct ia_css_stream_config *stream_cfg,
+		ia_css_isys_descr_t	*isys_stream_descr)
+{
+	bool rc;
+
+	rc = true;
+	switch (stream_cfg->mode) {
+	case IA_CSS_INPUT_MODE_TPG:
+
+		if (stream_cfg->source.tpg.id == IA_CSS_TPG_ID0) {
+			isys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT0_ID;
+		} else if (stream_cfg->source.tpg.id == IA_CSS_TPG_ID1) {
+			isys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT1_ID;
+		} else if (stream_cfg->source.tpg.id == IA_CSS_TPG_ID2) {
+			isys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT2_ID;
+		}
+
+		break;
+	case IA_CSS_INPUT_MODE_PRBS:
+
+		if (stream_cfg->source.prbs.id == IA_CSS_PRBS_ID0) {
+			isys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT0_ID;
+		} else if (stream_cfg->source.prbs.id == IA_CSS_PRBS_ID1) {
+			isys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT1_ID;
+		} else if (stream_cfg->source.prbs.id == IA_CSS_PRBS_ID2) {
+			isys_stream_descr->input_port_id = INPUT_SYSTEM_PIXELGEN_PORT2_ID;
+		}
+
+		break;
+	case IA_CSS_INPUT_MODE_BUFFERED_SENSOR:
+
+		if (stream_cfg->source.port.port == IA_CSS_CSI2_PORT0) {
+			isys_stream_descr->input_port_id = INPUT_SYSTEM_CSI_PORT0_ID;
+		} else if (stream_cfg->source.port.port == IA_CSS_CSI2_PORT1) {
+			isys_stream_descr->input_port_id = INPUT_SYSTEM_CSI_PORT1_ID;
+		} else if (stream_cfg->source.port.port == IA_CSS_CSI2_PORT2) {
+			isys_stream_descr->input_port_id = INPUT_SYSTEM_CSI_PORT2_ID;
+		}
+
+		break;
+	default:
+		rc = false;
+		break;
+	}
+
+	return rc;
+}
+
+static bool sh_css_translate_stream_cfg_to_input_system_input_port_type(
+		struct ia_css_stream_config *stream_cfg,
+		ia_css_isys_descr_t	*isys_stream_descr)
+{
+	bool rc;
+
+	rc = true;
+	switch (stream_cfg->mode) {
+	case IA_CSS_INPUT_MODE_TPG:
+
+		isys_stream_descr->mode = INPUT_SYSTEM_SOURCE_TYPE_TPG;
+
+		break;
+	case IA_CSS_INPUT_MODE_PRBS:
+
+		isys_stream_descr->mode = INPUT_SYSTEM_SOURCE_TYPE_PRBS;
+
+		break;
+	case IA_CSS_INPUT_MODE_SENSOR:
+	case IA_CSS_INPUT_MODE_BUFFERED_SENSOR:
+
+		isys_stream_descr->mode = INPUT_SYSTEM_SOURCE_TYPE_SENSOR;
+		break;
+
+	default:
+		rc = false;
+		break;
+	}
+
+	return rc;
+}
+
+static bool sh_css_translate_stream_cfg_to_input_system_input_port_attr(
+		struct ia_css_stream_config *stream_cfg,
+		ia_css_isys_descr_t	*isys_stream_descr)
+{
+	bool rc;
+
+	rc = true;
+	switch (stream_cfg->mode) {
+	case IA_CSS_INPUT_MODE_TPG:
+		if (stream_cfg->source.tpg.mode == IA_CSS_TPG_MODE_RAMP) {
+			isys_stream_descr->tpg_port_attr.mode = PIXELGEN_TPG_MODE_RAMP;
+		} else if (stream_cfg->source.tpg.mode == IA_CSS_TPG_MODE_CHECKERBOARD) {
+			isys_stream_descr->tpg_port_attr.mode = PIXELGEN_TPG_MODE_CHBO;
+		} else if (stream_cfg->source.tpg.mode == IA_CSS_TPG_MODE_MONO) {
+			isys_stream_descr->tpg_port_attr.mode = PIXELGEN_TPG_MODE_MONO;
+		} else {
+			rc = false;
+		}
+
+		/*
+		 * zhengjie.lu@intel.com:
+		 *
+		 * TODO
+		 * - Make "color_cfg" as part of "ia_css_tpg_config".
+		 */
+		isys_stream_descr->tpg_port_attr.color_cfg.R1 = 51;
+		isys_stream_descr->tpg_port_attr.color_cfg.G1 = 102;
+		isys_stream_descr->tpg_port_attr.color_cfg.B1 = 255;
+		isys_stream_descr->tpg_port_attr.color_cfg.R2 = 0;
+		isys_stream_descr->tpg_port_attr.color_cfg.G2 = 100;
+		isys_stream_descr->tpg_port_attr.color_cfg.B2 = 160;
+
+		isys_stream_descr->tpg_port_attr.mask_cfg.h_mask = stream_cfg->source.tpg.x_mask;
+		isys_stream_descr->tpg_port_attr.mask_cfg.v_mask = stream_cfg->source.tpg.y_mask;
+		isys_stream_descr->tpg_port_attr.mask_cfg.hv_mask = stream_cfg->source.tpg.xy_mask;
+
+		isys_stream_descr->tpg_port_attr.delta_cfg.h_delta = stream_cfg->source.tpg.x_delta;
+		isys_stream_descr->tpg_port_attr.delta_cfg.v_delta = stream_cfg->source.tpg.y_delta;
+
+		/*
+		 * zhengjie.lu@intel.com:
+		 *
+		 * TODO
+		 * - Make "sync_gen_cfg" as part of "ia_css_tpg_config".
+		 */
+		isys_stream_descr->tpg_port_attr.sync_gen_cfg.hblank_cycles = 100;
+		isys_stream_descr->tpg_port_attr.sync_gen_cfg.vblank_cycles = 100;
+		isys_stream_descr->tpg_port_attr.sync_gen_cfg.pixels_per_clock = stream_cfg->pixels_per_clock;
+		isys_stream_descr->tpg_port_attr.sync_gen_cfg.nr_of_frames = ~(0x0);
+		isys_stream_descr->tpg_port_attr.sync_gen_cfg.pixels_per_line = stream_cfg->input_res.width;
+		isys_stream_descr->tpg_port_attr.sync_gen_cfg.lines_per_frame = stream_cfg->input_res.height;
+
+		break;
+	case IA_CSS_INPUT_MODE_PRBS:
+
+		isys_stream_descr->prbs_port_attr.seed0 = stream_cfg->source.prbs.seed;
+		isys_stream_descr->prbs_port_attr.seed1 = stream_cfg->source.prbs.seed1;
+
+		/*
+		 * zhengjie.lu@intel.com:
+		 *
+		 * TODO
+		 * - Make "sync_gen_cfg" as part of "ia_css_prbs_config".
+		 */
+		isys_stream_descr->prbs_port_attr.sync_gen_cfg.hblank_cycles = 100;
+		isys_stream_descr->prbs_port_attr.sync_gen_cfg.vblank_cycles = 100;
+		isys_stream_descr->prbs_port_attr.sync_gen_cfg.pixels_per_clock = stream_cfg->pixels_per_clock;
+		isys_stream_descr->prbs_port_attr.sync_gen_cfg.nr_of_frames = ~(0x0);
+		isys_stream_descr->prbs_port_attr.sync_gen_cfg.pixels_per_line = stream_cfg->input_res.width;
+		isys_stream_descr->prbs_port_attr.sync_gen_cfg.lines_per_frame = stream_cfg->input_res.height;
+
+		break;
+	case IA_CSS_INPUT_MODE_BUFFERED_SENSOR:
+	{
+		enum ia_css_err err;
+		unsigned int fmt_type;
+
+		err = ia_css_isys_convert_stream_format_to_mipi_format(
+			stream_cfg->format,
+			sh_css_csi2_compression_type_2_mipi_predictor(stream_cfg->source.port.compression.type),
+				&fmt_type);
+		if (err != IA_CSS_SUCCESS)
+			rc = false;
+
+		isys_stream_descr->csi_port_attr.active_lanes = stream_cfg->source.port.num_lanes;
+		isys_stream_descr->csi_port_attr.fmt_type = fmt_type;
+		isys_stream_descr->csi_port_attr.ch_id = stream_cfg->channel_id;
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+		isys_stream_descr->online = stream_cfg->online;
+#endif
+
+		/* metadata */
+		isys_stream_descr->metadata.enable = false;
+		if (stream_cfg->metadata_config.resolution.height > 0) {
+			err = ia_css_isys_convert_stream_format_to_mipi_format(
+				stream_cfg->metadata_config.data_type,
+				sh_css_csi2_compression_type_2_mipi_predictor(stream_cfg->source.port.compression.type),
+					&fmt_type);
+			if (err != IA_CSS_SUCCESS)
+				rc = false;
+			isys_stream_descr->metadata.fmt_type = fmt_type;
+			isys_stream_descr->metadata.bits_per_pixel =
+				ia_css_util_input_format_bpp(stream_cfg->metadata_config.data_type, true);
+			isys_stream_descr->metadata.pixels_per_line = stream_cfg->metadata_config.resolution.width;
+			isys_stream_descr->metadata.lines_per_frame = stream_cfg->metadata_config.resolution.height;
+			isys_stream_descr->metadata.enable = true;
+		}
+
+		break;
+	}
+	default:
+		rc = false;
+		break;
+	}
+
+	return rc;
+}
+
+static bool sh_css_translate_stream_cfg_to_input_system_input_port_resolution(
+		struct ia_css_stream_config *stream_cfg,
+		ia_css_isys_descr_t	*isys_stream_descr)
+{
+	unsigned int bits_per_subpixel;
+	/* unsigned int subpixels_per_color_pixel; */
+	/* unsigned int color_pixels_per_line; */
+	unsigned int max_subpixels_per_line;
+	unsigned int lines_per_frame;
+
+	bits_per_subpixel =
+		sh_css_stream_format_2_bits_per_subpixel(stream_cfg->format);
+	if (bits_per_subpixel == 0)
+		return false;
+
+	if (stream_cfg->online){
+		max_subpixels_per_line =
+			csi2_protocol_calculate_max_subpixels_per_line(stream_cfg->format, stream_cfg->input_res.width);
+		}
+	else {
+		max_subpixels_per_line =
+			csi2_protocol_calculate_max_subpixels_per_line(stream_cfg->format, stream_cfg->input_res.width);
+		}
+	if (max_subpixels_per_line == 0)
+		return false;
+
+	lines_per_frame = stream_cfg->input_res.height;
+	if (lines_per_frame == 0)
+		return false;
+
+	/* HW needs subpixel info for their settings */
+	isys_stream_descr->input_port_resolution.bits_per_pixel	= bits_per_subpixel;
+	isys_stream_descr->input_port_resolution.pixels_per_line	= max_subpixels_per_line;
+	isys_stream_descr->input_port_resolution.lines_per_frame = lines_per_frame;
+
+	return true;
+}
+
+static bool sh_css_translate_stream_cfg_to_isys_stream_descr(
+		struct ia_css_stream_config *stream_cfg,
+		ia_css_isys_descr_t	*isys_stream_descr)
+{
+	bool rc;
+
+	rc  = sh_css_translate_stream_cfg_to_input_system_input_port_id(stream_cfg, isys_stream_descr);
+	rc &= sh_css_translate_stream_cfg_to_input_system_input_port_type(stream_cfg, isys_stream_descr);
+	rc &= sh_css_translate_stream_cfg_to_input_system_input_port_attr(stream_cfg, isys_stream_descr);
+	rc &= sh_css_translate_stream_cfg_to_input_system_input_port_resolution(stream_cfg, isys_stream_descr);
+
+	return rc;
+}
+
+static bool sh_css_translate_binary_info_to_input_system_output_port_attr(
+		struct ia_css_binary *binary,
+                ia_css_isys_descr_t     *isys_stream_descr)
+{
+	if (!binary)
+		return false;
+
+	isys_stream_descr->output_port_attr.left_padding = binary->left_padding;
+	isys_stream_descr->output_port_attr.max_isp_input_width = binary->info->sp.max_input_width;
+
+	return true;
+}
+
+static enum ia_css_err
+sh_css_config_input_network(struct ia_css_pipe *pipe,
+		struct ia_css_binary *binary)
+{
+	bool					rc;
+	ia_css_isys_descr_t			isys_stream_descr;
+	unsigned int				sp_thread_id;
+	struct sh_css_sp_pipeline_terminal	*sp_pipeline_input_terminal;
+
+	if (pipe->pipeline.stages)
+		binary = pipe->pipeline.stages->binary;
+
+	/* initialization */
+	memset((void*)(&isys_stream_descr), 0, sizeof(ia_css_isys_descr_t));
+
+	/* translate the stream configuration to the Input System (2401) configuration */
+	rc = sh_css_translate_stream_cfg_to_isys_stream_descr(
+			&(pipe->stream->config),
+			&(isys_stream_descr));
+
+	if (pipe->stream->config.online) {
+		rc &= sh_css_translate_binary_info_to_input_system_output_port_attr(
+				binary,
+				&(isys_stream_descr));
+	}
+
+	if (rc != true)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	/* get the SP thread id */
+	rc = ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &sp_thread_id);
+	if (rc != true)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	/* get the target input terminal */
+	sp_pipeline_input_terminal = &(sh_css_sp_group.pipe_io[sp_thread_id].input);
+
+	/* create the virtual Input System (2401) */
+	rc =  ia_css_isys_stream_create(
+			&(isys_stream_descr),
+			&(sp_pipeline_input_terminal->context.virtual_input_system));
+	if (rc != true)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	/* calculate the configuration of the virtual Input System (2401) */
+	rc = ia_css_isys_stream_calculate_cfg(
+			&(sp_pipeline_input_terminal->context.virtual_input_system),
+			&(isys_stream_descr),
+			&(sp_pipeline_input_terminal->ctrl.virtual_input_system_cfg));
+	if (rc != true) {
+		ia_css_isys_stream_destroy(&(sp_pipeline_input_terminal->context.virtual_input_system));
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+
+	return IA_CSS_SUCCESS;
+}
+
+static struct ia_css_pipe* stream_get_last_pipe(
+		struct ia_css_stream *stream)
+{
+	struct ia_css_pipe *last_pipe = NULL;
+	if (stream != NULL)
+		last_pipe = stream->last_pipe;
+
+	return last_pipe;
+}
+
+static struct ia_css_pipe* stream_get_copy_pipe(
+		struct ia_css_stream *stream)
+{
+	struct ia_css_pipe *copy_pipe = NULL;
+	struct ia_css_pipe *last_pipe = NULL;
+	enum ia_css_pipe_id pipe_id;
+
+	last_pipe = stream_get_last_pipe(stream);
+
+	if ((stream != NULL) &&
+	    (last_pipe != NULL) &&
+	    (stream->config.continuous)) {
+
+		pipe_id = last_pipe->mode;
+		switch (pipe_id) {
+			case IA_CSS_PIPE_ID_PREVIEW:
+				copy_pipe = last_pipe->pipe_settings.preview.copy_pipe;
+				break;
+			case IA_CSS_PIPE_ID_VIDEO:
+				copy_pipe = last_pipe->pipe_settings.video.copy_pipe;
+				break;
+			default:
+				copy_pipe = NULL;
+				break;
+		}
+	}
+
+	return copy_pipe;
+}
+
+
+static enum ia_css_err stream_register_with_csi_rx(
+	struct ia_css_stream *stream)
+{
+	enum ia_css_err retval = IA_CSS_ERR_INTERNAL_ERROR;
+	unsigned int	sp_thread_id;
+
+	struct ia_css_pipe *target_pipe = NULL;
+
+	if ((stream != NULL) && (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR)) {
+		/* get the pipe that consumes the stream */
+		if (stream->config.continuous) {
+			target_pipe = stream_get_copy_pipe(stream);
+		} else {
+			target_pipe = stream_get_last_pipe(stream);
+		}
+
+		if (target_pipe != NULL) {
+			bool rc;
+			rc = ia_css_pipeline_get_sp_thread_id(
+				ia_css_pipe_get_pipe_num(target_pipe),
+				&sp_thread_id);
+			if (rc) {
+				retval = ia_css_isys_csi_rx_register_stream(
+						stream->config.source.port.port,
+						sp_thread_id);
+			}
+		}
+	}
+
+	return retval;
+}
+
+static enum ia_css_err stream_unregister_with_csi_rx(
+	struct ia_css_stream *stream)
+{
+	enum ia_css_err retval = IA_CSS_ERR_INTERNAL_ERROR;
+	unsigned int	sp_thread_id;
+	struct ia_css_pipe *target_pipe = NULL;
+
+	if ((stream != NULL) && (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR)) {
+
+		if (stream->config.continuous) {
+			target_pipe = stream_get_copy_pipe(stream);
+		} else {
+			target_pipe = stream_get_last_pipe(stream);
+		}
+
+		if (target_pipe != NULL) {
+			bool rc;
+			rc = ia_css_pipeline_get_sp_thread_id(
+				ia_css_pipe_get_pipe_num(target_pipe),
+				&sp_thread_id);
+			if (rc) {
+				retval = ia_css_isys_csi_rx_unregister_stream(
+						stream->config.source.port.port,
+						sp_thread_id);
+			}
+		}
+	}
+
+	return retval;
+}
+#endif
+
+#if WITH_PC_MONITORING
+static struct task_struct *my_kthread;    /* Handle for the monitoring thread */
+static int sh_binary_running;         /* Enable sampling in the thread */
+
+static void print_pc_histo(char *core_name, struct sh_css_pc_histogram *hist)
+{
+	unsigned i;
+	unsigned cnt_run = 0;
+	unsigned cnt_stall = 0;
+
+	assert(hist != NULL);
+
+	sh_css_print("%s histogram length = %d\n", core_name, hist->length);
+	sh_css_print("%s PC\trun\tstall\n", core_name);
+
+	for (i = 0; i < hist->length; i++) {
+		if ((hist->run[i] == 0) && (hist->run[i] == hist->stall[i]))
+			continue;
+		sh_css_print("%s %d\t%d\t%d\n",
+				core_name, i, hist->run[i], hist->stall[i]);
+		cnt_run += hist->run[i];
+		cnt_stall += hist->stall[i];
+	}
+
+	sh_css_print(" Statistics for %s, cnt_run = %d, cnt_stall = %d, "
+	       "hist->length = %d\n",
+			core_name, cnt_run, cnt_stall, hist->length);
+}
+
+static void print_pc_histogram(void)
+{
+	struct ia_css_binary_metrics *metrics;
+
+	for (metrics = sh_css_metrics.binary_metrics;
+	     metrics;
+	     metrics = metrics->next) {
+		if (metrics->mode == IA_CSS_BINARY_MODE_PREVIEW ||
+		    metrics->mode == IA_CSS_BINARY_MODE_VF_PP) {
+			sh_css_print("pc_histogram for binary %d is SKIPPED\n",
+				metrics->id);
+			continue;
+		}
+
+		sh_css_print(" pc_histogram for binary %d\n", metrics->id);
+		print_pc_histo("  ISP", &metrics->isp_histogram);
+		print_pc_histo("  SP",   &metrics->sp_histogram);
+		sh_css_print("print_pc_histogram() done for binay->id = %d, "
+			     "done.\n", metrics->id);
+	}
+
+	sh_css_print("PC_MONITORING:print_pc_histogram() -- DONE\n");
+}
+
+static int pc_monitoring(void *data)
+{
+	int i = 0;
+
+	(void)data;
+	while (true) {
+		if (sh_binary_running) {
+			sh_css_metrics_sample_pcs();
+#if MULTIPLE_SAMPLES
+			for (i = 0; i < NOF_SAMPLES; i++)
+				sh_css_metrics_sample_pcs();
+#endif
+		}
+		usleep_range(10, 50);
+	}
+	return 0;
+}
+
+static void spying_thread_create(void)
+{
+	my_kthread = kthread_run(pc_monitoring, NULL, "sh_pc_monitor");
+	sh_css_metrics_enable_pc_histogram(1);
+}
+
+static void input_frame_info(struct ia_css_frame_info frame_info)
+{
+	sh_css_print("SH_CSS:input_frame_info() -- frame->info.res.width = %d, "
+	       "frame->info.res.height = %d, format = %d\n",
+			frame_info.res.width, frame_info.res.height, frame_info.format);
+}
+#endif /* WITH_PC_MONITORING */
+
+static void
+start_binary(struct ia_css_pipe *pipe,
+	     struct ia_css_binary *binary)
+{
+	struct ia_css_stream *stream;
+
+	assert(pipe != NULL);
+	/* Acceleration uses firmware, the binary thus can be NULL */
+	/* assert(binary != NULL); */
+
+	(void)binary;
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+	stream = pipe->stream;
+#else
+	(void)pipe;
+	(void)stream;
+#endif
+
+#ifdef THIS_CODE_IS_NO_LONGER_NEEDED_FOR_DUAL_STREAM
+#if !defined(HAS_NO_INPUT_SYSTEM)
+	if (stream && stream->reconfigure_css_rx)
+		ia_css_isys_rx_disable();
+#endif
+#endif
+
+	if (binary)
+		sh_css_metrics_start_binary(&binary->metrics);
+
+#if WITH_PC_MONITORING
+	sh_css_print("PC_MONITORING: %s() -- binary id = %d , "
+		     "enable_dvs_envelope = %d\n",
+		     __func__, binary->info->sp.id,
+		     binary->info->sp.enable.dvs_envelope);
+	input_frame_info(binary->in_frame_info);
+
+	if (binary && binary->info->sp.mode == IA_CSS_BINARY_MODE_VIDEO)
+		sh_binary_running = true;
+#endif
+
+	/* sh_css_sp_start_isp(); */
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && !defined(USE_INPUT_SYSTEM_VERSION_2401)
+	if (stream->reconfigure_css_rx) {
+		ia_css_isys_rx_configure(&pipe->stream->csi_rx_config,
+					 pipe->stream->config.mode);
+		stream->reconfigure_css_rx = false;
+	}
+#endif
+}
+
+/* start the copy function on the SP */
+static enum ia_css_err
+start_copy_on_sp(struct ia_css_pipe *pipe,
+		 struct ia_css_frame *out_frame)
+{
+
+	(void)out_frame;
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	if ((pipe == NULL) || (pipe->stream == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && !defined(USE_INPUT_SYSTEM_VERSION_2401)
+	if (pipe->stream->reconfigure_css_rx)
+		ia_css_isys_rx_disable();
+#endif
+
+	if (pipe->stream->config.format != IA_CSS_STREAM_FORMAT_BINARY_8)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	sh_css_sp_start_binary_copy(ia_css_pipe_get_pipe_num(pipe), out_frame, pipe->stream->config.pixels_per_clock == 2);
+
+	//sh_css_sp_start_isp();
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && !defined(USE_INPUT_SYSTEM_VERSION_2401)
+	if (pipe->stream->reconfigure_css_rx) {
+		ia_css_isys_rx_configure(&pipe->stream->csi_rx_config, pipe->stream->config.mode);
+		pipe->stream->reconfigure_css_rx = false;
+	}
+#endif
+
+	return IA_CSS_SUCCESS;
+}
+
+void sh_css_binary_args_reset(struct sh_css_binary_args *args)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++)
+		args->tnr_frames[i] = NULL;
+	for (i = 0; i < NUM_VIDEO_DELAY_FRAMES; i++)
+		args->delay_frames[i] = NULL;
+	args->in_frame      = NULL;
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
+		args->out_frame[i] = NULL;
+	args->out_vf_frame  = NULL;
+	args->copy_vf       = false;
+	args->copy_output   = true;
+	args->vf_downscale_log2 = 0;
+}
+
+
+static void
+pipe_start(struct ia_css_pipe *pipe)
+{
+	struct ia_css_pipeline_stage *stage;
+	assert(pipe != NULL);
+	stage = pipe->pipeline.stages;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"pipe_start() enter:\n");
+	if (!stage)
+		return;
+	pipe->pipeline.current_stage = stage;
+
+	start_binary(pipe, stage->binary);
+}
+
+static enum ia_css_err start_pipe(
+	struct ia_css_pipe *me,
+	enum sh_css_pipe_config_override copy_ovrd,
+	enum ia_css_input_mode input_mode)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	assert(me != NULL);
+
+#if defined(HAS_NO_INPUT_SYSTEM)
+	(void)input_mode;
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"start_pipe() enter:\n");
+
+	configure_pipe_inout_port(&me->pipeline, me->stream->config.continuous);
+
+	sh_css_sp_init_pipeline(&me->pipeline,
+				me->mode,
+				(uint8_t)ia_css_pipe_get_pipe_num(me),
+				me->config.default_capture_config.enable_xnr,
+				me->stream->config.pixels_per_clock == 2,
+				me->stream->config.continuous,
+				false,
+				me->required_bds_factor,
+				copy_ovrd,
+				input_mode,
+				&me->stream->config.metadata_config,
+				&me->stream->info.metadata_info
+#if !defined(HAS_NO_INPUT_SYSTEM)
+				, (input_mode==IA_CSS_INPUT_MODE_MEMORY)?
+					(mipi_port_ID_t)0:
+				me->stream->config.source.port.port
+#endif
+				);
+
+	if (me->config.mode != IA_CSS_PIPE_MODE_COPY){
+		/* prepare update of params to ddr */
+		err = sh_css_commit_isp_config(me->stream, &me->pipeline);
+		if (err == IA_CSS_SUCCESS)
+			pipe_start(me);
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"start_pipe() leave: return (%d)\n", err);
+	return err;
+}
+
+void
+sh_css_invalidate_shading_tables(struct ia_css_stream *stream)
+{
+	int i;
+	assert(stream != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_invalidate_shading_tables() enter:\n");
+
+	for (i=0; i<stream->num_pipes; i++) {
+		assert(stream->pipes[i] != NULL);
+		sh_css_pipe_free_shading_table(stream->pipes[i]);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_invalidate_shading_tables() leave: return_void\n");
+}
+
+static void
+enable_interrupts(enum ia_css_irq_type irq_type)
+{
+	bool enable_pulse = irq_type != IA_CSS_IRQ_TYPE_EDGE;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "enable_interrupts() enter:\n");
+/* Enable IRQ on the SP which signals that SP goes to idle (aka ready state) */
+	cnd_sp_irq_enable(SP0_ID, true);
+/* Set the IRQ device 0 to either level or pulse */
+	irq_enable_pulse(IRQ0_ID, enable_pulse);
+
+#if defined(IS_ISP_2500_SYSTEM)
+	cnd_virq_enable_channel(virq_sp0, true);
+	cnd_virq_enable_channel(virq_sp1, true);
+#else
+	cnd_virq_enable_channel(virq_sp, true);
+#endif
+
+	/* Triggered by SP to signal Host that there are new statistics */
+	cnd_virq_enable_channel((virq_id_t)(IRQ_SW_CHANNEL1_ID + IRQ_SW_CHANNEL_OFFSET), true);
+	/* Triggered by SP to signal Host that there is data in one of the
+	 * SP->Host queues.*/
+#if !defined(HAS_IRQ_MAP_VERSION_2)
+/* IRQ_SW_CHANNEL2_ID does not exist on 240x systems */
+	cnd_virq_enable_channel((virq_id_t)(IRQ_SW_CHANNEL2_ID + IRQ_SW_CHANNEL_OFFSET), true);
+	virq_clear_all();
+#endif
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && !defined(USE_INPUT_SYSTEM_VERSION_2401)
+	ia_css_isys_rx_enable_all_interrupts();
+#endif
+
+#if defined(HRT_CSIM)
+/*
+ * Enable IRQ on the SP which signals that SP goes to idle
+ * to get statistics for each binary
+ */
+	cnd_isp_irq_enable(ISP0_ID, true);
+	cnd_virq_enable_channel(virq_isp, true);
+#endif
+}
+
+static bool sh_css_setup_spctrl_config(const struct ia_css_fw_info *fw,
+							const char * program,
+							ia_css_spctrl_cfg  *spctrl_cfg)
+{
+	if((fw == NULL)||(spctrl_cfg == NULL))
+		return false;
+	spctrl_cfg->sp_entry = 0;
+	spctrl_cfg->program_name = (char *)(program);
+
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+	spctrl_cfg->ddr_data_offset =  fw->blob.data_source;
+	spctrl_cfg->dmem_data_addr = fw->blob.data_target;
+	spctrl_cfg->dmem_bss_addr = fw->blob.bss_target;
+	spctrl_cfg->data_size = fw->blob.data_size ;
+	spctrl_cfg->bss_size = fw->blob.bss_size;
+
+	spctrl_cfg->spctrl_config_dmem_addr = fw->info.sp.init_dmem_data;
+	spctrl_cfg->spctrl_state_dmem_addr = fw->info.sp.sw_state;
+
+	spctrl_cfg->code_size = fw->blob.size;
+	spctrl_cfg->code      = fw->blob.code;
+	spctrl_cfg->sp_entry  = fw->info.sp.sp_entry; /* entry function ptr on SP */
+#endif
+	return true;
+}
+void
+ia_css_unload_firmware(bool forced)
+{
+	int i = 0;
+	ia_css_binary_uninit(forced);	//ia_css_binary_uninit has protection within it for multiple acccesses
+	if (sh_css_num_binaries)
+	{
+		/* we have already loaded before so get rid of the old stuff */
+		sh_css_unload_firmware();
+	}
+	fw_explicitly_loaded = false;
+
+	/*When the forced flag is true, free the mipi_frames that were being reused till now*/
+	if (forced){
+		for (i = 0; i < my_css.num_mipi_frames; i++) {
+	    	if (my_css.mipi_frames[i] != NULL) {
+	        	ia_css_frame_free(my_css.mipi_frames[i]);
+	            my_css.mipi_frames[i] = NULL;
+	        }
+	    }
+	    ref_count_mipi_allocation = 0;
+	}
+}
+
+static void
+ia_css_reset_defaults(struct sh_css* css)
+{
+	struct sh_css default_css;
+
+	/* Reset everything to zero */
+	memset(&default_css, 0, sizeof(default_css));
+
+	/* Initialize the non zero values*/
+	default_css.check_system_idle = true;
+	default_css.num_cont_raw_frames = NUM_CONTINUOUS_FRAMES;
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	default_css.num_mipi_frames = NUM_MIPI_FRAMES;
+#endif
+	default_css.contiguous = true;
+	default_css.irq_type = IA_CSS_IRQ_TYPE_EDGE;
+
+	/*Set the defaults to the output */
+	*css = default_css;
+}
+
+enum ia_css_err
+ia_css_load_firmware(const struct ia_css_env *env,
+	    const struct ia_css_fw  *fw)
+{
+	enum ia_css_err err;
+
+	if (env == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (fw == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_load_firmware() enter\n");
+
+	ia_css_memory_access_init(&env->css_mem_env);
+
+	/* make sure we initialize my_css */
+	if ((my_css.malloc != env->cpu_mem_env.alloc) ||
+	    (my_css.free != env->cpu_mem_env.free) ||
+	    (my_css.flush != env->cpu_mem_env.flush)
+	    )
+	{
+		ia_css_reset_defaults(&my_css);
+
+		my_css.malloc = env->cpu_mem_env.alloc;
+		my_css.free = env->cpu_mem_env.free;
+		my_css.flush = env->cpu_mem_env.flush;
+	}
+
+	ia_css_unload_firmware(false); /* in case we are called twice */
+	err = sh_css_load_firmware(fw->data, fw->bytes);
+	if (err == IA_CSS_SUCCESS) {
+		err = ia_css_binary_init_infos();
+		if (err == IA_CSS_SUCCESS)
+			fw_explicitly_loaded = true;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_load_firmware() leave \n");
+	return err;
+
+}
+
+enum ia_css_err
+ia_css_init(const struct ia_css_env *env,
+	    const struct ia_css_fw  *fw,
+	    uint32_t                 mmu_l1_base,
+	    enum ia_css_irq_type     irq_type)
+{
+	enum ia_css_err err;
+	ia_css_spctrl_cfg spctrl_cfg;
+#if defined(IS_ISP_2500_SYSTEM)
+	ia_css_spctrl_cfg sp1ctrl_cfg;
+#endif
+	//uint32_t i = 0;
+	int i = 0;
+	struct ia_css_frame *backup_mipi_frames[NUM_MIPI_FRAMES] = {NULL, NULL, NULL, NULL};
+
+	void *(*malloc_func) (size_t size, bool zero_mem);
+	void (*free_func) (void *ptr);
+	void (*flush_func) (struct ia_css_acc_fw *fw);
+#if !defined(HAS_NO_GPIO)
+	hrt_data select, enable;
+#endif
+
+	/**
+	 * The C99 standard does not specify the exact object representation of structs;
+	 * the representation is compiler dependent.
+	 *
+	 * The structs that are communicated between host and SP/ISP should have the
+	 * exact same object representation. The compiler that is used to compile the
+	 * firmware is hivecc.
+	 *
+	 * To check if a different compiler, used to compile a host application, uses
+	 * another object representation, macros are defined specifying the size of
+	 * the structs as expected by the firmware.
+	 *
+	 * A host application shall verify that a sizeof( ) of the struct is equal to
+	 * the SIZE_OF_XXX macro of the corresponding struct. If they are not
+	 * equal, functionality will break.
+	 */
+#if !defined(IS_ISP_2500_SYSTEM)
+	/* Check struct sh_css_ddr_address_map */
+	COMPILATION_ERROR_IF( sizeof(struct sh_css_ddr_address_map)		!= SIZE_OF_SH_CSS_DDR_ADDRESS_MAP_STRUCT	);
+#endif
+	/* Check struct host_sp_queues */
+	COMPILATION_ERROR_IF( sizeof(struct host_sp_queues)			!= SIZE_OF_HOST_SP_QUEUES_STRUCT		);
+	COMPILATION_ERROR_IF( sizeof(struct ia_css_circbuf_desc_s)		!= SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT		);
+	COMPILATION_ERROR_IF( sizeof(struct ia_css_circbuf_elem_s)		!= SIZE_OF_IA_CSS_CIRCBUF_ELEM_S_STRUCT		);
+
+	/* Check struct host_sp_communication */
+	COMPILATION_ERROR_IF( sizeof(struct host_sp_communication)		!= SIZE_OF_HOST_SP_COMMUNICATION_STRUCT		);
+	COMPILATION_ERROR_IF( sizeof(struct sh_css_event_irq_mask)		!= SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT		);
+
+	/* Check struct sh_css_hmm_buffer */
+	COMPILATION_ERROR_IF( sizeof(struct sh_css_hmm_buffer)			!= SIZE_OF_SH_CSS_HMM_BUFFER_STRUCT		);
+	COMPILATION_ERROR_IF( sizeof(struct ia_css_isp_3a_statistics)		!= SIZE_OF_IA_CSS_ISP_3A_STATISTICS_STRUCT	);
+	COMPILATION_ERROR_IF( sizeof(struct ia_css_isp_dvs_statistics)		!= SIZE_OF_IA_CSS_ISP_DVS_STATISTICS_STRUCT	);
+	COMPILATION_ERROR_IF( sizeof(struct ia_css_metadata)			!= SIZE_OF_IA_CSS_METADATA_STRUCT		);
+
+	/* Check struct ia_css_init_dmem_cfg */
+	COMPILATION_ERROR_IF( sizeof(struct ia_css_sp_init_dmem_cfg)		!= SIZE_OF_IA_CSS_SP_INIT_DMEM_CFG_STRUCT	);
+
+	if (fw == NULL && !fw_explicitly_loaded)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (env == NULL)
+	    return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	malloc_func = env->cpu_mem_env.alloc;
+	free_func   = env->cpu_mem_env.free;
+	flush_func  = env->cpu_mem_env.flush;
+
+	pipe_global_init();
+	ia_css_pipeline_init();
+	ia_css_queue_map_init();
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_init() enter: void\n");
+
+	ia_css_device_access_init(&env->hw_access_env);
+	ia_css_memory_access_init(&env->css_mem_env);
+
+#if !defined(HAS_NO_GPIO)
+	select = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_select)
+						& (~GPIO_FLASH_PIN_MASK);
+	enable = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_e)
+							| GPIO_FLASH_PIN_MASK;
+#endif
+	sh_css_mmu_set_page_table_base_index(mmu_l1_base);
+	my_css_save.mmu_base = mmu_l1_base;
+
+	if (malloc_func == NULL || free_func == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+       /*Temporarily backup the mipi_frames pointers, so that they can be reused*/
+       if (backup_mipi_frames[0] == NULL) {
+               for (i=0;i<NUM_MIPI_FRAMES;i++) {
+                       backup_mipi_frames[i] = my_css.mipi_frames[i];
+           }
+       }
+
+        ia_css_reset_defaults(&my_css);
+
+       /*restore mipi frames' ponters*/
+       for (i=0;i<NUM_MIPI_FRAMES;i++) {
+               if (backup_mipi_frames[i] != NULL) my_css.mipi_frames[i] = backup_mipi_frames[i];
+               else backup_mipi_frames == NULL;
+       }
+
+	my_css.malloc = malloc_func;
+	my_css.free = free_func;
+	my_css.flush = flush_func;
+	sh_css_printf = env->print_env.debug_print;
+	my_css_save.driver_env = (struct ia_css_env *)env;
+
+	err = ia_css_rmgr_init();
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	ia_css_debug_set_dtrace_level(IA_CSS_DEBUG_WARNING);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_init()\n");
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_init() init: %d\n",my_css_save_initialized);
+
+	if (!my_css_save_initialized)
+	{
+		my_css_save_initialized = true;
+		my_css_save.mode = sh_css_mode_working;
+		memset(my_css_save.stream_seeds, 0, sizeof(struct sh_css_stream_seed) * MAX_ACTIVE_STREAMS);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_init() init: %d mode=%d\n",my_css_save_initialized, my_css_save.mode);
+	}
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	ref_count_mipi_allocation = 0;
+#endif
+	/* In case this has been programmed already, update internal
+	   data structure ... DEPRECATED */
+	my_css.page_table_base_index = mmu_get_page_table_base_index(MMU0_ID);
+
+	my_css.irq_type = irq_type;
+	my_css_save.irq_type = irq_type;
+	enable_interrupts(my_css.irq_type);
+
+#if !defined(HAS_NO_GPIO)
+	/* configure GPIO to output mode */
+	gpio_reg_store(GPIO0_ID, _gpio_block_reg_do_select, select);
+	gpio_reg_store(GPIO0_ID, _gpio_block_reg_do_e, enable);
+	gpio_reg_store(GPIO0_ID, _gpio_block_reg_do_0, 0);
+#endif
+
+	err = ia_css_refcount_init(REFCOUNT_SIZE);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = sh_css_params_init();
+	if (err != IA_CSS_SUCCESS)
+		goto refcnt_uninit;
+	if (fw)
+	{
+		ia_css_unload_firmware(false); /* in case we already had firmware loaded */
+		err = sh_css_load_firmware(fw->data, fw->bytes);
+		if (err != IA_CSS_SUCCESS)
+			goto params_uninit;
+		err = ia_css_binary_init_infos();
+		if (err != IA_CSS_SUCCESS)
+			goto params_uninit;
+		fw_explicitly_loaded = false;
+		my_css_save.loaded_fw = (struct ia_css_fw *)fw;
+	}
+	if(!sh_css_setup_spctrl_config(&sh_css_sp_fw,SP_PROG_NAME,&spctrl_cfg))
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	err = ia_css_spctrl_load_fw(SP0_ID, &spctrl_cfg);
+	if (err != IA_CSS_SUCCESS) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_init() leave: return_err=%d\n",err);
+		goto unload_fw;
+	}
+#if defined(IS_ISP_2500_SYSTEM)
+	if(!sh_css_setup_spctrl_config(&sh_css_sp1_fw,SP1_PROG_NAME,&sp1ctrl_cfg))
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	err = ia_css_sp1ctrl_load_fw(SP1_ID, &sp1ctrl_cfg);
+	if (err != IA_CSS_SUCCESS) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_init() leave: return_err=%d\n",err);
+		goto unload_fw;
+	}
+#endif
+
+#if defined(HRT_CSIM)
+	/**
+	 * In compiled simulator context include debug support by default.
+	 * In all other cases (e.g. Android phone), the user (e.g. driver)
+	 * must explicitly enable debug support by calling this function.
+	 */
+	if (!ia_css_debug_mode_init()) {
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_init() leave: return_err=%d\n",IA_CSS_ERR_INTERNAL_ERROR);
+			err = IA_CSS_ERR_INTERNAL_ERROR;
+	        goto free_sp_bin_addr;
+	}
+#endif
+
+#if WITH_PC_MONITORING
+	if (!thread_alive) {
+		thread_alive++;
+		sh_css_print("PC_MONITORING: %s() -- create thread DISABLED\n",
+			     __func__);
+		spying_thread_create();
+	}
+	sh_css_printf = printk;
+#endif
+	if (!sh_css_hrt_system_is_idle()) {
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_init() leave: return_err=%d\n",IA_CSS_ERR_SYSTEM_NOT_IDLE);
+		err = IA_CSS_ERR_SYSTEM_NOT_IDLE;
+        goto free_sp_bin_addr;
+	}
+	/* can be called here, queuing works, but:
+	   - when sp is started later, it will wipe queued items
+	   so for now we leave it for later and make sure
+	   updates are not called to frequently.
+	sh_css_init_buffer_queues();
+	*/
+
+#if defined(HAS_INPUT_SYSTEM_VERSION_2) && defined(HAS_INPUT_SYSTEM_VERSION_2401)
+#if	defined(USE_INPUT_SYSTEM_VERSION_2)
+	gp_device_reg_store(GP_DEVICE0_ID, _REG_GP_SWITCH_ISYS2401_ADDR, 0);
+#elif defined (USE_INPUT_SYSTEM_VERSION_2401)
+	gp_device_reg_store(GP_DEVICE0_ID, _REG_GP_SWITCH_ISYS2401_ADDR, 1);
+#endif
+#endif
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+	if(ia_css_isys_init() != INPUT_SYSTEM_ERR_NO_ERROR)
+		err = IA_CSS_ERR_INVALID_ARGUMENTS;
+#endif
+
+    if(err== IA_CSS_SUCCESS)
+       goto init_done;
+
+free_sp_bin_addr:
+         mmgr_free(my_css.sp_bin_addr);
+         my_css.sp_bin_addr = mmgr_NULL;
+unload_fw:
+         if(fw)
+           ia_css_unload_firmware(true);
+params_uninit:
+         sh_css_params_uninit();
+refcnt_uninit:
+         ia_css_refcount_uninit();
+init_done:
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_init() leave: return_err=%d\n",err);
+	return err;
+}
+
+enum ia_css_err
+ia_css_suspend(void)
+{
+	int i;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_suspend() enter\n");
+	my_css_save.mode = sh_css_mode_suspend;
+	for(i=0;i<MAX_ACTIVE_STREAMS;i++)
+		if (my_css_save.stream_seeds[i].stream != NULL)
+		{
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "==*> unloading seed %d (%p)\n", i, my_css_save.stream_seeds[i].stream);
+			ia_css_stream_unload(my_css_save.stream_seeds[i].stream);
+		}
+	my_css_save.mode = sh_css_mode_working;
+	ia_css_stop_sp();
+	ia_css_uninit();
+	for(i=0;i<MAX_ACTIVE_STREAMS;i++)
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "==*> after 1: seed %d (%p)\n", i, my_css_save.stream_seeds[i].stream);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_suspend() leave\n");
+	return(IA_CSS_SUCCESS);
+}
+
+enum ia_css_err
+ia_css_resume(void)
+{
+	int i;
+	enum ia_css_err err;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_resume() enter: void\n");
+
+	err = ia_css_init(my_css_save.driver_env, my_css_save.loaded_fw, my_css_save.mmu_base, my_css_save.irq_type);
+	if (err != IA_CSS_SUCCESS)
+		return(err);
+	err = ia_css_start_sp();
+	if (err != IA_CSS_SUCCESS)
+		return(err);
+	my_css_save.mode = sh_css_mode_resume;
+	for(i=0;i<MAX_ACTIVE_STREAMS;i++)
+	{
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "==*> seed stream %p\n", my_css_save.stream_seeds[i].stream);
+		if (my_css_save.stream_seeds[i].stream != NULL)
+		{
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "==*> loading seed %d\n", i);
+			err = ia_css_stream_load(my_css_save.stream_seeds[i].stream);
+			if (err != IA_CSS_SUCCESS)
+			{
+				int j;
+				if (i)
+					for(j=0;j<i;j++)
+						ia_css_stream_unload(my_css_save.stream_seeds[j].stream);
+				return(err);
+			}
+			*my_css_save.stream_seeds[i].orig_stream = my_css_save.stream_seeds[i].stream;
+		}
+	}
+	my_css_save.mode = sh_css_mode_working;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_resume() leave: return_void\n");
+	return(IA_CSS_SUCCESS);
+}
+
+void *
+sh_css_malloc(size_t size)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_malloc() enter: size=%d\n",size);
+	if (size > 0 && my_css.malloc)
+		return my_css.malloc(size, false);
+	return NULL;
+}
+
+void *
+sh_css_calloc(size_t N, size_t size)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_calloc() enter: N=%d, size=%d\n",N,size);
+	if (size > 0 && my_css.malloc) {
+		return my_css.malloc(N*size, true);
+	}
+	return NULL;
+}
+
+void
+sh_css_free(void *ptr)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_free() enter:\n");
+	if (ptr && my_css.free)
+		my_css.free(ptr);
+}
+
+/* For Acceleration API: Flush FW (shared buffer pointer) arguments */
+void
+sh_css_flush(struct ia_css_acc_fw *fw)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_flush() enter:\n");
+	if ((fw != NULL) && (my_css.flush != NULL))
+		my_css.flush(fw);
+}
+
+/* Mapping sp threads. Currently, this is done when a stream is created and
+ * pipelines are ready to be converted to sp pipelines. Be careful if you are
+ * doing it from stream_create since we could run out of sp threads due to
+ * allocation on inactive pipelines. */
+static enum ia_css_err
+map_sp_threads(struct ia_css_stream *stream, bool map)
+{
+	struct ia_css_pipe *main_pipe = NULL;
+	struct ia_css_pipe *copy_pipe = NULL, *capture_pipe = NULL;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	enum ia_css_pipe_id pipe_id;
+
+	assert(stream != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"map_sp_threads() enter: map = %d\n", map);
+
+	main_pipe 	= stream->last_pipe;
+	pipe_id 	= main_pipe->mode;
+
+	ia_css_pipeline_map(main_pipe->pipe_num, map);
+
+	switch (pipe_id) {
+	case IA_CSS_PIPE_ID_PREVIEW:
+		copy_pipe    = main_pipe->pipe_settings.preview.copy_pipe;
+		capture_pipe = main_pipe->pipe_settings.preview.capture_pipe;
+		break;
+
+	case IA_CSS_PIPE_ID_VIDEO:
+		copy_pipe    = main_pipe->pipe_settings.video.copy_pipe;
+		capture_pipe = main_pipe->pipe_settings.video.capture_pipe;
+		break;
+
+	case IA_CSS_PIPE_ID_CAPTURE:
+	case IA_CSS_PIPE_ID_ACC:
+	default:
+		break;
+	}
+
+	if(capture_pipe) {
+		ia_css_pipeline_map(capture_pipe->pipe_num, map);
+	}
+
+	/* Firmware expects copy pipe to be the last pipe mapped. (if needed) */
+	if(copy_pipe) {
+		ia_css_pipeline_map(copy_pipe->pipe_num, map);
+	}
+
+	return err;
+}
+
+/* creates a host pipeline skeleton for all pipes in a stream. Called during
+ * stream_create. */
+static enum ia_css_err
+create_host_pipeline_structure(struct ia_css_stream *stream)
+{
+	struct ia_css_pipe *copy_pipe = NULL, *capture_pipe = NULL;
+	enum ia_css_pipe_id pipe_id;
+	struct ia_css_pipe *main_pipe = NULL;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(stream != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_pipeline_structure() enter:\n");
+
+	main_pipe 	= stream->last_pipe;
+	assert(main_pipe != NULL);
+
+	pipe_id 	= main_pipe->mode;
+
+#if !defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* Standalone Capture pipe cannot work with continuous capture. */
+	if((pipe_id == IA_CSS_PIPE_ID_CAPTURE) && (stream->num_pipes == 1)) {
+		if(!stream->config.online &&
+			!main_pipe->pipe_settings.capture.copy_binary.info) {
+			goto ERR;
+		}
+	}
+#endif
+
+	switch (pipe_id) {
+	case IA_CSS_PIPE_ID_PREVIEW:
+		copy_pipe    = main_pipe->pipe_settings.preview.copy_pipe;
+		capture_pipe = main_pipe->pipe_settings.preview.capture_pipe;
+		err = ia_css_pipeline_create(&main_pipe->pipeline, main_pipe->mode, main_pipe->pipe_num);
+		break;
+
+	case IA_CSS_PIPE_ID_VIDEO:
+		copy_pipe    = main_pipe->pipe_settings.video.copy_pipe;
+		capture_pipe = main_pipe->pipe_settings.video.capture_pipe;
+		err = ia_css_pipeline_create(&main_pipe->pipeline, main_pipe->mode, main_pipe->pipe_num);
+		break;
+
+	case IA_CSS_PIPE_ID_CAPTURE:
+		capture_pipe = main_pipe;
+		break;
+
+	case IA_CSS_PIPE_ID_YUVPP:
+		err = ia_css_pipeline_create(&main_pipe->pipeline, main_pipe->mode,
+						main_pipe->pipe_num);
+		break;
+
+	case IA_CSS_PIPE_ID_ACC:
+		err = ia_css_pipeline_create(&main_pipe->pipeline, main_pipe->mode, main_pipe->pipe_num);
+		break;
+
+	default:
+		err = IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	if ((IA_CSS_SUCCESS == err) && copy_pipe) {
+		err = ia_css_pipeline_create(&copy_pipe->pipeline, copy_pipe->mode, copy_pipe->pipe_num);
+	}
+
+	if ((IA_CSS_SUCCESS == err) && capture_pipe) {
+		err = ia_css_pipeline_create(&capture_pipe->pipeline, capture_pipe->mode, capture_pipe->pipe_num);
+	}
+
+#if !defined(USE_INPUT_SYSTEM_VERSION_2401)
+ERR:
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_pipeline_structure() leave: return (%d)\n", err);
+	return err;
+}
+
+/* creates a host pipeline for all pipes in a stream. Called during
+ * stream_start. */
+static enum ia_css_err
+create_host_pipeline(struct ia_css_stream *stream)
+{
+	struct ia_css_pipe *copy_pipe = NULL, *capture_pipe = NULL;
+	enum ia_css_pipe_id pipe_id;
+	struct ia_css_pipe *main_pipe = NULL;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+    unsigned max_input_width = 0;
+
+	assert(stream != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_pipeline() enter:\n");
+
+	main_pipe 	= stream->last_pipe;
+	pipe_id 	= main_pipe->mode;
+
+#if !defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* Standalone Capture pipe cannot work with continuous capture. */
+	if((pipe_id == IA_CSS_PIPE_ID_CAPTURE) && (stream->num_pipes == 1)) {
+		if (!stream->config.online &&
+		    !main_pipe->pipe_settings.capture.copy_binary.info) {
+			err = IA_CSS_ERR_INVALID_ARGUMENTS;
+			goto ERR;
+		}
+	}
+#endif
+	/* No continuous frame allocation for capture pipe. It uses the
+	 * "main" pipe's frames. */
+	if((pipe_id == IA_CSS_PIPE_ID_PREVIEW) ||
+	   (pipe_id == IA_CSS_PIPE_ID_VIDEO)) {
+		if(stream->config.continuous || pipe_id == IA_CSS_PIPE_ID_PREVIEW) {
+			err = alloc_continuous_frames(main_pipe, true);
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+		}
+
+#ifdef HRT_CSIM
+		if(main_pipe->continuous_frames[0])
+			ia_css_frame_zero(main_pipe->continuous_frames[0]);
+#endif
+	}
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	if((pipe_id != IA_CSS_PIPE_ID_ACC) &&
+	   (main_pipe->config.mode != IA_CSS_PIPE_MODE_COPY)) {
+		err = allocate_mipi_frames(main_pipe);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+	}
+#endif
+
+	switch (pipe_id) {
+	case IA_CSS_PIPE_ID_PREVIEW:
+		copy_pipe    = main_pipe->pipe_settings.preview.copy_pipe;
+		capture_pipe = main_pipe->pipe_settings.preview.capture_pipe;
+		max_input_width =
+			main_pipe->pipe_settings.preview.preview_binary.info->sp.max_input_width;
+
+		err = create_host_preview_pipeline(main_pipe);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+
+		break;
+
+	case IA_CSS_PIPE_ID_VIDEO:
+		copy_pipe    = main_pipe->pipe_settings.video.copy_pipe;
+		capture_pipe = main_pipe->pipe_settings.video.capture_pipe;
+		max_input_width =
+			main_pipe->pipe_settings.video.video_binary.info->sp.max_input_width;
+
+		err = create_host_video_pipeline(main_pipe);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+
+		break;
+
+	case IA_CSS_PIPE_ID_CAPTURE:
+		capture_pipe = main_pipe;
+
+		break;
+
+	case IA_CSS_PIPE_ID_YUVPP:
+		err = create_host_yuvpp_pipeline(main_pipe);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+
+		break;
+
+	case IA_CSS_PIPE_ID_ACC:
+		err = create_host_acc_pipeline(main_pipe);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+
+		break;
+	default:
+		err = IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+
+	if(copy_pipe) {
+		err = create_host_copy_pipeline(copy_pipe, max_input_width,
+					  main_pipe->continuous_frames[0]);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+	}
+
+	if(capture_pipe) {
+		err = create_host_capture_pipeline(capture_pipe);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+	}
+
+ERR:
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_pipeline() leave: return (%d)\n", err);
+	return err;
+}
+
+static enum ia_css_err
+init_pipe_defaults(enum ia_css_pipe_mode mode,
+	       struct ia_css_pipe *pipe,
+	       bool copy_pipe)
+{
+	static struct ia_css_pipe default_pipe = DEFAULT_PIPE;
+	static struct ia_css_preview_settings prev  = DEFAULT_PREVIEW_SETTINGS;
+	static struct ia_css_capture_settings capt  = DEFAULT_CAPTURE_SETTINGS;
+	static struct ia_css_video_settings   video = DEFAULT_VIDEO_SETTINGS;
+	static struct ia_css_yuvpp_settings   yuvpp = DEFAULT_YUVPP_SETTINGS;
+
+	assert(pipe != NULL);
+
+	/* Initialize pipe to pre-defined defaults */
+	*pipe = default_pipe;
+
+	/* TODO: JB should not be needed, but temporary backward reference */
+	switch (mode) {
+	case IA_CSS_PIPE_MODE_PREVIEW:
+		pipe->mode = IA_CSS_PIPE_ID_PREVIEW;
+		pipe->pipe_settings.preview = prev;
+		break;
+	case IA_CSS_PIPE_MODE_CAPTURE:
+		if (copy_pipe) {
+			pipe->mode = IA_CSS_PIPE_ID_COPY;
+		} else {
+			pipe->mode = IA_CSS_PIPE_ID_CAPTURE;
+		}
+		pipe->pipe_settings.capture = capt;
+		break;
+	case IA_CSS_PIPE_MODE_VIDEO:
+		pipe->mode = IA_CSS_PIPE_ID_VIDEO;
+		pipe->pipe_settings.video = video;
+		break;
+	case IA_CSS_PIPE_MODE_ACC:
+		pipe->mode = IA_CSS_PIPE_ID_ACC;
+		break;
+	case IA_CSS_PIPE_MODE_COPY:
+		pipe->mode = IA_CSS_PIPE_ID_CAPTURE;
+		break;
+	case IA_CSS_PIPE_MODE_YUVPP:
+		pipe->mode = IA_CSS_PIPE_ID_YUVPP;
+		pipe->pipe_settings.yuvpp = yuvpp;
+		break;
+	default:
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	return IA_CSS_SUCCESS;
+}
+
+static void
+pipe_global_init(void)
+{
+	uint8_t i;
+
+	my_css.pipe_counter = 0;
+	for (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++) {
+		my_css.all_pipes[i] = NULL;
+	}
+}
+
+static uint8_t
+pipe_generate_pipe_num(const struct ia_css_pipe *pipe)
+{
+	uint8_t i;
+	uint8_t pipe_num = ~0; /* UINT8_MAX; but Linux does not have this macro */
+
+	assert(pipe != NULL);
+	/* Assign a new pipe_num .... search for empty place */
+	for (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++) {
+		if (my_css.all_pipes[i] == NULL) {
+			/*position is reserved */
+			my_css.all_pipes[i] = (struct ia_css_pipe *)pipe;
+			pipe_num = i;
+			break;
+		}
+	}
+	assert(pipe_num != (uint8_t)~0); /* UINT8_MAX; but Linux does not have this macro */
+	my_css.pipe_counter++;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"pipe_generate_pipe_num (%d)\n", pipe_num);
+	return pipe_num;
+}
+
+static void
+pipe_release_pipe_num(unsigned int pipe_num)
+{
+	my_css.all_pipes[pipe_num] = NULL;
+	my_css.pipe_counter--;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"pipe_release_pipe_num (%d)\n", pipe_num);
+}
+
+static enum ia_css_err
+create_pipe(enum ia_css_pipe_mode mode,
+	    struct ia_css_pipe **pipe,
+	    bool copy_pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_pipe *me = sh_css_malloc(sizeof(*me));
+
+	assert(pipe != NULL);
+
+	if (!me)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	err = init_pipe_defaults(mode, me, copy_pipe);
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_free(me);
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+
+	me->pipe_num = pipe_generate_pipe_num(me);
+	*pipe = me;
+	return IA_CSS_SUCCESS;
+}
+
+static struct ia_css_pipe *
+find_pipe_by_num(uint8_t pipe_num)
+{
+	unsigned int i;
+	for (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++){
+		if (my_css.all_pipes[i] &&
+				ia_css_pipe_get_pipe_num(my_css.all_pipes[i]) == pipe_num) {
+			return my_css.all_pipes[i];
+		}
+	}
+	return NULL;
+}
+
+static void sh_css_pipe_free_acc_binaries (
+    struct ia_css_pipe *pipe)
+{
+	struct ia_css_pipeline *pipeline;
+	struct ia_css_pipeline_stage *stage;
+
+	assert(pipe != NULL);
+	pipeline = &pipe->pipeline;
+
+	/* loop through the stages and unload them */
+	for (stage = pipeline->stages; stage; stage = stage->next) {
+		struct ia_css_fw_info *firmware = (struct ia_css_fw_info *)
+						stage->firmware;
+		if (firmware)
+			ia_css_pipe_unload_extension(pipe, firmware);
+	}
+}
+
+enum ia_css_err
+ia_css_pipe_destroy(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_destroy() enter\n");
+
+	if (pipe == NULL) return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (pipe->stream != NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_destroy(): "
+							"ia_css_stream_destroy not called!\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	switch (pipe->config.mode) {
+	case IA_CSS_PIPE_MODE_PREVIEW:
+		/* need to take into account that this function is also called
+		   on the internal copy pipe */
+		if (pipe->mode == IA_CSS_PIPE_ID_PREVIEW) {
+			ia_css_frame_free_multiple(NUM_CONTINUOUS_FRAMES,
+					pipe->continuous_frames);
+			ia_css_metadata_free_multiple(NUM_CONTINUOUS_FRAMES,
+					pipe->cont_md_buffers);
+			if (pipe->pipe_settings.preview.copy_pipe) {
+				err = ia_css_pipe_destroy(pipe->pipe_settings.preview.copy_pipe);
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_destroy(): "
+					"destroyed internal copy pipe err=%d\n", err);
+			}
+		}
+		break;
+	case IA_CSS_PIPE_MODE_VIDEO:
+		if (pipe->mode == IA_CSS_PIPE_ID_VIDEO) {
+			ia_css_frame_free_multiple(NUM_CONTINUOUS_FRAMES,
+				pipe->continuous_frames);
+			ia_css_metadata_free_multiple(NUM_CONTINUOUS_FRAMES,
+					pipe->cont_md_buffers);
+			if (pipe->pipe_settings.video.copy_pipe) {
+				err = ia_css_pipe_destroy(pipe->pipe_settings.video.copy_pipe);
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_destroy(): "
+					"destroyed internal copy pipe err=%d\n", err);
+			}
+		}
+		ia_css_frame_free_multiple(NUM_VIDEO_TNR_FRAMES, pipe->pipe_settings.video.tnr_frames);
+		ia_css_frame_free_multiple((pipe->dvs_frame_delay + 1), pipe->pipe_settings.video.delay_frames);
+		break;
+	case IA_CSS_PIPE_MODE_CAPTURE:
+#if 0
+		/* Do not destroy, these are shared with preview */
+		ia_css_frame_free_multiple(NUM_CONTINUOUS_FRAMES,
+				pipe->pipe_settings.capture.continuous_frames);
+#endif
+		break;
+	case IA_CSS_PIPE_MODE_ACC:
+		sh_css_pipe_free_acc_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_MODE_COPY:
+		break;
+	case IA_CSS_PIPE_MODE_YUVPP:
+		break;
+	}
+
+	my_css.active_pipes[ia_css_pipe_get_pipe_num(pipe)] = NULL;
+	sh_css_pipe_free_shading_table(pipe);
+
+	ia_css_pipeline_destroy(&pipe->pipeline);
+	pipe_release_pipe_num(ia_css_pipe_get_pipe_num(pipe));
+
+	/* Temporarily, not every sh_css_pipe has an acc_extension. */
+	if (pipe->config.acc_extension) {
+		ia_css_pipe_unload_extension(pipe, pipe->config.acc_extension);
+	}
+	sh_css_free(pipe);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_destroy() exit, err=%d\n", err);
+	return err;
+}
+
+void
+ia_css_uninit(void)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_uninit() enter: void\n");
+#if WITH_PC_MONITORING
+	sh_css_print("PC_MONITORING: %s() -- started\n", __func__);
+	print_pc_histogram();
+#endif
+	/* TODO: JB: implement decent check and handling of freeing mipi frames */
+	//assert(ref_count_mipi_allocation == 0); //mipi frames are not freed
+	/* cleanup generic data */
+	sh_css_params_uninit();
+	ia_css_refcount_uninit();
+
+	ia_css_rmgr_uninit();
+
+#if !defined(HAS_NO_INPUT_FORMATTER)
+	/* needed for reprogramming the inputformatter after power cycle of css */
+	ifmtr_set_if_blocking_mode_reset = true;
+#endif
+
+	if (fw_explicitly_loaded == false) {
+		ia_css_unload_firmware(false);
+	}
+	ia_css_spctrl_unload_fw(SP0_ID);
+#if defined(IS_ISP_2500_SYSTEM)
+	ia_css_spctrl_unload_fw(SP1_ID);
+#endif
+
+	sh_css_sp_set_sp_running(false);
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* check and free any remaining mipi frames */
+	free_mipi_frames(NULL, true);
+#endif
+
+	sh_css_sp_reset_global_vars();
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+	ia_css_isys_uninit();
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_uninit() leave: return_void\n");
+}
+
+static unsigned int translate_sw_interrupt(unsigned value)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "translate_sw_interrupt() enter:\n");
+	/* previous versions of sp would put info in the upper word
+	   better safe than sorry so mask that away
+	*/
+	value = value & 0xffff;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "translate_sw_interrupt() leave: return %d\n", value);
+	return value;
+}
+
+static unsigned int translate_sw_interrupt1(void)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "translate_sw_interrupt1() enter:\n");
+	return translate_sw_interrupt(sh_css_get_sw_interrupt_value(1));
+}
+
+#if 0
+static unsigned int translate_sw_interrupt2(void)
+{
+	/* By smart coding the flag/bits in value (on the SP side),
+	 * no translation is required. The returned value can be
+	 * binary ORed with existing interrupt info
+	 * (it is compatible with enum ia_css_irq_info)
+	 */
+/* MW: No smart coding required, we should just keep interrupt info
+   and local context info separated */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "translate_sw_interrupt2() enter:\n");
+	return translate_sw_interrupt(sh_css_get_sw_interrupt_value(2));
+}
+#endif
+
+/* Deprecated, this is an HRT backend function (memory_access.h) */
+static void
+sh_css_mmu_set_page_table_base_index(hrt_data base_index)
+{
+	int i;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_mmu_set_page_table_base_index() enter: base_index=0x%08x\n",base_index);
+	my_css.page_table_base_index = base_index;
+	for (i = 0; i < (int)N_MMU_ID; i++) {
+		mmu_ID_t mmu_id = (mmu_ID_t)i;
+		mmu_set_page_table_base_index(mmu_id, base_index);
+		mmu_invalidate_cache(mmu_id);
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_mmu_set_page_table_base_index() leave: return_void\n");
+}
+
+void
+ia_css_mmu_invalidate_cache(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_mmu_invalidate_cache() enter\n");
+
+	/* if the SP is not running we should not access its dmem */
+	if (sh_css_sp_is_running())
+	{
+		HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb = fw->info.sp.invalidate_tlb;
+
+		(void)HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb; /* Suppres warnings in CRUN */
+
+		sp_dmem_store_uint32(SP0_ID,
+			(unsigned int)sp_address_of(ia_css_dmaproxy_sp_invalidate_tlb),
+			true);
+	}
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_mmu_invalidate_cache() leave\n");
+}
+
+#if defined(HAS_IRQ_MAP_VERSION_1) || defined(HAS_IRQ_MAP_VERSION_1_DEMO)
+enum ia_css_err ia_css_irq_translate(
+	unsigned int *irq_infos)
+{
+	virq_id_t	irq;
+	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_more_irqs;
+	unsigned int infos = 0;
+
+/* irq_infos can be NULL, but that would make the function useless */
+/* assert(irq_infos != NULL); */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_irq_translate() enter: irq_infos=%p\n",irq_infos);
+
+	while (status == hrt_isp_css_irq_status_more_irqs) {
+		status = virq_get_channel_id(&irq);
+		if (status == hrt_isp_css_irq_status_error)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+
+#if WITH_PC_MONITORING
+		sh_css_print("PC_MONITORING: %s() irq = %d, "
+			     "sh_binary_running set to 0\n", __func__, irq);
+		sh_binary_running = 0 ;
+#endif
+
+		switch (irq) {
+		case virq_sp:
+			infos |= IA_CSS_IRQ_INFO_EVENTS_READY;
+			break;
+		case virq_isp:
+#ifdef HRT_CSIM
+			/* Enable IRQ which signals that ISP goes to idle
+			 * to get statistics for each binary */
+			infos |= IA_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY;
+#endif
+			break;
+		case virq_isys_csi:
+			/* css rx interrupt, read error bits from css rx */
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR;
+			break;
+		case virq_isys_fifo_full:
+			infos |=
+			    IA_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW;
+			break;
+		case virq_isys_sof:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF;
+			break;
+		case virq_isys_eof:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF;
+			break;
+/* Temporarily removed, until we have a seperate flag for FRAME_READY irq */
+#if 0
+/* hmm, an interrupt mask, why would we have that ? */
+		case virq_isys_sol:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_SOL;
+			break;
+#endif
+		case virq_isys_eol:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_EOL;
+			break;
+/*
+ * MW: The 2300 demo system does not have a receiver, and it
+ * does not have the following three IRQ channels defined
+ */
+#if defined(HAS_IRQ_MAP_VERSION_1)
+		case virq_ifmt_sideband_changed:
+			infos |=
+			    IA_CSS_IRQ_INFO_CSS_RECEIVER_SIDEBAND_CHANGED;
+			break;
+		case virq_gen_short_0:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0;
+			break;
+		case virq_gen_short_1:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1;
+			break;
+#endif
+		case virq_ifmt0_id:
+			infos |= IA_CSS_IRQ_INFO_IF_PRIM_ERROR;
+			break;
+		case virq_ifmt1_id:
+			infos |= IA_CSS_IRQ_INFO_IF_PRIM_B_ERROR;
+			break;
+		case virq_ifmt2_id:
+			infos |= IA_CSS_IRQ_INFO_IF_SEC_ERROR;
+			break;
+		case virq_ifmt3_id:
+			infos |= IA_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR;
+			break;
+		case virq_sw_pin_0:
+			infos |= IA_CSS_IRQ_INFO_SW_0;
+			break;
+		case virq_sw_pin_1:
+			infos |= translate_sw_interrupt1();
+			/* pqiao TODO: also assumption here */
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (irq_infos)
+		*irq_infos = infos;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_irq_translate() "
+		"leave: irq_infos=%p\n", infos);
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_irq_enable(enum ia_css_irq_info info,
+		  bool enable)
+{
+	virq_id_t	irq = N_virq_id;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_irq_enable() enter: info=%d, enable=%d\n",info,enable);
+
+	switch (info) {
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR:
+		irq = virq_isys_csi;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW:
+		irq = virq_isys_fifo_full;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF:
+		irq = virq_isys_sof;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF:
+		irq = virq_isys_eof;
+		break;
+/* Temporarily removed, until we have a seperate flag for FRAME_READY irq */
+#if 0
+/* hmm, an interrupt mask, why would we have that ? */
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_SOL:
+		irq = virq_isys_sol;
+		break;
+#endif
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_EOL:
+		irq = virq_isys_eol;
+		break;
+#if defined(HAS_IRQ_MAP_VERSION_1)
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_SIDEBAND_CHANGED:
+		irq = virq_ifmt_sideband_changed;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0:
+		irq = virq_gen_short_0;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1:
+		irq = virq_gen_short_1;
+		break;
+#endif
+	case IA_CSS_IRQ_INFO_IF_PRIM_ERROR:
+		irq = virq_ifmt0_id;
+		break;
+	case IA_CSS_IRQ_INFO_IF_PRIM_B_ERROR:
+		irq = virq_ifmt1_id;
+		break;
+	case IA_CSS_IRQ_INFO_IF_SEC_ERROR:
+		irq = virq_ifmt2_id;
+		break;
+	case IA_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR:
+		irq = virq_ifmt3_id;
+		break;
+	case IA_CSS_IRQ_INFO_SW_0:
+		irq = virq_sw_pin_0;
+		break;
+	case IA_CSS_IRQ_INFO_SW_1:
+		irq = virq_sw_pin_1;
+		break;
+	case IA_CSS_IRQ_INFO_SW_2:
+		irq = virq_sw_pin_2;
+		break;
+	default:
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_irq_enable() leave: return_err=%d\n",IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	cnd_virq_enable_channel(irq, enable);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_irq_enable() leave: return_err=%d\n",IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
+}
+
+#elif defined(HAS_IRQ_MAP_VERSION_2)
+
+enum ia_css_err ia_css_irq_translate(
+	unsigned int *irq_infos)
+{
+	virq_id_t	irq;
+	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_more_irqs;
+	unsigned int infos = 0;
+
+/* irq_infos can be NULL, but that would make the function useless */
+/* assert(irq_infos != NULL); */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_irq_translate() enter: irq_infos=%p\n",irq_infos);
+
+	while (status == hrt_isp_css_irq_status_more_irqs) {
+		status = virq_get_channel_id(&irq);
+		if (status == hrt_isp_css_irq_status_error)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+
+#if WITH_PC_MONITORING
+		sh_css_print("PC_MONITORING: %s() irq = %d, "
+			     "sh_binary_running set to 0\n", __func__, irq);
+		sh_binary_running = 0 ;
+#endif
+
+		switch (irq) {
+#if defined(IS_ISP_2500_SYSTEM)
+		case virq_sp0:
+#else
+		case virq_sp:
+#endif
+			infos |= IA_CSS_IRQ_INFO_EVENTS_READY;
+			break;
+		case virq_isp:
+#ifdef HRT_CSIM
+			/* Enable IRQ which signals that ISP goes to idle
+			 * to get statistics for each binary */
+			infos |= IA_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY;
+#endif
+			break;
+#if !defined(HAS_NO_INPUT_SYSTEM)
+		case virq_isys_sof:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF;
+			break;
+		case virq_isys_eof:
+			infos |= IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF;
+			break;
+		case virq_isys_csi:
+			infos |= IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR;
+			break;
+#endif
+#if !defined(HAS_NO_INPUT_FORMATTER)
+		case virq_ifmt0_id:
+			infos |= IA_CSS_IRQ_INFO_IF_ERROR;
+			break;
+#endif
+		case virq_dma:
+			infos |= IA_CSS_IRQ_INFO_DMA_ERROR;
+			break;
+		case virq_sw_pin_0:
+			infos |= IA_CSS_IRQ_INFO_SW_0;
+			break;
+		case virq_sw_pin_1:
+			infos |= translate_sw_interrupt1();
+			/* pqiao TODO: also assumption here */
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (irq_infos)
+		*irq_infos = infos;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_irq_translate() "
+		"leave: irq_infos=%p\n", infos);
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err ia_css_irq_enable(
+	enum ia_css_irq_info info,
+	bool enable)
+{
+	virq_id_t	irq = N_virq_id;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_irq_enable() enter: info=%d, enable=%d\n",info,enable);
+
+	switch (info) {
+#if !defined(HAS_NO_INPUT_FORMATTER)
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_SOF:
+		irq = virq_isys_sof;
+		break;
+	case IA_CSS_IRQ_INFO_CSS_RECEIVER_EOF:
+		irq = virq_isys_eof;
+		break;
+	case IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR:
+		irq = virq_isys_csi;
+		break;
+#endif
+#if !defined(HAS_NO_INPUT_FORMATTER)
+	case IA_CSS_IRQ_INFO_IF_ERROR:
+		irq = virq_ifmt0_id;
+		break;
+#endif
+	case IA_CSS_IRQ_INFO_DMA_ERROR:
+		irq = virq_dma;
+		break;
+	case IA_CSS_IRQ_INFO_SW_0:
+		irq = virq_sw_pin_0;
+		break;
+	case IA_CSS_IRQ_INFO_SW_1:
+		irq = virq_sw_pin_1;
+		break;
+	default:
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_irq_enable() leave: return_err=%d\n",IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	cnd_virq_enable_channel(irq, enable);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_irq_enable() leave: return_err=%d\n",IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
+}
+
+#else
+#error "sh_css.c: IRQ MAP must be one of \
+	{IRQ_MAP_VERSION_1, IRQ_MAP_VERSION_1_DEMO, IRQ_MAP_VERSION_2}"
+#endif
+
+static unsigned int
+sh_css_get_sw_interrupt_value(unsigned int irq)
+{
+	unsigned int irq_value;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_get_sw_interrupt_value() enter: irq=%d\n",irq);
+	irq_value = sh_css_sp_get_sw_interrupt_value(irq);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_get_sw_interrupt_value() leave: irq_value=%d\n",irq_value);
+	return irq_value;
+}
+
+#if 0
+/* Disabled because it is currently unused. */
+static void
+sh_css_pipe_get_extra_pixels_count(const struct sh_css_pipe *pipe,
+				   struct ia_css_resolution *extra)
+{
+	int rows = SH_CSS_MAX_LEFT_CROPPING,
+	    cols = SH_CSS_MAX_LEFT_CROPPING;
+
+	assert(pipe != NULL);
+	assert(extra != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_pipe_get_extra_pixels_count() enter: void\n");
+
+	if (ia_css_ifmtr_lines_needed_for_bayer_order(&pipe->stream->config))
+		rows += 2;
+
+	if (ia_css_ifmtr_columns_needed_for_bayer_order(&pipe->stream->config))
+		cols  += 2;
+
+	extra->width  = cols;
+	extra->height = rows;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_pipe_get_extra_pixels_count() leave: extra_rows=%d, extra_cols=%d\n",
+		rows, cols);
+}
+#endif
+
+/* configure and load the copy binary, the next binary is used to
+   determine whether the copy binary needs to do left padding. */
+static enum ia_css_err load_copy_binary(
+	struct ia_css_pipe *pipe,
+	struct ia_css_binary *copy_binary,
+	struct ia_css_binary *next_binary)
+{
+	struct ia_css_frame_info copy_out_info, copy_in_info, copy_vf_info;
+	unsigned int left_padding;
+	enum ia_css_err err;
+	struct ia_css_binary_descr copy_descr;
+
+	/* next_binary can be NULL */
+	assert(pipe != NULL);
+	assert(copy_binary != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"load_copy_binary() enter:\n");
+
+	if (next_binary != NULL) {
+		copy_out_info = next_binary->in_frame_info;
+		left_padding = next_binary->left_padding;
+	} else {
+		copy_out_info = pipe->output_info[0];
+		copy_vf_info = pipe->vf_output_info[0];
+		ia_css_frame_info_set_format(&copy_vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);
+		left_padding = 0;
+	}
+
+	ia_css_pipe_get_copy_binarydesc(pipe, &copy_descr,
+		&copy_in_info, &copy_out_info, (next_binary != NULL) ? NULL : NULL/*TODO: &copy_vf_info*/);
+	err = ia_css_binary_find(&copy_descr, copy_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	copy_binary->left_padding = left_padding;
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+alloc_continuous_frames(
+	struct ia_css_pipe *pipe, bool init_time)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame_info ref_info;
+	enum ia_css_pipe_id pipe_id;
+	bool continuous;
+	unsigned int i, idx;
+	unsigned int num_frames;
+	unsigned int left_cropping = 0, top_cropping;
+	uint8_t raw_binning = 0;
+	struct ia_css_pipe *capture_pipe = NULL;
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	pipe_id = pipe->mode;
+	continuous = pipe->stream->config.continuous;
+
+	if (continuous) {
+		if (init_time) {
+			num_frames = pipe->stream->config.init_num_cont_raw_buf;
+			pipe->stream->continuous_pipe = pipe;
+		} else
+			num_frames = pipe->stream->config.target_num_cont_raw_buf;
+	} else {
+	    num_frames = NUM_ONLINE_INIT_CONTINUOUS_FRAMES;
+	}
+
+	if (pipe_id == IA_CSS_PIPE_ID_PREVIEW) {
+		left_cropping = pipe->pipe_settings.preview.preview_binary.info->sp.left_cropping;
+		top_cropping = pipe->pipe_settings.preview.preview_binary.info->sp.top_cropping;
+		ref_info = pipe->pipe_settings.preview.preview_binary.in_frame_info;
+		raw_binning = pipe->pipe_settings.preview.preview_binary.info->sp.enable.raw_binning;
+	} else if (pipe_id == IA_CSS_PIPE_ID_VIDEO) {
+		left_cropping = pipe->pipe_settings.video.video_binary.info->sp.left_cropping;
+		top_cropping = pipe->pipe_settings.video.video_binary.info->sp.top_cropping;
+		ref_info = pipe->pipe_settings.video.video_binary.in_frame_info;
+		raw_binning = pipe->pipe_settings.video.video_binary.info->sp.enable.raw_binning;
+	}
+	else {
+		/* should not happen */
+		assert(false);
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* [Must Revert]
+	 * The following changes are interim updates in order to
+	 * have an immediate solution.  The formal solutions will
+	 * be forthcoming on follow-up updates. These changes
+	 * are intended to be reverted.
+	 */
+
+	/* Ensure padded width is aligned for 2401 */
+	ref_info.padded_width = CEIL_MUL(ref_info.res.width, 2 * ISP_VEC_NELEMS);
+
+	/* avoid memguard error */
+	ref_info.res.height += 4;
+#endif
+
+#if !defined(HAS_NO_PACKED_RAW_PIXELS)
+	if (pipe->stream->config.pack_raw_pixels) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"alloc_continuous_frames() IA_CSS_FRAME_FORMAT_RAW_PACKED\n");
+		ref_info.format = IA_CSS_FRAME_FORMAT_RAW_PACKED;
+	} else
+#endif
+	{
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"alloc_continuous_frames() IA_CSS_FRAME_FORMAT_RAW\n");
+		ref_info.format = IA_CSS_FRAME_FORMAT_RAW;
+	}
+
+	/* Write format back to binary */
+	if (pipe_id == IA_CSS_PIPE_ID_PREVIEW) {
+		pipe->pipe_settings.preview.preview_binary.in_frame_info.format = ref_info.format;
+		capture_pipe = pipe->pipe_settings.preview.capture_pipe;
+	} else if (pipe_id == IA_CSS_PIPE_ID_VIDEO) {
+		pipe->pipe_settings.video.video_binary.in_frame_info.format = ref_info.format;
+		capture_pipe = pipe->pipe_settings.video.capture_pipe;
+	} else {
+		/* should not happen */
+		assert(false);
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+
+	if (init_time)
+	    idx = 0;
+	else
+		idx = pipe->stream->config.init_num_cont_raw_buf;
+
+	for (i = idx; i < NUM_CONTINUOUS_FRAMES; i++) {
+		/* free previous frame */
+		if (pipe->continuous_frames[i]) {
+			ia_css_frame_free(pipe->continuous_frames[i]);
+			pipe->continuous_frames[i] = NULL;
+		}
+		/* free previous metadata buffer */
+		ia_css_metadata_free(pipe->cont_md_buffers[i]);
+		pipe->cont_md_buffers[i] = NULL;
+
+		/* check if new frame needed */
+		if (i < num_frames) {
+			/* allocate new frame */
+			err = ia_css_frame_allocate_from_info(
+				&pipe->continuous_frames[i],
+				&ref_info);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+			/* allocate metadata buffer */
+			pipe->cont_md_buffers[i] = ia_css_metadata_allocate(
+					&pipe->stream->info.metadata_info);
+		}
+	}
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_alloc_continuous_frame_remain(struct ia_css_stream *stream)
+{
+	if (stream == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return alloc_continuous_frames(stream->continuous_pipe, false);
+}
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+/* start of MIPI functions */
+static enum ia_css_err
+allocate_mipi_frames(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;
+	unsigned int i, j;
+	struct ia_css_frame_info mipi_intermediate_info;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"allocate_mipi_frames(%p) enter:\n", pipe);
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	if (pipe->stream->config.online) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"allocate_mipi_frames(%p) exit: no buffers needed for 2401 pipe mode\n",
+			pipe);
+		return IA_CSS_SUCCESS;
+	}
+
+#endif
+	if (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"allocate_mipi_frames(%p) exit: no buffers needed for pipe mode\n",
+			pipe);
+		return IA_CSS_SUCCESS;
+	}
+
+	assert(my_css.size_mem_words != 0);
+	if (my_css.size_mem_words == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"allocate_mipi_frames(%p) exit: mipi frame size not specified\n",
+			pipe);
+		return err;
+	}
+
+	ref_count_mipi_allocation++;
+	if (ref_count_mipi_allocation > 1) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"allocate_mipi_frames(%p) exit: already allocated\n",
+			pipe);
+		return IA_CSS_SUCCESS;
+	}
+	assert(ref_count_mipi_allocation == 1);
+
+// This code needs to modified to allocate the MIPI frames in the correct normal way with a allocate from info
+// by justin
+	mipi_intermediate_info = pipe->pipe_settings.video.video_binary.internal_frame_info;
+	mipi_intermediate_info.res.width = 0;
+	mipi_intermediate_info.res.height = 0;
+	// To indicate it is not (yet) valid format.
+	mipi_intermediate_info.format = IA_CSS_FRAME_FORMAT_NUM;
+	mipi_intermediate_info.padded_width = 0;
+	mipi_intermediate_info.raw_bit_depth = 0;
+	//mipi_intermediate_info.data_bytes = my_css.size_mem_words * HIVE_ISP_DDR_WORD_BYTES;
+	//mipi_intermediate_info.contiguous = my_css.contiguous;
+	// To indicate it is not valid frame.
+	//mipi_intermediate_info.dynamic_data_index = SH_CSS_INVALID_FRAME_ID;
+
+	for (i = 0; i < my_css.num_mipi_frames; i++) {
+		/* If there is a previous frame available, reuse it */
+		if (my_css.mipi_frames[i]) {
+			err = IA_CSS_SUCCESS;
+			continue;
+
+		}
+		/* check if new frame needed */
+		if (i < my_css.num_mipi_frames) {
+			/* allocate new frame */
+			err = ia_css_frame_allocate_with_buffer_size(
+				&my_css.mipi_frames[i],
+				my_css.size_mem_words * HIVE_ISP_DDR_WORD_BYTES,
+				my_css.contiguous);
+			if (err != IA_CSS_SUCCESS) {
+				for (j = 0; j < i; j++) {
+					if (my_css.mipi_frames[j]) {
+						ia_css_frame_free(my_css.mipi_frames[j]);
+						my_css.mipi_frames[j] = NULL;
+					}
+				}
+				return err;
+			}
+#ifdef HRT_CSIM
+			ia_css_frame_zero(my_css.mipi_frames[i]);
+#endif
+		}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"allocate_mipi_frames(%p) exit:\n", pipe);
+
+	return err;
+}
+
+static void
+free_mipi_frames(struct ia_css_pipe *pipe, bool uninit)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"free_mipi_frames(%p, %d) enter:\n", pipe, uninit);
+	if (!uninit) {
+		assert(pipe != NULL);
+		assert(pipe->stream != NULL);
+
+		if (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+				"free_mipi_frames() exit: wrong mode\n");
+			return;
+		}
+
+		assert(ref_count_mipi_allocation > 0);
+		ref_count_mipi_allocation--;
+
+		if (ref_count_mipi_allocation > 0) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+				"free_mipi_frames(%p, %d) exit: "
+				"not last pipe (ref_count=%d):\n",
+				pipe, uninit, ref_count_mipi_allocation);
+			return;
+		}
+	}
+
+	/* TODO: change into return error value instead of assert
+	 * task is pending, disable for now
+	 */
+	//assert(ref_count_mipi_allocation == 0);
+	ref_count_mipi_allocation = 0;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"free_mipi_frames(%p, %d) exit (deallocated):\n", pipe, uninit);
+}
+
+
+static void
+send_mipi_frames(struct ia_css_pipe *pipe)
+{
+	unsigned int i;
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	/* multi stream video needs mipi buffers */
+	if (pipe->stream->config.mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR)
+		return;
+
+	/* Hand-over the SP-internal mipi buffers */
+	for (i = 0; i < my_css.num_mipi_frames; i++) {
+		sh_css_update_host2sp_mipi_frame(i,
+			my_css.mipi_frames[i]);
+	}
+	sh_css_update_host2sp_num_mipi_frames
+		(my_css.num_mipi_frames);
+
+	/**********************************
+	 *
+	 * Hack for Baytrail.
+	 *
+	 * AUTHOR: zhengjie.lu@intel.com
+	 * TIME: 2013-01-19, 14:38.
+	 * LOCATION: Santa Clara, U.S.A.
+	 * COMMENT:
+	 * Send an event to inform the SP
+	 * that all MIPI frames are passed.
+	 *
+	 **********************************/
+	{
+		if (!sh_css_sp_is_running()) {
+			/* SP is not running. The queues are not valid */
+			return;
+		}
+		ia_css_bufq_enqueue_event(SP_SW_EVENT_ID_6,	/* the event ID  */
+			0,				/* not used */
+			0,				/* not used */
+			0				/* not used */);
+
+	}
+	/** End of hack of Baytrail **/
+}
+/* end of MIPI functions */
+#endif
+
+static enum ia_css_err
+load_preview_binaries(struct ia_css_pipe *pipe)
+{
+	struct ia_css_frame_info prev_in_info,
+				 prev_bds_out_info,
+				 prev_out_info,
+				 prev_vf_info;
+	struct ia_css_binary_descr preview_descr;
+	bool online;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool continuous, need_vf_pp = false;
+	unsigned int left_cropping;
+	bool need_isp_copy_binary = false;
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	bool sensor = false;
+#endif
+	/* preview only have 1 output pin now */
+	struct ia_css_frame_info *pipe_out_info = &pipe->output_info[0];
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	online = pipe->stream->config.online;
+	continuous = pipe->stream->config.continuous;
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	sensor = pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR;
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"load_preview_binaries() enter:\n");
+
+	if (pipe->pipe_settings.preview.preview_binary.info)
+		return IA_CSS_SUCCESS;
+
+	err = ia_css_util_check_input(&pipe->stream->config, false, false);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = ia_css_frame_check_info(pipe_out_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Note: the current selection of vf_pp binary and
+	 * parameterization of the preview binary contains a few pieces
+	 * of hardcoded knowledge. This needs to be cleaned up such that
+	 * the binary selection becomes more generic.
+	 * The vf_pp binary is needed if one or more of the following features
+	 * are required:
+	 * 1. YUV downscaling.
+	 * 2. Digital zoom.
+	 * 3. An output format that is not supported by the preview binary.
+	 *    In practice this means something other than yuv_line or nv12.
+	 * The decision if the vf_pp binary is needed for YUV downscaling is
+	 * made after the preview binary selection, since some preview binaries
+	 * can perform the requested YUV downscaling.
+	 * */
+	need_vf_pp = pipe->config.enable_dz;
+	need_vf_pp |= pipe_out_info->format != IA_CSS_FRAME_FORMAT_YUV_LINE &&
+		      pipe_out_info->format != IA_CSS_FRAME_FORMAT_NV12;
+
+	/* Preview step 1 */
+	if (pipe->vf_yuv_ds_input_info.res.width)
+		prev_vf_info = pipe->vf_yuv_ds_input_info;
+	else
+		prev_vf_info = *pipe_out_info;
+	/* If vf_pp is needed, then preview must output yuv_line.
+	 * The exception is when vf_pp is manually disabled, that is only
+	 * used in combination with a pipeline extension that requires
+	 * yuv_line as input.
+	 * */
+	if (need_vf_pp)
+		ia_css_frame_info_set_format(&prev_vf_info,
+					     IA_CSS_FRAME_FORMAT_YUV_LINE);
+
+	err = ia_css_pipe_get_preview_binarydesc(pipe, &preview_descr,
+		&prev_in_info, &prev_bds_out_info, &prev_out_info, &prev_vf_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = ia_css_binary_find(&preview_descr,
+				 &pipe->pipe_settings.preview.preview_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* The vf_pp binary is needed when (further) YUV downscaling is required */
+	need_vf_pp |= pipe->pipe_settings.preview.preview_binary.out_frame_info[0].res.width != pipe_out_info->res.width;
+	need_vf_pp |= pipe->pipe_settings.preview.preview_binary.out_frame_info[0].res.height != pipe_out_info->res.height;
+
+	/* When vf_pp is needed, then the output format of the selected
+	 * preview binary must be yuv_line. If this is not the case,
+	 * then the preview binary selection is done again.
+	 */
+	if (need_vf_pp &&
+	    (pipe->pipe_settings.preview.preview_binary.out_frame_info[0].format != IA_CSS_FRAME_FORMAT_YUV_LINE)) {
+
+		/* Preview step 2 */
+		if (pipe->vf_yuv_ds_input_info.res.width)
+			prev_vf_info = pipe->vf_yuv_ds_input_info;
+		else
+			prev_vf_info = *pipe_out_info;
+
+		ia_css_frame_info_set_format(&prev_vf_info,
+					     IA_CSS_FRAME_FORMAT_YUV_LINE);
+
+		err = ia_css_pipe_get_preview_binarydesc(pipe, &preview_descr,
+			&prev_in_info, &prev_bds_out_info, &prev_out_info, &prev_vf_info);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		err = ia_css_binary_find(&preview_descr,
+					 &pipe->pipe_settings.preview.preview_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	if (need_vf_pp) {
+		struct ia_css_binary_descr vf_pp_descr;
+
+		/* Viewfinder post-processing */
+		ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
+			&pipe->pipe_settings.preview.preview_binary.out_frame_info[0],
+			pipe_out_info);
+		err = ia_css_binary_find(&vf_pp_descr,
+				 &pipe->pipe_settings.preview.vf_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	/* When the input system is 2401, only the Direct Sensor Mode
+	 * Offline Preview uses the ISP copy binary.
+	 */
+	need_isp_copy_binary = !online && sensor;
+#else
+	need_isp_copy_binary = !online && !continuous;
+#endif
+
+	/* Copy */
+	if (need_isp_copy_binary) {
+		err = load_copy_binary(pipe,
+				       &pipe->pipe_settings.preview.copy_binary,
+				       &pipe->pipe_settings.preview.preview_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	left_cropping = pipe->pipe_settings.preview.preview_binary.info->sp.left_cropping;
+
+	if (pipe->shading_table) {
+		ia_css_shading_table_free(pipe->shading_table);
+		pipe->shading_table = NULL;
+	}
+
+	return IA_CSS_SUCCESS;
+}
+
+static void
+ia_css_binary_unload(struct ia_css_binary *binary)
+{
+	ia_css_binary_destroy_isp_parameters(binary);
+}
+
+static void
+unload_preview_binaries(struct ia_css_pipe *pipe)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"unload_preview_binaries() enter:\n");
+
+	ia_css_binary_unload(&pipe->pipe_settings.preview.copy_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.preview.preview_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.preview.vf_pp_binary);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"unload_preview_binaries() leave:\n");
+}
+
+static const struct ia_css_fw_info *last_output_firmware(
+	const struct ia_css_fw_info *fw)
+{
+	const struct ia_css_fw_info *last_fw = NULL;
+/* fw can be NULL */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"last_output_firmware() enter:\n");
+
+	for (; fw; fw = fw->next) {
+		const struct ia_css_fw_info *info = fw;
+		if (info->info.isp.sp.enable.output)
+			last_fw = fw;
+	}
+	return last_fw;
+}
+
+static enum ia_css_err add_firmwares(
+	struct ia_css_pipeline *me,
+	struct ia_css_binary *binary,
+	const struct ia_css_fw_info *fw,
+	const struct ia_css_fw_info *last_fw,
+	unsigned int binary_mode,
+	struct ia_css_frame *in_frame,
+	struct ia_css_frame *out_frame,
+	struct ia_css_frame *vf_frame,
+	struct ia_css_pipeline_stage **my_stage,
+	struct ia_css_pipeline_stage **vf_stage)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_pipeline_stage *extra_stage = NULL;
+	struct ia_css_pipeline_stage_desc stage_desc;
+
+/* all args can be NULL ??? */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"add_firmwares() enter:\n");
+
+	for (; fw; fw = fw->next) {
+		struct ia_css_frame *out[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {NULL};
+		struct ia_css_frame *in = NULL;
+		struct ia_css_frame *vf = NULL;
+		if ((fw == last_fw) && (fw->info.isp.sp.enable.out_frame  != 0)) {
+			out[0] = out_frame;
+		}
+		if (fw->info.isp.sp.enable.in_frame != 0) {
+			in = in_frame;
+		}
+		if (fw->info.isp.sp.enable.out_frame != 0) {
+			vf = vf_frame;
+		}
+		ia_css_pipe_get_firmwares_stage_desc(&stage_desc, binary,
+			out, in, vf, fw, binary_mode);
+		err = ia_css_pipeline_create_and_add_stage(me,
+				&stage_desc,
+				&extra_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (fw->info.isp.sp.enable.output != 0)
+			in_frame = extra_stage->args.out_frame[0];
+		if (my_stage && !*my_stage && extra_stage)
+			*my_stage = extra_stage;
+		if (vf_stage && !*vf_stage && extra_stage &&
+		    fw->info.isp.sp.enable.vf_veceven)
+			*vf_stage = extra_stage;
+	}
+	return err;
+}
+
+static enum ia_css_err add_vf_pp_stage(
+	struct ia_css_pipe *pipe,
+	struct ia_css_frame *out_frame,
+	struct ia_css_binary *vf_pp_binary,
+	struct ia_css_pipeline_stage *post_stage,
+	struct ia_css_pipeline_stage **vf_pp_stage)
+{
+
+	struct ia_css_pipeline *me = NULL;
+	const struct ia_css_fw_info *last_fw = NULL;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame *in_frame = NULL;
+	struct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_pipeline_stage_desc stage_desc;
+
+/* out_frame can be NULL ??? */
+
+	assert(pipe != NULL);
+	assert(vf_pp_binary != NULL);
+	assert(post_stage != NULL);
+	assert(vf_pp_stage != NULL);
+
+	ia_css_pipe_util_create_output_frames(out_frames);
+	me = &pipe->pipeline;
+	in_frame = post_stage->args.out_vf_frame;
+
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+	"add_vf_pp_stage() enter:\n");
+
+	*vf_pp_stage = NULL;
+
+	if (in_frame == NULL)
+		in_frame = post_stage->args.out_frame[0];
+
+	last_fw = last_output_firmware(pipe->vf_stage);
+	if (!pipe->extra_config.disable_vf_pp) {
+		if (last_fw) {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, vf_pp_binary,
+				out_frames, in_frame, NULL, NULL);
+		} else{
+			ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, vf_pp_binary,
+				out_frames, in_frame, NULL, NULL);
+		}
+		err = ia_css_pipeline_create_and_add_stage(me, &stage_desc, vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		in_frame = (*vf_pp_stage)->args.out_frame[0];
+	}
+	err = add_firmwares(me, vf_pp_binary, pipe->vf_stage, last_fw,
+			    IA_CSS_BINARY_MODE_VF_PP,
+			    in_frame, out_frame, NULL,
+			    vf_pp_stage, NULL);
+	return err;
+}
+
+static enum ia_css_err add_yuv_scaler_stage(
+	struct ia_css_pipe *pipe,
+	struct ia_css_pipeline *me,
+	struct ia_css_frame *in_frame,
+	struct ia_css_frame *out_frame,
+	struct ia_css_frame *internal_out_frame,
+	struct ia_css_binary *yuv_scaler_binary,
+	struct ia_css_pipeline_stage *prev_stage,
+	struct ia_css_pipeline_stage **pre_vf_pp_stage,
+	bool is_output_stage)
+{
+	const struct ia_css_fw_info *last_fw;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame *vf_frame = NULL;
+	struct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_pipeline_stage_desc stage_desc;
+
+	/* out_frame can be NULL ??? */
+	assert(in_frame != NULL);
+	assert(pipe != NULL);
+	assert(me != NULL);
+	assert(yuv_scaler_binary != NULL);
+	assert(prev_stage != NULL);
+	assert(pre_vf_pp_stage != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"add_yuv_scaler_stage() enter:\n");
+
+	*pre_vf_pp_stage = NULL;
+	ia_css_pipe_util_create_output_frames(out_frames);
+
+	last_fw = last_output_firmware(pipe->output_stage);
+	if (need_yuv_scaler(pipe)) {
+		if (is_output_stage) {
+			err = ia_css_frame_allocate_from_info(&vf_frame,
+					    &yuv_scaler_binary->vf_frame_info);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+		if(last_fw)	{
+			ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc,
+				yuv_scaler_binary, out_frames, in_frame, NULL, vf_frame);
+		} else {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
+			ia_css_pipe_util_set_output_frames(out_frames, 1, internal_out_frame);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc,
+				yuv_scaler_binary, out_frames, in_frame, NULL, vf_frame);
+		}
+		err = ia_css_pipeline_create_and_add_stage(me,
+			&stage_desc,
+			pre_vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		in_frame = (*pre_vf_pp_stage)->args.out_frame[0];
+	}
+	err = add_firmwares(me, yuv_scaler_binary, pipe->output_stage, last_fw,
+			    IA_CSS_BINARY_MODE_CAPTURE_PP,
+			    in_frame, out_frame, vf_frame,
+			    NULL, pre_vf_pp_stage);
+	/* If a firmware produce vf_pp output, we set that as vf_pp input */
+	if (*pre_vf_pp_stage) {
+		(*pre_vf_pp_stage)->args.vf_downscale_log2 =
+		  yuv_scaler_binary->vf_downscale_log2;
+	} else {
+		*pre_vf_pp_stage = prev_stage;
+	}
+	return err;
+}
+
+static enum ia_css_err add_capture_pp_stage(
+	struct ia_css_pipe *pipe,
+	struct ia_css_pipeline *me,
+	struct ia_css_frame *out_frame,
+	struct ia_css_binary *capture_pp_binary,
+	struct ia_css_pipeline_stage *capture_stage,
+	struct ia_css_pipeline_stage **pre_vf_pp_stage)
+{
+	const struct ia_css_fw_info *last_fw = NULL;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame *in_frame = NULL;
+	struct ia_css_frame *vf_frame = NULL;
+	struct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_pipeline_stage_desc stage_desc;
+	//unsigned int i;
+
+	/* out_frame can be NULL ??? */
+	assert(pipe != NULL);
+	assert(me != NULL);
+	assert(capture_pp_binary != NULL);
+	assert(capture_stage != NULL);
+	assert(pre_vf_pp_stage != NULL);
+	in_frame = capture_stage->args.out_frame[0];
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"add_capture_pp_stage() enter:\n");
+
+	*pre_vf_pp_stage = NULL;
+	ia_css_pipe_util_create_output_frames(out_frames);
+
+	last_fw = last_output_firmware(pipe->output_stage);
+	if (need_capture_pp(pipe)) {
+		err = ia_css_frame_allocate_from_info(&vf_frame,
+					    &capture_pp_binary->vf_frame_info);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if(last_fw)	{
+			ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc,
+				capture_pp_binary, out_frames, NULL, NULL, vf_frame);
+		} else {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc,
+				capture_pp_binary, out_frames, NULL, NULL, vf_frame);
+		}
+		err = ia_css_pipeline_create_and_add_stage(me,
+			&stage_desc,
+			pre_vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		in_frame = (*pre_vf_pp_stage)->args.out_frame[0];
+	}
+	err = add_firmwares(me, capture_pp_binary, pipe->output_stage, last_fw,
+			    IA_CSS_BINARY_MODE_CAPTURE_PP,
+			    in_frame, out_frame, vf_frame,
+			    NULL, pre_vf_pp_stage);
+	/* If a firmware produce vf_pp output, we set that as vf_pp input */
+	if (*pre_vf_pp_stage) {
+		(*pre_vf_pp_stage)->args.vf_downscale_log2 =
+		  capture_pp_binary->vf_downscale_log2;
+	} else {
+		*pre_vf_pp_stage = capture_stage;
+	}
+	return err;
+}
+
+/* keep this function for future use */
+#if 0
+static void
+ia_css_connect_buf_queues(unsigned int host2sp_addr,
+	unsigned int desc_addr,
+	unsigned int elems_addr,
+	ia_css_queue_t *qhandle)
+{
+	ia_css_queue_remote_t remoteq;
+	/* Setup queue location as SP and proc id as SP0_ID*/
+	remoteq.location = IA_CSS_QUEUE_LOC_SP;
+	remoteq.proc_id = SP0_ID;
+
+	remoteq.cb_desc_addr = host2sp_addr + desc_addr;
+	remoteq.cb_elems_addr = host2sp_addr + elems_addr;
+
+	/* Initialize the queue instance and obtain handle */
+	ia_css_queue_remote_init(qhandle, &remoteq);
+}
+#endif
+
+static void sh_css_setup_queues(void)
+{
+	enum ia_css_err error;
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_host_sp_queues_initialized;
+	int i;
+
+	for (i = 0; i < MAX_HMM_BUFFER_NUM; i++)
+		hmm_buffer_record_h[i] = NULL;
+
+	sh_css_event_init_irq_mask();
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_queues_initialized =
+		fw->info.sp.host_sp_queues_initialized;
+
+	error = ia_css_bufq_init();
+	if(error != IA_CSS_SUCCESS)
+		return;
+
+		/* set "host_sp_queues_initialized" to "true" */
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(host_sp_queues_initialized),
+		(uint32_t)(1));
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_setup_queues() leave:\n");
+	return;
+}
+
+
+
+static enum ia_css_err
+init_vf_frameinfo_defaults(struct ia_css_pipe *pipe,
+	struct ia_css_frame *vf_frame, unsigned int idx)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	unsigned int thread_id;
+	enum sh_css_queue_id queue_id;
+
+	assert(vf_frame != NULL);
+
+	sh_css_pipe_get_viewfinder_frame_info(pipe, &vf_frame->info, idx);
+	vf_frame->contiguous = false;
+	vf_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME + idx, thread_id, &queue_id);
+	vf_frame->dynamic_data_index = queue_id;
+	vf_frame->buf_type = IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME + idx;
+
+	err = ia_css_frame_init_planes(vf_frame);
+	return err;
+}
+
+static enum ia_css_err
+init_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,
+	struct ia_css_frame *frame)
+{
+	struct ia_css_frame *in_frame;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	unsigned int thread_id;
+	enum sh_css_queue_id queue_id;
+
+	assert(frame != NULL);
+
+	in_frame = frame;
+
+	in_frame->info.format = IA_CSS_FRAME_FORMAT_RAW;
+	in_frame->info.res.width = pipe->stream->config.input_res.width;
+	in_frame->info.res.height = pipe->stream->config.input_res.height;
+	in_frame->info.raw_bit_depth =
+		ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	ia_css_frame_info_set_width(&in_frame->info, pipe->stream->config.input_res.width, 0);
+
+	in_frame->contiguous = false;
+	in_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_INPUT_FRAME, thread_id, &queue_id);
+	in_frame->dynamic_data_index = queue_id;
+	in_frame->buf_type = IA_CSS_BUFFER_TYPE_INPUT_FRAME;
+
+	err = ia_css_frame_init_planes(in_frame);
+
+	return err;
+}
+
+static enum ia_css_err
+init_out_frameinfo_defaults(struct ia_css_pipe *pipe,
+	struct ia_css_frame *out_frame, unsigned int idx)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	unsigned int thread_id;
+	enum sh_css_queue_id queue_id;
+
+	assert(out_frame != NULL);
+
+	sh_css_pipe_get_output_frame_info(pipe, &out_frame->info, idx);
+	out_frame->contiguous = false;
+	out_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx, thread_id, &queue_id);
+	out_frame->dynamic_data_index = queue_id;
+	out_frame->buf_type = IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx;
+	err = ia_css_frame_init_planes(out_frame);
+
+	return err;
+}
+
+/* Create stages for video pipe */
+static enum ia_css_err create_host_video_pipeline(struct ia_css_pipe *pipe)
+{
+	struct ia_css_pipeline_stage_desc stage_desc;
+	struct ia_css_binary *copy_binary, *video_binary, *vf_pp_binary;
+	struct ia_css_pipeline_stage *copy_stage  = NULL;
+	struct ia_css_pipeline_stage *video_stage = NULL;
+	struct ia_css_pipeline_stage *vf_pp_stage = NULL;
+	struct ia_css_pipeline_stage *in_stage    = NULL;
+	struct ia_css_pipeline *me;
+	struct ia_css_frame *in_frame = NULL;
+	struct ia_css_frame *out_frame;
+	struct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_frame *vf_frame;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool resolution_differs;
+	bool need_vf_pp = false;
+	unsigned num_output_pins;
+	bool need_in_frameinfo_memory = false;
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_video_pipeline() enter:\n");
+
+	ia_css_pipe_util_create_output_frames(out_frames);
+	in_frame = &pipe->in_frame_struct;
+	out_frame = &pipe->out_frame_struct;
+	vf_frame = &pipe->vf_frame_struct;
+
+	pipe->out_frame_struct.data = 0;
+	pipe->vf_frame_struct.data = 0;
+
+	/* pipeline already created as part of create_host_pipeline_structure */
+	me = &pipe->pipeline;
+	ia_css_pipeline_clean(me);
+
+	me->dvs_frame_delay = pipe->dvs_frame_delay;
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	/* When the input system is 2401, always enable 'in_frameinfo_memory'
+	 * except for the following: online or continuous
+	 */
+	need_in_frameinfo_memory = !(pipe->stream->config.online || pipe->stream->config.continuous);
+#else
+	/* Construct in_frame info (only in case we have dynamic input */
+	need_in_frameinfo_memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;
+#endif
+
+	/* Construct in_frame info (only in case we have dynamic input */
+	if (need_in_frameinfo_memory) {
+		err = init_in_frameinfo_memory_defaults(pipe, in_frame);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+	} else {
+		in_frame = NULL;
+	}
+
+	out_frame->data = 0;
+	err = init_out_frameinfo_defaults(pipe, out_frame, 0);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+
+	if (!pipe->enable_viewfinder) {
+		/* These situations don't support viewfinder output */
+		vf_frame = NULL;
+	} else {
+		vf_frame->data = 0;
+		err = init_vf_frameinfo_defaults(pipe, vf_frame, 0);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+	}
+
+	copy_binary  = &pipe->pipe_settings.video.copy_binary;
+	video_binary = &pipe->pipe_settings.video.video_binary;
+	vf_pp_binary = &pipe->pipe_settings.video.vf_pp_binary;
+	num_output_pins = video_binary->info->num_output_pins;
+
+	if (pipe->pipe_settings.video.copy_binary.info) {
+		ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+		ia_css_pipe_get_generic_stage_desc(&stage_desc, copy_binary,
+			out_frames, NULL, NULL, NULL);
+		err = ia_css_pipeline_create_and_add_stage(me,
+			&stage_desc,
+			&copy_stage);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+		in_frame = me->stages->args.out_frame[0];
+		in_stage = copy_stage;
+	} else if (pipe->stream->config.continuous) {
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+		/* When continous is enabled, configure in_frame with the
+		 * last pipe, which is the copy pipe.
+		 */
+		in_frame = pipe->stream->last_pipe->continuous_frames[0];
+#else
+		in_frame = pipe->continuous_frames[0];
+#endif
+	}
+
+	resolution_differs =
+		(pipe->vf_output_info[0].res.width != pipe->output_info[0].res.width) ||
+		(pipe->vf_output_info[0].res.height != pipe->output_info[0].res.height);
+
+	need_vf_pp = pipe->enable_viewfinder && ((num_output_pins == 1) ||
+		((num_output_pins == 2) && resolution_differs));
+
+	/* when the video binary supports a second output pin,
+	   it can directly produce the vf_frame.  */
+	ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
+	if(need_vf_pp) {
+		ia_css_pipe_get_generic_stage_desc(&stage_desc, video_binary,
+			out_frames, in_frame, NULL, NULL);
+	} else {
+		ia_css_pipe_get_generic_stage_desc(&stage_desc, video_binary,
+			out_frames, in_frame, NULL, vf_frame);
+	}
+	err = ia_css_pipeline_create_and_add_stage(me,
+			&stage_desc,
+			&video_stage);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+
+	/* If we use copy iso video, the input must be yuv iso raw */
+	if(video_stage) {
+		video_stage->args.copy_vf =
+			video_binary->info->sp.mode == IA_CSS_BINARY_MODE_COPY;
+		video_stage->args.copy_output = video_stage->args.copy_vf;
+	}
+
+	/* when the video binary supports only 1 output pin, vf_pp is needed to
+	produce the vf_frame.*/
+	if (need_vf_pp && video_stage) {
+		err = add_vf_pp_stage(pipe, vf_frame, vf_pp_binary,
+				      video_stage, &vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+	}
+
+	pipe->pipeline.acquire_isp_each_stage = false;
+	ia_css_pipeline_finalize_stages(&pipe->pipeline);
+
+	if (video_stage) {
+		int i;
+		for (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++) {
+			video_stage->args.tnr_frames[i] =
+				pipe->pipe_settings.video.tnr_frames[i];
+		}
+		for (i = 0; i < NUM_VIDEO_DELAY_FRAMES; i++) {
+			video_stage->args.delay_frames[i] =
+				pipe->pipe_settings.video.delay_frames[i];
+		}
+	}
+
+	/* update the arguments with the latest info */
+	if (video_stage)
+		video_stage->args.out_frame[0] = out_frame;
+
+	if (vf_pp_stage)
+		vf_pp_stage->args.out_frame[0] = vf_frame;
+
+	if (pipe->stream->config.continuous) {
+		if (video_stage)
+			video_stage->args.in_frame =  pipe->continuous_frames[0];
+	}
+
+	configure_pipe_inout_port(&pipe->pipeline,
+		pipe->stream->config.continuous);
+
+ERR:
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_video_pipeline() leave: return (%x)\n", err);
+	return err;
+}
+
+static enum ia_css_err
+create_host_acc_pipeline(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	unsigned int i;
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"create_host_acc_pipeline() enter\n");
+
+	pipe->pipeline.num_execs = pipe->config.acc_num_execs;
+
+	for (i=0; i<pipe->config.num_acc_stages; i++) {
+		struct ia_css_fw_info *fw = pipe->config.acc_stages[i];
+		err = sh_css_pipeline_add_acc_stage(&pipe->pipeline, fw);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+	}
+
+	ia_css_pipeline_finalize_stages(&pipe->pipeline);
+	configure_pipe_inout_port(&pipe->pipeline, false);
+
+ERR:
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"create_host_acc_pipeline() leave: return(%d)\n", err);
+	return err;
+}
+
+/* Create stages for preview */
+static enum ia_css_err
+create_host_preview_pipeline(struct ia_css_pipe *pipe)
+{
+	struct ia_css_pipeline_stage *post_stage;
+	struct ia_css_pipeline_stage_desc stage_desc;
+	struct ia_css_pipeline_stage *preview_stage, *out_stage = NULL;
+	struct ia_css_pipeline *me = NULL;
+	struct ia_css_binary *copy_binary, *preview_binary, *vf_pp_binary = NULL;
+	struct ia_css_frame *in_frame = NULL, *cc_frame = NULL;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_frame *out_frame;
+	struct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	bool need_in_frameinfo_memory = false;
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	bool sensor = false;
+	bool buffered_sensor = false;
+	bool online = false;
+	bool continuous = false;
+#endif
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"create_host_preview_pipeline(): enter\n");
+
+	ia_css_pipe_util_create_output_frames(out_frames);
+	/* pipeline already created as part of create_host_pipeline_structure */
+	me = &pipe->pipeline;
+	ia_css_pipeline_clean(me);
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	/* When the input system is 2401, always enable 'in_frameinfo_memory'
+	 * except for the following:
+	 * - Direct Sensor Mode Online Preview
+	 * - Buffered Sensor Mode Online Preview
+	 * - Direct Sensor Mode Continuous Preview
+	 * - Buffered Sensor Mode Continous Preview
+	 */
+	sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR);
+	buffered_sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR);
+	online = pipe->stream->config.online;
+	continuous = pipe->stream->config.continuous;
+	need_in_frameinfo_memory =
+		!((sensor && (online || continuous)) || (buffered_sensor && (online || continuous)));
+#else
+	/* Construct in_frame info (only in case we have dynamic input */
+	need_in_frameinfo_memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;
+#endif
+	if (need_in_frameinfo_memory) {
+		err = init_in_frameinfo_memory_defaults(pipe, &me->in_frame);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+
+		in_frame = &me->in_frame;
+	} else {
+		in_frame = NULL;
+	}
+
+	err = init_out_frameinfo_defaults(pipe, &me->out_frame[0], 0);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+	out_frame = &me->out_frame[0];
+
+	copy_binary    = &pipe->pipe_settings.preview.copy_binary;
+	preview_binary = &pipe->pipe_settings.preview.preview_binary;
+	if (pipe->pipe_settings.preview.vf_pp_binary.info)
+		vf_pp_binary = &pipe->pipe_settings.preview.vf_pp_binary;
+
+	if (pipe->pipe_settings.preview.copy_binary.info) {
+		ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+		ia_css_pipe_get_generic_stage_desc(&stage_desc, copy_binary,
+			out_frames, NULL, NULL, NULL);
+		err = ia_css_pipeline_create_and_add_stage(me,
+				&stage_desc,
+				&post_stage);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+		in_frame = me->stages->args.out_frame[0];
+	} else {
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+		/* When continuous is enabled, configure in_frame with the
+		 * last pipe, which is the copy pipe.
+		 */
+		if (continuous)
+			in_frame = pipe->stream->last_pipe->continuous_frames[0];
+#else
+		in_frame = pipe->continuous_frames[0];
+#endif
+	}
+
+	if (vf_pp_binary) {
+		ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+		ia_css_pipe_get_generic_stage_desc(&stage_desc, preview_binary,
+			out_frames, in_frame, cc_frame, NULL);
+	} else {
+		ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
+		ia_css_pipe_get_generic_stage_desc(&stage_desc, preview_binary,
+			out_frames, in_frame, cc_frame, NULL);
+	}
+	err = ia_css_pipeline_create_and_add_stage(me,
+		&stage_desc,
+		&post_stage);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+	/* If we use copy iso preview, the input must be yuv iso raw */
+	post_stage->args.copy_vf =
+		preview_binary->info->sp.mode == IA_CSS_BINARY_MODE_COPY;
+	post_stage->args.copy_output = !post_stage->args.copy_vf;
+	if (post_stage->args.copy_vf && !post_stage->args.out_vf_frame) {
+		/* in case of copy, use the vf frame as output frame */
+		post_stage->args.out_vf_frame =
+			post_stage->args.out_frame[0];
+	}
+	if (vf_pp_binary) {
+		err = add_vf_pp_stage(pipe, out_frame, vf_pp_binary,
+				post_stage, &out_stage);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+	}
+
+	pipe->pipeline.acquire_isp_each_stage = false;
+	ia_css_pipeline_finalize_stages(&pipe->pipeline);
+
+	if (vf_pp_binary) {
+		err = ia_css_pipeline_get_output_stage(me, IA_CSS_BINARY_MODE_VF_PP,
+						       &out_stage);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+	}
+
+	err = ia_css_pipeline_get_stage(me, preview_binary->info->sp.mode,
+					&preview_stage);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+
+	if (!out_stage)
+		out_stage = preview_stage;
+
+	out_stage->args.out_frame[0] = out_frame;
+	if (pipe->stream->config.continuous) {
+		preview_stage->args.in_frame = pipe->continuous_frames[0];
+	}
+
+	configure_pipe_inout_port(&pipe->pipeline,
+		pipe->stream->config.continuous);
+
+ERR:
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"create_host_preview_pipeline() leave: return(%d)\n", err);
+	return err;
+}
+
+static void send_raw_frames(struct ia_css_pipe *pipe)
+{
+	if (pipe->stream->config.continuous) {
+		struct ia_css_frame *in_frame = NULL;
+		unsigned int i;
+
+		in_frame = pipe->continuous_frames[0];
+
+		sh_css_update_host2sp_cont_num_raw_frames
+			(pipe->stream->config.init_num_cont_raw_buf, true);
+		sh_css_update_host2sp_cont_num_raw_frames
+			(pipe->stream->config.target_num_cont_raw_buf, false);
+
+		/* Hand-over all the SP-internal buffers */
+		for (i = 0; i < pipe->stream->config.init_num_cont_raw_buf; i++) {
+			sh_css_update_host2sp_offline_frame(i,
+				pipe->continuous_frames[i], pipe->cont_md_buffers[i]);
+		}
+	}
+
+	return;
+}
+
+static enum ia_css_err
+preview_start(struct ia_css_pipe *pipe)
+{
+	struct ia_css_pipeline *me ;
+	struct ia_css_binary *copy_binary, *preview_binary, *vf_pp_binary = NULL;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_pipe *copy_pipe, *capture_pipe;
+	enum sh_css_pipe_config_override copy_ovrd;
+	enum ia_css_input_mode preview_pipe_input_mode;
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	struct ia_css_pipe *target_pipe = NULL;
+#endif
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	me = &pipe->pipeline;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+	"preview_start() enter: void\n");
+
+	preview_pipe_input_mode = pipe->stream->config.mode;
+
+	copy_pipe    = pipe->pipe_settings.preview.copy_pipe;
+	capture_pipe = pipe->pipe_settings.preview.capture_pipe;
+
+	copy_binary    = &pipe->pipe_settings.preview.copy_binary;
+	preview_binary = &pipe->pipe_settings.preview.preview_binary;
+	if (pipe->pipe_settings.preview.vf_pp_binary.info)
+		vf_pp_binary = &pipe->pipe_settings.preview.vf_pp_binary;
+
+	sh_css_metrics_start_frame();
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* multi stream video needs mipi buffers */
+	send_mipi_frames(pipe);
+#endif
+	send_raw_frames(pipe);
+
+	{
+		unsigned int thread_id;
+
+		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+		copy_ovrd = 1 << thread_id;
+
+		if (pipe->stream->cont_capt) {
+			ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(capture_pipe), &thread_id);
+			copy_ovrd |= 1 << thread_id;
+		}
+	}
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#if defined(USE_INPUT_SYSTEM_VERSION_2)
+	err = sh_css_config_input_network(pipe, copy_binary);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+#elif defined(USE_INPUT_SYSTEM_VERSION_2401)
+	if (pipe->stream->config.continuous) {
+		/* make the copy pipe create/own the ISYS stream */
+		target_pipe = copy_pipe;
+	} else {
+		/* make the preview pipe create/own the ISYS stream */
+		target_pipe = pipe;
+	}
+
+	err = sh_css_config_input_network(target_pipe, NULL);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+#endif
+#endif /* !HAS_NO_INPUT_SYSTEM */
+
+	/* Construct and load the copy pipe */
+	if (pipe->stream->config.continuous) {
+		sh_css_sp_init_pipeline(&copy_pipe->pipeline,
+			IA_CSS_PIPE_ID_COPY,
+			(uint8_t)ia_css_pipe_get_pipe_num(copy_pipe),
+			false,
+			pipe->stream->config.pixels_per_clock == 2, false,
+			false, pipe->required_bds_factor,
+			copy_ovrd,
+			pipe->stream->config.mode,
+			&pipe->stream->config.metadata_config,
+			&pipe->stream->info.metadata_info
+#if !defined(HAS_NO_INPUT_SYSTEM)
+			, pipe->stream->config.source.port.port
+#endif
+			);
+
+		/* make the preview pipe start with mem mode input, copy handles
+		   the actual mode */
+		preview_pipe_input_mode = IA_CSS_INPUT_MODE_MEMORY;
+	}
+
+	/* Construct and load the capture pipe */
+	if (pipe->stream->cont_capt) {
+		sh_css_sp_init_pipeline(&capture_pipe->pipeline,
+			IA_CSS_PIPE_ID_CAPTURE,
+			(uint8_t)ia_css_pipe_get_pipe_num(capture_pipe),
+			pipe->config.default_capture_config.enable_xnr,
+			capture_pipe->stream->config.pixels_per_clock == 2,
+			true, /* continuous */
+			false, /* offline */
+			capture_pipe->required_bds_factor,
+			0,
+			IA_CSS_INPUT_MODE_MEMORY,
+			&pipe->stream->config.metadata_config,
+			&pipe->stream->info.metadata_info
+#if !defined(HAS_NO_INPUT_SYSTEM)
+			, (mipi_port_ID_t)0
+#endif
+			);
+	}
+
+	err = start_pipe(pipe, copy_ovrd, preview_pipe_input_mode);
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+ERR:
+#endif
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"preview_start() leave: return (%d)\n", err);
+	return err;
+}
+
+enum ia_css_err
+ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
+			   const struct ia_css_buffer *buffer)
+{
+	enum ia_css_err return_err = IA_CSS_SUCCESS;
+	unsigned int thread_id, i;
+	enum sh_css_queue_id queue_id;
+	struct ia_css_pipeline *pipeline;
+	struct ia_css_pipeline_stage *stage;
+	struct ia_css_rmgr_vbuf_handle p_vbuf;
+	struct ia_css_rmgr_vbuf_handle *h_vbuf;
+	struct sh_css_hmm_buffer ddr_buffer;
+	enum ia_css_buffer_type buf_type;
+	enum ia_css_pipe_id pipe_id;
+
+	if (pipe == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (buffer == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	buf_type = buffer->type;
+	pipe_id = pipe->mode;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipe_enqueue_buffer() enter: pipe_id=%d, buf_type=%d, buffer=%p\n",
+		pipe_id, buf_type, buffer);
+
+	assert(pipe_id < IA_CSS_PIPE_ID_NUM);
+	assert(buf_type < IA_CSS_NUM_DYNAMIC_BUFFER_TYPE);
+	if ((buf_type == IA_CSS_BUFFER_TYPE_INVALID) ||
+	    (buf_type >= IA_CSS_NUM_DYNAMIC_BUFFER_TYPE) ||
+	    (pipe_id >= IA_CSS_PIPE_ID_NUM))
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	//ia_css_pipeline_get_sp_thread_id(pipe_id, &thread_id);
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+
+	ia_css_query_internal_queue_id(buf_type, thread_id, &queue_id);
+	if ((queue_id <= SH_CSS_INVALID_QUEUE_ID) || (queue_id >= SH_CSS_MAX_NUM_QUEUES))
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (!sh_css_sp_is_running()) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_pipe_enqueue_buffer() leaving:"
+			"queues unavailable\n");
+		/* SP is not running. The queues are not valid */
+		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+
+
+	pipeline = &pipe->pipeline;
+
+	assert(pipeline != NULL ||
+	       pipe_id == IA_CSS_PIPE_ID_COPY ||
+	       pipe_id == IA_CSS_PIPE_ID_ACC);
+
+	assert(sizeof(NULL) <= sizeof(ddr_buffer.kernel_ptr));
+	ddr_buffer.kernel_ptr = HOST_ADDRESS(NULL);
+	ddr_buffer.cookie_ptr = buffer->driver_cookie;
+
+	if (buf_type == IA_CSS_BUFFER_TYPE_3A_STATISTICS) {
+		if (buffer->data.stats_3a == NULL)
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+		ddr_buffer.kernel_ptr = HOST_ADDRESS(buffer->data.stats_3a);
+		ddr_buffer.payload.s3a = *buffer->data.stats_3a;
+	} else if (buf_type == IA_CSS_BUFFER_TYPE_DIS_STATISTICS) {
+		if (buffer->data.stats_dvs == NULL)
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+		ddr_buffer.kernel_ptr = HOST_ADDRESS(buffer->data.stats_dvs);
+		ddr_buffer.payload.dis = *buffer->data.stats_dvs;
+#if defined(IS_ISP_2500_SYSTEM)
+	} else if (buf_type == IA_CSS_BUFFER_TYPE_LACE_STATISTICS) {
+		if (buffer->data.stats_acc_lace == 0)
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+		ddr_buffer.kernel_ptr = HOST_ADDRESS(buffer->data.stats_acc_lace);
+		ddr_buffer.payload.lace_stat = buffer->data.stats_acc_lace;
+#endif
+	} else if (buf_type == IA_CSS_BUFFER_TYPE_METADATA) {
+		ddr_buffer.kernel_ptr = HOST_ADDRESS(buffer->data.metadata);
+		ddr_buffer.payload.metadata = *buffer->data.metadata;
+	} else if ((buf_type == IA_CSS_BUFFER_TYPE_INPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME)) {
+		if (buffer->data.frame == NULL)
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+		ddr_buffer.kernel_ptr = HOST_ADDRESS(buffer->data.frame);
+		ddr_buffer.payload.frame.frame_data = buffer->data.frame->data;
+		ddr_buffer.payload.frame.flashed = 0;
+#if CONFIG_ON_FRAME_ENQUEUE()
+		return_err = set_config_on_frame_enqueue(
+				&buffer->data.frame->info,
+				&ddr_buffer.payload.frame);
+		if (IA_CSS_SUCCESS != return_err)
+			return return_err;
+#endif
+	}
+
+
+
+	/* start of test for using rmgr for acq/rel memory */
+	p_vbuf.vptr = 0;
+	p_vbuf.count = 0;
+	p_vbuf.size = sizeof(struct sh_css_hmm_buffer);
+	h_vbuf = &p_vbuf;
+	// TODO: change next to correct pool for optimization
+	ia_css_rmgr_acq_vbuf(hmm_buffer_pool, &h_vbuf);
+
+	assert(h_vbuf != NULL);
+	assert(h_vbuf->vptr != 0x0);
+
+	if ((h_vbuf == NULL) || (h_vbuf->vptr == 0x0))
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	mmgr_store(h_vbuf->vptr,
+				(void *)(&ddr_buffer),
+				sizeof(struct sh_css_hmm_buffer));
+	if ((buf_type == IA_CSS_BUFFER_TYPE_3A_STATISTICS)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_DIS_STATISTICS)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_LACE_STATISTICS)) {
+		assert(pipeline != NULL);
+		for (stage = pipeline->stages; stage; stage = stage->next) {
+			/* The SP will read the params
+				after it got empty 3a and dis */
+			if (STATS_ENABLED(stage)) {
+				/* there is a stage that needs it */
+				return_err = ia_css_bufq_enqueue_buffer(thread_id,
+								queue_id,
+								(uint32_t)h_vbuf->vptr);
+			}
+		}
+	} else if ((buf_type == IA_CSS_BUFFER_TYPE_INPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME)
+		|| (buf_type == IA_CSS_BUFFER_TYPE_METADATA)) {
+			return_err = ia_css_bufq_enqueue_buffer(thread_id,
+							queue_id,
+							(uint32_t)h_vbuf->vptr);
+	}
+
+	if (return_err == IA_CSS_SUCCESS) {
+		for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
+			if (hmm_buffer_record_h[i] == NULL) {
+				hmm_buffer_record_h[i] = h_vbuf;
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+					     "ia_css_pipe_enqueue_buffer()"
+					     " send vbuf=%x\n",h_vbuf);
+				break;
+			}
+		}
+	} else {
+		ia_css_rmgr_rel_vbuf(hmm_buffer_pool, &h_vbuf);
+	}
+
+		/*
+		 * Tell the SP which queues are not empty,
+		 * by sending the software event.
+		 */
+	if (return_err == IA_CSS_SUCCESS)
+		if (!sh_css_sp_is_running()) {
+			/* SP is not running. The queues are not valid */
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_pipe_enqueue_buffer() leaving:"
+				"queues unavailable\n");
+			return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+		}
+		return_err = ia_css_bufq_enqueue_event(
+				SP_SW_EVENT_ID_1,
+				(uint8_t)thread_id,
+				queue_id,
+				0);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipe_enqueue_buffer() leave: return_err=%d\n",return_err);
+
+	return return_err;
+}
+
+/*
+ * TODO: Free up the hmm memory space.
+	 */
+enum ia_css_err
+ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
+			   struct ia_css_buffer *buffer)
+{
+	enum ia_css_err return_err;
+	enum sh_css_queue_id queue_id;
+	hrt_vaddress ddr_buffer_addr;
+	struct sh_css_hmm_buffer ddr_buffer;
+	unsigned int i, found_record;
+	enum ia_css_buffer_type buf_type;
+	enum ia_css_pipe_id pipe_id;
+	unsigned int thread_id;
+
+	if (buffer == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (pipe == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	pipe_id = pipe->mode;
+
+	buf_type = buffer->type;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipe_dequeue_buffer() enter: pipe_id=%d, buf_type=%d\n",
+		(int)pipe_id, buf_type);
+
+	ddr_buffer.kernel_ptr = 0;
+
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ia_css_query_internal_queue_id(buf_type, thread_id, &queue_id);
+	if ((queue_id <= SH_CSS_INVALID_QUEUE_ID) || (queue_id >= SH_CSS_MAX_NUM_QUEUES))
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (!sh_css_sp_is_running()) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_pipe_dequeue_buffer() leaving:"
+			"queues unavailable\n");
+		/* SP is not running. The queues are not valid */
+		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+
+	return_err = ia_css_bufq_dequeue_buffer(queue_id,
+		(uint32_t *)&ddr_buffer_addr);
+
+	if (return_err == IA_CSS_SUCCESS) {
+		struct ia_css_frame *frame;
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			     "ia_css_pipe_dequeue_buffer() receive vbuf=%x\n",
+			     (int)ddr_buffer_addr);
+
+		found_record = 0;
+		for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
+			if (hmm_buffer_record_h[i] != NULL && hmm_buffer_record_h[i]->vptr == ddr_buffer_addr) {
+				ia_css_rmgr_rel_vbuf(hmm_buffer_pool, &hmm_buffer_record_h[i]);
+				hmm_buffer_record_h[i] = NULL;
+				found_record = 1;
+				break;
+			}
+		}
+
+		assert(found_record == 1);
+
+		mmgr_load(ddr_buffer_addr,
+				&ddr_buffer,
+				sizeof(struct sh_css_hmm_buffer));
+
+		assert(ddr_buffer.kernel_ptr != 0);
+
+		/* if the pointer is 0 we only want to return an error;
+		   we do not want to touch buffer
+		*/
+		if (ddr_buffer.kernel_ptr == 0)
+			return_err = IA_CSS_ERR_INTERNAL_ERROR;
+		else {
+			/* buffer->exp_id : all instances to be removed later once the driver change
+			 * is completed. See patch #5758 for reference */
+			buffer->exp_id = 0;
+			buffer->driver_cookie = ddr_buffer.cookie_ptr;
+
+			switch (buf_type) {
+			case IA_CSS_BUFFER_TYPE_INPUT_FRAME:
+			case IA_CSS_BUFFER_TYPE_OUTPUT_FRAME:
+			case IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME:
+				if ((pipe) && (pipe->stop_requested == true))
+				{
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+					free_mipi_frames(pipe, false);
+#endif
+					pipe->stop_requested = false;
+				}
+			case IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
+			case IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME:
+				frame = (struct ia_css_frame*)HOST_ADDRESS(ddr_buffer.kernel_ptr);
+				buffer->data.frame = frame;
+				buffer->exp_id = ddr_buffer.payload.frame.exp_id;
+				frame->exp_id = ddr_buffer.payload.frame.exp_id;
+				/* JWU */
+				frame->frame_nr= ddr_buffer.payload.frame.frame_nr;
+				frame->isp_config_id = ddr_buffer.payload.frame.isp_parameters_id;
+				if (ddr_buffer.payload.frame.flashed == 1)
+					frame->flash_state =
+						IA_CSS_FRAME_FLASH_STATE_PARTIAL;
+				if (ddr_buffer.payload.frame.flashed == 2)
+					frame->flash_state =
+						IA_CSS_FRAME_FLASH_STATE_FULL;
+				frame->valid = pipe->num_invalid_frames == 0;
+				if (!frame->valid)
+					pipe->num_invalid_frames--;
+				if (frame->info.format == IA_CSS_FRAME_FORMAT_BINARY_8) {
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+					frame->planes.binary.size = frame->data_bytes;
+#else
+					frame->planes.binary.size =
+					    sh_css_sp_get_binary_copy_size();
+#endif
+				}
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,"ia_css_pipe_dequeue_buffer() pipe number=%d, frame number=%p\n", pipe->pipe_num, frame->frame_nr);
+				break;
+			case IA_CSS_BUFFER_TYPE_3A_STATISTICS:
+				buffer->data.stats_3a =
+					(struct ia_css_isp_3a_statistics*)HOST_ADDRESS(ddr_buffer.kernel_ptr);
+				buffer->exp_id = ddr_buffer.payload.s3a.exp_id;
+				buffer->data.stats_3a->exp_id = ddr_buffer.payload.s3a.exp_id;
+				break;
+			case IA_CSS_BUFFER_TYPE_DIS_STATISTICS:
+				buffer->data.stats_dvs =
+					(struct ia_css_isp_dvs_statistics*)HOST_ADDRESS(ddr_buffer.kernel_ptr);
+				buffer->exp_id = ddr_buffer.payload.dis.exp_id;
+				buffer->data.stats_dvs->exp_id = ddr_buffer.payload.dis.exp_id;
+				break;
+			case IA_CSS_BUFFER_TYPE_LACE_STATISTICS:
+#if defined(IS_ISP_2500_SYSTEM)
+				buffer->data.stats_acc_lace =
+					(ia_css_ptr)HOST_ADDRESS(ddr_buffer.kernel_ptr);
+#endif
+				break;
+			case IA_CSS_BUFFER_TYPE_METADATA:
+				buffer->data.metadata =
+					(struct ia_css_metadata*)HOST_ADDRESS(ddr_buffer.kernel_ptr);
+				buffer->exp_id = ddr_buffer.payload.metadata.exp_id;
+				buffer->data.metadata->exp_id = ddr_buffer.payload.metadata.exp_id;
+				break;
+			default:
+				return_err = IA_CSS_ERR_INTERNAL_ERROR;
+				break;
+			}
+		}
+	}
+
+
+	/*
+	 * Tell the SP which queues are not full,
+	 * by sending the software event.
+	 */
+	if (return_err == IA_CSS_SUCCESS){
+		if (!sh_css_sp_is_running()) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_pipe_dequeue_buffer() leaving:"
+				"queues unavailable\n");
+			/* SP is not running. The queues are not valid */
+			return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+		}
+		ia_css_bufq_enqueue_event(SP_SW_EVENT_ID_2,
+					0,
+					queue_id,
+					0);
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipe_dequeue_buffer() leave: buffer=%p\n", buffer);
+
+	return return_err;
+}
+
+/*
+ * Cannot Move this to event module as it is of ia_css_event_type which is declared in ia_css.h
+ * TODO: modify and move it if possible.
+ * */
+static enum ia_css_event_type convert_event_sp_to_host_domain[] = {
+	IA_CSS_EVENT_TYPE_OUTPUT_FRAME_DONE,	/**< Output frame ready. */
+	IA_CSS_EVENT_TYPE_SECOND_OUTPUT_FRAME_DONE,	/**< Second output frame ready. */
+	IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE,	/**< Viewfinder Output frame ready. */
+	IA_CSS_EVENT_TYPE_SECOND_VF_OUTPUT_FRAME_DONE,	/**< Second viewfinder Output frame ready. */
+	IA_CSS_EVENT_TYPE_3A_STATISTICS_DONE,	/**< Indication that 3A statistics are available. */
+	IA_CSS_EVENT_TYPE_DIS_STATISTICS_DONE,	/**< Indication that DIS statistics are available. */
+	IA_CSS_EVENT_TYPE_PIPELINE_DONE,	/**< Pipeline Done event, sent after last pipeline stage. */
+	IA_CSS_EVENT_TYPE_FRAME_TAGGED,		/**< Frame tagged. */
+	IA_CSS_EVENT_TYPE_INPUT_FRAME_DONE,	/**< Input frame ready. */
+	IA_CSS_EVENT_TYPE_METADATA_DONE,	/**< Metadata ready. */
+	IA_CSS_EVENT_TYPE_LACE_STATISTICS_DONE,	/**< Indication that LACE statistics are available. */
+	IA_CSS_EVENT_TYPE_PORT_EOF,		/**< End Of Frame event, sent when in buffered sensor mode.  MUST BE LAST */
+	0,					/** error if sp passes  SH_CSS_SP_EVENT_NR_OF_TYPES as a valid event. */
+};
+
+enum ia_css_err
+ia_css_dequeue_event(struct ia_css_event *event)
+{
+	enum ia_css_pipe_id pipe_id;
+	uint8_t payload[4] = {0,0,0,0};
+	enum ia_css_err ret_err;
+
+	if (event == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+        /*TODO:
+	 * a) use generic decoding function , same as the one used by sp.
+	 * b) group decode and dequeue into eventQueue module
+	 */
+	if (!sh_css_sp_is_running()) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_dequeue_event() leaving:"
+			"queues unavailable\n");
+		/* SP is not running. The queues are not valid */
+		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+
+	/* dequeue the IRQ event */
+	/* check whether the IRQ event is available or not */
+
+	ret_err = ia_css_bufq_dequeue_event(payload);
+	if (ret_err != IA_CSS_SUCCESS) {
+		/* ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_bufq_dequeue_event() returned error\n"); */
+		return ret_err;
+	} else {
+		/*
+		 * Tell the SP which queues are not full,
+		 * by sending the software event.
+		 */
+		/* No need to check here as queue is definetly initialized
+		 * by the time we reach here.*/
+		ia_css_bufq_enqueue_event(SP_SW_EVENT_ID_3, 0, 0, 0);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_dequeue_event() enter: queue not empty\n");
+	/*  queue contains an event, it is decoded into 4 bytes of payload,
+	 *  convert sp event type in payload to host event type,
+	 *  TODO: can this enum conversion be eliminated */
+	event->type = convert_event_sp_to_host_domain[payload[0]];
+	pipe_id = (enum ia_css_pipe_id)payload[2];
+
+	if (event->type != IA_CSS_EVENT_TYPE_PORT_EOF) {
+		/* pipe related events */
+		event->pipe = find_pipe_by_num(payload[1]);
+		if (!event->pipe)
+		{
+			/* an event is generated of a port that is not longer available*/
+			return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+		}
+		event->port = 0;
+		event->exp_id = 0;
+		if (event->type == IA_CSS_EVENT_TYPE_FRAME_TAGGED)
+		{
+			/* find the capture pipe that goes with this */
+			int i, n;
+			n = event->pipe->stream->num_pipes;
+			for (i = 0; i < n; i++)
+			{
+				if (event->pipe->stream->pipes[i]->config.mode == IA_CSS_PIPE_MODE_CAPTURE)
+				{
+					event->pipe = event->pipe->stream->pipes[i];
+					break;
+				}
+			}
+			event->exp_id = payload[3];
+		}
+	}
+	else {
+		/* handle IA_CSS_EVENT_TYPE_PORT_EOF */
+		/* event is not directly correlated to a pipe */
+		event->pipe = NULL;
+		event->port = payload[1];
+		event->exp_id = payload[3];
+	}
+#if 0
+  /* temporary debug code to dump the intermediate vf buffer to raw file*/
+	if (event->type == IA_CSS_EVENT_TYPE_VF_OUTPUT_FRAME_DONE)
+	{
+	  static int count = 0;
+	  FILE* fp;
+    char *xmem_y_addr  = (char*)(event->pipe->pipeline.stages->args.out_vf_frame->data + event->pipe->pipeline.stages->args.out_vf_frame->planes.yuyv.offset);
+    unsigned stride = event->pipe->pipeline.stages->args.out_vf_frame->planes.yuyv.stride;
+    unsigned height = event->pipe->pipeline.stages->args.out_vf_frame->planes.yuyv.height;
+    //printf ("init_frame_pointers format %d\n", stage->frames.in.info.format);
+    //if (stage->frames.in.info.format == IA_CSS_FRAME_FORMAT_YUV_LINE) {
+    unsigned char pixel;
+    unsigned char buf[5000];
+    unsigned int i;
+    mmgr_load(xmem_y_addr, &pixel, sizeof(char));
+    printf ("vf_pp: line 0 pixel %d\n", pixel);
+    mmgr_load(xmem_y_addr+stride, &pixel, sizeof(char));
+    printf ("vf_pp: line 1 pixel %d\n", pixel);
+    mmgr_load(xmem_y_addr+2*stride, &pixel, sizeof(char));
+    printf ("vf_pp: line 2 pixel %d\n", pixel);
+    mmgr_load(xmem_y_addr+3*stride, &pixel, sizeof(char));
+    printf ("vf_pp: line 3 pixel %d\n", pixel);
+
+    fp = fopen("dump.raw", "w+");
+
+    for (i=0; i< height/2; i++)
+    {
+      mmgr_load(xmem_y_addr, buf, stride);
+      fwrite(buf, 1, stride, fp);
+      xmem_y_addr += stride;
+      mmgr_load(xmem_y_addr, buf, stride);
+      fwrite(buf, 1, stride, fp);
+      xmem_y_addr += stride;
+      xmem_y_addr += stride;
+
+    }
+    fclose(fp);
+
+    count++;
+	}
+#endif
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_dequeue_event() leave: pipe_id=%d, event_id=%d\n",
+				pipe_id, event->type);
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+acc_start(struct ia_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	return start_pipe(pipe, SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD,
+			pipe->stream->config.mode);
+}
+
+static enum ia_css_err
+sh_css_pipe_start(struct ia_css_stream *stream)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	struct ia_css_pipe *pipe;
+	enum ia_css_pipe_id pipe_id;
+	unsigned int thread_id;
+
+	assert(stream != NULL);
+	pipe = stream->last_pipe;
+	assert(pipe != NULL);
+
+	pipe_id = pipe->mode;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_pipe_start() enter: pipe_id=%d\n", pipe_id);
+#ifdef __KERNEL__
+	printk("sh_css_pipe_start() enter: pipe_id=%d\n", pipe_id);
+#endif
+
+	if(stream->started == true) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"Cannot start stream that is already started\n");
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"sh_css_pipe_start() leave: return_err=%d\n", err);
+		return err;
+	}
+
+	pipe->stop_requested = false;
+
+	switch (pipe_id) {
+	case IA_CSS_PIPE_ID_PREVIEW:
+		err = preview_start(pipe);
+		break;
+	case IA_CSS_PIPE_ID_VIDEO:
+		err = video_start(pipe);
+		break;
+	case IA_CSS_PIPE_ID_CAPTURE:
+		err = capture_start(pipe);
+		break;
+	case IA_CSS_PIPE_ID_YUVPP:
+		err = yuvpp_start(pipe);
+		break;
+	case IA_CSS_PIPE_ID_ACC:
+		err = acc_start(pipe);
+		break;
+	default:
+		err = IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	if (err != IA_CSS_SUCCESS) {
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_pipe_start() leave: return_err=%d\n", err);
+		return err;
+	}
+
+	/* Force ISP parameter calculation after a mode change
+	 * Acceleration API examples pass NULL for stream but they
+	 * don't use ISP parameters anyway. So this should be okay.
+	 * The SP binary (jpeg) copy does not use any parameters.
+	 */
+	if (!copy_on_sp(pipe)) {
+		sh_css_invalidate_params(stream);
+		err = sh_css_param_update_isp_params(stream, true, NULL);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	ia_css_debug_pipe_graph_dump_epilogue();
+
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+
+	if (!sh_css_sp_is_running()) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"sh_css_pipe_start() leaving:"
+			"queue unavailable\n");
+		/* SP is not running. The queues are not valid */
+		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+	ia_css_bufq_enqueue_event(SP_SW_EVENT_ID_4, (uint8_t)thread_id, 0, 0);
+
+	/* in case of continuous capture mode, we also start capture thread and copy thread*/
+	if (pipe->stream->config.continuous) {
+		struct ia_css_pipe *copy_pipe = NULL;
+
+		if (pipe_id == IA_CSS_PIPE_ID_PREVIEW)
+			copy_pipe = pipe->pipe_settings.preview.copy_pipe;
+		else if (pipe_id == IA_CSS_PIPE_ID_VIDEO)
+			copy_pipe = pipe->pipe_settings.video.copy_pipe;
+
+		assert(copy_pipe != NULL);
+		if (copy_pipe == NULL)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(copy_pipe), &thread_id);
+		 /* by the time we reach here q is initialized and handle is available.*/
+		ia_css_bufq_enqueue_event(SP_SW_EVENT_ID_4, (uint8_t)thread_id, 0,  0);
+	}
+	if (pipe->stream->cont_capt) {
+		struct ia_css_pipe *capture_pipe = NULL;
+		if (pipe_id == IA_CSS_PIPE_ID_PREVIEW)
+			capture_pipe = pipe->pipe_settings.preview.capture_pipe;
+		else if (pipe_id == IA_CSS_PIPE_ID_VIDEO)
+			capture_pipe = pipe->pipe_settings.video.capture_pipe;
+
+		assert(capture_pipe != NULL);
+		if (capture_pipe == NULL)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(capture_pipe), &thread_id);
+		 /* by the time we reach here q is initialized and handle is available.*/
+		ia_css_bufq_enqueue_event(SP_SW_EVENT_ID_4, (uint8_t)thread_id, 0,  0);
+	}
+
+	stream->started = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_pipe_start() leave: return_err=%d\n", err);
+	return err;
+}
+
+#if 0
+static enum ia_css_err sh_css_pipeline_stop(
+	struct ia_css_pipe *pipe)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipeline_stop() enter\n");
+	(void)pipe;
+	/* TO BE IMPLEMENTED */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipeline_stop() exit\n");
+	return IA_CSS_SUCCESS;
+}
+#endif
+
+/* this is a legacy from CSS 1.5, we still need this here because we need this info
+   to configure the sensor ouput in CameraDriver, but it is not needed in real device.
+   add this macro to make this explicit. */
+#if defined(HRT_CSIM) || defined(HRT_RTL)
+static enum ia_css_err
+sh_css_pipe_get_input_resolution(struct ia_css_pipe *pipe,
+				 unsigned int *width,
+				 unsigned int *height)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+	assert(width != NULL);
+	assert(height != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_get_input_resolution() enter: void\n");
+	if (pipe->mode == IA_CSS_PIPE_ID_CAPTURE &&
+	    copy_on_sp(pipe) &&
+	    pipe->stream->config.format == IA_CSS_STREAM_FORMAT_BINARY_8) {
+		*width  = JPEG_BYTES;
+		*height = 1;
+		return IA_CSS_SUCCESS;
+	}
+
+	{
+		const struct ia_css_binary *binary = NULL;
+		if (pipe->mode == IA_CSS_PIPE_ID_PREVIEW) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+				"sh_css_pipe_get_input_resolution: preview\n");
+			if (pipe->pipe_settings.preview.copy_binary.info)
+				binary = &pipe->pipe_settings.preview.copy_binary;
+			else
+				binary = &pipe->pipe_settings.preview.preview_binary;
+
+		} else if (pipe->mode == IA_CSS_PIPE_ID_VIDEO) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+				"sh_css_pipe_get_input_resolution: video\n");
+			if (pipe->pipe_settings.video.copy_binary.info)
+				binary = &pipe->pipe_settings.video.copy_binary;
+			else
+				binary = &pipe->pipe_settings.video.video_binary;
+		} else if (pipe->mode == IA_CSS_PIPE_ID_CAPTURE) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+				"sh_css_pipe_get_input_resolution: capture\n");
+			if (pipe->pipe_settings.capture.copy_binary.info)
+				binary = &pipe->pipe_settings.capture.copy_binary;
+			else if (pipe->pipe_settings.capture.primary_binary.info)
+				binary = &pipe->pipe_settings.capture.primary_binary;
+			else
+				binary = &pipe->pipe_settings.capture.pre_isp_binary;
+		} else if (pipe->mode == IA_CSS_PIPE_ID_YUVPP) {
+			binary = &pipe->pipe_settings.yuvpp.copy_binary;
+		}
+		if (binary) {
+			*width  = binary->in_frame_info.res.width +
+#if !defined(HAS_NO_INPUT_SYSTEM) && !defined(HAS_NO_INPUT_FORMATTER)
+				ia_css_ifmtr_columns_needed_for_bayer_order(&pipe->stream->config);
+#else
+				0;
+#endif
+
+			*height = binary->in_frame_info.res.height +
+#if !defined(HAS_NO_INPUT_SYSTEM) && !defined(HAS_NO_INPUT_FORMATTER)
+				ia_css_ifmtr_lines_needed_for_bayer_order(&pipe->stream->config);
+#else
+				0;
+#endif
+		} else
+			err = IA_CSS_ERR_INTERNAL_ERROR;
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_pipe_get_input_resolution() leave: width=%d, height=%d err=%d\n",
+		*width, *height, err);
+	return err;
+}
+#endif
+
+void
+sh_css_enable_cont_capt(bool enable, bool stop_copy_preview)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_enable_cont_capt() enter: enable=%d\n", enable);
+	//my_css.cont_capt = enable;
+	my_css.stop_copy_preview = stop_copy_preview;
+}
+
+bool
+sh_css_continuous_is_enabled(uint8_t pipe_num)
+{
+	struct ia_css_pipe *pipe;
+	bool continuous;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_continuous_is_enabled() enter: pipe_num=%d\n", pipe_num);
+
+	pipe = find_pipe_by_num(pipe_num);
+	continuous = pipe && pipe->stream->config.continuous;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_continuous_is_enabled() leave: enable=%d\n",
+		continuous);
+	return continuous;
+}
+
+enum ia_css_err
+ia_css_stream_get_max_buffer_depth(struct ia_css_stream *stream, int *buffer_depth)
+{
+	if (buffer_depth == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_get_max_buffer_depth() enter: void\n");
+	(void)stream;
+	*buffer_depth = NUM_CONTINUOUS_FRAMES;
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_stream_set_buffer_depth(struct ia_css_stream *stream, int buffer_depth)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_set_buffer_depth() enter: num_frames=%d\n",buffer_depth);
+	(void)stream;
+	if (buffer_depth > NUM_CONTINUOUS_FRAMES || buffer_depth < 1)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	/* ok, value allowed */
+	stream->config.target_num_cont_raw_buf = buffer_depth;
+	// TODO: check what to regarding initialization
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_stream_get_buffer_depth(struct ia_css_stream *stream, int *buffer_depth)
+{
+	if (buffer_depth == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_get_buffer_depth() enter: void\n");
+	(void)stream;
+	*buffer_depth = stream->config.target_num_cont_raw_buf;
+	return IA_CSS_SUCCESS;
+}
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+unsigned int
+sh_css_get_mipi_sizes_for_check(const unsigned int port, const unsigned int idx)
+{
+	OP___assert(port < N_CSI_PORTS);
+	OP___assert(idx  < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_mipi_sizes_for_check(port %d, idx %d): %d\n",
+		port, idx, my_css.mipi_sizes_for_check[port][idx]);
+	return my_css.mipi_sizes_for_check[port][idx];
+}
+#endif
+
+static enum ia_css_err sh_css_pipe_configure_output(
+	struct ia_css_pipe *pipe,
+	unsigned int width,
+	unsigned int height,
+	unsigned int padded_width,
+	enum ia_css_frame_format format,
+	unsigned int idx)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_configure_output() enter:\n");
+
+	err = ia_css_util_check_res(width, height);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (pipe->output_info[idx].res.width != width ||
+	    pipe->output_info[idx].res.height != height ||
+	    pipe->output_info[idx].format != format)
+	{
+		ia_css_frame_info_init(
+				&pipe->output_info[idx],
+				width,
+				height,
+				format,
+				padded_width);
+	}
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+sh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,
+			  struct ia_css_grid_info *info)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_binary *s3a_binary = NULL;
+
+	assert(pipe != NULL);
+	assert(info != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_get_grid_info() enter:\n");
+
+	s3a_binary = ia_css_pipe_get_3a_binary(pipe);
+	if (s3a_binary)
+		ia_css_binary_grid_info(s3a_binary, info);
+	else
+		memset(info, 0, sizeof(*info));
+
+	return err;
+}
+
+/*
+ * @GC: TEMPORARY CODE TO TEST DVS AGAINST THE REFERENCE
+ * PLEASE DO NOT REMOVE IT!
+ */
+#if DVS_REF_TESTING
+static enum ia_css_err alloc_frame_from_file(
+	struct ia_css_pipe *pipe,
+	int width,
+	int height)
+{
+	FILE *fp;
+	int len = 0, err;
+	int bytes_per_pixel;
+	const char *file = "../File_input/dvs_input2.yuv";
+	char *y_buf, *u_buf, *v_buf;
+	char *uv_buf;
+	int offset = 0;
+	int h, w;
+
+	hrt_vaddress out_base_addr;
+	hrt_vaddress out_y_addr;
+	hrt_vaddress out_uv_addr;
+
+	assert(pipe != NULL);
+
+	out_base_addr = pipe->pipe_settings.video.delay_frames[0]->data;
+	out_y_addr  = out_base_addr
+		+ pipe->pipe_settings.video.delay_frames[0]->planes.yuv.y.offset;
+	out_uv_addr = out_base_addr
+		+ pipe->pipe_settings.video.delay_frames[0]->planes.yuv.u.offset;
+
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "alloc_frame_from_file() enter:\n");
+
+
+	bytes_per_pixel = sizeof(char);
+
+	if (!file) {printf("Error: Input file for dvs is not specified\n"); return 1;}
+	fp = fopen(file, "rb");
+	if (!fp) {printf("Error: Input file for dvs is not found\n"); return 1;}
+
+	err = fseek(fp, 0, SEEK_END);
+	if (err) {
+		fclose(fp);
+		printf("Error: Fseek error\n");
+		return 1;
+	}
+	len = ftell(fp);
+
+	err = fseek(fp, 0, SEEK_SET);
+	if (err) {
+		fclose(fp);
+		printf("Error: Fseek error2\n");
+		return 1;
+	}
+
+	len = 2 * len / 3;
+	if (len != width * height * bytes_per_pixel) {
+		fclose(fp);
+		printf("Error: File size mismatches with the internal resolution\n");
+		return 1;
+	}
+
+	y_buf = (char *) malloc(len);
+	u_buf = (char *) malloc(len/4);
+	v_buf = (char *) malloc(len/4);
+	uv_buf= (char *) malloc(len/2);
+
+	fread(y_buf, 1, len, fp);
+	fread(u_buf, 1, len/4, fp);
+	fread(v_buf, 1, len/4, fp);
+
+	for (h=0; h<height/2; h++) {
+		for (w=0; w<width/2; w++) {
+			*(uv_buf + offset + w) = *(u_buf++);
+			*(uv_buf + offset + w + width/2) = *(v_buf++);
+			//printf("width: %d\n", width);
+			//printf("offset_u: %d\n", offset+w);
+			//printf("offset_v: %d\n", offset+w+width/2);
+		}
+		offset += width;
+	}
+
+	mmgr_store(out_y_addr, y_buf, len);
+	mmgr_store(out_uv_addr, uv_buf, len/2);
+
+	out_base_addr = pipe->pipe_settings.video.delay_frames[1]->data;
+	out_y_addr  = out_base_addr + pipe->pipe_settings.video.delay_frames[1]->planes.yuv.y.offset;
+	out_uv_addr = out_base_addr + pipe->pipe_settings.video.delay_frames[1]->planes.yuv.u.offset;
+	mmgr_store(out_y_addr, y_buf, len);
+	mmgr_store(out_uv_addr, uv_buf, len/2);
+
+	fclose(fp);
+
+	return IA_CSS_SUCCESS;
+}
+
+/* MW: Why do we not pass the pointer to the struct ? */
+static enum ia_css_err fill_ref_frame_for_dvs(
+	struct ia_css_pipe *pipe,
+	struct ia_css_frame_info ref_info)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "fill_ref_frame_for_dvs() enter:\n");
+	/* Allocate tmp_frame which is used to store YUV420 input.
+	 * Read YUV420 input from the file to tmp_frame.
+	 * Convert from YUV420 to NV12 format */
+	err = alloc_frame_from_file(pipe, ref_info.res.width, ref_info.res.height);
+
+	return err;
+}
+#endif
+
+#define SH_CSS_TNR_BIT_DEPTH 8
+#if defined(IS_ISP_2500_SYSTEM)
+#define SH_CSS_REF_BIT_DEPTH 12   /* Skylake: reference frame is in 12 bit YUV domain */
+#else
+#define SH_CSS_REF_BIT_DEPTH 8
+#endif
+
+static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
+{
+	struct ia_css_frame_info video_in_info, ref_info, tnr_info,
+				 *video_vf_info, video_bds_out_info, *pipe_out_info, *pipe_vf_out_info;
+	bool online;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+#if !defined(IS_ISP_2500_SYSTEM)
+	bool continuous = pipe->stream->config.continuous;
+#endif
+	int i;
+	unsigned num_output_pins;
+	bool resolution_differs = false;
+
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "load_video_binaries() enter:\n");
+	/* we only test the video_binary because offline video doesn't need a
+	 * vf_pp binary and online does not (always use) the copy_binary.
+	 * All are always reset at the same time anyway.
+	 */
+	if (pipe->pipe_settings.video.video_binary.info)
+		return IA_CSS_SUCCESS;
+
+	pipe_out_info = &pipe->output_info[0];
+	pipe_vf_out_info = &pipe->vf_output_info[0];
+	online = pipe->stream->config.online;
+	err = ia_css_util_check_input(&pipe->stream->config, !online, false);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	/* cannot have online video and input_mode memory */
+	if (online && pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (pipe->enable_viewfinder) {
+		err = ia_css_util_check_vf_out_info(pipe_out_info,
+					pipe_vf_out_info);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else {
+		err = ia_css_frame_check_info(pipe_out_info);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	/* Video */
+	if (pipe->enable_viewfinder){
+		video_vf_info = pipe_vf_out_info;
+		resolution_differs = (video_vf_info->res.width != pipe_out_info->res.width) ||
+				(video_vf_info->res.height != pipe_out_info->res.height);
+	}
+	else {
+		video_vf_info = NULL;
+	}
+
+	{
+		struct ia_css_binary_descr video_descr;
+
+		err = ia_css_pipe_get_video_binarydesc(pipe,
+			&video_descr, &video_in_info, &video_bds_out_info, video_vf_info,
+			pipe->stream->config.left_padding);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+
+		err = ia_css_binary_find(&video_descr,
+					 &pipe->pipe_settings.video.video_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	num_output_pins = pipe->pipe_settings.video.video_binary.info->num_output_pins;
+	/* This is where we set the flag for invalid first frame */
+	if (video_vf_info || (pipe->dvs_frame_delay == IA_CSS_FRAME_DELAY_2) )
+		pipe->num_invalid_frames = 2;
+	else
+		pipe->num_invalid_frames = 1;
+
+#if !defined(IS_ISP_2500_SYSTEM)    // skycam doesn't need the copy stage
+	/* Copy */
+	if (!online && !continuous) {
+		/* TODO: what exactly needs doing, prepend the copy binary to
+		 *	 video base this only on !online?
+		 */
+		err = load_copy_binary(pipe,
+				       &pipe->pipe_settings.video.copy_binary,
+				       &pipe->pipe_settings.video.video_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+#endif
+
+	/* Viewfinder post-processing */
+	if (pipe->enable_viewfinder &&  // only when viewfinder is enabled.
+	   ((num_output_pins == 1)        // when the binary has a single output pin, we need vf_pp
+      || ((num_output_pins == 2) && resolution_differs)) ) { // when the binary has dual output pin, we only need vf_pp in case the resolution is different.
+		struct ia_css_binary_descr vf_pp_descr;
+
+		ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
+			&pipe->pipe_settings.video.video_binary.vf_frame_info,
+			pipe_vf_out_info);
+		err = ia_css_binary_find(&vf_pp_descr,
+				&pipe->pipe_settings.video.vf_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	/* yuv copy does not use reference frames */
+	if (ia_css_util_is_input_format_yuv(pipe->stream->config.format)) {
+		return err;
+	}
+
+	ref_info = pipe->pipe_settings.video.video_binary.internal_frame_info;
+#if defined(IS_ISP_2500_SYSTEM)
+	ref_info.format = IA_CSS_FRAME_FORMAT_YUV420_16;   /* Skylake: reference frame is in 12 bit YUV domain */
+#else
+	ref_info.format = IA_CSS_FRAME_FORMAT_YUV420;
+#endif
+	ref_info.raw_bit_depth = SH_CSS_REF_BIT_DEPTH;
+
+	/*Allocate the exact number of required reference buffers */
+	for (i = 0; i <= (int)pipe->dvs_frame_delay ; i++){
+		if (pipe->pipe_settings.video.delay_frames[i]) {
+			ia_css_frame_free(pipe->pipe_settings.video.delay_frames[i]);
+			pipe->pipe_settings.video.delay_frames[i] = NULL;
+		}
+		err = ia_css_frame_allocate_from_info(
+				&pipe->pipe_settings.video.delay_frames[i],
+				&ref_info);
+#ifdef HRT_CSIM
+		ia_css_frame_zero(pipe->pipe_settings.video.delay_frames[i]);
+#endif
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+
+#if DVS_REF_TESTING
+	/* @GC: TEMPORARY CODE TO TEST DVS AGAINST THE REFERENCE
+	 * To test dvs-6axis:
+	 * 1. Enable this function call
+	 * 2. Set "reqs.ref_out_requests" to "0" in lineloop.hive.c
+	 */
+	err = fill_ref_frame_for_dvs(pipe, ref_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+#endif
+
+
+  if (pipe->pipe_settings.video.video_binary.info->sp.enable.block_output){
+    tnr_info = pipe->pipe_settings.video.video_binary.out_frame_info[0];
+  }
+  else {
+    tnr_info = pipe->pipe_settings.video.video_binary.internal_frame_info;
+  }
+	tnr_info.format = IA_CSS_FRAME_FORMAT_YUV_LINE;
+	tnr_info.raw_bit_depth = SH_CSS_TNR_BIT_DEPTH;
+
+	for (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++) {
+		if (pipe->pipe_settings.video.tnr_frames[i]) {
+			ia_css_frame_free(pipe->pipe_settings.video.tnr_frames[i]);
+			pipe->pipe_settings.video.tnr_frames[i] = NULL;
+		}
+		err = ia_css_frame_allocate_from_info(
+				&pipe->pipe_settings.video.tnr_frames[i],
+				&tnr_info);
+#ifdef HRT_CSIM
+		ia_css_frame_zero(pipe->pipe_settings.video.tnr_frames[i]);
+#endif
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	return IA_CSS_SUCCESS;
+}
+
+static void
+unload_video_binaries(struct ia_css_pipe *pipe)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "unload_video_binaries() enter:\n");
+
+	ia_css_binary_unload(&pipe->pipe_settings.video.copy_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.video.video_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.video.vf_pp_binary);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "unload_video_binaries() leave:\n");
+}
+
+static enum ia_css_err video_start(struct ia_css_pipe *pipe)
+{
+	struct ia_css_binary *copy_binary;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_pipe *copy_pipe, *capture_pipe;
+	enum sh_css_pipe_config_override copy_ovrd;
+	enum ia_css_input_mode video_pipe_input_mode;
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	struct ia_css_pipe *target_pipe = NULL;
+#endif
+	assert(pipe != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "video_start() enter:\n");
+
+	video_pipe_input_mode = pipe->stream->config.mode;
+
+	copy_pipe    = pipe->pipe_settings.video.copy_pipe;
+	capture_pipe = pipe->pipe_settings.video.capture_pipe;
+
+	copy_binary  = &pipe->pipe_settings.video.copy_binary;
+
+	sh_css_metrics_start_frame();
+
+	/* multi stream video needs mipi buffers */
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	send_mipi_frames(pipe);
+#endif
+
+	send_raw_frames(pipe);
+	{
+		unsigned int thread_id;
+
+		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+		copy_ovrd = 1 << thread_id;
+
+		if (pipe->stream->cont_capt) {
+			ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(capture_pipe), &thread_id);
+			copy_ovrd |= 1 << thread_id;
+		}
+	}
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#if defined(USE_INPUT_SYSTEM_VERSION_2)
+	err = sh_css_config_input_network(pipe, copy_binary);
+#elif defined(USE_INPUT_SYSTEM_VERSION_2401)
+	if (pipe->stream->config.continuous) {
+		/* make the copy pipe create/own the ISYS stream */
+		target_pipe = copy_pipe;
+	} else {
+		/* make the video pipe create/own the ISYS stream */
+		target_pipe = pipe;
+	}
+
+	err = sh_css_config_input_network(target_pipe, NULL);
+#endif
+	if (err != IA_CSS_SUCCESS)
+		goto EXIT;
+#endif
+
+	/* Construct and load the copy pipe */
+	if (pipe->stream->config.continuous) {
+		sh_css_sp_init_pipeline(&copy_pipe->pipeline,
+			IA_CSS_PIPE_ID_COPY,
+			(uint8_t)ia_css_pipe_get_pipe_num(copy_pipe),
+			false,
+			pipe->stream->config.pixels_per_clock == 2, false,
+			false, pipe->required_bds_factor,
+			copy_ovrd,
+			pipe->stream->config.mode,
+			&pipe->stream->config.metadata_config,
+			&pipe->stream->info.metadata_info
+#if !defined(HAS_NO_INPUT_SYSTEM)
+			, pipe->stream->config.source.port.port
+#endif
+			);
+
+		/* make the video pipe start with mem mode input, copy handles
+		   the actual mode */
+		video_pipe_input_mode = IA_CSS_INPUT_MODE_MEMORY;
+	}
+
+	/* Construct and load the capture pipe */
+	if (pipe->stream->cont_capt) {
+		sh_css_sp_init_pipeline(&capture_pipe->pipeline,
+			IA_CSS_PIPE_ID_CAPTURE,
+			(uint8_t)ia_css_pipe_get_pipe_num(capture_pipe),
+			pipe->config.default_capture_config.enable_xnr,
+			capture_pipe->stream->config.pixels_per_clock == 2,
+			true, /* continuous */
+			false, /* offline */
+			capture_pipe->required_bds_factor,
+			0,
+			IA_CSS_INPUT_MODE_MEMORY,
+			&pipe->stream->config.metadata_config,
+			&pipe->stream->info.metadata_info
+#if !defined(HAS_NO_INPUT_SYSTEM)
+			, (mipi_port_ID_t)0
+#endif
+			);
+	}
+
+	err = start_pipe(pipe, copy_ovrd, video_pipe_input_mode);
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+EXIT:
+#endif
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"video_start() leave: return (%d)\n", err);
+	return err;
+}
+
+static
+enum ia_css_err sh_css_pipe_get_viewfinder_frame_info(
+	struct ia_css_pipe *pipe,
+	struct ia_css_frame_info *info,
+	unsigned int idx)
+{
+	assert(pipe != NULL);
+	assert(info != NULL);
+
+/* We could print the pointer as input arg, and the values as output */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_get_viewfinder_frame_info() enter: void\n");
+
+	if ( pipe->mode == IA_CSS_PIPE_ID_CAPTURE &&
+	    (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW ||
+	     pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER))
+		return IA_CSS_ERR_MODE_HAS_NO_VIEWFINDER;
+	/* offline video does not generate viewfinder output */
+	if ( pipe->mode == IA_CSS_PIPE_ID_VIDEO &&
+	    !pipe->stream->config.online && !pipe->stream->config.continuous) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"sh_css_pipe_get_viewfinder_frame_info() leave: return_err=%d\n",
+			IA_CSS_ERR_MODE_HAS_NO_VIEWFINDER);
+		return IA_CSS_ERR_MODE_HAS_NO_VIEWFINDER;
+	} else {
+		*info = pipe->vf_output_info[idx];
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_pipe_get_viewfinder_frame_info() leave: \
+		info.res.width=%d, info.res.height=%d, \
+		info.padded_width=%d, info.format=%d, \
+		info.raw_bit_depth=%d, info.raw_bayer_order=%d\n",
+		info->res.width,info->res.height,
+		info->padded_width,info->format,
+		info->raw_bit_depth,info->raw_bayer_order);
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+sh_css_pipe_configure_viewfinder(struct ia_css_pipe *pipe, unsigned int width,
+				 unsigned int height, unsigned int min_width,
+				 enum ia_css_frame_format format,
+				 unsigned int idx)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_pipe_configure_viewfinder() enter: \
+		width=%d, height=%d format=%d\n",
+		width, height, format);
+
+	err = ia_css_util_check_res(width, height);
+	if (err != IA_CSS_SUCCESS) {
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_configure_viewfinder() leave: return_err=%d\n",err);
+		return err;
+	}
+	if (pipe->vf_output_info[idx].res.width != width ||
+	    pipe->vf_output_info[idx].res.height != height ||
+	    pipe->vf_output_info[idx].format != format) {
+		ia_css_frame_info_init(&pipe->vf_output_info[idx], width, height,
+				       format, min_width);
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_configure_viewfinder() leave: return_err=%d\n",IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err load_copy_binaries(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "load_copy_binaries() enter:\n");
+
+	if (pipe->pipe_settings.capture.copy_binary.info)
+		return IA_CSS_SUCCESS;
+
+	err = ia_css_frame_check_info(&pipe->output_info[0]);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	err = verify_copy_out_frame_format(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	err = load_copy_binary(pipe,
+				&pipe->pipe_settings.capture.copy_binary,
+				NULL);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	return err;
+}
+
+static bool need_capture_pp(
+	const struct ia_css_pipe *pipe)
+{
+	const struct ia_css_frame_info *out_info = &pipe->output_info[0];
+	assert(pipe != NULL);
+	assert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "need_capture_pp() enter:\n");
+	/* determine whether we need to use the capture_pp binary.
+	 * This is needed for:
+	 *   1. XNR or
+	 *   2. Digital Zoom or
+	 *   3. YUV downscaling
+	 */
+	if (pipe->out_yuv_ds_input_info.res.width &&
+	    ((pipe->out_yuv_ds_input_info.res.width != out_info->res.width) ||
+	     (pipe->out_yuv_ds_input_info.res.height != out_info->res.height)))
+		return true;
+	if (pipe->config.default_capture_config.enable_xnr)
+		return true;
+
+	if ((pipe->stream->isp_params_configs->dz_config.dx < HRT_GDC_N) ||
+	    (pipe->stream->isp_params_configs->dz_config.dy < HRT_GDC_N) ||
+	    pipe->config.enable_dz)
+		return true;
+
+	return false;
+}
+
+static enum ia_css_err load_primary_binaries(
+	struct ia_css_pipe *pipe)
+{
+	bool online = false;
+	bool memory = false;
+	bool continuous = false;
+	bool need_pp = false;
+	bool need_isp_copy_binary = false;
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	bool sensor = false;
+#endif
+	struct ia_css_frame_info prim_in_info,
+				 prim_out_info, vf_info,
+				 *vf_pp_in_info, *pipe_out_info,
+				 *pipe_vf_out_info;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_capture_settings *mycs;
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	online = pipe->stream->config.online;
+	memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;
+	continuous = pipe->stream->config.continuous;
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR);
+#endif
+
+	mycs = &pipe->pipe_settings.capture;
+	pipe_out_info = &pipe->output_info[0];
+	pipe_vf_out_info = &pipe->vf_output_info[0];
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "load_primary_binaries() enter:\n");
+
+	if (mycs->primary_binary.info)
+		return IA_CSS_SUCCESS;
+
+	err = ia_css_util_check_vf_out_info(pipe_out_info,
+			pipe_vf_out_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	need_pp = need_capture_pp(pipe);
+
+	/* we use the vf output info to get the primary/capture_pp binary
+	   configured for vf_veceven. It will select the closest downscaling
+	   factor. */
+	vf_info = *pipe_vf_out_info;
+	ia_css_frame_info_set_format(&vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);
+
+	/* we build up the pipeline starting at the end */
+	/* Capture post-processing */
+	if (need_pp) {
+		struct ia_css_binary_descr capture_pp_descr;
+		ia_css_pipe_get_capturepp_binarydesc(pipe,
+			&capture_pp_descr, &prim_out_info, &vf_info);
+		err = ia_css_binary_find(&capture_pp_descr,
+					&mycs->capture_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else {
+		prim_out_info = *pipe_out_info;
+	}
+
+	/* Primary */
+	{
+		struct ia_css_binary_descr prim_descr;
+
+		ia_css_pipe_get_primary_binarydesc(pipe,
+			&prim_descr, &prim_in_info, &prim_out_info, &vf_info);
+		err = ia_css_binary_find(&prim_descr, &mycs->primary_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	/* Viewfinder post-processing */
+	if (need_pp) {
+		vf_pp_in_info =
+		    &mycs->capture_pp_binary.vf_frame_info;
+	} else {
+		vf_pp_in_info =
+		    &mycs->primary_binary.vf_frame_info;
+	}
+
+	{
+		struct ia_css_binary_descr vf_pp_descr;
+
+		ia_css_pipe_get_vfpp_binarydesc(pipe,
+			&vf_pp_descr, vf_pp_in_info, pipe_vf_out_info);
+		err = ia_css_binary_find(&vf_pp_descr, &mycs->vf_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	/* When the input system is 2401, only the Direct Sensor Mode
+	 * Offline Capture uses the ISP copy binary.
+	 */
+	need_isp_copy_binary = !online && sensor;
+#else
+	need_isp_copy_binary = !online && !continuous && !memory;
+#endif
+	/* ISP Copy */
+	if (need_isp_copy_binary) {
+		err = load_copy_binary(pipe,
+				       &mycs->copy_binary,
+				       &mycs->primary_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err load_advanced_binaries(
+	struct ia_css_pipe *pipe)
+{
+	struct ia_css_frame_info pre_in_info, gdc_in_info,
+				 post_in_info, post_out_info,
+				 vf_info, *vf_pp_in_info, *pipe_out_info,
+				 *pipe_vf_out_info;
+	bool need_pp;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "load_advanced_binaries() enter:\n");
+
+	if (pipe->pipe_settings.capture.pre_isp_binary.info)
+		return IA_CSS_SUCCESS;
+	pipe_out_info = &pipe->output_info[0];
+	pipe_vf_out_info = &pipe->vf_output_info[0];
+
+	vf_info = *pipe_vf_out_info;
+	err = ia_css_util_check_vf_out_info(pipe_out_info, &vf_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	need_pp = need_capture_pp(pipe);
+
+	ia_css_frame_info_set_format(&vf_info,
+				     IA_CSS_FRAME_FORMAT_YUV_LINE);
+
+	/* we build up the pipeline starting at the end */
+	/* Capture post-processing */
+	if (need_pp) {
+		struct ia_css_binary_descr capture_pp_descr;
+
+		ia_css_pipe_get_capturepp_binarydesc(pipe,
+			&capture_pp_descr, &post_out_info, &vf_info);
+		err = ia_css_binary_find(&capture_pp_descr,
+				&pipe->pipe_settings.capture.capture_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else {
+		post_out_info = *pipe_out_info;
+	}
+
+	/* Post-gdc */
+	{
+		struct ia_css_binary_descr post_gdc_descr;
+
+		ia_css_pipe_get_post_gdc_binarydesc(pipe,
+			&post_gdc_descr, &post_in_info, &post_out_info, &vf_info);
+		err = ia_css_binary_find(&post_gdc_descr,
+					 &pipe->pipe_settings.capture.post_isp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	/* Gdc */
+	{
+		struct ia_css_binary_descr gdc_descr;
+
+		ia_css_pipe_get_gdc_binarydesc(pipe, &gdc_descr, &gdc_in_info,
+			       &pipe->pipe_settings.capture.post_isp_binary.in_frame_info);
+		err = ia_css_binary_find(&gdc_descr,
+					 &pipe->pipe_settings.capture.anr_gdc_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+	pipe->pipe_settings.capture.anr_gdc_binary.left_padding =
+		pipe->pipe_settings.capture.post_isp_binary.left_padding;
+
+	/* Pre-gdc */
+	{
+		struct ia_css_binary_descr pre_gdc_descr;
+
+		ia_css_pipe_get_pre_gdc_binarydesc(pipe, &pre_gdc_descr, &pre_in_info,
+				   &pipe->pipe_settings.capture.anr_gdc_binary.in_frame_info);
+		err = ia_css_binary_find(&pre_gdc_descr,
+					 &pipe->pipe_settings.capture.pre_isp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+	pipe->pipe_settings.capture.pre_isp_binary.left_padding =
+		pipe->pipe_settings.capture.anr_gdc_binary.left_padding;
+
+	/* Viewfinder post-processing */
+	if (need_pp) {
+		vf_pp_in_info =
+		    &pipe->pipe_settings.capture.capture_pp_binary.vf_frame_info;
+	} else {
+		vf_pp_in_info =
+		    &pipe->pipe_settings.capture.post_isp_binary.vf_frame_info;
+	}
+
+	{
+		struct ia_css_binary_descr vf_pp_descr;
+
+		ia_css_pipe_get_vfpp_binarydesc(pipe,
+			&vf_pp_descr, vf_pp_in_info, pipe_vf_out_info);
+		err = ia_css_binary_find(&vf_pp_descr,
+					 &pipe->pipe_settings.capture.vf_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	/* Copy */
+	err = load_copy_binary(pipe,
+			       &pipe->pipe_settings.capture.copy_binary,
+			       &pipe->pipe_settings.capture.pre_isp_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err load_bayer_isp_binaries(
+	struct ia_css_pipe *pipe)
+{
+	struct ia_css_frame_info pre_isp_in_info, *pipe_out_info;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_binary_descr pre_de_descr;
+
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "load_pre_isp_binaries() enter:\n");
+	pipe_out_info = &pipe->output_info[0];
+
+	if (pipe->pipe_settings.capture.pre_isp_binary.info)
+		return IA_CSS_SUCCESS;
+
+	err = ia_css_frame_check_info(pipe_out_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	ia_css_pipe_get_pre_de_binarydesc(pipe, &pre_de_descr,
+				&pre_isp_in_info,
+				pipe_out_info);
+
+	err = ia_css_binary_find(&pre_de_descr,
+				 &pipe->pipe_settings.capture.pre_isp_binary);
+
+	return err;
+}
+
+static enum ia_css_err load_low_light_binaries(
+	struct ia_css_pipe *pipe)
+{
+	struct ia_css_frame_info pre_in_info, anr_in_info,
+				 post_in_info, post_out_info,
+				 vf_info, *pipe_vf_out_info, *pipe_out_info,
+				 *vf_pp_in_info;
+	bool need_pp;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "load_low_light_binaries() enter:\n");
+
+	if (pipe->pipe_settings.capture.pre_isp_binary.info)
+		return IA_CSS_SUCCESS;
+	pipe_vf_out_info = &pipe->vf_output_info[0];
+	pipe_out_info = &pipe->output_info[0];
+
+	vf_info = *pipe_vf_out_info;
+	err = ia_css_util_check_vf_out_info(pipe_out_info,
+				&vf_info);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	need_pp = need_capture_pp(pipe);
+
+	ia_css_frame_info_set_format(&vf_info,
+				     IA_CSS_FRAME_FORMAT_YUV_LINE);
+
+	/* we build up the pipeline starting at the end */
+	/* Capture post-processing */
+	if (need_pp) {
+		struct ia_css_binary_descr capture_pp_descr;
+
+		ia_css_pipe_get_capturepp_binarydesc(pipe,
+			&capture_pp_descr, &post_out_info, &vf_info);
+		err = ia_css_binary_find(&capture_pp_descr,
+				&pipe->pipe_settings.capture.capture_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else {
+		post_out_info = *pipe_out_info;
+	}
+
+	/* Post-anr */
+	{
+		struct ia_css_binary_descr post_anr_descr;
+
+		ia_css_pipe_get_post_anr_binarydesc(pipe,
+			&post_anr_descr, &post_in_info, &post_out_info, &vf_info);
+		err = ia_css_binary_find(&post_anr_descr,
+					 &pipe->pipe_settings.capture.post_isp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	/* Anr */
+	{
+		struct ia_css_binary_descr anr_descr;
+
+		ia_css_pipe_get_anr_binarydesc(pipe, &anr_descr, &anr_in_info,
+				&pipe->pipe_settings.capture.post_isp_binary.in_frame_info);
+		err = ia_css_binary_find(&anr_descr,
+					 &pipe->pipe_settings.capture.anr_gdc_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+	pipe->pipe_settings.capture.anr_gdc_binary.left_padding =
+		pipe->pipe_settings.capture.post_isp_binary.left_padding;
+
+	/* Pre-anr */
+	{
+		struct ia_css_binary_descr pre_anr_descr;
+
+		ia_css_pipe_get_pre_anr_binarydesc(pipe, &pre_anr_descr, &pre_in_info,
+				   &pipe->pipe_settings.capture.anr_gdc_binary.in_frame_info);
+		err = ia_css_binary_find(&pre_anr_descr,
+				&pipe->pipe_settings.capture.pre_isp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+	pipe->pipe_settings.capture.pre_isp_binary.left_padding =
+		pipe->pipe_settings.capture.anr_gdc_binary.left_padding;
+
+	/* Viewfinder post-processing */
+	if (need_pp) {
+		vf_pp_in_info =
+		    &pipe->pipe_settings.capture.capture_pp_binary.vf_frame_info;
+	} else {
+		vf_pp_in_info =
+		    &pipe->pipe_settings.capture.post_isp_binary.vf_frame_info;
+	}
+
+	{
+		struct ia_css_binary_descr vf_pp_descr;
+
+		ia_css_pipe_get_vfpp_binarydesc(pipe,
+			&vf_pp_descr, vf_pp_in_info, pipe_vf_out_info);
+		err = ia_css_binary_find(&vf_pp_descr,
+					 &pipe->pipe_settings.capture.vf_pp_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	/* Copy */
+	err = load_copy_binary(pipe,
+			       &pipe->pipe_settings.capture.copy_binary,
+			       &pipe->pipe_settings.capture.pre_isp_binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	return IA_CSS_SUCCESS;
+}
+
+static bool copy_on_sp(struct ia_css_pipe *pipe)
+{
+	bool rval;
+
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "copy_on_sp() enter:\n");
+
+	rval = true;
+
+	rval &=	(pipe->mode == IA_CSS_PIPE_ID_CAPTURE);
+
+	rval &= (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW);
+
+	rval &= ((pipe->stream->config.format == IA_CSS_STREAM_FORMAT_BINARY_8) ||
+		(pipe->config.mode == IA_CSS_PIPE_MODE_COPY));
+
+	return rval;
+}
+
+static enum ia_css_err load_capture_binaries(
+	struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool must_be_raw;
+
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "load_capture_binaries() enter:\n");
+
+	if (pipe->pipe_settings.capture.primary_binary.info)
+		return IA_CSS_SUCCESS;
+
+	/* in primary, advanced,low light or bayer,
+						the input format must be raw */
+	must_be_raw =
+		pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_ADVANCED ||
+		pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER ||
+		pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT;
+	err = ia_css_util_check_input(&pipe->stream->config, must_be_raw, false);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	if (copy_on_sp(pipe) &&
+	    pipe->stream->config.format == IA_CSS_STREAM_FORMAT_BINARY_8) {
+		ia_css_frame_info_init(
+			&pipe->output_info[0],
+			JPEG_BYTES,
+			1,
+			IA_CSS_FRAME_FORMAT_BINARY_8,
+			0);
+		return IA_CSS_SUCCESS;
+	}
+
+	switch (pipe->config.default_capture_config.mode) {
+	case IA_CSS_CAPTURE_MODE_RAW:
+		err = load_copy_binaries(pipe);
+		break;
+	case IA_CSS_CAPTURE_MODE_BAYER:
+		err = load_bayer_isp_binaries(pipe);
+		break;
+	case IA_CSS_CAPTURE_MODE_PRIMARY:
+		err = load_primary_binaries(pipe);
+		break;
+	case IA_CSS_CAPTURE_MODE_ADVANCED:
+		err = load_advanced_binaries(pipe);
+		break;
+	case IA_CSS_CAPTURE_MODE_LOW_LIGHT:
+		err = load_low_light_binaries(pipe);
+		break;
+	}
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	return err;
+}
+
+static void
+unload_capture_binaries(struct ia_css_pipe *pipe)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "unload_capture_binaries() enter:\n");
+
+	ia_css_binary_unload(&pipe->pipe_settings.capture.copy_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.capture.primary_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.capture.pre_isp_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.capture.anr_gdc_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.capture.post_isp_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.capture.capture_pp_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.capture.vf_pp_binary);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "unload_capture_binaries() leave:\n");
+}
+
+static bool
+need_yuv_scaler(const struct ia_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+	assert(pipe->mode == IA_CSS_PIPE_ID_YUVPP);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "need_yuv_scaler() enter:\n");
+
+	if (((pipe->output_info[0].res.width != 0) && (pipe->output_info[0].res.width < pipe->stream->info.effective_info.width)) ||
+		((pipe->output_info[1].res.width != 0) && (pipe->output_info[1].res.width < pipe->stream->info.effective_info.width)) ||
+		pipe->config.enable_dz)
+		return true;
+
+	return false;
+}
+
+static enum ia_css_err ia_css_pipe_get_cas_scaler_desc(struct ia_css_pipe *pipe,
+	struct ia_css_cas_binary_descr *descr)
+{
+	struct ia_css_frame_info in_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;
+	struct ia_css_frame_info *out_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_frame_info *vf_out_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_frame_info tmp_in_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;
+	unsigned int i, j;
+	unsigned int hor_ds_factor[IA_CSS_PIPE_MAX_OUTPUT_STAGE],
+				ver_ds_factor[IA_CSS_PIPE_MAX_OUTPUT_STAGE],
+				ds_factor = 0;
+	unsigned int num_stages = 0;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_pipe_get_cas_scaler_desc() enter:\n");
+
+	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
+		out_info[i] = NULL;
+		vf_out_info[i] = NULL;
+		hor_ds_factor[i] = 0;
+		ver_ds_factor[i] = 0;
+	}
+
+	in_info.res = pipe->stream->info.effective_info;
+	in_info.padded_width = in_info.res.width;
+	descr->num_output_stage = 0;
+	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
+		if (pipe->output_info[i].res.width != 0) {
+			out_info[i] = &pipe->output_info[i];
+			if (pipe->vf_output_info[i].res.width != 0)
+				vf_out_info[i] = &pipe->vf_output_info[i];
+			descr->num_output_stage += 1;
+		}
+
+		if (out_info[i] != NULL) {
+			hor_ds_factor[i] = CEIL_DIV(in_info.res.width, out_info[i]->res.width);
+			ver_ds_factor[i] = CEIL_DIV(in_info.res.height, out_info[i]->res.height);
+			/* use the same horizontal and vertical downscaling factor for simplicity */
+			assert(hor_ds_factor[i] == ver_ds_factor[i]);
+		}
+		if (hor_ds_factor[i] > ds_factor)
+			ds_factor = hor_ds_factor[i];
+	}
+#if 0
+	hor_ds_factor = MAX(hor_ds_factor_a, hor_ds_factor_b);
+	ver_ds_factor = MAX(ver_ds_factor_a, ver_ds_factor_b);
+	while (hor_ds_factor > 1) {
+		hor_num_stages++;
+		hor_ds_factor /= 2;
+	}
+	while (ver_ds_factor > 1) {
+		ver_num_stages++;
+		ver_ds_factor /= 2;
+	}
+	assert(hor_num_stages == ver_num_stages);
+	descr->num_stage = MAX(hor_num_stages, ver_num_stages);
+#else
+	i = 1;
+	while (i < ds_factor) {
+		num_stages++;
+		i *= 2;
+	}
+	if (pipe->config.enable_dz && (num_stages == 0))
+		num_stages = 1;
+	descr->num_stage = num_stages;
+#endif
+
+	/* if two outputs requires the same number of downscaling stages, we
+	 * extent it by one because we only have fixed number of output pins. */
+	if ((out_info[0] != NULL) && (out_info[1] != NULL) &&
+		(out_info[0]->res.width == out_info[1]->res.width) &&
+		(descr->num_output_stage > 1)) {
+		descr->num_stage += 1;
+	}
+	descr->in_info = sh_css_malloc(descr->num_stage * sizeof(struct ia_css_frame_info));
+	if (descr->in_info == NULL) {
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		goto ERR;
+	}
+	descr->internal_out_info = sh_css_malloc(descr->num_stage * sizeof(struct ia_css_frame_info));
+	if (descr->internal_out_info == NULL) {
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		goto ERR;
+	}
+	descr->out_info = sh_css_malloc(descr->num_stage * sizeof(struct ia_css_frame_info));
+	if (descr->out_info == NULL) {
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		goto ERR;
+	}
+	descr->vf_info = sh_css_malloc(descr->num_stage * sizeof(struct ia_css_frame_info));
+	if (descr->vf_info == NULL) {
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		goto ERR;
+	}
+	descr->is_output_stage = sh_css_malloc(descr->num_stage * sizeof(bool));
+	if (descr->is_output_stage == NULL) {
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		goto ERR;
+	}
+
+#if 0
+	/* swap the frame info if sec_output is bigger than output */
+	if ((out_info->res.width < sec_out_info->res.width) &&
+		(out_info->res.height < sec_out_info->res.height)) {
+		tmp_out_info[0] = sec_out_info;
+		tmp_out_info[1] = out_info;
+		tmp_vf_out_info[0] = secvf__out_info;
+		tmp_vf_out_info[1] = vf_out_info;
+	} else {
+		tmp_out_info[0] = out_info;
+		tmp_out_info[1] = sec_out_info;
+		tmp_vf_out_info[0] = vf_out_info;
+		tmp_vf_out_info[1] = sec_vf_out_info;
+	}
+#else
+	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
+		if (out_info[i]) {
+			if (i > 0) {
+				assert((out_info[i-1]->res.width >= out_info[i]->res.width) &&
+						(out_info[i-1]->res.height >= out_info[i]->res.height));
+			}
+		}
+	}
+#endif
+
+	tmp_in_info.res = pipe->stream->info.effective_info;
+	tmp_in_info.format = IA_CSS_FRAME_FORMAT_YUV420;
+	for (i = 0, j = 0; i < descr->num_stage; i++) {
+		assert(j < 2);
+		assert(out_info[j] != NULL);
+
+		descr->in_info[i] = tmp_in_info;
+		if ((tmp_in_info.res.width / 2) <= out_info[j]->res.width) {
+			descr->is_output_stage[i] = true;
+			if ((descr->num_output_stage > 1) && (i != (descr->num_stage - 1))) {
+				descr->internal_out_info[i].res.width = out_info[j]->res.width;
+				descr->internal_out_info[i].res.height = out_info[j]->res.height;
+				descr->internal_out_info[i].padded_width = out_info[j]->padded_width;
+				descr->internal_out_info[i].format = IA_CSS_FRAME_FORMAT_YUV420;
+			} else {
+				assert(i == (descr->num_stage - 1));
+				descr->internal_out_info[i].res.width = 0;
+				descr->internal_out_info[i].res.height = 0;
+			}
+			descr->out_info[i].res.width = out_info[j]->res.width;
+			descr->out_info[i].res.height = out_info[j]->res.height;
+			descr->out_info[i].padded_width = out_info[j]->padded_width;
+			descr->out_info[i].format = out_info[j]->format;
+			descr->vf_info[i].res.width = vf_out_info[j]->res.width;
+			descr->vf_info[i].res.height = vf_out_info[j]->res.height;
+			descr->vf_info[i].padded_width = vf_out_info[j]->padded_width;
+			ia_css_frame_info_set_format(&descr->vf_info[i], IA_CSS_FRAME_FORMAT_YUV_LINE);
+			//descr->vf_info[i].format = tmp_vf_out_info[j]->format;
+			j++;
+		} else {
+			descr->is_output_stage[i] = false;
+			descr->internal_out_info[i].res.width = tmp_in_info.res.width / 2;
+			descr->internal_out_info[i].res.height = tmp_in_info.res.height / 2;
+			descr->internal_out_info[i].format = IA_CSS_FRAME_FORMAT_YUV420;
+			ia_css_frame_info_init(&descr->internal_out_info[i], tmp_in_info.res.width / 2,
+					tmp_in_info.res.height / 2, IA_CSS_FRAME_FORMAT_YUV420, 0);
+			descr->out_info[i].res.width = 0;
+			descr->out_info[i].res.height = 0;
+			descr->vf_info[i].res.width = 0;
+			descr->vf_info[i].res.height = 0;
+		}
+		tmp_in_info = descr->internal_out_info[i];
+	}
+ERR:
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_pipe_get_cas_scaler_desc() leave, err=%d\n",
+			err);
+	return err;
+}
+
+static enum ia_css_err
+load_yuvpp_binaries(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool need_scaler = false;
+	struct ia_css_frame_info *vf_pp_in_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_yuvpp_settings *mycs;
+	struct ia_css_binary *next_binary;
+	struct ia_css_cas_binary_descr cas_scaler_descr = IA_CSS_DEFAULT_CAS_BINARY_DESCR;
+	unsigned int i, j;
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	if (pipe->pipe_settings.yuvpp.copy_binary.info)
+		goto ERR;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "load_yuvpp_binaries() enter:\n");
+
+	err = ia_css_util_check_input(&pipe->stream->config, false, true);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+
+	mycs = &pipe->pipe_settings.yuvpp;
+
+	err = ia_css_util_check_vf_out_info(&pipe->output_info[0],
+			&pipe->vf_output_info[0]);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+
+	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
+		vf_pp_in_info[i] = NULL;
+	}
+
+	need_scaler = need_yuv_scaler(pipe);
+
+	/* we use the vf output info to get the primary/capture_pp binary
+	   configured for vf_veceven. It will select the closest downscaling
+	   factor. */
+	//vf_info = pipe->vf_output_info;
+	//ia_css_frame_info_set_format(&vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);
+
+	/* we build up the pipeline starting at the end */
+	/* Capture post-processing */
+	if (need_scaler) {
+		struct ia_css_binary_descr yuv_scaler_descr;
+
+		ia_css_pipe_get_cas_scaler_desc(pipe,
+			&cas_scaler_descr);
+		mycs->num_output = cas_scaler_descr.num_output_stage;
+		mycs->num_yuv_scaler = cas_scaler_descr.num_stage;
+		mycs->yuv_scaler_binary = sh_css_calloc(cas_scaler_descr.num_stage,
+			sizeof(struct ia_css_binary));
+		if (mycs->yuv_scaler_binary == NULL) {
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+			goto ERR;
+		}
+		mycs->is_output_stage = sh_css_calloc(cas_scaler_descr.num_stage,
+			sizeof(bool));
+		if (mycs->is_output_stage == NULL) {
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+			goto ERR;
+		}
+		for (i = 0; i < cas_scaler_descr.num_stage; i++) {
+			mycs->is_output_stage[i] = cas_scaler_descr.is_output_stage[i];
+			ia_css_pipe_get_yuvscaler_binarydesc(pipe,
+				&yuv_scaler_descr, &cas_scaler_descr.in_info[i],
+				&cas_scaler_descr.out_info[i],
+				&cas_scaler_descr.internal_out_info[i],
+				&cas_scaler_descr.vf_info[i]);
+			err = ia_css_binary_find(&yuv_scaler_descr,
+						&mycs->yuv_scaler_binary[i]);
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+		}
+	} else {
+		mycs->num_output = 1;
+	}
+
+	if (need_scaler) {
+		next_binary = &mycs->yuv_scaler_binary[0];
+	} else {
+		next_binary = NULL;
+	}
+	/* ISP Copy */
+	err = load_copy_binary(pipe,
+			       &mycs->copy_binary,
+			       next_binary);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+
+	/* Viewfinder post-processing */
+	if (need_scaler) {
+		for (i = 0, j = 0; i < cas_scaler_descr.num_stage; i++) {
+			if (cas_scaler_descr.is_output_stage[i]) {
+				assert(j < 2);
+				vf_pp_in_info[j] =
+					&mycs->yuv_scaler_binary[i].vf_frame_info;
+				j++;
+			}
+		}
+		mycs->num_vf_pp = j;
+	} else {
+		vf_pp_in_info[0] =
+		    &mycs->copy_binary.vf_frame_info;
+		for (i = 1; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
+			vf_pp_in_info[i] = NULL;
+		}
+		mycs->num_vf_pp = 1;
+	}
+	mycs->vf_pp_binary = sh_css_calloc(mycs->num_vf_pp, sizeof(struct ia_css_binary));
+	if (mycs->vf_pp_binary == NULL) {
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		goto ERR;
+	}
+
+	{
+		struct ia_css_binary_descr vf_pp_descr;
+
+		for (i = 0; i < mycs->num_vf_pp; i++) {
+			ia_css_pipe_get_vfpp_binarydesc(pipe,
+				&vf_pp_descr, vf_pp_in_info[i], &pipe->vf_output_info[i]);
+			err = ia_css_binary_find(&vf_pp_descr, &mycs->vf_pp_binary[i]);
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+		}
+	}
+
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+
+ERR:
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "load_yuvpp_binaries() leave, err=%d\n",
+			err);
+	return err;
+}
+
+static void
+unload_yuvpp_binaries(struct ia_css_pipe *pipe)
+{
+	unsigned int i;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "unload_yuvpp_binaries() enter:\n");
+
+	ia_css_binary_unload(&pipe->pipe_settings.yuvpp.copy_binary);
+	for (i = 0; i < pipe->pipe_settings.yuvpp.num_yuv_scaler; i++) {
+		ia_css_binary_unload(&pipe->pipe_settings.yuvpp.yuv_scaler_binary[i]);
+	}
+	for (i = 0; i < pipe->pipe_settings.yuvpp.num_vf_pp; i++) {
+		ia_css_binary_unload(&pipe->pipe_settings.yuvpp.vf_pp_binary[i]);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "unload_yuvpp_binaries() leave:\n");
+}
+
+static enum ia_css_err yuvpp_start(struct ia_css_pipe *pipe)
+{
+	struct ia_css_binary *copy_binary;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	enum sh_css_pipe_config_override copy_ovrd;
+	enum ia_css_input_mode yuvpp_pipe_input_mode;
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	struct ia_css_pipe *target_pipe = NULL;
+#endif
+	assert(pipe != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "yuvpp_start() enter:\n");
+
+	yuvpp_pipe_input_mode = pipe->stream->config.mode;
+
+	copy_binary  = &pipe->pipe_settings.yuvpp.copy_binary;
+
+	sh_css_metrics_start_frame();
+
+	/* multi stream video needs mipi buffers */
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && ( defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401) )
+	send_mipi_frames(pipe);
+#endif
+
+	{
+		unsigned int thread_id;
+
+		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+		copy_ovrd = 1 << thread_id;
+	}
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#if defined(USE_INPUT_SYSTEM_VERSION_2)
+	err = sh_css_config_input_network(pipe, copy_binary);
+#elif defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* make the video pipe create/own the ISYS stream */
+	target_pipe = pipe;
+
+	err = sh_css_config_input_network(target_pipe, NULL);
+#endif
+	if (err != IA_CSS_SUCCESS)
+		goto EXIT;
+#endif
+
+	err = start_pipe(pipe, copy_ovrd, yuvpp_pipe_input_mode);
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+EXIT:
+#endif
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"video_start() leave: return (%d)\n", err);
+	return err;
+}
+
+static enum ia_css_err
+sh_css_pipe_load_binaries(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_load_binaries() enter:\n");
+
+	/* PIPE_MODE_COPY has no binaries, but has output frames to outside*/
+	if (pipe->config.mode == IA_CSS_PIPE_MODE_COPY)
+		return err;
+
+	switch (pipe->mode) {
+	case IA_CSS_PIPE_ID_PREVIEW:
+		err = load_preview_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_VIDEO:
+		err = load_video_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_CAPTURE:
+		err = load_capture_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_YUVPP:
+		err = load_yuvpp_binaries(pipe);
+		break;
+	default:
+		err = IA_CSS_ERR_INTERNAL_ERROR;
+		break;
+	}
+	return err;
+}
+
+static void
+sh_css_pipe_unload_binaries(struct ia_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_unload_binaries() enter:\n");
+
+	/* PIPE_MODE_COPY has no binaries, but has output frames to outside*/
+	if (pipe->config.mode == IA_CSS_PIPE_MODE_COPY)
+		return;
+
+	switch (pipe->mode) {
+	case IA_CSS_PIPE_ID_PREVIEW:
+		unload_preview_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_VIDEO:
+		unload_video_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_CAPTURE:
+		unload_capture_binaries(pipe);
+		break;
+	case IA_CSS_PIPE_ID_YUVPP:
+		unload_yuvpp_binaries(pipe);
+		break;
+	default:
+		break;
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_unload_binaries() leave:\n");
+}
+
+static enum ia_css_err
+create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
+{
+	struct ia_css_pipeline *me;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_pipeline_stage *vf_pp_stage = NULL,
+				     *post_stage = NULL;
+	struct ia_css_binary *copy_binary,
+			     *vf_pp_binary,
+			     *yuv_scaler_binary;
+	bool need_scaler = false;
+	unsigned int num_stage, num_vf_pp_stage, num_output_stage;
+	unsigned int i, j;
+
+	struct ia_css_frame *in_frame = NULL;
+	struct ia_css_frame *out_frame[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_frame *bin_out_frame[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_frame *vf_frame[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	struct ia_css_pipeline_stage_desc stage_desc;
+	bool need_in_frameinfo_memory = false;
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	bool sensor = false;
+	bool buffered_sensor = false;
+	bool online = false;
+	bool continuous = false;
+#endif
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	me = &pipe->pipeline;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		 "create_host_yuvpp_pipeline() enter:\n");
+	ia_css_pipeline_clean(me);
+	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
+		out_frame[i] = NULL;
+		vf_frame[i] = NULL;
+	}
+	ia_css_pipe_util_create_output_frames(bin_out_frame);
+	num_stage  = pipe->pipe_settings.yuvpp.num_yuv_scaler;
+	num_vf_pp_stage   = pipe->pipe_settings.yuvpp.num_vf_pp;
+	num_output_stage   = pipe->pipe_settings.yuvpp.num_output;
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	/* When the input system is 2401, always enable 'in_frameinfo_memory'
+	 * except for the following:
+	 * - Direct Sensor Mode Online Capture
+	 * - Direct Sensor Mode Continuous Capture
+	 * - Buffered Sensor Mode Continous Capture
+	 */
+	sensor = pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR;
+	buffered_sensor = pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
+	online = pipe->stream->config.online;
+	continuous = pipe->stream->config.continuous;
+	need_in_frameinfo_memory =
+		!((sensor && (online || continuous)) || (buffered_sensor && continuous));
+#else
+	/* Construct in_frame info (only in case we have dynamic input */
+	need_in_frameinfo_memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;
+#endif
+	if (need_in_frameinfo_memory) {
+		err = init_in_frameinfo_memory_defaults(pipe, &me->in_frame);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+
+		in_frame = &me->in_frame;
+	} else {
+		in_frame = NULL;
+	}
+
+	for (i = 0; i < num_output_stage; i++) {
+		assert(i < IA_CSS_PIPE_MAX_OUTPUT_STAGE);
+		if (pipe->output_info[i].res.width != 0) {
+			err = init_out_frameinfo_defaults(pipe, &me->out_frame[i], i);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+			out_frame[i] = &me->out_frame[i];
+		}
+
+		/* Construct vf_frame info (only in case we have VF) */
+		if (pipe->vf_output_info[i].res.width != 0) {
+			err = init_vf_frameinfo_defaults(pipe, &me->vf_frame[i], i);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+			vf_frame[i] = &me->vf_frame[i];
+		}
+	}
+
+	copy_binary       = &pipe->pipe_settings.yuvpp.copy_binary;
+	vf_pp_binary      = pipe->pipe_settings.yuvpp.vf_pp_binary;
+	yuv_scaler_binary = pipe->pipe_settings.yuvpp.yuv_scaler_binary;
+	need_scaler = need_yuv_scaler(pipe);
+
+	if (pipe->pipe_settings.yuvpp.copy_binary.info) {
+		if(need_scaler) {
+			ia_css_pipe_util_set_output_frames(bin_out_frame, 0, NULL);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, copy_binary,
+				bin_out_frame, NULL, NULL, NULL);
+		} else {
+			ia_css_pipe_util_set_output_frames(bin_out_frame, 0, out_frame[0]);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, copy_binary,
+				bin_out_frame, NULL, NULL, NULL);
+		}
+
+		err = ia_css_pipeline_create_and_add_stage(me,
+			&stage_desc,
+			&post_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (post_stage) {
+			/* if we use yuv scaler binary, vf output should be from there */
+			post_stage->args.copy_vf = !need_scaler;
+			/* for yuvpp pipe, it should always be enabled */
+			post_stage->args.copy_output = true;
+		}
+	}
+
+	if (need_scaler && post_stage) {
+		struct ia_css_frame *tmp_out_frame = NULL;
+		struct ia_css_frame *tmp_vf_frame = NULL;
+		struct ia_css_frame *tmp_in_frame = post_stage->args.out_frame[0];
+
+		for (i = 0, j = 0; i < num_stage; i++) {
+			assert(j < num_output_stage);
+			if (pipe->pipe_settings.yuvpp.is_output_stage[i] == true) {
+				tmp_out_frame = out_frame[j];
+				tmp_vf_frame = vf_frame[j];
+			} else {
+				tmp_out_frame = NULL;
+				tmp_vf_frame = NULL;
+			}
+
+			err = add_yuv_scaler_stage(pipe, me, tmp_in_frame, tmp_out_frame,
+						   NULL,
+						   &yuv_scaler_binary[i],
+						   post_stage, &post_stage,
+						   pipe->pipe_settings.yuvpp.is_output_stage[i]);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+			/* we use output port 1 as internal output port */
+			tmp_in_frame = post_stage->args.out_frame[1];
+			if (pipe->pipe_settings.yuvpp.is_output_stage[i] == true) {
+				err = add_vf_pp_stage(pipe, tmp_vf_frame, &vf_pp_binary[j],
+					      post_stage, &vf_pp_stage);
+				if (err != IA_CSS_SUCCESS)
+					return err;
+				j++;
+			}
+		}
+	} else if (post_stage != NULL) {
+		err = add_vf_pp_stage(pipe, vf_frame[0], &vf_pp_binary[0],
+				      post_stage, &vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	ia_css_pipeline_finalize_stages(&pipe->pipeline);
+#if 0
+	if (!need_scaler) {
+		err = ia_css_pipeline_get_stage(me, copy_binary->info->sp.mode,
+						&out_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		copy_stage = out_stage;
+	} else {
+		if (copy_binary->info) {
+			err = ia_css_pipeline_get_stage(me,
+							copy_binary->info->sp.mode,
+							&copy_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+		if (yuv_scaler_binary->info) {
+			err = ia_css_pipeline_get_stage(me,
+					yuv_scaler_binary->info->sp.mode,
+					&out_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+	}
+	if (vf_pp_stage)
+		vf_pp_stage->args.out_frame = vf_frame;
+#if 0
+	/* rvanimme: why is this? */
+	/* TODO: investigate if this can be removed */
+	if (!pipe->output_stage)
+		out_stage->args.out_frame = out_frame;
+#endif
+	if (copy_stage && in_frame)
+		copy_stage->args.out_frame = in_frame;
+#endif
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_regular_capture_pipeline() leave:\n");
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+create_host_copy_pipeline(struct ia_css_pipe *pipe,
+    unsigned max_input_width,
+    struct ia_css_frame *out_frame)
+{
+	struct ia_css_pipeline *me;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_pipeline_stage_desc stage_desc;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_copy_pipeline() enter:\n");
+
+	/* pipeline already created as part of create_host_pipeline_structure */
+	me = &pipe->pipeline;
+	ia_css_pipeline_clean(me);
+
+	/* Construct out_frame info */
+	out_frame->contiguous = false;
+	out_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+
+	if (copy_on_sp(pipe) &&
+	    pipe->stream->config.format == IA_CSS_STREAM_FORMAT_BINARY_8) {
+		ia_css_frame_info_init(
+			&out_frame->info,
+			JPEG_BYTES,
+			1,
+			IA_CSS_FRAME_FORMAT_BINARY_8,
+			0);
+	} else if (out_frame->info.format == IA_CSS_FRAME_FORMAT_RAW) {
+		out_frame->info.raw_bit_depth =
+			ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	}
+
+	me->num_stages = 1;
+	me->pipe_id = IA_CSS_PIPE_ID_COPY;
+	pipe->mode  = IA_CSS_PIPE_ID_COPY;
+
+	ia_css_pipe_get_sp_func_stage_desc(&stage_desc, out_frame,
+		IA_CSS_PIPELINE_RAW_COPY, max_input_width);
+	err = ia_css_pipeline_create_and_add_stage(me,
+		&stage_desc,
+		NULL);
+
+	ia_css_pipeline_finalize_stages(&pipe->pipeline);
+
+	configure_pipe_inout_port(&pipe->pipeline, true);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_copy_pipeline() leave:\n");
+
+	return err;
+}
+
+static enum ia_css_err
+create_host_isyscopy_capture_pipeline(struct ia_css_pipe *pipe)
+{
+	struct ia_css_pipeline *me = &pipe->pipeline;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_pipeline_stage_desc stage_desc;
+	struct ia_css_frame *out_frame = &me->out_frame[0];
+	struct ia_css_pipeline_stage *out_stage = NULL;
+	unsigned int thread_id;
+	enum sh_css_queue_id queue_id;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_isyscopy_capture_pipeline() enter:\n");
+	ia_css_pipeline_clean(me);
+
+	/* Construct out_frame info */
+	err = sh_css_pipe_get_output_frame_info(pipe, &out_frame->info, 0);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	out_frame->contiguous = false;
+	out_frame->flash_state = IA_CSS_FRAME_FLASH_STATE_NONE;
+	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, thread_id, &queue_id);
+	out_frame->dynamic_data_index = queue_id;
+	out_frame->buf_type = IA_CSS_BUFFER_TYPE_OUTPUT_FRAME;
+
+	me->num_stages = 1;
+	me->pipe_id = IA_CSS_PIPE_ID_CAPTURE;
+	pipe->mode  = IA_CSS_PIPE_ID_CAPTURE;
+	ia_css_pipe_get_sp_func_stage_desc(&stage_desc, out_frame,
+		IA_CSS_PIPELINE_ISYS_COPY, 0);
+	err = ia_css_pipeline_create_and_add_stage(me,
+		&stage_desc, &out_stage);
+	if(err != IA_CSS_SUCCESS)
+		return err;
+
+	ia_css_pipeline_finalize_stages(me);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_isyscopy_capture_pipeline() leave:\n");
+
+	return err;
+}
+
+static enum ia_css_err
+create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
+{
+	struct ia_css_pipeline *me;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	enum ia_css_capture_mode mode;
+	struct ia_css_pipeline_stage *out_stage = NULL,
+				     *vf_pp_stage = NULL,
+				     *copy_stage = NULL,
+				     *in_stage = NULL,
+				     *post_stage = NULL;
+	struct ia_css_frame *cc_frame = NULL;
+	struct ia_css_binary *copy_binary,
+			     *primary_binary,
+			     *vf_pp_binary,
+			     *pre_isp_binary,
+			     *anr_gdc_binary,
+			     *post_isp_binary,
+			     *capture_pp_binary;
+	bool need_pp = false;
+	bool raw;
+
+	struct ia_css_frame *in_frame;
+	struct ia_css_frame *out_frame;
+	struct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_frame *vf_frame;
+	struct ia_css_pipeline_stage_desc stage_desc;
+	bool need_in_frameinfo_memory = false;
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	bool sensor = false;
+	bool buffered_sensor = false;
+	bool online = false;
+	bool continuous = false;
+#endif
+
+	assert(pipe != NULL);
+	assert(pipe->stream != NULL);
+
+	me = &pipe->pipeline;
+	mode = pipe->config.default_capture_config.mode;
+	raw = (mode == IA_CSS_CAPTURE_MODE_RAW);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		 "create_host_regular_capture_pipeline() enter:\n");
+	ia_css_pipeline_clean(me);
+	ia_css_pipe_util_create_output_frames(out_frames);
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	/* When the input system is 2401, always enable 'in_frameinfo_memory'
+	 * except for the following:
+	 * - Direct Sensor Mode Online Capture
+	 * - Direct Sensor Mode Online Capture
+	 * - Direct Sensor Mode Continuous Capture
+	 * - Buffered Sensor Mode Continous Capture
+	 */
+	sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_SENSOR);
+	buffered_sensor = (pipe->stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR);
+	online = pipe->stream->config.online;
+	continuous = pipe->stream->config.continuous;
+	need_in_frameinfo_memory =
+		!((sensor && (online || continuous)) || (buffered_sensor && (online || continuous)));
+#else
+	/* Construct in_frame info (only in case we have dynamic input */
+	need_in_frameinfo_memory = pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY;
+#endif
+	if (need_in_frameinfo_memory) {
+		err = init_in_frameinfo_memory_defaults(pipe, &me->in_frame);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+
+		in_frame = &me->in_frame;
+	} else {
+		in_frame = NULL;
+	}
+
+	err = init_out_frameinfo_defaults(pipe, &me->out_frame[0], 0);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	out_frame = &me->out_frame[0];
+
+	/* Construct vf_frame info (only in case we have VF) */
+	if (mode == IA_CSS_CAPTURE_MODE_RAW ||
+			mode == IA_CSS_CAPTURE_MODE_BAYER) {
+		/* These modes don't support viewfinder output */
+		vf_frame = NULL;
+	} else {
+		init_vf_frameinfo_defaults(pipe, &me->vf_frame[0], 0);
+		vf_frame = &me->vf_frame[0];
+	}
+
+	copy_stage = NULL;
+	in_stage = NULL;
+
+	copy_binary       = &pipe->pipe_settings.capture.copy_binary;
+	primary_binary    = &pipe->pipe_settings.capture.primary_binary;
+	vf_pp_binary      = &pipe->pipe_settings.capture.vf_pp_binary;
+	pre_isp_binary    = &pipe->pipe_settings.capture.pre_isp_binary;
+	anr_gdc_binary    = &pipe->pipe_settings.capture.anr_gdc_binary;
+	post_isp_binary   = &pipe->pipe_settings.capture.post_isp_binary;
+	capture_pp_binary = &pipe->pipe_settings.capture.capture_pp_binary;
+	need_pp = (need_capture_pp(pipe) || pipe->output_stage) &&
+		  mode != IA_CSS_CAPTURE_MODE_RAW &&
+		  mode != IA_CSS_CAPTURE_MODE_BAYER;
+
+	if (pipe->pipe_settings.capture.copy_binary.info) {
+		if(raw) {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, copy_binary,
+				out_frames, NULL, NULL, NULL);
+		} else {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, in_frame);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, copy_binary,
+				out_frames, NULL, NULL, NULL);
+		}
+
+		err = ia_css_pipeline_create_and_add_stage(me,
+			&stage_desc,
+			&post_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		in_stage = post_stage;
+	} else if (pipe->stream->config.continuous) {
+		in_frame = pipe->stream->last_pipe->continuous_frames[0];
+	}
+
+	if (mode == IA_CSS_CAPTURE_MODE_PRIMARY) {
+
+		if(need_pp) {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, primary_binary,
+				out_frames, in_frame, cc_frame, NULL);
+		} else {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, primary_binary,
+				out_frames, in_frame, cc_frame, NULL);
+		}
+
+		err = ia_css_pipeline_create_and_add_stage(me,
+			&stage_desc,
+			&post_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		/* If we use copy iso primary,
+		   the input must be yuv iso raw */
+		post_stage->args.copy_vf =
+			primary_binary->info->sp.mode ==
+			IA_CSS_BINARY_MODE_COPY;
+		post_stage->args.copy_output = post_stage->args.copy_vf;
+	} else if (mode == IA_CSS_CAPTURE_MODE_ADVANCED ||
+	           mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT) {
+		ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+		ia_css_pipe_get_generic_stage_desc(&stage_desc, pre_isp_binary,
+			out_frames, in_frame, cc_frame, NULL);
+		err = ia_css_pipeline_create_and_add_stage(me,
+				&stage_desc, NULL);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+		ia_css_pipe_get_generic_stage_desc(&stage_desc, anr_gdc_binary,
+			out_frames, NULL, NULL, NULL);
+		err = ia_css_pipeline_create_and_add_stage(me,
+				&stage_desc, NULL);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+
+		if(need_pp) {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, post_isp_binary,
+				out_frames, NULL, NULL, NULL);
+		} else {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, post_isp_binary,
+				out_frames, NULL, NULL, NULL);
+		}
+
+		err = ia_css_pipeline_create_and_add_stage(me,
+				&stage_desc, &post_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else if (mode == IA_CSS_CAPTURE_MODE_BAYER) {
+		ia_css_pipe_util_set_output_frames(out_frames, 0, out_frame);
+		ia_css_pipe_get_generic_stage_desc(&stage_desc, pre_isp_binary,
+			out_frames, in_frame, cc_frame, NULL);
+		err = ia_css_pipeline_create_and_add_stage(me,
+			&stage_desc,
+			NULL);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+	if (!in_stage)
+		in_stage = post_stage;
+
+	if (need_pp) {
+		err = add_capture_pp_stage(pipe, me, out_frame,
+					   capture_pp_binary,
+					   post_stage, &post_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+	if (mode != IA_CSS_CAPTURE_MODE_RAW &&
+		mode != IA_CSS_CAPTURE_MODE_BAYER) {
+		err = add_vf_pp_stage(pipe, vf_frame, vf_pp_binary,
+				      post_stage, &vf_pp_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+
+	ia_css_pipeline_finalize_stages(&pipe->pipeline);
+
+	/**
+	 * Maybe we can return earlier but this was the original position
+	 * in the original version of capture_start()
+	 */
+	if (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW ||
+	    pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER) {
+		if (copy_on_sp(pipe))
+			return IA_CSS_SUCCESS;
+	}
+
+	if (mode == IA_CSS_CAPTURE_MODE_RAW) {
+		err = ia_css_pipeline_get_stage(me, copy_binary->info->sp.mode,
+						&out_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		copy_stage = out_stage;
+	} else if (mode == IA_CSS_CAPTURE_MODE_BAYER) {
+		err = ia_css_pipeline_get_stage(me,
+				pre_isp_binary->info->sp.mode,
+				&out_stage);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	} else {
+		if (copy_binary->info) {
+			err = ia_css_pipeline_get_stage(me,
+							copy_binary->info->sp.mode,
+							&copy_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+		if (capture_pp_binary->info) {
+			err = ia_css_pipeline_get_stage(me,
+					capture_pp_binary->info->sp.mode,
+					&out_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		} else if (mode ==
+			   IA_CSS_CAPTURE_MODE_PRIMARY) {
+			err = ia_css_pipeline_get_stage(me,
+					primary_binary->info->sp.mode, &out_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		} else if (mode ==
+			   IA_CSS_CAPTURE_MODE_LOW_LIGHT) {
+			err = ia_css_pipeline_get_stage(me,
+					post_isp_binary->info->sp.mode,
+					&out_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		} else {
+			err = ia_css_pipeline_get_stage(me,
+					post_isp_binary->info->sp.mode,
+					&out_stage);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+	}
+
+	/* rvanimme: why is this? */
+	/* TODO: investigate if this can be removed */
+	if (!pipe->output_stage)
+		out_stage->args.out_frame[0] = out_frame;
+
+	if (copy_stage && in_frame)
+		copy_stage->args.out_frame[0] = in_frame;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_regular_capture_pipeline() leave:\n");
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+create_host_capture_pipeline(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_capture_pipeline() enter:\n");
+
+	if (pipe->config.mode == IA_CSS_PIPE_MODE_COPY)
+		err = create_host_isyscopy_capture_pipeline(pipe);
+	else
+		err = create_host_regular_capture_pipeline(pipe);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* pipeline already created as part of create_host_pipeline_structure */
+	configure_pipe_inout_port(&pipe->pipeline,
+		pipe->stream->config.continuous);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"create_host_capture_pipeline() leave:\n");
+
+	return err;
+}
+
+static enum ia_css_err capture_start(
+	struct ia_css_pipe *pipe)
+{
+	struct ia_css_pipeline *me;
+
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	enum sh_css_pipe_config_override copy_ovrd;
+
+	assert(pipe != NULL);
+
+	me = &pipe->pipeline;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "capture_start() enter:\n");
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+	if (pipe->stream->config.mode != IA_CSS_INPUT_MODE_MEMORY) {
+		err = sh_css_config_input_network(pipe,
+			&pipe->pipe_settings.capture.copy_binary);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+	}
+#endif
+
+	if ((pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW   ||
+	     pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER   ) &&
+		(pipe->config.mode != IA_CSS_PIPE_MODE_COPY)) {
+		if (copy_on_sp(pipe)) {
+			return start_copy_on_sp(pipe, &me->out_frame[0]);
+		}
+	}
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* multi stream video needs mipi buffers */
+	if (pipe->config.mode != IA_CSS_PIPE_MODE_COPY) {
+		send_mipi_frames(pipe);
+	}
+#endif
+
+	{
+		unsigned int thread_id;
+
+		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
+		copy_ovrd = 1 << thread_id;
+
+	}
+	err = start_pipe(pipe, copy_ovrd, pipe->stream->config.mode);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"capture_start() leave: return (%d)\n", err);
+	return err;
+
+}
+
+static enum ia_css_err
+sh_css_pipe_get_output_frame_info(struct ia_css_pipe *pipe,
+				  struct ia_css_frame_info *info,
+				  unsigned int idx)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(pipe != NULL);
+	assert(info != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+						"sh_css_pipe_get_output_frame_info() enter:\n");
+
+	*info = pipe->output_info[idx];
+	if (copy_on_sp(pipe) &&
+	    pipe->stream->config.format == IA_CSS_STREAM_FORMAT_BINARY_8) {
+		ia_css_frame_info_init(
+			info,
+			JPEG_BYTES,
+			1,
+			IA_CSS_FRAME_FORMAT_BINARY_8,
+			0);
+	} else if (info->format == IA_CSS_FRAME_FORMAT_RAW ||
+		   info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED) {
+		info->raw_bit_depth =
+			ia_css_pipe_util_pipe_input_format_bpp(pipe);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+						"sh_css_pipe_get_output_frame_info() leave:\n");
+	return err;
+}
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+void
+ia_css_stream_send_input_frame(const struct ia_css_stream *stream,
+			       const unsigned short *data,
+			       unsigned int width,
+			       unsigned int height)
+{
+	assert(stream != NULL);
+
+	ia_css_inputfifo_send_input_frame(
+			data, width, height,
+			stream->config.channel_id,
+			stream->config.format,
+			stream->config.pixels_per_clock == 2);
+}
+
+void
+ia_css_stream_start_input_frame(const struct ia_css_stream *stream)
+{
+	assert(stream != NULL);
+
+	ia_css_inputfifo_start_frame(
+			stream->config.channel_id,
+			stream->config.format,
+			stream->config.pixels_per_clock == 2);
+}
+
+void
+ia_css_stream_send_input_line(const struct ia_css_stream *stream,
+			      const unsigned short *data,
+			      unsigned int width,
+			      const unsigned short *data2,
+			      unsigned int width2)
+{
+	assert(stream != NULL);
+
+	ia_css_inputfifo_send_line(stream->config.channel_id,
+					       data, width, data2, width2);
+}
+
+void
+ia_css_stream_send_input_embedded_line(const struct ia_css_stream *stream,
+		enum ia_css_stream_format format,
+		const unsigned short *data,
+		unsigned int width)
+{
+	assert(stream != NULL);
+	if (data == NULL || width == 0)
+		return;
+	ia_css_inputfifo_send_embedded_line(stream->config.channel_id,
+			format, data, width);
+}
+
+void
+ia_css_stream_end_input_frame(const struct ia_css_stream *stream)
+{
+	assert(stream != NULL);
+
+	ia_css_inputfifo_end_frame(stream->config.channel_id);
+}
+#endif
+
+static void
+append_firmware(struct ia_css_fw_info **l, struct ia_css_fw_info *firmware)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "append_firmware() enter:\n");
+	while (*l)
+		l = &(*l)->next;
+	*l = firmware;
+	firmware->next = NULL;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "append_firmware() leave:\n");
+}
+
+static void
+remove_firmware(struct ia_css_fw_info **l, struct ia_css_fw_info *firmware)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "remove_firmware() enter:\n");
+	while (*l && *l != firmware)
+		l = &(*l)->next;
+	if (!*l)
+		return;
+	*l = firmware->next;
+	firmware->next = NULL;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "remove_firmware() leave:\n");
+}
+
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+static enum ia_css_err
+upload_isp_code(struct ia_css_fw_info *firmware)
+{
+	hrt_vaddress binary = firmware->info.isp.xmem_addr;
+	if (!binary) {
+		unsigned size = firmware->blob.size;
+		const unsigned char *blob;
+		const unsigned char *binary_name;
+		binary_name =
+			(const unsigned char *)(IA_CSS_EXT_ISP_PROG_NAME(
+						firmware));
+		blob = binary_name +
+			strlen((const char *)binary_name) +
+			1;
+		binary = sh_css_load_blob(blob, size);
+		firmware->info.isp.xmem_addr = binary;
+	}
+
+	if (!binary)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	return IA_CSS_SUCCESS;
+}
+#endif
+
+static enum ia_css_err
+acc_load_extension(struct ia_css_fw_info *firmware)
+{
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+	enum ia_css_err err = upload_isp_code(firmware);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+#endif
+
+	firmware->loaded = true;
+	return IA_CSS_SUCCESS;
+}
+
+static void
+acc_unload_extension(struct ia_css_fw_info *firmware)
+{
+	if (firmware->info.isp.xmem_addr) {
+		mmgr_free(firmware->info.isp.xmem_addr);
+		firmware->info.isp.xmem_addr = mmgr_NULL;
+	}
+	firmware->isp_code = NULL;
+	firmware->loaded = false;
+}
+/* Load firmware for extension */
+static enum ia_css_err
+ia_css_pipe_load_extension(struct ia_css_pipe *pipe,
+			   struct ia_css_fw_info *firmware)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(firmware != NULL);
+	assert(pipe != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_load_extension() enter:\n");
+	if (firmware->info.isp.type == IA_CSS_ACC_OUTPUT)
+		append_firmware(&pipe->output_stage, firmware);
+	else if (firmware->info.isp.type == IA_CSS_ACC_VIEWFINDER) {
+		append_firmware(&pipe->vf_stage, firmware);
+	}
+	err = acc_load_extension(firmware);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_load_extension() leave:\n");
+	return err;
+}
+
+/* Unload firmware for extension */
+static void
+ia_css_pipe_unload_extension(struct ia_css_pipe *pipe,
+			     struct ia_css_fw_info *firmware)
+{
+	assert(firmware != NULL);
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_unload_extension() enter:\n");
+	if (firmware->info.isp.type == IA_CSS_ACC_OUTPUT)
+		remove_firmware(&pipe->output_stage, firmware);
+	else if (firmware->info.isp.type == IA_CSS_ACC_VIEWFINDER)
+		remove_firmware(&pipe->vf_stage, firmware);
+	acc_unload_extension(firmware);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_unload_extension() leave:\n");
+}
+
+bool
+ia_css_pipeline_uses_params(struct ia_css_pipeline *me)
+{
+	struct ia_css_pipeline_stage *stage;
+
+	assert(me != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_uses_params() enter: me=%p\n", me);
+
+	for (stage = me->stages; stage; stage = stage->next)
+		if (stage->binary_info && stage->binary_info->enable.params) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_pipeline_uses_params() leave: "
+				"return_bool=true\n");
+			return true;
+		}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_uses_params() leave: return_bool=false\n");
+	return false;
+}
+
+static enum ia_css_err
+sh_css_pipeline_add_acc_stage(struct ia_css_pipeline *pipeline,
+			      const void *acc_fw)
+{
+	struct ia_css_fw_info *fw = (struct ia_css_fw_info *)acc_fw;
+	enum ia_css_err	err = acc_load_extension(fw);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_pipeline_add_acc_stage() enter: pipeline=%p,"
+		" acc_fw=%p\n", pipeline, acc_fw);
+
+	if (err == IA_CSS_SUCCESS) {
+		struct ia_css_pipeline_stage_desc stage_desc;
+		ia_css_pipe_get_acc_stage_desc(&stage_desc, NULL, fw);
+		err = ia_css_pipeline_create_and_add_stage(pipeline,
+			&stage_desc,
+			NULL);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_pipeline_add_acc_stage() leave: return_err=%d\n",err);
+	return err;
+}
+
+/**
+ * @brief Tag a specific frame in continuous capture.
+ * Refer to "sh_css_internal.h" for details.
+ */
+enum ia_css_err ia_css_stream_capture_frame(struct ia_css_stream *stream,
+				unsigned int exp_id)
+{
+	struct sh_css_tag_descr tag_descr;
+	unsigned int encoded_tag_descr;
+	enum ia_css_err return_err;
+
+	(void)stream;
+	assert(stream != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_capture_frame() enter: exp_id=%d\n",
+		exp_id);
+
+	if (exp_id == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_stream_capture_frame() "
+			"leave: return_err=%d\n",
+			IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	/* Create the tag descriptor from the parameters */
+	sh_css_create_tag_descr(0, 0, 0, exp_id, &tag_descr);
+
+
+	/* Encode the tag descriptor into a 32-bit value */
+	encoded_tag_descr = sh_css_encode_tag_descr(&tag_descr);
+
+	if (!sh_css_sp_is_running()) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_stream_capture_frame() leaving:"
+			"queue unavailable\n");
+		/* SP is not running. The queues are not valid */
+		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+
+
+	/* Enqueue the encoded tag to the host2sp queue.
+	 * Note: The pipe and stage IDs for tag_cmd queue are hard-coded to 0
+	 * on both host and the SP side.
+	 * It is mainly because it is enough to have only one tag_cmd queue */
+	return_err= ia_css_bufq_enqueue_tag_cmd((uint32_t)encoded_tag_descr);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_capture_frame() leave: return_err=%d\n",
+		return_err);
+
+	return return_err;
+}
+
+/**
+ * @brief Configure the continuous capture.
+ * Refer to "sh_css_internal.h" for details.
+ */
+enum ia_css_err ia_css_stream_capture(
+	struct ia_css_stream *stream,
+	int num_captures,
+	unsigned int skip,
+	int offset)
+{
+	struct sh_css_tag_descr tag_descr;
+	unsigned int encoded_tag_descr;
+	enum ia_css_err return_err;
+
+	if (stream == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_capture() enter: num_captures=%d,"
+		" skip=%d, offset=%d\n", num_captures, skip,offset);
+
+	/* Check if the tag descriptor is valid */
+	if (num_captures < SH_CSS_MINIMUM_TAG_ID) {
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_capture() leave: return_err=%d\n",
+		IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	/* Create the tag descriptor from the parameters */
+	sh_css_create_tag_descr(num_captures, skip, offset, 0, &tag_descr);
+
+
+	/* Encode the tag descriptor into a 32-bit value */
+	encoded_tag_descr = sh_css_encode_tag_descr(&tag_descr);
+
+	if (!sh_css_sp_is_running()) {
+		/* SP is not running. The queues are not valid */
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_stream_capture() leaving:"
+			"queues unavailable\n");
+		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+	}
+
+	/* Enqueue the encoded tag to the host2sp queue.
+	 * Note: The pipe and stage IDs for tag_cmd queue are hard-coded to 0
+	 * on both host and the SP side.
+	 * It is mainly because it is enough to have only one tag_cmd queue */
+	return_err = ia_css_bufq_enqueue_tag_cmd((uint32_t)encoded_tag_descr);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_capture() leave: return_err=%d\n",
+		return_err);
+
+	return return_err;
+}
+
+void ia_css_stream_request_flash(struct ia_css_stream *stream)
+{
+	(void)stream;
+
+	assert(stream != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_request_flash() enter: void\n");
+
+	sh_css_write_host2sp_command(host2sp_cmd_start_flash);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_request_flash() leave: return_void\n");
+}
+
+static void
+sh_css_init_host_sp_control_vars(void)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_ia_css_ispctrl_sp_isp_started;
+
+	unsigned int HIVE_ADDR_host_sp_queues_initialized;
+	unsigned int HIVE_ADDR_sp_sleep_mode;
+	unsigned int HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb;
+	unsigned int HIVE_ADDR_sp_stop_copy_preview;
+	unsigned int HIVE_ADDR_host_sp_com;
+	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
+				/ sizeof(int);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_init_host_sp_control_vars() enter: void\n");
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_ia_css_ispctrl_sp_isp_started = fw->info.sp.isp_started;
+
+	HIVE_ADDR_host_sp_queues_initialized =
+		fw->info.sp.host_sp_queues_initialized;
+	HIVE_ADDR_sp_sleep_mode = fw->info.sp.sleep_mode;
+	HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb = fw->info.sp.invalidate_tlb;
+	HIVE_ADDR_sp_stop_copy_preview = fw->info.sp.stop_copy_preview;
+	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+
+	(void)HIVE_ADDR_ia_css_ispctrl_sp_isp_started; /* Suppres warnings in CRUN */
+
+	(void)HIVE_ADDR_sp_sleep_mode;
+	(void)HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb;
+	(void)HIVE_ADDR_sp_stop_copy_preview;
+	(void)HIVE_ADDR_host_sp_com;
+
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(ia_css_ispctrl_sp_isp_started),
+		(uint32_t)(0));
+
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(host_sp_queues_initialized),
+		(uint32_t)(0));
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_sleep_mode),
+		(uint32_t)(0));
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(ia_css_dmaproxy_sp_invalidate_tlb),
+		(uint32_t)(false));
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_stop_copy_preview),
+		my_css.stop_copy_preview?(uint32_t)(1):(uint32_t)(0));
+	store_sp_array_uint(host_sp_com, o, host2sp_cmd_ready);
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	sh_css_update_host2sp_num_mipi_frames
+			(my_css.num_mipi_frames);
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_init_host_sp_control_vars() leave: return_void\n");
+}
+
+/**
+ * create the internal structures and fill in the configuration data
+ */
+void ia_css_pipe_config_defaults(struct ia_css_pipe_config *pipe_config)
+{
+	struct ia_css_pipe_config def_config = {
+		IA_CSS_PIPE_MODE_PREVIEW, /* mode */
+		1,      /* isp_pipe_version */
+		{0, 0}, /* bayer_ds_out_res */
+		{0, 0}, /* capt_pp_in_res */
+		{0, 0}, /* vf_pp_in_res */
+		{0, 0}, /* dvs_crop_out_res */
+		{{0, 0}, 0, 0, 0, 0}, /* output_info */
+		{{0, 0}, 0, 0, 0, 0}, /* second_output_info */
+		{{0, 0}, 0, 0, 0, 0}, /* vf_output_info */
+		{{0, 0}, 0, 0, 0, 0}, /* second_vf_output_info */
+		NULL,   /* acc_extension */
+		NULL,   /* acc_stages */
+		0,      /* num_acc_stages */
+		{
+			IA_CSS_CAPTURE_MODE_RAW, /* mode */
+			false, /* enable_xnr */
+			false  /* enable_raw_output */
+		},      /* default_capture_config */
+		{0, 0}, /* dvs_envelope */
+		IA_CSS_FRAME_DELAY_1, /* dvs_frame_delay */
+		-1,     /* acc_num_execs */
+		true,   /* enable_dz */
+	};
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_config_defaults()\n");
+	*pipe_config = def_config;
+}
+
+void
+ia_css_pipe_extra_config_defaults(struct ia_css_pipe_extra_config *extra_config)
+{
+	assert(extra_config != NULL);
+
+	extra_config->enable_raw_binning = false;
+	extra_config->enable_yuv_ds = false;
+	extra_config->enable_high_speed = false;
+	extra_config->enable_dvs_6axis = false;
+	extra_config->enable_reduced_pipe = false;
+	extra_config->disable_vf_pp = false;
+	extra_config->enable_fractional_ds = false;
+}
+
+void ia_css_stream_config_defaults(struct ia_css_stream_config *stream_config)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_config_defaults()\n");
+	assert(stream_config != NULL);
+	memset(stream_config, 0, sizeof(*stream_config));
+	stream_config->online = true;
+	stream_config->left_padding = -1;
+	/* temporary default value for backwards compatibility.
+	 * This field used to be hardcoded within CSS but this has now
+	 * been moved to the stream_config struct. */
+	stream_config->source.port.rxcount = 0x04040404;
+}
+
+static enum ia_css_err
+ia_css_acc_pipe_create(struct ia_css_pipe *pipe)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(pipe != NULL);
+
+	/* There is not meaning for num_execs = 0 semantically. Run atleast once. */
+	if (pipe->config.acc_num_execs == 0)
+		pipe->config.acc_num_execs = 1;
+
+	return err;
+}
+
+enum ia_css_err
+ia_css_pipe_create(const struct ia_css_pipe_config *config,
+		   struct ia_css_pipe **pipe)
+{
+	if (config == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	if (pipe == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	return ia_css_pipe_create_extra(config, NULL, pipe);
+}
+
+enum ia_css_err
+ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
+			 const struct ia_css_pipe_extra_config *extra_config,
+			 struct ia_css_pipe **pipe)
+{
+	enum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;
+	struct ia_css_pipe *internal_pipe = NULL;
+	unsigned int i;
+	struct ia_css_frame_info *tmp_output_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE],
+				 *tmp_vf_output_info[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+	bool *tmp_enable_viewfinder[IA_CSS_PIPE_MAX_OUTPUT_STAGE];
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_create()\n");
+	ia_css_debug_dump_pipe_config(config);
+	ia_css_debug_dump_pipe_extra_config(extra_config);
+
+	if (pipe == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	err = create_pipe(config->mode, &internal_pipe, false);
+	if (internal_pipe == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	/* now we have a pipe structure to fill */
+	internal_pipe->config = *config;
+	if (extra_config)
+		internal_pipe->extra_config = *extra_config;
+	else
+		ia_css_pipe_extra_config_defaults(&internal_pipe->extra_config);
+
+	if (config->mode == IA_CSS_PIPE_MODE_ACC) {
+		/* Temporary hack to migrate acceleration to CSS 2.0.
+		 * In the future the code for all pipe types should be
+		 * unified. */
+		*pipe = internal_pipe;
+		return ia_css_acc_pipe_create(internal_pipe);
+	}
+
+	/*Use config value when dvs_frame_delay setting equal to 2, otherwise always 1 by default */
+	internal_pipe->dvs_frame_delay =
+		(internal_pipe->config.dvs_frame_delay == IA_CSS_FRAME_DELAY_2) ?
+		IA_CSS_FRAME_DELAY_2 : IA_CSS_FRAME_DELAY_1;
+
+	/* we still keep enable_raw_binning for backward compatibility, for any new
+	   fractional bayer downscaling, we should use bayer_ds_out_res. if both are
+	   specified, bayer_ds_out_res will take precedence.if none is specified, we
+	   set bayer_ds_out_res equal to IF output resolution(IF may do cropping on
+	   sensor output) or use default decimation factor 1. */
+	if (internal_pipe->extra_config.enable_raw_binning &&
+		 internal_pipe->config.bayer_ds_out_res.width) {
+		/* fill some code here, if no code is needed, please remove it during integration */
+	}
+
+	/* YUV downscaling */
+	if ((internal_pipe->config.vf_pp_in_res.width ||
+		 internal_pipe->config.capt_pp_in_res.width) &&
+	     internal_pipe->config.mode == IA_CSS_PIPE_MODE_CAPTURE) {
+		enum ia_css_frame_format format;
+		if (internal_pipe->config.vf_pp_in_res.width) {
+			format = IA_CSS_FRAME_FORMAT_YUV_LINE;
+			ia_css_frame_info_init(
+				&internal_pipe->vf_yuv_ds_input_info,
+				internal_pipe->config.vf_pp_in_res.width,
+				internal_pipe->config.vf_pp_in_res.height,
+				format, 0);
+		}
+		if (internal_pipe->config.capt_pp_in_res.width) {
+			format = IA_CSS_FRAME_FORMAT_YUV420;
+			ia_css_frame_info_init(
+				&internal_pipe->out_yuv_ds_input_info,
+				internal_pipe->config.capt_pp_in_res.width,
+				internal_pipe->config.capt_pp_in_res.height,
+				format, 0);
+		}
+	}
+	if (internal_pipe->config.vf_pp_in_res.width &&
+	    internal_pipe->config.mode == IA_CSS_PIPE_MODE_PREVIEW) {
+		ia_css_frame_info_init(
+				&internal_pipe->vf_yuv_ds_input_info,
+				internal_pipe->config.vf_pp_in_res.width,
+				internal_pipe->config.vf_pp_in_res.height,
+				IA_CSS_FRAME_FORMAT_YUV_LINE, 0);
+	}
+	/* handle bayer downscaling output info */
+	if (internal_pipe->config.bayer_ds_out_res.width) {
+			ia_css_frame_info_init(
+				&internal_pipe->bds_output_info,
+				internal_pipe->config.bayer_ds_out_res.width,
+				internal_pipe->config.bayer_ds_out_res.height,
+				IA_CSS_FRAME_FORMAT_RAW, 0);
+	}
+
+	tmp_output_info[0]	= &internal_pipe->config.output_info;
+	tmp_output_info[1] 	= &internal_pipe->config.second_output_info;
+	tmp_vf_output_info[0]	= &internal_pipe->config.vf_output_info;
+	tmp_vf_output_info[1] 	= &internal_pipe->config.second_vf_output_info;
+	tmp_enable_viewfinder[0]= &internal_pipe->enable_viewfinder;
+	tmp_enable_viewfinder[1]= &internal_pipe->enable_second_viewfinder;
+	/* handle output info, asume always needed */
+	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
+		if (tmp_output_info[i]->res.width) {
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+			if ( tmp_output_info[i]->format == IA_CSS_FRAME_FORMAT_BINARY_8) {
+				tmp_output_info[i]->res.height =
+					ceil_div(tmp_output_info[i]->res.width, HIVE_ISP_DDR_WORD_BYTES);
+				tmp_output_info[i]->res.width = HIVE_ISP_DDR_WORD_BYTES;
+			}
+#endif
+			err = sh_css_pipe_configure_output(
+					internal_pipe,
+					tmp_output_info[i]->res.width,
+					tmp_output_info[i]->res.height,
+					tmp_output_info[i]->padded_width,
+					tmp_output_info[i]->format,
+					i);
+			if (err != IA_CSS_SUCCESS) {
+				ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "ia_css_pipe_create: "
+								"invalid output info\n");
+				sh_css_free(internal_pipe);
+				internal_pipe = NULL;
+				return err;
+			}
+		}
+
+		/* handle vf output info, when configured */
+		*tmp_enable_viewfinder[i] = (tmp_vf_output_info[i]->res.width != 0);
+		if (tmp_vf_output_info[i]->res.width) {
+			err = sh_css_pipe_configure_viewfinder(
+					internal_pipe,
+					tmp_vf_output_info[i]->res.width,
+					tmp_vf_output_info[i]->res.height,
+					tmp_vf_output_info[i]->padded_width,
+					tmp_vf_output_info[i]->format,
+					i);
+			if (err != IA_CSS_SUCCESS) {
+				ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "ia_css_pipe_create: "
+								"invalid vf output info\n");
+				sh_css_free(internal_pipe);
+				internal_pipe = NULL;
+				return err;
+			}
+		}
+	}
+	if (internal_pipe->config.acc_extension) {
+		ia_css_pipe_load_extension(internal_pipe,
+			internal_pipe->config.acc_extension);
+	}
+	/* set all info to zeroes first */
+	memset(&internal_pipe->info, 0, sizeof(internal_pipe->info));
+
+	/* all went well, return the pipe */
+	*pipe = internal_pipe;
+	return IA_CSS_SUCCESS;
+}
+
+
+enum ia_css_err
+ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
+		     struct ia_css_pipe_info *pipe_info)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipe_get_info()\n");
+	assert(pipe_info != NULL);
+	if (pipe_info == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+			"ia_css_pipe_get_info: pipe_info cannot be NULL\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	if (pipe == NULL || pipe->stream == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+			"ia_css_pipe_get_info: ia_css_stream_create needs to"
+			" be called before ia_css_[stream/pipe]_get_info\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	/* we succeeded return the info */
+	*pipe_info = pipe->info;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_get_info() leave\n");
+	return IA_CSS_SUCCESS;
+}
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2)
+/* Configuration of INPUT_SYSTEM_VERSION_2401 is done on SP */
+static enum ia_css_err
+ia_css_stream_configure_rx(struct ia_css_stream *stream)
+{
+	struct ia_css_input_port *config;
+	assert(stream != NULL);
+
+	config = &stream->config.source.port;
+// AM: this code is not reliable, especially for 2400
+	if (config->num_lanes == 1)
+		stream->csi_rx_config.mode = MONO_1L_1L_0L;
+	else if (config->num_lanes == 2)
+		stream->csi_rx_config.mode = STEREO_2L_1L_2L;
+	else if (config->num_lanes == 3)
+		stream->csi_rx_config.mode = MONO_3L_1L_0L;
+	else if (config->num_lanes == 4)
+		stream->csi_rx_config.mode = MONO_4L_1L_0L;
+	else if (config->num_lanes != 0)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (config->port == IA_CSS_CSI2_PORT1)
+		stream->csi_rx_config.port = MIPI_PORT1_ID;
+	else if (config->port == IA_CSS_CSI2_PORT2)
+		stream->csi_rx_config.port = MIPI_PORT2_ID;
+	else if (config->port == IA_CSS_CSI2_PORT0)
+		stream->csi_rx_config.port = MIPI_PORT0_ID;
+	else
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	stream->csi_rx_config.timeout    = config->timeout;
+	stream->csi_rx_config.initcount  = 0;
+	stream->csi_rx_config.synccount  = 0x28282828;
+	stream->csi_rx_config.rxcount    = config->rxcount;
+	if (config->compression.type == IA_CSS_CSI2_COMPRESSION_TYPE_NONE)
+		stream->csi_rx_config.comp = MIPI_PREDICTOR_NONE;
+	else {
+		/* not implemented yet, requires extension of the rx_cfg_t
+		 * struct */
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	stream->csi_rx_config.is_two_ppc = (stream->config.pixels_per_clock == 2);
+	stream->reconfigure_css_rx = true;
+	return IA_CSS_SUCCESS;
+}
+#endif
+
+static struct ia_css_pipe *
+find_pipe(struct ia_css_pipe *pipes[],
+		unsigned int num_pipes,
+		enum ia_css_pipe_mode mode,
+		bool copy_pipe)
+{
+	unsigned i;
+	assert(pipes != NULL);
+	for (i = 0; i < num_pipes; i++) {
+		assert(pipes[i] != NULL);
+		if (pipes[i]->config.mode != mode)
+			continue;
+		if (copy_pipe && pipes[i]->mode != IA_CSS_PIPE_ID_COPY)
+			continue;
+		return pipes[i];
+	}
+	return NULL;
+}
+
+static enum ia_css_err
+ia_css_acc_stream_create(struct ia_css_stream *stream)
+{
+	int i;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_acc_stream_create() enter:\n");
+
+	assert(stream != NULL);
+
+	for (i = 0;  i< stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		assert(pipe != NULL);
+		pipe->stream = stream;
+	}
+
+	/* Map SP threads before doing anything. */
+	err = map_sp_threads(stream, true);
+	if (err != IA_CSS_SUCCESS) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_acc_stream_create(): map_sp_threads: err=%d\n", err);
+		return err;
+	}
+
+	for (i = 0;  i< stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		assert(pipe != NULL);
+		ia_css_pipe_map_queue(pipe, true);
+	}
+
+	err = create_host_pipeline_structure(stream);
+	if (err != IA_CSS_SUCCESS) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_acc_stream_create(): create_host_pipeline_structure: err=%d\n", err);
+		return err;
+	}
+
+	stream->started = false;
+
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"ia_css_acc_stream_create() leave:\n");
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+metadata_info_init(const struct ia_css_metadata_config *mdc,
+		   struct ia_css_metadata_info *md)
+{
+	/* Either both width and height should be set or neither */
+	if ((mdc->resolution.height > 0) ^ (mdc->resolution.width > 0))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	md->resolution = mdc->resolution;
+        /* We round up the stride to a multiple of the width
+         * of the port going to DDR, this is a HW requirements (DMA). */
+	md->stride = CEIL_MUL(mdc->resolution.width, HIVE_ISP_DDR_WORD_BYTES);
+	md->size = mdc->resolution.height * md->stride;
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_stream_create(const struct ia_css_stream_config *stream_config,
+					 int num_pipes,
+					 struct ia_css_pipe *pipes[],
+					 struct ia_css_stream **stream)
+{
+	struct ia_css_pipe *curr_pipe;
+	struct ia_css_stream *curr_stream = NULL;
+	bool spcopyonly;
+	bool sensor_binning_changed;
+	int i;
+	enum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;
+	struct ia_css_metadata_info md_info;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_create() enter, num_pipes=%d\n", num_pipes);
+	ia_css_debug_dump_stream_config(stream_config, num_pipes);
+
+	/* some checks */
+	if (num_pipes == 0 ||
+		stream == NULL ||
+		pipes == NULL) {
+		err = IA_CSS_ERR_INVALID_ARGUMENTS;
+		goto ERR;
+	}
+
+	/* We don't support metadata for JPEG stream, since they both use str2mem */
+	if (stream_config->format == IA_CSS_STREAM_FORMAT_BINARY_8 &&
+	    stream_config->metadata_config.resolution.height > 0)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+	ia_css_debug_pipe_graph_dump_stream_config(stream_config);
+
+	/* check if mipi size specified */
+	if (stream_config->mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR)
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	if (stream_config->online)
+#endif
+	{
+		if (my_css.size_mem_words == 0) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_stream_create() exit, need to set mipi frame size\n");
+			assert(my_css.size_mem_words != 0);
+			err = IA_CSS_ERR_INTERNAL_ERROR;
+			goto ERR;
+		}
+	}
+#endif
+
+	/* Currently we only supported metadata up to a certain size. */
+	err = metadata_info_init(&stream_config->metadata_config, &md_info);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+
+	/* allocate the stream instance */
+	curr_stream = sh_css_malloc(sizeof(struct ia_css_stream));
+	if (curr_stream == NULL) {
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		goto ERR;
+	}
+	/* default all to 0 */
+	memset(curr_stream, 0, sizeof(struct ia_css_stream));
+	curr_stream->info.metadata_info = md_info;
+
+	/* allocate pipes */
+	curr_stream->num_pipes = num_pipes;
+	curr_stream->pipes = sh_css_malloc(num_pipes * sizeof(struct ia_css_pipe *));
+	if (curr_stream->pipes == NULL) {
+		sh_css_free(curr_stream);
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		goto ERR;
+	}
+	/* store pipes */
+	spcopyonly = (num_pipes == 1) && (pipes[0]->config.mode == IA_CSS_PIPE_MODE_COPY);
+	for (i = 0; i < num_pipes; i++)
+		curr_stream->pipes [i] = pipes[i];
+	curr_stream->last_pipe = curr_stream->pipes[0];
+	/* take over stream config */
+	curr_stream->config = *stream_config;
+
+#ifdef USE_INPUT_SYSTEM_VERSION_2401
+	if (curr_stream->config.online) {
+		curr_stream->config.source.port.num_lanes = stream_config->source.port.num_lanes;
+		curr_stream->config.mode =  IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
+	}
+#endif
+	/* TO BE REMOVED when all drivers move to CSS API 2.1 */
+	if (curr_stream->config.pixels_per_clock == 0)
+		curr_stream->config.pixels_per_clock =
+			curr_stream->config.two_pixels_per_clock ? 2 : 1;
+
+	/* in case driver doesn't configure init number of raw buffers, configure it here */
+	if (curr_stream->config.target_num_cont_raw_buf == 0)
+		curr_stream->config.target_num_cont_raw_buf = NUM_CONTINUOUS_FRAMES;
+	if (curr_stream->config.init_num_cont_raw_buf == 0)
+		curr_stream->config.init_num_cont_raw_buf = curr_stream->config.target_num_cont_raw_buf;
+
+	/* copy mode specific stuff */
+	switch (curr_stream->config.mode) {
+		case IA_CSS_INPUT_MODE_SENSOR:
+		case IA_CSS_INPUT_MODE_BUFFERED_SENSOR:
+#if defined(USE_INPUT_SYSTEM_VERSION_2)
+		ia_css_stream_configure_rx(curr_stream);
+#endif
+		break;
+	case IA_CSS_INPUT_MODE_TPG:
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_stream_create tpg_configuration: "
+			"x_mask=%d, y_mask=%d, x_delta=%d, "
+			"y_delta=%d, xy_mask=%d\n",
+			curr_stream->config.source.tpg.x_mask,
+			curr_stream->config.source.tpg.y_mask,
+			curr_stream->config.source.tpg.x_delta,
+			curr_stream->config.source.tpg.y_delta,
+			curr_stream->config.source.tpg.xy_mask);
+
+		sh_css_sp_configure_tpg(
+			curr_stream->config.source.tpg.x_mask,
+			curr_stream->config.source.tpg.y_mask,
+			curr_stream->config.source.tpg.x_delta,
+			curr_stream->config.source.tpg.y_delta,
+			curr_stream->config.source.tpg.xy_mask);
+#endif
+		break;
+	case IA_CSS_INPUT_MODE_PRBS:
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_create: mode prbs\n");
+		sh_css_sp_configure_prbs(curr_stream->config.source.prbs.seed);
+#endif
+		break;
+	case IA_CSS_INPUT_MODE_MEMORY:
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_create: mode memory\n");
+		curr_stream->reconfigure_css_rx = false;
+		break;
+	default:
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_create: mode sensor/default\n");
+	}
+	err = ia_css_stream_isp_parameters_init(curr_stream);
+	if (err != IA_CSS_SUCCESS)
+		goto ERR;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_create: isp_params_configs: %p\n",curr_stream->isp_params_configs);
+
+	if (num_pipes == 1 && pipes[0]->config.mode == IA_CSS_PIPE_MODE_ACC) {
+		*stream = curr_stream;
+		err = ia_css_acc_stream_create(curr_stream);
+		goto ERR;
+	}
+	/* sensor binning */
+	if (!spcopyonly){
+		sensor_binning_changed =
+			sh_css_params_set_binning_factor(curr_stream, curr_stream->config.sensor_binning_factor);
+	} else {
+		sensor_binning_changed = false;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_create: sensor_binning=%d, changed=%d\n",
+		curr_stream->config.sensor_binning_factor, sensor_binning_changed);
+	/* loop over pipes */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_create: num_pipes=%d\n",
+		num_pipes);
+	curr_stream->cont_capt = false;
+	/* Temporary hack: we give the preview pipe a reference to the capture
+	 * pipe in continuous capture mode. */
+	if (curr_stream->config.continuous) {
+		/* Search for the preview pipe and create the copy pipe */
+		struct ia_css_pipe *preview_pipe;
+		struct ia_css_pipe *video_pipe;
+		struct ia_css_pipe *capture_pipe = NULL;
+		struct ia_css_pipe *copy_pipe = NULL;
+
+		if (num_pipes >= 2)
+			curr_stream->cont_capt = true;
+
+		/* Create copy pipe here, since it may not be exposed to the driver */
+		preview_pipe = find_pipe(pipes, num_pipes,
+						IA_CSS_PIPE_MODE_PREVIEW, false);
+		video_pipe = find_pipe(pipes, num_pipes,
+						IA_CSS_PIPE_MODE_VIDEO, false);
+		if (curr_stream->cont_capt == true) {
+			capture_pipe = find_pipe(pipes, num_pipes,
+						IA_CSS_PIPE_MODE_CAPTURE, false);
+			if (capture_pipe == NULL) {
+				err = IA_CSS_ERR_INTERNAL_ERROR;
+				goto ERR;
+			}
+		}
+		/* We do not support preview and video pipe at the same time */
+		if (preview_pipe && video_pipe) {
+			err = IA_CSS_ERR_INVALID_ARGUMENTS;
+			goto ERR;
+		}
+
+		if (preview_pipe && !preview_pipe->pipe_settings.preview.copy_pipe) {
+			err = create_pipe(IA_CSS_PIPE_MODE_CAPTURE, &copy_pipe, true);
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+			ia_css_pipe_config_defaults(&copy_pipe->config);
+			preview_pipe->pipe_settings.preview.copy_pipe = copy_pipe;
+			copy_pipe->stream = curr_stream;
+		}
+		if (preview_pipe && (curr_stream->cont_capt == true)) {
+			preview_pipe->pipe_settings.preview.capture_pipe = capture_pipe;
+		}
+		if (video_pipe && !video_pipe->pipe_settings.video.copy_pipe) {
+			err = create_pipe(IA_CSS_PIPE_MODE_CAPTURE, &copy_pipe, true);
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+			ia_css_pipe_config_defaults(&copy_pipe->config);
+			video_pipe->pipe_settings.video.copy_pipe = copy_pipe;
+			copy_pipe->stream = curr_stream;
+		}
+		if (video_pipe && (curr_stream->cont_capt == true)) {
+			video_pipe->pipe_settings.video.capture_pipe = capture_pipe;
+		}
+	}
+	for (i = 0; i < num_pipes; i++) {
+		curr_pipe = pipes[i];
+		/* set current stream */
+		curr_pipe->stream = curr_stream;
+		/* take over effective info */
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+		if ((curr_stream->config.format >= IA_CSS_STREAM_FORMAT_USER_DEF1) &&
+		    (curr_stream->config.format <= IA_CSS_STREAM_FORMAT_USER_DEF8)) {
+			curr_stream->config.effective_res.height =
+				ceil_div(curr_stream->config.effective_res.width, HIVE_ISP_DDR_WORD_BYTES);
+			curr_stream->config.effective_res.width = HIVE_ISP_DDR_WORD_BYTES;
+		}
+#endif
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_create: effective_res=%dx%d\n",
+			curr_stream->config.effective_res.width,
+			curr_stream->config.effective_res.height);
+
+		err = ia_css_util_check_res(
+			curr_stream->config.effective_res.width,
+			curr_stream->config.effective_res.height);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+
+		if (curr_stream->info.effective_info.width != curr_stream->config.effective_res.width ||
+			curr_stream->info.effective_info.height != curr_stream->config.effective_res.height) {
+			curr_stream->info.effective_info.width = curr_stream->config.effective_res.width;
+			curr_stream->info.effective_info.height = curr_stream->config.effective_res.height;
+		}
+		/* sensor binning per pipe */
+		if (sensor_binning_changed)
+			sh_css_pipe_free_shading_table(curr_pipe);
+	}
+
+	/* now pipes have been configured, info should be available */
+	for (i = 0; i < num_pipes; i++) {
+		struct ia_css_pipe_info *pipe_info = NULL;
+		curr_pipe = pipes[i];
+
+		err = sh_css_pipe_load_binaries(curr_pipe);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+
+		/* handle each pipe */
+		pipe_info = &curr_pipe->info;
+		err = sh_css_pipe_get_output_frame_info(curr_pipe,
+				&pipe_info->output_info, 0);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+		err = sh_css_pipe_get_output_frame_info(curr_pipe,
+				&pipe_info->second_output_info, 1);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+		if (!spcopyonly){
+			err = sh_css_pipe_get_grid_info(curr_pipe,
+						&pipe_info->grid_info);
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+			sh_css_pipe_get_viewfinder_frame_info(curr_pipe,
+					&pipe_info->vf_output_info, 0);
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+			sh_css_pipe_get_viewfinder_frame_info(curr_pipe,
+					&pipe_info->second_vf_output_info, 1);
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+		}
+
+		my_css.active_pipes[ia_css_pipe_get_pipe_num(curr_pipe)] = curr_pipe;
+	}
+	/* this is a legacy from CSS 1.5, we still need this here because we need this info
+	   to configure the sensor ouput in CameraDriver, but it is not needed in real device.
+	   add this macro to make this explicit. */
+#if defined(HRT_CSIM) || defined(HRT_RTL)
+	/* stream has been configured, info should be available */
+	{
+		/* use first pipe in list, should be identical anyway */
+		// TODO: should come from stream something
+		struct ia_css_stream_info *stream_info = &curr_stream->info;
+		// TODO: JB implement stream info
+		err = sh_css_pipe_get_input_resolution(pipes[0],
+				&stream_info->raw_info.width,
+				&stream_info->raw_info.height);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+	}
+#endif
+
+	curr_stream->started = false;
+
+	/* Map SP threads before doing anything. */
+	err = map_sp_threads(curr_stream, true);
+	if (err != IA_CSS_SUCCESS) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_stream_create(): map_sp_threads: return_err=%d\n", err);
+	}
+
+	for (i = 0; i < num_pipes; i++) {
+		curr_pipe = pipes[i];
+		ia_css_pipe_map_queue(curr_pipe, true);
+	}
+
+	/* Create host side pipeline objects without stages */
+	err = create_host_pipeline_structure(curr_stream);
+	if (err != IA_CSS_SUCCESS) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_stream_create(): create_host_pipeline_structure: err=%d\n", err);
+		goto ERR;
+	}
+
+	/* assign curr_stream */
+	*stream = curr_stream;
+
+ERR:
+	if (err == IA_CSS_SUCCESS)
+	{
+		/* working mode: enter into the seed list */
+		if (my_css_save.mode == sh_css_mode_working)
+		for(i=0;i<MAX_ACTIVE_STREAMS;i++)
+			if (my_css_save.stream_seeds[i].stream == NULL)
+			{
+				int j;
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_stream_create(): entered stream into loc=%d\n", i);
+				my_css_save.stream_seeds[i].orig_stream = stream;
+				my_css_save.stream_seeds[i].stream = curr_stream;
+				my_css_save.stream_seeds[i].num_pipes = num_pipes;
+				my_css_save.stream_seeds[i].stream_config = *stream_config;
+				for(j=0;j<num_pipes;j++)
+				{
+					my_css_save.stream_seeds[i].pipe_config[j] = pipes[j]->config;
+					my_css_save.stream_seeds[i].pipes[j] = pipes[j];
+				}
+				break;
+			}
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_stream_create() leave, err=%d mode=%d\n",
+			err, my_css_save.mode);
+	return err;
+}
+
+enum ia_css_err
+ia_css_stream_destroy(struct ia_css_stream *stream)
+{
+	int i;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_destroy: enter\n");
+	assert(stream != NULL);
+
+	ia_css_stream_isp_parameters_uninit(stream);
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+	stream_unregister_with_csi_rx(stream);
+#endif
+
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *curr_pipe = stream->pipes[i];
+		assert(curr_pipe != NULL);
+		ia_css_pipe_map_queue(curr_pipe, false);
+	}
+
+	err = map_sp_threads(stream, false);
+	if (err != IA_CSS_SUCCESS) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			"ia_css_stream_destroy(): map_sp_threads: return_err=%d\n", err);
+		return err;
+	}
+
+	/* remove references from pipes to stream */
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *entry = stream->pipes[i];
+		assert(entry != NULL);
+		if (entry != NULL) {
+			/* clear reference to stream */
+			entry->stream = NULL;
+			/* check internal copy pipe */
+			if (entry->mode == IA_CSS_PIPE_ID_PREVIEW &&
+			    entry->pipe_settings.preview.copy_pipe) {
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+					"ia_css_stream_destroy: "
+					"clearing stream on internal preview copy pipe\n");
+				entry->pipe_settings.preview.copy_pipe->stream = NULL;
+			}
+			if (entry->mode == IA_CSS_PIPE_ID_VIDEO &&
+				entry->pipe_settings.video.copy_pipe) {
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+					"ia_css_stream_destroy: "
+					"clearing stream on internal video copy pipe\n");
+				entry->pipe_settings.video.copy_pipe->stream = NULL;
+			}
+			sh_css_pipe_unload_binaries(entry);
+		}
+	}
+	/* free associated memory of stream struct */
+	sh_css_free(stream->pipes);
+	stream->pipes = NULL;
+	stream->num_pipes = 0;
+	/* working mode: take out of the seed list */
+	if (my_css_save.mode == sh_css_mode_working)
+		for(i=0;i<MAX_ACTIVE_STREAMS;i++)
+			if (my_css_save.stream_seeds[i].stream == stream)
+			{
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,"ia_css_stream_destroy: took out stream %d", i);
+				my_css_save.stream_seeds[i].stream = NULL;
+				break;
+			}
+	sh_css_free(stream);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_destroy: leave\n");
+
+	return err;
+}
+
+enum ia_css_err
+ia_css_stream_get_info(const struct ia_css_stream *stream,
+		       struct ia_css_stream_info *stream_info)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_get_info: enter/exit\n");
+	assert(stream != NULL);
+	assert(stream_info != NULL);
+
+	*stream_info = stream->info;
+	return IA_CSS_SUCCESS;
+}
+
+/*
+ * Rebuild a stream, including allocating structs, setting configuration and
+ * building the required pipes.
+ * The data is taken from the css_save struct updated upon stream creation.
+ * The stream handle is used to identify the correct entry in the css_save struct
+ */
+enum ia_css_err
+ia_css_stream_load(struct ia_css_stream *stream)
+{
+	int i;
+	enum ia_css_err err;
+	assert(stream != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,	"ia_css_stream_load() enter, \n");
+	for(i=0;i<MAX_ACTIVE_STREAMS;i++)
+		if (my_css_save.stream_seeds[i].stream == stream)
+		{
+			int j;
+			for(j=0;j<my_css_save.stream_seeds[i].num_pipes;j++)
+				if ((err = ia_css_pipe_create(&(my_css_save.stream_seeds[i].pipe_config[j]), &my_css_save.stream_seeds[i].pipes[j])) != IA_CSS_SUCCESS)
+				{
+					if (j)
+					{
+						int k;
+						for(k=0;k<j;k++)
+							ia_css_pipe_destroy(my_css_save.stream_seeds[i].pipes[k]);
+					}
+					return(err);
+				}
+			err = ia_css_stream_create(&(my_css_save.stream_seeds[i].stream_config), my_css_save.stream_seeds[i].num_pipes,
+						    my_css_save.stream_seeds[i].pipes, &(my_css_save.stream_seeds[i].stream));
+		    if (err != IA_CSS_SUCCESS)
+			{
+				ia_css_stream_destroy(stream);
+				for(j=0;j<my_css_save.stream_seeds[i].num_pipes;j++)
+					ia_css_pipe_destroy(my_css_save.stream_seeds[i].pipes[j]);
+				return(err);
+			}
+			break;
+		}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,	"ia_css_stream_load() exit, \n");
+	return(IA_CSS_SUCCESS);
+}
+
+enum ia_css_err
+ia_css_stream_start(struct ia_css_stream *stream)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_start()\n");
+	assert(stream != NULL);
+	assert(stream->last_pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_start: starting %d\n",
+		stream->last_pipe->mode);
+
+	/* Create host side pipeline. */
+	err = create_host_pipeline(stream);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+	if((stream->config.mode == IA_CSS_INPUT_MODE_SENSOR) ||
+	   (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR))
+		stream_register_with_csi_rx(stream);
+#endif
+#endif
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+	// Initialize mipi size checks
+	if (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR)
+	{
+		unsigned int idx;
+		unsigned int port = (unsigned int) (stream->config.source.port.port) ;
+
+		for (idx = 0; idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT; idx++) {
+			sh_css_sp_group.config.mipi_sizes_for_check[port][idx] =  sh_css_get_mipi_sizes_for_check(port, idx);
+		}
+	}
+#endif
+
+	return sh_css_pipe_start(stream);
+}
+
+enum ia_css_err
+ia_css_stream_stop(struct ia_css_stream *stream)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_stop() enter/exit\n");
+	assert(stream != NULL);
+	assert(stream->last_pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_stop: stopping %d\n",
+		stream->last_pipe->mode);
+
+	// Check if this is the last pipe, if not return else stop everything
+	//if (pipe_num_counter > 1) return IA_CSS_SUCCESS;
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+	// De-initialize mipi size checks
+	if (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR)
+	{
+		unsigned int idx;
+		unsigned int port = (unsigned int) (stream->config.source.port.port) ;
+
+		for (idx = 0; idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT; idx++) {
+			sh_css_sp_group.config.mipi_sizes_for_check[port][idx] = 0;
+		}
+	}
+#endif
+	err = ia_css_pipeline_request_stop(&stream->last_pipe->pipeline);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* Ideally, unmapping should happen after pipeline_stop, but current
+	 * semantics do not allow that. */
+	/* err = map_sp_threads(stream, false); */
+
+	return err;
+}
+
+bool
+ia_css_stream_has_stopped(struct ia_css_stream *stream)
+{
+	bool stopped;
+	assert(stream != NULL);
+
+	stopped = ia_css_pipeline_has_stopped(&stream->last_pipe->pipeline);
+
+	return stopped;
+}
+
+/*
+ * Destroy the stream and all the pipes related to it.
+ * The stream handle is used to identify the correct entry in the css_save struct
+ */
+enum ia_css_err
+ia_css_stream_unload(struct ia_css_stream *stream)
+{
+	int i;
+	assert(stream != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,	"ia_css_stream_unload() enter, \n");
+	/* some checks */
+	assert (stream != NULL);
+	for(i=0;i<MAX_ACTIVE_STREAMS;i++)
+		if (my_css_save.stream_seeds[i].stream == stream)
+		{
+			int j;
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,	"ia_css_stream_unload(): unloading %d (%p)\n", i, my_css_save.stream_seeds[i].stream);
+			ia_css_stream_destroy(stream);
+			for(j=0;j<my_css_save.stream_seeds[i].num_pipes;j++)
+				ia_css_pipe_destroy(my_css_save.stream_seeds[i].pipes[j]);
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,	"ia_css_stream_unload(): after unloading %d (%p)\n", i, my_css_save.stream_seeds[i].stream);
+			break;
+		}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,	"ia_css_stream_unload() exit, \n");
+	return(IA_CSS_SUCCESS);
+}
+
+enum ia_css_err
+ia_css_temp_pipe_to_pipe_id(const struct ia_css_pipe *pipe, enum ia_css_pipe_id *pipe_id)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_temp_pipe_to_pipe_id() enter/exit\n");
+	if (pipe != NULL)
+		*pipe_id = pipe->mode;
+	else
+		*pipe_id = IA_CSS_PIPE_ID_COPY;
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_stream_format
+ia_css_stream_get_format(const struct ia_css_stream *stream)
+{
+	return stream->config.format;
+}
+
+bool
+ia_css_stream_get_two_pixels_per_clock(const struct ia_css_stream *stream)
+{
+	return (stream->config.pixels_per_clock == 2);
+}
+
+struct ia_css_binary *
+ia_css_stream_get_dvs_binary(const struct ia_css_stream *stream)
+{
+	int i;
+	struct ia_css_pipe *video_pipe = NULL;
+
+	/* First we find the video pipe */
+	for (i=0; i<stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		if (pipe->config.mode == IA_CSS_PIPE_MODE_VIDEO) {
+			video_pipe = pipe;
+			break;
+		}
+	}
+	if (video_pipe)
+		return &video_pipe->pipe_settings.video.video_binary;
+	return NULL;
+}
+
+struct ia_css_binary *
+ia_css_stream_get_3a_binary(const struct ia_css_stream *stream)
+{
+	struct ia_css_pipe *pipe;
+
+	assert(stream != NULL);
+
+	pipe = stream->pipes[0];
+
+	if (stream->num_pipes == 2) {
+		assert(stream->pipes[1] != NULL);
+		if (stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_VIDEO ||
+		    stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_PREVIEW)
+			pipe = stream->pipes[1];
+	}
+
+	return ia_css_pipe_get_3a_binary(pipe);
+}
+
+enum ia_css_err
+ia_css_stream_set_output_padded_width(struct ia_css_stream *stream, unsigned int output_padded_width)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	struct ia_css_pipe *pipe;
+
+	assert(stream != NULL);
+
+	pipe = stream->last_pipe;
+
+	assert(pipe != NULL);
+
+	// set the config also just in case (redundant info? why do we save config in pipe?)
+	pipe->config.output_info.padded_width = output_padded_width;
+	pipe->output_info[0].padded_width = output_padded_width;
+
+	return err;
+}
+
+
+static struct ia_css_binary *
+ia_css_pipe_get_3a_binary (const struct ia_css_pipe *pipe)
+{
+	struct ia_css_binary *s3a_binary = NULL;
+
+	assert(pipe != NULL);
+
+	switch (pipe->config.mode) {
+	case IA_CSS_PIPE_MODE_PREVIEW:
+		s3a_binary = (struct ia_css_binary*)&pipe->pipe_settings.preview.preview_binary;
+		break;
+	case IA_CSS_PIPE_MODE_VIDEO:
+		s3a_binary = (struct ia_css_binary*)&pipe->pipe_settings.video.video_binary;
+		break;
+	case IA_CSS_PIPE_MODE_CAPTURE:
+		if (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_PRIMARY)
+			s3a_binary = (struct ia_css_binary*)&pipe->pipe_settings.capture.primary_binary;
+		else if (pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_ADVANCED ||
+			 pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_LOW_LIGHT ||
+			 pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER) {
+			s3a_binary
+				= (struct ia_css_binary*)&pipe->pipe_settings.capture.pre_isp_binary;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (s3a_binary && s3a_binary->info->sp.enable.s3a)
+		return s3a_binary;
+
+	return NULL;
+}
+
+#if defined(IS_ISP_2500_SYSTEM)
+void ia_css_pipe_get_bds_resolution(const struct ia_css_pipe *pipe, struct ia_css_resolution *res)
+{
+	assert(pipe != NULL);
+
+	*res = pipe->bds_output_info.res;
+}
+
+void ia_css_pipe_get_dvs_envelope(const struct ia_css_pipe *pipe, struct ia_css_resolution *res)
+{
+	assert(pipe != NULL);
+
+	*res = pipe->config.dvs_envelope;
+}
+#endif
+
+struct ia_css_pipeline *
+ia_css_pipe_get_pipeline(const struct ia_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+
+	return (struct ia_css_pipeline*)&pipe->pipeline;
+}
+
+unsigned int
+ia_css_pipe_get_pipe_num(const struct ia_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+
+	/* KW was not sure this function was not returning a value
+	   that was out of range; so added an assert, and, for the
+	   case when asserts are not enabled, clip to the largest
+	   value; pipe_num is unsigned so the value cannot be too small
+	*/
+	assert(pipe->pipe_num < IA_CSS_PIPELINE_NUM_MAX);
+
+	if (pipe->pipe_num >= IA_CSS_PIPELINE_NUM_MAX)
+		return (IA_CSS_PIPELINE_NUM_MAX - 1);
+
+	return pipe->pipe_num;
+}
+
+
+unsigned int
+ia_css_pipe_get_isp_pipe_version(const struct ia_css_pipe *pipe)
+{
+	assert(pipe != NULL);
+
+	return pipe->config.isp_pipe_version;
+}
+
+#define SP_START_TIMEOUT_US 30000000
+
+#if defined(IS_ISP_2500_SYSTEM)
+void
+ia_css_start_sp1(void)
+{
+	unsigned long timeout;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_start_sp1() enter\n");
+	sh_css_sp1_start();
+	/* waiting for the SP is completely started */
+	timeout = SP_START_TIMEOUT_US;
+	while((ia_css_sp1ctrl_get_state(SP1_ID) != IA_CSS_SP_SW_INITIALIZED) && timeout) {
+		timeout--;
+		hrt_sleep();
+	}
+	if (timeout == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "ia_css_start_sp1() timeout\n");
+		return; /* IA_CSS_ERR_INTERNAL_ERROR; */
+	}
+	sh_css_write_host2sp1_command(host2sp_cmd_ready);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_start_sp1() exit\n");
+}
+#endif
+enum ia_css_err
+ia_css_start_sp(void)
+{
+	unsigned long timeout;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_start_sp() enter\n");
+	sh_css_sp_start_isp();
+
+	/* waiting for the SP is completely started */
+	timeout = SP_START_TIMEOUT_US;
+	while((ia_css_spctrl_get_state(SP0_ID) != IA_CSS_SP_SW_INITIALIZED) && timeout) {
+		timeout--;
+		hrt_sleep();
+	}
+	if (timeout == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "ia_css_start_sp() timeout\n");
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+
+	/* Workaround, in order to run two streams in parallel. See TASK 4271*/
+	/* TODO: Fix this. */
+
+	sh_css_init_host_sp_control_vars();
+
+	/* buffers should be initialized only when sp is started */
+	/* AM: At the moment it will be done only when there is no stream active. */
+
+	sh_css_setup_queues();
+
+#if defined(IS_ISP_2500_SYSTEM)
+	/* Start the SP1 Core */
+	ia_css_start_sp1();
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_start_sp() exit\n");
+	return IA_CSS_SUCCESS;
+}
+
+/**
+ *	Time to wait SP for termincate. Only condition when this can happen
+ *	is a fatal hw failure, but we must be able to detect this and emit
+ *	a proper error trace.
+ */
+#define SP_SHUTDOWN_TIMEOUT_US 200000
+
+#if defined(IS_ISP_2500_SYSTEM)
+enum ia_css_err
+ia_css_stop_sp1(void)
+{
+	unsigned long timeout;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_stop_sp1() enter\n");
+	/* For now, stop whole SP1 */
+	sh_css_write_host2sp1_command(host2sp_cmd_terminate);
+	sh_css_sp1_set_sp1_running(false);
+#ifdef __KERNEL__
+	printk("STOP_FUNC SP1: reach point 1\n");
+#endif
+	timeout = SP_SHUTDOWN_TIMEOUT_US;
+	while ((ia_css_sp1ctrl_get_state(SP1_ID)!= IA_CSS_SP_SW_TERMINATED) && timeout) {
+		timeout--;
+		hrt_sleep();
+	}
+	if (timeout == 0) {
+		ia_css_debug_dump_debug_info("sh_css_stop_sp1 point1");
+		//ia_css_debug_dump_sp_sw_debug_info();
+#ifdef __KERNEL__
+		printk(KERN_ERR "%s poll timeout point 1!!!\n", __func__);
+#endif
+	}
+#ifdef __KERNEL__
+	printk("STOP_FUNC SP1: reach point 2\n");
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_stop_sp1() exit\n");
+
+	return IA_CSS_SUCCESS;
+}
+#endif //#if defined(IS_ISP_2500_SYSTEM)
+
+enum ia_css_err
+ia_css_stop_sp(void)
+{
+	unsigned int i;
+	unsigned long timeout;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_stop_sp() enter\n");
+	/* For now, stop whole SP */
+	sh_css_write_host2sp_command(host2sp_cmd_terminate);
+	sh_css_sp_set_sp_running(false);
+#ifdef __KERNEL__
+	printk("STOP_FUNC: reach point 1\n");
+#endif
+	timeout = SP_SHUTDOWN_TIMEOUT_US;
+	while ((ia_css_spctrl_get_state(SP0_ID)!= IA_CSS_SP_SW_TERMINATED) && timeout) {
+		timeout--;
+		hrt_sleep();
+	}
+	if (timeout == 0) {
+		ia_css_debug_dump_debug_info("sh_css_stop_sp point1");
+		ia_css_debug_dump_sp_sw_debug_info();
+#ifdef __KERNEL__
+		printk(KERN_ERR "%s poll timeout point 1!!!\n", __func__);
+#endif
+	}
+#ifdef __KERNEL__
+	printk("STOP_FUNC: reach point 2\n");
+#endif
+	while (!isp_ctrl_getbit(ISP0_ID, ISP_SC_REG, ISP_IDLE_BIT) && timeout) {
+		timeout--;
+		hrt_sleep();
+	}
+	if (timeout == 0) {
+		ia_css_debug_dump_debug_info("sh_css_stop_sp point2");
+		ia_css_debug_dump_sp_sw_debug_info();
+#ifdef __KERNEL__
+		printk(KERN_ERR "%s poll timeout point 2!!!\n", __func__);
+#endif
+	}
+#ifdef __KERNEL__
+	printk("STOP_FUNC: reach point 3\n");
+#endif
+
+	for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
+		if (hmm_buffer_record_h[i] != NULL) {
+			ia_css_rmgr_rel_vbuf(hmm_buffer_pool, &hmm_buffer_record_h[i]);
+		}
+	}
+
+	/* clear pending param sets from refcount */
+	sh_css_param_clear_param_sets();
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_stop_sp() exit\n");
+
+#if defined(IS_ISP_2500_SYSTEM)
+	/* Stop SP1 Core */
+	ia_css_stop_sp1();
+#endif
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_update_continuous_frames(struct ia_css_stream *stream)
+{
+	struct ia_css_pipe *pipe;
+	unsigned int i;
+
+	ia_css_debug_dtrace(
+	    IA_CSS_DEBUG_TRACE,
+	    "sh_css_update_continuous_frames() enter:\n");
+
+	if (stream == NULL) {
+		ia_css_debug_dtrace(
+			IA_CSS_DEBUG_TRACE,
+			"sh_css_update_continuous_frames() leave: invalid stream, return_void\n");
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	pipe = stream->continuous_pipe;
+
+	for (i = stream->config.init_num_cont_raw_buf;
+				i < stream->config.target_num_cont_raw_buf; i++) {
+		sh_css_update_host2sp_offline_frame(i,
+				pipe->continuous_frames[i], pipe->cont_md_buffers[i]);
+	}
+	sh_css_update_host2sp_cont_num_raw_frames
+			(stream->config.target_num_cont_raw_buf, true);
+	ia_css_debug_dtrace(
+	    IA_CSS_DEBUG_TRACE,
+	    "sh_css_update_continuous_frames() leave: return_void\n");
+
+	return IA_CSS_SUCCESS;
+}
+
+void ia_css_pipe_map_queue(struct ia_css_pipe *pipe, bool map)
+{
+	unsigned int thread_id;
+	enum ia_css_pipe_id pipe_id;
+	unsigned int pipe_num;
+
+	assert(pipe != NULL);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_pipeline_create() enter:\n");
+
+	pipe_id = pipe->mode;
+	pipe_num = pipe->pipe_num;
+
+	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+
+	/* map required buffer queues to resources */
+	/* TODO: to be improved */
+	if (pipe->mode == IA_CSS_PIPE_ID_PREVIEW) {
+#if defined(HAS_NO_INPUT_SYSTEM) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
+#endif
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);
+#if defined SH_CSS_ENABLE_METADATA
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
+#endif
+		if (pipe->pipe_settings.preview.preview_binary.info &&
+			pipe->pipe_settings.preview.preview_binary.info->sp.enable.s3a)
+			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);
+	} else if (pipe->mode == IA_CSS_PIPE_ID_CAPTURE) {
+#if defined(HAS_NO_INPUT_SYSTEM) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
+#endif
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);
+#if defined SH_CSS_ENABLE_METADATA
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
+#endif
+		if ((pipe->pipe_settings.capture.primary_binary.info &&
+			pipe->pipe_settings.capture.primary_binary.info->sp.enable.s3a) ||
+			(pipe->pipe_settings.capture.pre_isp_binary.info &&
+			pipe->pipe_settings.capture.pre_isp_binary.info->sp.enable.s3a))
+			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);
+	} else if (pipe->mode == IA_CSS_PIPE_ID_VIDEO) {
+#if defined(HAS_NO_INPUT_SYSTEM) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
+#endif
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
+		if (pipe->enable_viewfinder)
+			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);
+#if defined SH_CSS_ENABLE_METADATA
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
+#endif
+		if (pipe->pipe_settings.video.video_binary.info &&
+			pipe->pipe_settings.video.video_binary.info->sp.enable.s3a)
+			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_3A_STATISTICS, map);
+		if (pipe->pipe_settings.video.video_binary.info &&
+			pipe->pipe_settings.video.video_binary.info->sp.enable.dis)
+			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_DIS_STATISTICS, map);
+#if defined(IS_ISP_2500_SYSTEM)
+		if (pipe->pipe_settings.video.video_binary.info &&
+			pipe->pipe_settings.video.video_binary.info->sp.enable.lace_stats)
+			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_LACE_STATISTICS, map);
+#endif
+	} else if (pipe->mode == IA_CSS_PIPE_ID_COPY) {
+#if defined(HAS_NO_INPUT_SYSTEM) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
+#endif
+		if (!pipe->stream->config.continuous)
+			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
+#if defined SH_CSS_ENABLE_METADATA
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
+#endif
+	} else if (pipe->mode == IA_CSS_PIPE_ID_ACC) {
+#if defined(HAS_NO_INPUT_SYSTEM) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_INPUT_FRAME, map);
+#endif
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);
+#if defined SH_CSS_ENABLE_METADATA
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
+#endif
+	} else if (pipe->mode == IA_CSS_PIPE_ID_YUVPP) {
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_OUTPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME, map);
+		if (pipe->enable_viewfinder)
+			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME, map);
+		if (pipe->enable_second_viewfinder)
+			ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME, map);
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_PARAMETER_SET, map);
+#if defined SH_CSS_ENABLE_METADATA
+		ia_css_queue_map(thread_id, IA_CSS_BUFFER_TYPE_METADATA, map);
+#endif
+	}
+}
+
+#if CONFIG_ON_FRAME_ENQUEUE()
+static enum ia_css_err set_config_on_frame_enqueue(struct ia_css_frame_info *info, struct frame_data_wrapper *frame)
+{
+	frame->config_on_frame_enqueue.padded_width = 0;
+
+	// currently we support configuration on frame enqueue only on YUV formats
+	// on other formats the padded_width is zeroed for no configuration override
+	switch (info->format) {
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_NV12:
+		if (info->padded_width > info->res.width)
+		{
+			frame->config_on_frame_enqueue.padded_width = info->padded_width;
+		}
+		else if ((info->padded_width < info->res.width) && (info->padded_width > 0))
+		{
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+		}
+		// nothing to do if width == padded width or padded width is zeroed (the same)
+		break;
+	default:
+		break;
+	}
+
+	return IA_CSS_SUCCESS;
+}
+#endif
diff --git a/drivers/media/atomisp2/css2400/sh_css_defs.h b/drivers/media/atomisp2/css2400/sh_css_defs.h
new file mode 100644
index 0000000..9c76cd5
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_defs.h
@@ -0,0 +1,452 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_DEFS_H_
+#define _SH_CSS_DEFS_H_
+
+#if !defined(__SP1)
+#include "isp.h"
+#else
+#include "system_local.h"  /* to get IS_ISP_2500_SYSTEM for SP1*/
+#endif
+/*#include "vamem.h"*/ /* Cannot include for VAMEM properties this file is visible on ISP -> pipeline generator */
+
+#include "math_support.h"	/* max(), min, etc etc */
+
+/* Macros for Controlling SP1 enabling and compilation */
+/* SH_CSS_DEFS_INCLUDED is to test whether all SP1 dependent files have included
+	sh_css_defs.h file or not */
+#define SH_CSS_DEFS_INCLUDED
+
+#if defined(IS_ISP_2500_SYSTEM)
+#define ENABLE_SP1  /* Disabling this Macro excludes SP1 from the system */
+#define SWITCH_GACS_TO_SP1 /* Enabling this macro switches the GACs to SP1 */
+#endif /*defined(IS_ISP_2500_SYSTEM)*/
+
+#if !defined(ENABLE_SP1)
+#undef SWITCH_GACS_TO_SP1
+#endif
+
+/* ID's for refcount */
+#define IA_CSS_REFCOUNT_PARAM_SET_POOL  0xCAFE0001
+#define IA_CSS_REFCOUNT_PARAM_BUFFER    0xCAFE0002
+
+/* Digital Image Stabilization */
+#define SH_CSS_DIS_DECI_FACTOR_LOG2       6
+
+/* UV offset: 1:uv=-128...127, 0:uv=0...255 */
+#define SH_CSS_UV_OFFSET_IS_0             0
+
+#if !defined(IS_ISP_2500_SYSTEM)
+/* Bits of bayer is adjusted as 13 in ISP */
+#define SH_CSS_BAYER_BITS                 13
+#else /* defined(IS_ISP_2500_SYSTEM) */
+/* Bits of bayer is adjusted as 11 in ISP */
+#define SH_CSS_BAYER_BITS                 11
+#endif
+
+/* Max value of bayer data (unsigned 13bit in ISP) */
+#define SH_CSS_BAYER_MAXVAL               ((1U << SH_CSS_BAYER_BITS) - 1)
+
+/* Bits of yuv in ISP */
+#define SH_CSS_ISP_YUV_BITS               8
+
+#define SH_CSS_DP_GAIN_SHIFT              5
+#define SH_CSS_BNR_GAIN_SHIFT             13
+#define SH_CSS_YNR_GAIN_SHIFT             13
+#define SH_CSS_AE_YCOEF_SHIFT             13
+#define SH_CSS_AF_FIR_SHIFT               13
+#define SH_CSS_YEE_DETAIL_GAIN_SHIFT      8  /* [u5.8] */
+#define SH_CSS_YEE_SCALE_SHIFT            8
+#define SH_CSS_TNR_COEF_SHIFT             13
+#define SH_CSS_MACC_COEF_SHIFT            11 /* [s2.11] for ISP1 */
+#define SH_CSS_MACC2_COEF_SHIFT           13 /* [s[exp].[13-exp]] for ISP2 */
+#define SH_CSS_DIS_COEF_SHIFT             13
+
+/* enumeration of the bayer downscale factors. When a binary supports multiple
+ * factors, the OR of these defines is used to build the mask of supported
+ * factors. The BDS factor is used in pre-processor expressions so we cannot
+ * use an enum here. */
+#define SH_CSS_BDS_FACTOR_1_00	(0)
+#define SH_CSS_BDS_FACTOR_1_25	(1)
+#define SH_CSS_BDS_FACTOR_1_50	(2)
+#define SH_CSS_BDS_FACTOR_2_00	(3)
+#define SH_CSS_BDS_FACTOR_2_25	(4)
+#define SH_CSS_BDS_FACTOR_2_50	(5)
+#define SH_CSS_BDS_FACTOR_3_00	(6)
+#define SH_CSS_BDS_FACTOR_4_00	(7)
+#define SH_CSS_BDS_FACTOR_4_50	(8)
+#define SH_CSS_BDS_FACTOR_5_00	(9)
+#define SH_CSS_BDS_FACTOR_6_00	(10)
+#define SH_CSS_BDS_FACTOR_8_00	(11)
+#define NUM_BDS_FACTORS	        (12)
+
+#define PACK_BDS_FACTOR(factor)	(1<<(factor))
+
+/*--------------- sRGB Gamma -----------------
+CCM        : YCgCo[0,8191] -> RGB[0,4095]
+sRGB Gamma : RGB  [0,4095] -> RGB[0,8191]
+CSC        : RGB  [0,8191] -> YUV[0,8191]
+
+CCM:
+Y[0,8191],CgCo[-4096,4095],coef[-8192,8191] -> RGB[0,4095]
+
+sRGB Gamma:
+RGB[0,4095] -(interpolation step16)-> RGB[0,255] -(LUT 12bit)-> RGB[0,4095] -> RGB[0,8191]
+
+CSC:
+RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
+--------------------------------------------*/
+/* Bits of input/output of sRGB Gamma */
+#define SH_CSS_RGB_GAMMA_INPUT_BITS       12 /* [0,4095] */
+#define SH_CSS_RGB_GAMMA_OUTPUT_BITS      13 /* [0,8191] */
+
+/* Bits of fractional part of interpolation in vamem, [0,4095]->[0,255] */
+#define SH_CSS_RGB_GAMMA_FRAC_BITS        \
+	(SH_CSS_RGB_GAMMA_INPUT_BITS - SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE_LOG2)
+#define SH_CSS_RGB_GAMMA_ONE              (1 << SH_CSS_RGB_GAMMA_FRAC_BITS)
+
+/* Bits of input of CCM,  = 13, Y[0,8191],CgCo[-4096,4095] */
+#define SH_CSS_YUV2RGB_CCM_INPUT_BITS     SH_CSS_BAYER_BITS
+
+/* Bits of output of CCM,  = 12, RGB[0,4095] */
+#define SH_CSS_YUV2RGB_CCM_OUTPUT_BITS    SH_CSS_RGB_GAMMA_INPUT_BITS
+
+/* Maximum value of output of CCM */
+#define SH_CSS_YUV2RGB_CCM_MAX_OUTPUT     \
+	((1 << SH_CSS_YUV2RGB_CCM_OUTPUT_BITS) - 1)
+
+#define SH_CSS_NUM_INPUT_BUF_LINES        4
+
+/* Left cropping only applicable for sufficiently large nway */
+#if ISP_VEC_NELEMS == 16
+#define SH_CSS_MAX_LEFT_CROPPING          0
+#define SH_CSS_MAX_TOP_CROPPING           0
+#else
+#define SH_CSS_MAX_LEFT_CROPPING          12
+#define SH_CSS_MAX_TOP_CROPPING           12
+#endif
+
+#define	SH_CSS_SP_MAX_WIDTH               1280
+
+/* This is the maximum grid we can handle in the ISP binaries.
+ * The host code makes sure no bigger grid is ever selected. */
+#define SH_CSS_MAX_BQ_GRID_WIDTH          80
+#define SH_CSS_MAX_BQ_GRID_HEIGHT         60
+
+/* The minimum dvs envelope is 12x12 to make sure the invalid rows/columns
+   that result from filter initialization are skipped. */
+#define SH_CSS_MIN_DVS_ENVELOPE           12U
+
+/* The FPGA system (vec_nelems == 16) only supports upto 5MP */
+#if ISP_VEC_NELEMS == 16
+#define SH_CSS_MAX_SENSOR_WIDTH           2560
+#define SH_CSS_MAX_SENSOR_HEIGHT          1920
+#else
+#define SH_CSS_MAX_SENSOR_WIDTH           4608
+#define SH_CSS_MAX_SENSOR_HEIGHT          3450
+#endif
+
+/* Limited to reduce vmem pressure */
+#if ISP_VMEM_DEPTH >= 3072
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH  SH_CSS_MAX_SENSOR_WIDTH
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT SH_CSS_MAX_SENSOR_HEIGHT
+#else
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH  3264
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT 2448
+#endif
+/* When using bayer decimation */
+/*
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC  4224
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC 3168
+*/
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC  SH_CSS_MAX_SENSOR_WIDTH
+#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC SH_CSS_MAX_SENSOR_HEIGHT
+
+#define SH_CSS_MIN_SENSOR_WIDTH           2
+#define SH_CSS_MIN_SENSOR_HEIGHT          2
+
+#if defined(IS_ISP_2400_SYSTEM)
+#define SH_CSS_MAX_VF_WIDTH               1920
+#define SH_CSS_MAX_VF_HEIGHT              1080
+#else
+#define SH_CSS_MAX_VF_WIDTH               1280
+#define SH_CSS_MAX_VF_HEIGHT              960
+#endif
+/*
+#define SH_CSS_MAX_VF_WIDTH_DEC               1920
+#define SH_CSS_MAX_VF_HEIGHT_DEC              1080
+*/
+#define SH_CSS_MAX_VF_WIDTH_DEC               SH_CSS_MAX_VF_WIDTH
+#define SH_CSS_MAX_VF_HEIGHT_DEC              SH_CSS_MAX_VF_HEIGHT
+
+/* We use 16 bits per coordinate component, including integer
+   and fractional bits */
+#define SH_CSS_MORPH_TABLE_GRID               ISP_VEC_NELEMS
+#define SH_CSS_MORPH_TABLE_ELEM_BYTES         2
+#define SH_CSS_MORPH_TABLE_ELEMS_PER_DDR_WORD \
+	(HIVE_ISP_DDR_WORD_BYTES/SH_CSS_MORPH_TABLE_ELEM_BYTES)
+
+#define SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR   (SH_CSS_MAX_BQ_GRID_WIDTH + 1)
+#define SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR   (SH_CSS_MAX_BQ_GRID_HEIGHT + 1)
+#define SH_CSS_MAX_SCTBL_ALIGNED_WIDTH_PER_COLOR \
+	CEIL_MUL(SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR, ISP_VEC_NELEMS)
+
+/* Each line of this table is aligned to the maximum line width. */
+#define SH_CSS_MAX_S3ATBL_WIDTH              SH_CSS_MAX_BQ_GRID_WIDTH
+
+
+#define NUM_VIDEO_DELAY_FRAMES	3
+#define NUM_VIDEO_TNR_FRAMES	2
+
+/* Rules: these implement logic shared between the host code and ISP firmware.
+   The ISP firmware needs these rules to be applied at pre-processor time,
+   that's why these are macros, not functions. */
+#define _ISP_BQS(num)  ((num)/2)
+#define _ISP_VECS(width) CEIL_DIV(width, ISP_VEC_NELEMS)
+
+#define ISP_BQ_GRID_WIDTH(elements_per_line, deci_factor_log2) \
+	CEIL_SHIFT(elements_per_line/2,  deci_factor_log2)
+#define ISP_BQ_GRID_HEIGHT(lines_per_frame, deci_factor_log2) \
+	CEIL_SHIFT(lines_per_frame/2,  deci_factor_log2)
+#define ISP_C_VECTORS_PER_LINE(elements_per_line) \
+	_ISP_VECS(elements_per_line/2)
+
+/* The morphing table is similar to the shading table in the sense that we
+   have 1 more value than we have cells in the grid. */
+#define _ISP_MORPH_TABLE_WIDTH(int_width) \
+	(CEIL_DIV(int_width, SH_CSS_MORPH_TABLE_GRID) + 1)
+#define _ISP_MORPH_TABLE_HEIGHT(int_height) \
+	(CEIL_DIV(int_height, SH_CSS_MORPH_TABLE_GRID) + 1)
+#define _ISP_MORPH_TABLE_ALIGNED_WIDTH(width) \
+	CEIL_MUL(_ISP_MORPH_TABLE_WIDTH(width), \
+		 SH_CSS_MORPH_TABLE_ELEMS_PER_DDR_WORD)
+
+#define _ISP_SCTBL_WIDTH_PER_COLOR(input_width, deci_factor_log2) \
+	(ISP_BQ_GRID_WIDTH(input_width, deci_factor_log2) + 1)
+#define _ISP_SCTBL_HEIGHT(input_height, deci_factor_log2) \
+	(ISP_BQ_GRID_HEIGHT(input_height, deci_factor_log2) + 1)
+#define _ISP_SCTBL_ALIGNED_WIDTH_PER_COLOR(input_width, deci_factor_log2) \
+	CEIL_MUL(_ISP_SCTBL_WIDTH_PER_COLOR(input_width, deci_factor_log2), \
+		 ISP_VEC_NELEMS)
+
+/* ********************************************************
+ * Statistics for Digital Image Stabilization
+ * ********************************************************/
+/* Some binaries put the vertical coefficients in DMEM instead
+   of VMEM to save VMEM. */
+/* ISP dmem is not enough to hold all params, configs and states for video_yuv_ds
+   binary,  so put dis coef to vmem */
+#define _SDIS_VER_COEF_TBL_USE_DMEM(mode, enable_sdis, enable_ds, isp_pipe_version) \
+	(mode == IA_CSS_BINARY_MODE_VIDEO \
+	&& enable_sdis && enable_ds != 2 && isp_pipe_version == 1)
+
+/* For YUV upscaling, the internal size is used for DIS statistics */
+#define _ISP_SDIS_ELEMS_ISP(input, internal, enable_us) \
+	((enable_us) ? (internal) : (input))
+
+/* SDIS Number of Grid */
+#define _ISP_SDIS_HOR_GRID_NUM_ISP(in_width, deci_factor_log2) \
+	CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2)
+#define _ISP_SDIS_VER_GRID_NUM_ISP(in_height, deci_factor_log2) \
+	CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)
+
+#define _ISP_SDIS_HOR_GRID_NUM_3A(in_width, deci_factor_log2) \
+	(_ISP_BQS(in_width) >> deci_factor_log2)
+#define _ISP_SDIS_VER_GRID_NUM_3A(in_height, deci_factor_log2) \
+	(_ISP_BQS(in_height) >> deci_factor_log2)
+
+/* SDIS Projections:
+ * SDIS1: Horizontal projections are calculated for each line.
+ * Vertical projections are calculated for each column.
+ * SDIS2: Projections are calculated for each grid cell.
+ * Grid cells that do not fall completely within the image are not
+ * valid. The host needs to use the bigger one for the stride but
+ * should only return the valid ones to the 3A. */
+#define __ISP_SDIS_HOR_PROJ_NUM_ISP(in_width, in_height, deci_factor_log2, \
+	isp_pipe_version) \
+	((isp_pipe_version == 1) ? \
+		CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2) : \
+		(CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2) * \
+		 CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)))
+
+#define __ISP_SDIS_VER_PROJ_NUM_ISP(in_width, in_height, deci_factor_log2, \
+	isp_pipe_version) \
+	((isp_pipe_version == 1) ? \
+		CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2) : \
+		(CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2) * \
+		 CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)))
+
+#define _ISP_SDIS_HOR_PROJ_NUM_3A(in_width, in_height, deci_factor_log2, \
+	isp_pipe_version) \
+	((isp_pipe_version == 1) ? \
+		(_ISP_BQS(in_height) >> deci_factor_log2) : \
+		((_ISP_BQS(in_width) >> deci_factor_log2) * \
+		 (_ISP_BQS(in_height) >> deci_factor_log2)))
+
+#define _ISP_SDIS_VER_PROJ_NUM_3A(in_width, in_height, deci_factor_log2, \
+	isp_pipe_version) \
+	((isp_pipe_version == 1) ? \
+		(_ISP_BQS(in_width) >> deci_factor_log2) : \
+		((_ISP_BQS(in_width) >> deci_factor_log2) * \
+		 (_ISP_BQS(in_height) >> deci_factor_log2)))
+
+/* SDIS Coefficients: */
+/* The ISP uses vectors to store the coefficients, so we round
+   the number of coefficients up to vectors. */
+#define __ISP_SDIS_HOR_COEF_NUM_VECS(in_width)  _ISP_VECS(_ISP_BQS(in_width))
+#define __ISP_SDIS_VER_COEF_NUM_VECS(in_height) _ISP_VECS(_ISP_BQS(in_height))
+
+/* The number of coefficients produced by the ISP */
+#define _ISP_SDIS_HOR_COEF_NUM_ISP(in_width) \
+	(__ISP_SDIS_HOR_COEF_NUM_VECS(in_width) * ISP_VEC_NELEMS)
+#define _ISP_SDIS_VER_COEF_NUM_ISP(in_height) \
+	(__ISP_SDIS_VER_COEF_NUM_VECS(in_height) * ISP_VEC_NELEMS)
+
+/* The number of coefficients used by the 3A library. This excludes
+   coefficients from grid cells that do not fall completely within the image. */
+#define _ISP_SDIS_HOR_COEF_NUM_3A(in_width, deci_factor_log2) \
+	((_ISP_BQS(in_width) >> deci_factor_log2) << deci_factor_log2)
+#define _ISP_SDIS_VER_COEF_NUM_3A(in_height, deci_factor_log2) \
+	((_ISP_BQS(in_height) >> deci_factor_log2) << deci_factor_log2)
+
+/* *****************************************************************
+ * Statistics for 3A (Auto Focus, Auto White Balance, Auto Exposure)
+ * *****************************************************************/
+/* if left cropping is used, 3A statistics are also cropped by 2 vectors. */
+#define _ISP_S3ATBL_WIDTH(in_width, deci_factor_log2) \
+	(_ISP_BQS(in_width) >> deci_factor_log2)
+#define _ISP_S3ATBL_HEIGHT(in_height, deci_factor_log2) \
+	(_ISP_BQS(in_height) >> deci_factor_log2)
+#define _ISP_S3A_ELEMS_ISP_WIDTH(width, left_crop) \
+	(width - ((left_crop) ? 2 * ISP_VEC_NELEMS : 0))
+
+#define _ISP_S3ATBL_ISP_WIDTH(in_width, deci_factor_log2) \
+	CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2)
+#define _ISP_S3ATBL_ISP_HEIGHT(in_height, deci_factor_log2) \
+	CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)
+#define ISP_S3ATBL_VECTORS \
+	_ISP_VECS(SH_CSS_MAX_S3ATBL_WIDTH * \
+		  (sizeof(struct ia_css_3a_output)/sizeof(int32_t)))
+#define ISP_S3ATBL_HI_LO_STRIDE \
+	(ISP_S3ATBL_VECTORS * ISP_VEC_NELEMS)
+#define ISP_S3ATBL_HI_LO_STRIDE_BYTES \
+	(sizeof(unsigned short) * ISP_S3ATBL_HI_LO_STRIDE)
+
+/* Viewfinder support */
+#define __ISP_MAX_VF_OUTPUT_WIDTH(width, left_crop) \
+	(width - 2*ISP_VEC_NELEMS + ((left_crop) ? 2 * ISP_VEC_NELEMS : 0))
+
+/* Number of vectors per vf line is determined by the chroma width,
+ * the luma width is derived from that. That's why we have the +1. */
+#define __ISP_VF_OUTPUT_WIDTH_VECS(out_width, vf_log_downscale) \
+	(_ISP_VECS((out_width) >> ((vf_log_downscale)+1)) * 2)
+
+#define _ISP_VF_OUTPUT_WIDTH(vf_out_vecs) ((vf_out_vecs) * ISP_VEC_NELEMS)
+#define _ISP_VF_OUTPUT_HEIGHT(out_height, vf_log_ds) \
+	((out_height) >> (vf_log_ds))
+
+#define _ISP_LOG_VECTOR_STEP(mode) \
+	((mode) == IA_CSS_BINARY_MODE_CAPTURE_PP ? 2 : 1)
+
+/* Rules for computing the internal width. This is extremely complicated
+ * and definitely needs to be commented and explained. */
+#define _ISP_LEFT_CROP_EXTRA(left_crop) ((left_crop) > 0 ? 2*ISP_VEC_NELEMS : 0)
+
+#if defined(IS_ISP_2500_SYSTEM)
+
+/* Nitsan - changed because of new iterator scheme for Stages in the line-loop
+	    it's no longer true that the min width is dependent on num-of-stages (pipelining)
+*/
+#define __ISP_MIN_INTERNAL_WIDTH(num_chunks, pipelining, mode)	256
+
+#else
+
+#define __ISP_MIN_INTERNAL_WIDTH(num_chunks, pipelining, mode) \
+	((num_chunks) * (pipelining) * (1<<_ISP_LOG_VECTOR_STEP(mode)) * \
+	 ISP_VEC_NELEMS)
+#endif
+
+#define __ISP_PADDED_OUTPUT_WIDTH(out_width, dvs_env_width, left_crop) \
+	((out_width) + MAX(dvs_env_width, _ISP_LEFT_CROP_EXTRA(left_crop)))
+
+#define __ISP_CHUNK_STRIDE_ISP(mode) \
+	((1<<_ISP_LOG_VECTOR_STEP(mode)) * ISP_VEC_NELEMS)
+
+#define __ISP_CHUNK_STRIDE_DDR(c_subsampling, num_chunks) \
+	((c_subsampling) * (num_chunks) * HIVE_ISP_DDR_WORD_BYTES)
+#define __ISP_INTERNAL_WIDTH(out_width, \
+			     dvs_env_width, \
+			     left_crop, \
+			     mode, \
+			     c_subsampling, \
+			     num_chunks, \
+			     pipelining) \
+	CEIL_MUL2(CEIL_MUL2(MAX(__ISP_PADDED_OUTPUT_WIDTH(out_width, \
+							    dvs_env_width, \
+							    left_crop), \
+				  __ISP_MIN_INTERNAL_WIDTH(num_chunks, \
+							   pipelining, \
+							   mode) \
+				 ), \
+			  __ISP_CHUNK_STRIDE_ISP(mode) \
+			 ), \
+		 __ISP_CHUNK_STRIDE_DDR(c_subsampling, num_chunks) \
+		)
+
+#define __ISP_INTERNAL_HEIGHT(out_height, dvs_env_height, top_crop) \
+	((out_height) + (dvs_env_height) + top_crop)
+
+/* @GC: Input can be up to sensor resolution when either bayer downscaling
+ *	or raw binning is enabled.
+ *	Also, during continuous mode, we need to align to 4*NWAY since input
+ *	should support binning */
+#define _ISP_MAX_INPUT_WIDTH(max_internal_width, enable_ds, enable_fixed_bayer_ds, enable_raw_bin, \
+				enable_continuous) \
+	((enable_ds) ? \
+	   SH_CSS_MAX_SENSOR_WIDTH :\
+	 (enable_fixed_bayer_ds) ? \
+	   CEIL_MUL(SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC, 4*ISP_VEC_NELEMS) : \
+	 (enable_raw_bin) ? \
+	   CEIL_MUL(SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH, 4*ISP_VEC_NELEMS) : \
+	 (enable_continuous) ? \
+	   SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH \
+	   : max_internal_width)
+
+#define _ISP_INPUT_WIDTH(internal_width, ds_input_width, enable_ds) \
+	((enable_ds) ? (ds_input_width) : (internal_width))
+
+#define _ISP_MAX_INPUT_HEIGHT(max_internal_height, enable_ds, enable_fixed_bayer_ds, enable_raw_bin, \
+				enable_continuous) \
+	((enable_ds) ? \
+	   SH_CSS_MAX_SENSOR_HEIGHT :\
+	 (enable_fixed_bayer_ds) ? \
+	   SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC : \
+	 (enable_raw_bin || enable_continuous) ? \
+	   SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT \
+	   : max_internal_height)
+
+#define _ISP_INPUT_HEIGHT(internal_height, ds_input_height, enable_ds) \
+	((enable_ds) ? (ds_input_height) : (internal_height))
+
+#define SH_CSS_MAX_STAGES 6 /* copy, preisp, anr, postisp, capture_pp, vf_pp */
+
+#endif /* _SH_CSS_DEFS_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_firmware.c b/drivers/media/atomisp2/css2400/sh_css_firmware.c
new file mode 100644
index 0000000..c586d2f
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_firmware.c
@@ -0,0 +1,223 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "platform_support.h"
+#include "sh_css_firmware.h"
+
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "sh_css_internal.h"
+#include "ia_css_isp_param.h"
+
+#include "memory_access.h"
+#include "assert_support.h"
+
+#include "isp.h"				/* PMEM_WIDTH_LOG2 */
+
+#define _STR(x) #x
+#define STR(x) _STR(x)
+
+struct firmware_header {
+	struct sh_css_fw_bi_file_h file_header;
+	struct ia_css_fw_info      binary_header;
+};
+
+/* Warning: same order as SH_CSS_BINARY_ID_* */
+static struct firmware_header *firmware_header;
+
+/* The string STR(140311_1735) is a place holder
+ * which will be replaced with the actual RELEASE_VERSION
+ * during package generation. Please do not modify  */
+static const char* release_version = STR(140311_1735);
+
+#define MAX_FW_REL_VER_NAME	300
+static char FW_rel_ver_name[MAX_FW_REL_VER_NAME] = "---";
+
+struct ia_css_fw_info	  sh_css_sp_fw;
+#if defined(IS_ISP_2500_SYSTEM)
+struct ia_css_fw_info	  sh_css_sp1_fw;
+#endif
+struct ia_css_blob_descr *sh_css_blob_info; /* Only ISP blob info (no SP) */
+unsigned		  sh_css_num_binaries; /* This includes 1 SP binary */
+
+char *sh_css_get_fw_version(void)
+{
+	return(FW_rel_ver_name);
+}
+
+
+/*
+ * Split the loaded firmware into blobs
+ */
+
+/* Setup sp/sp1 binary */
+static void
+setup_sp(struct ia_css_fw_info *fw, const char *fw_data, struct ia_css_fw_info *sh_css_sp_sp1_fw)
+{
+	const char *blob_data;
+
+	assert(fw != NULL);
+	assert(fw_data != NULL);
+
+	blob_data = fw_data + fw->blob.offset;
+
+	*sh_css_sp_sp1_fw = *fw;
+	/* MW: code starts at "offset" */
+	sh_css_sp_sp1_fw->blob.code = blob_data /* + fw->blob.text_source */;
+	sh_css_sp_sp1_fw->blob.data = blob_data + fw->blob.data_source;
+}
+enum ia_css_err
+sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi, struct ia_css_blob_descr *bd)
+{
+	const char *name;
+	const unsigned char *blob;
+
+	assert(fw != NULL);
+	assert(bd != NULL);
+
+	/* Special case: only one binary in fw */
+	if (bi == NULL) bi = (const struct ia_css_fw_info *)fw;
+
+	name = (const char *)fw + bi->blob.prog_name_offset;
+	blob = (const unsigned char *)fw + bi->blob.offset;
+
+	/* sanity check */
+	if (bi->blob.size != bi->blob.text_size + bi->blob.icache_size + bi->blob.data_size + bi->blob.padding_size) {
+		/* sanity check, note the padding bytes added for section to DDR alignment */
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	if ((bi->blob.offset % (1UL<<(ISP_PMEM_WIDTH_LOG2-3))) != 0)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	bd->blob = blob;
+	bd->header = *bi;
+	bd->name = name;
+	if (bi->type == ia_css_isp_firmware)
+		ia_css_isp_param_load_fw_params(fw, &bd->mem_offsets, &bi->blob.memory_offsets, bi->type == ia_css_isp_firmware);
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+sh_css_load_firmware(const char *fw_data,
+		     unsigned int fw_size)
+{
+	unsigned i;
+	struct ia_css_fw_info *binaries;
+	struct sh_css_fw_bi_file_h *file_header;
+
+	firmware_header = (struct firmware_header*)fw_data;
+	file_header = (struct sh_css_fw_bi_file_h *)&firmware_header->file_header;
+	binaries = (struct ia_css_fw_info *)&firmware_header->binary_header;
+	strcpy(FW_rel_ver_name, file_header->version);
+#ifdef VERSION_CHECK
+	if (strcmp(file_header->version, release_version) != 0) {
+#if (!defined HRT_CSIM && !defined HRT_RTL)
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "CSS code and firmware version mismatch!\n");
+		assert(false);
+		return IA_CSS_ERR_VERSION_MISMATCH;
+#endif
+	} else {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "successfully load firmware version %s\n", release_version);
+	}
+#endif
+
+	/* some sanity checks */
+	if (!fw_data || fw_size < sizeof(struct sh_css_fw_bi_file_h))
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	if (file_header->h_size != sizeof(struct sh_css_fw_bi_file_h))
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	sh_css_num_binaries = file_header->binary_nr;
+	/* Only allocate memory for ISP blob info */
+	sh_css_blob_info = sh_css_malloc((sh_css_num_binaries - NUM_OF_SPS) *
+						sizeof(*sh_css_blob_info));
+
+	if (sh_css_blob_info == NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	for (i = 0; i < sh_css_num_binaries; i++) {
+		struct ia_css_fw_info *bi = &binaries[i];
+		struct ia_css_blob_descr bd;
+		enum ia_css_err err;
+
+		err = sh_css_load_blob_info (fw_data, bi, &bd);
+		if (err != IA_CSS_SUCCESS)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+
+		if (bi->blob.offset + bi->blob.size > fw_size)
+			return IA_CSS_ERR_INTERNAL_ERROR;
+
+		if (bi->type == ia_css_sp_firmware) {
+			if (i != SP_FIRMWARE)
+				return IA_CSS_ERR_INTERNAL_ERROR;
+			setup_sp(bi, fw_data, &sh_css_sp_fw);
+#if defined(IS_ISP_2500_SYSTEM)
+		} else if (bi->type == ia_css_sp1_firmware) {
+			if (i != SP1_FIRMWARE)
+				return IA_CSS_ERR_INTERNAL_ERROR;
+			setup_sp(bi, fw_data, &sh_css_sp1_fw);
+#endif
+		} else {
+			/* All subsequent binaries (i>NUM_OF_SPS) are ISP firmware */
+			if (i < NUM_OF_SPS)
+				return IA_CSS_ERR_INTERNAL_ERROR;
+			if (bi->type != ia_css_isp_firmware)
+				return IA_CSS_ERR_INTERNAL_ERROR;
+			sh_css_blob_info[i-NUM_OF_SPS] = bd;
+		}
+	}
+	return IA_CSS_SUCCESS;
+}
+
+void sh_css_unload_firmware(void)
+{
+	memset(&sh_css_sp_fw, 0, sizeof(sh_css_sp_fw));
+#if defined(IS_ISP_2500_SYSTEM)
+	memset(&sh_css_sp1_fw, 0, sizeof(sh_css_sp1_fw));
+#endif
+	if (sh_css_blob_info) {
+		sh_css_free(sh_css_blob_info);
+		sh_css_blob_info = NULL;
+	}
+	sh_css_num_binaries = 0;
+}
+
+hrt_vaddress
+sh_css_load_blob(const unsigned char *blob, unsigned size)
+{
+	hrt_vaddress target_addr = mmgr_malloc(size);
+	/* this will allocate memory aligned to a DDR word boundary which
+	   is required for the CSS DMA to read the instructions. */
+
+	assert(blob != NULL);
+	if (target_addr) {
+		mmgr_store(target_addr, blob, size);
+#ifdef HRT_CSIM
+		{
+			unsigned padded_size = CEIL_MUL(size, HIVE_ISP_DDR_WORD_BYTES);
+			mmgr_clear(target_addr + size, padded_size - size);
+		}
+#endif
+	}
+	return target_addr;
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_firmware.h b/drivers/media/atomisp2/css2400/sh_css_firmware.h
new file mode 100644
index 0000000..3c7d4cf
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_firmware.h
@@ -0,0 +1,58 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_FIRMWARE_H_
+#define _SH_CSS_FIRMWARE_H_
+
+#include <system_types.h>
+
+#include <ia_css_err.h>
+#include <ia_css_acc_types.h>
+
+/* This is for the firmware loaded from user space */
+struct  sh_css_fw_bi_file_h {
+	char version[64];		/* branch tag + week day + time */
+	int binary_nr;			/* Number of binaries */
+	unsigned int h_size;		/* sizeof(struct sh_css_fw_bi_file_h) */
+};
+
+extern struct ia_css_fw_info     sh_css_sp_fw;
+#if defined(IS_ISP_2500_SYSTEM)
+extern struct ia_css_fw_info     sh_css_sp1_fw;
+#endif
+extern struct ia_css_blob_descr *sh_css_blob_info;
+extern unsigned			 sh_css_num_binaries;
+
+char
+*sh_css_get_fw_version(void);
+
+enum ia_css_err
+sh_css_load_firmware(const char *fw_data,
+		     unsigned int fw_size);
+
+void sh_css_unload_firmware(void);
+
+hrt_vaddress sh_css_load_blob(const unsigned char *blob, unsigned size);
+
+enum ia_css_err
+sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi, struct ia_css_blob_descr *bd);
+
+#endif /* _SH_CSS_FIRMWARE_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_frac.h b/drivers/media/atomisp2/css2400/sh_css_frac.h
new file mode 100644
index 0000000..c9cf324
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_frac.h
@@ -0,0 +1,45 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SH_CSS_FRAC_H
+#define __SH_CSS_FRAC_H
+
+#define sISP_REG_BIT		      ISP_VEC_ELEMBITS
+#define uISP_REG_BIT		      ((unsigned)(sISP_REG_BIT-1))
+#define sSHIFT				    (16-sISP_REG_BIT)
+#define uSHIFT				    ((unsigned)(16-uISP_REG_BIT))
+#define sFRACTION_BITS_FITTING(a) (a-sSHIFT)
+#define uFRACTION_BITS_FITTING(a) ((unsigned)(a-uSHIFT))
+#define sISP_VAL_MIN		      (-(1<<uISP_REG_BIT))
+#define sISP_VAL_MAX		      ((1<<uISP_REG_BIT)-1)
+#define uISP_VAL_MIN		      ((unsigned)0)
+#define uISP_VAL_MAX		      ((unsigned)((1<<uISP_REG_BIT)-1))
+
+/* a:fraction bits for 16bit precision, b:fraction bits for ISP precision */
+#define sDIGIT_FITTING(v, a, b) \
+	min(max((((v)>>sSHIFT) >> max(sFRACTION_BITS_FITTING(a)-(b), 0)), \
+	  sISP_VAL_MIN), sISP_VAL_MAX)
+#define uDIGIT_FITTING(v, a, b) \
+	min((unsigned)max((unsigned)(((v)>>uSHIFT) \
+	>> max((int)(uFRACTION_BITS_FITTING(a)-(b)), 0)), \
+	  uISP_VAL_MIN), uISP_VAL_MAX)
+
+#endif /* __SH_CSS_FRAC_H */
diff --git a/drivers/media/atomisp2/css2400/sh_css_hrt.c b/drivers/media/atomisp2/css2400/sh_css_hrt.c
new file mode 100644
index 0000000..4f3901b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_hrt.c
@@ -0,0 +1,120 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "platform_support.h"
+
+#include "sh_css_hrt.h"
+
+#include "device_access.h"
+
+#define __INLINE_EVENT__
+#include "event_fifo.h"
+#define __INLINE_SP__
+#include "sp.h"
+#define __INLINE_ISP__
+#include "isp.h"
+#define __INLINE_IRQ__
+#include "irq.h"
+#define __INLINE_FIFO_MONITOR__
+#include "fifo_monitor.h"
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include "input_system.h"	/* MIPI_PREDICTOR_NONE,... */
+#endif
+
+/* System independent */
+#include "sh_css_internal.h"
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include "ia_css_isys.h"
+#endif
+
+
+bool sh_css_hrt_system_is_idle(void)
+{
+	hrt_data	status;
+	bool not_idle = false;
+
+	not_idle |= !isp_ctrl_getbit(ISP0_ID, ISP_SC_REG, ISP_IDLE_BIT);
+
+	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
+#if defined(IS_ISP_2500_SYSTEM)
+		HIVE_GP_REGS_SP1_STRMON_STAT_IDX);
+#else
+		HIVE_GP_REGS_SP_STREAM_STAT_IDX);
+#endif
+	not_idle |= ((status & FIFO_CHANNEL_SP_VALID_MASK) != 0);
+
+#if defined(IS_ISP_2500_SYSTEM)
+	// checking status of 2nd SP
+	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
+		HIVE_GP_REGS_SP2_STRMON_STAT_IDX);
+	not_idle |= ((status & FIFO_CHANNEL_SP_VALID_MASK) != 0);
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+#if defined(HAS_FIFO_MONITORS_VERSION_2)
+	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
+		HIVE_GP_REGS_SP_STREAM_STAT_B_IDX);
+	not_idle |= ((status & FIFO_CHANNEL_SP_VALID_B_MASK) != 0);
+#endif
+#endif
+
+	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
+#if defined(IS_ISP_2500_SYSTEM)
+		HIVE_GP_REGS_ISP_STRMON_STAT_IDX);
+#else
+		HIVE_GP_REGS_ISP_STREAM_STAT_IDX);
+#endif
+	not_idle |= ((status & FIFO_CHANNEL_ISP_VALID_MASK) != 0);
+
+	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
+#if defined(IS_ISP_2500_SYSTEM)
+		HIVE_GP_REGS_MOD_STRMON_STAT_IDX);
+#else
+		HIVE_GP_REGS_MOD_STREAM_STAT_IDX);
+#endif
+	not_idle |= ((status & FIFO_CHANNEL_MOD_VALID_MASK) != 0);
+
+return !not_idle;
+}
+
+enum ia_css_err sh_css_hrt_sp_wait(void)
+{
+#if defined(HAS_IRQ_MAP_VERSION_2)
+	irq_sw_channel_id_t	irq_id = IRQ_SW_CHANNEL0_ID;
+#else
+	irq_sw_channel_id_t	irq_id = IRQ_SW_CHANNEL2_ID;
+#endif
+	/*
+	 * Wait till SP is idle or till there is a SW2 interrupt
+	 * The SW2 interrupt will be used when frameloop runs on SP
+	 * and signals an event with similar meaning as SP idle
+	 * (e.g. frame_done)
+	 */
+	while (!sp_ctrl_getbit(SP0_ID, SP_SC_REG, SP_IDLE_BIT) &&
+		((irq_reg_load(IRQ0_ID,
+			_HRT_IRQ_CONTROLLER_STATUS_REG_IDX) &
+			(1U<<(irq_id + IRQ_SW_CHANNEL_OFFSET))) == 0)) {
+		hrt_sleep();
+	}
+
+return IA_CSS_SUCCESS;
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_hrt.h b/drivers/media/atomisp2/css2400/sh_css_hrt.h
new file mode 100644
index 0000000..6ba911c
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_hrt.h
@@ -0,0 +1,41 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_HRT_H_
+#define _SH_CSS_HRT_H_
+
+#include <sp.h>
+#include <isp.h>
+
+#include <ia_css_err.h>
+
+/* SP access */
+void sh_css_hrt_sp_start_si(void);
+
+void sh_css_hrt_sp_start_copy_frame(void);
+
+void sh_css_hrt_sp_start_isp(void);
+
+enum ia_css_err sh_css_hrt_sp_wait(void);
+
+bool sh_css_hrt_system_is_idle(void);
+
+#endif /* _SH_CSS_HRT_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_internal.h b/drivers/media/atomisp2/css2400/sh_css_internal.h
new file mode 100644
index 0000000..c5092ec
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_internal.h
@@ -0,0 +1,994 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_INTERNAL_H_
+#define _SH_CSS_INTERNAL_H_
+
+#include <system_global.h>
+#include <type_support.h>
+#include <platform_support.h>
+
+#if !defined(HAS_NO_INPUT_FORMATTER)
+#include "input_formatter.h"
+#endif
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include "input_system.h"
+#endif
+
+#include "ia_css_types.h"
+#include "ia_css_acc_types.h"
+
+#include "ia_css_binary.h"
+#include "sh_css_firmware.h"
+#include "sh_css_legacy.h"
+#include "sh_css_defs.h"
+#include "sh_css_uds.h"
+#include "dma.h"	/* N_DMA_CHANNEL_ID */
+#include "ia_css_circbuf_comm.h" /* Circular buffer */
+#include "ia_css_frame_comm.h"
+#include "runtime/bufq/interface/ia_css_bufq.h"
+
+/* TODO: Move to a more suitable place when sp pipeline design is done. */
+#define IA_CSS_NUM_CB_SEM_READ_RESOURCE 	2
+#define IA_CSS_NUM_CB_SEM_WRITE_RESOURCE	1
+#define IA_CSS_NUM_CBS						2
+#define IA_CSS_CB_MAX_ELEMS					2
+
+/* Use case specific. index limited to IA_CSS_NUM_CB_SEM_READ_RESOURCE or
+ * IA_CSS_NUM_CB_SEM_WRITE_RESOURCE for read and write respectively.
+ * TODO: Enforce the limitation above.
+*/
+#define IA_CSS_COPYSINK_SEM_INDEX 	0
+#define IA_CSS_TAGGER_SEM_INDEX 	1
+
+/* Force generation of output event. Used by acceleration pipe. */
+#define IA_CSS_POST_OUT_EVENT_FORCE		2
+
+#define SH_CSS_MAX_BINARY_NAME	64
+
+#define SP_DEBUG_NONE	(0)
+#define SP_DEBUG_DUMP	(1)
+#define SP_DEBUG_COPY	(2)
+#define SP_DEBUG_TRACE	(3)
+#define SP_DEBUG_MINIMAL (4)
+
+#define SP_DEBUG SP_DEBUG_NONE
+#define SP_DEBUG_MINIMAL_OVERWRITE 1
+
+
+#ifdef __DISABLE_UNUSED_THREAD__
+#define SH_CSS_MAX_SP_THREADS	1 /* preview */
+#else
+#if defined(HAS_SP_2500)
+#define SH_CSS_MAX_SP_THREADS	2 /* (preview, capture), acceleration */
+#else
+#define SH_CSS_MAX_SP_THREADS	4 /* raw_copy, preview, capture, acceleration */
+#endif
+#endif
+
+#define SH_CSS_MAX_PIPELINES	SH_CSS_MAX_SP_THREADS
+
+/* keep next up to date with the definition for MAX_CB_ELEMS_FOR_TAGGER in tagger.sp.c */
+#if defined(HAS_SP_2400)
+#define NUM_CONTINUOUS_FRAMES	15
+#else
+#define NUM_CONTINUOUS_FRAMES	10
+#endif
+#define NUM_MIPI_FRAMES		4
+
+#define NUM_ONLINE_INIT_CONTINUOUS_FRAMES      2
+
+#define NR_OF_PIPELINES			IA_CSS_PIPE_ID_NUM /* Must match with IA_CSS_PIPE_ID_NUM */
+
+#define SH_CSS_MAX_IF_CONFIGS	3 /* Must match with IA_CSS_NR_OF_CONFIGS (not defined yet).*/
+#define SH_CSS_IF_CONFIG_NOT_NEEDED	0xFF
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+#define SH_CSS_ENABLE_METADATA
+#endif
+
+#if defined(SH_CSS_ENABLE_METADATA) && defined(USE_INPUT_SYSTEM_VERSION_2)
+#define SH_CSS_ENABLE_METADATA_THREAD
+#endif
+
+/**
+ * The C99 standard does not specify the exact object representation of structs;
+ * the representation is compiler dependent.
+ *
+ * The structs that are communicated between host and SP/ISP should have the
+ * exact same object representation. The compiler that is used to compile the
+ * firmware is hivecc.
+ *
+ * To check if a different compiler, used to compile a host application, uses
+ * another object representation, macros are defined specifying the size of
+ * the structs as expected by the firmware.
+ *
+ * A host application shall verify that a sizeof( ) of the struct is equal to
+ * the SIZE_OF_XXX macro of the corresponding struct. If they are not
+ * equal, functionality will break.
+ */
+#define CALC_ALIGNMENT_MEMBER(x, y)	(CEIL_MUL(x, y) - x)
+#define SIZE_OF_HRT_VADDRESS		sizeof(hive_uint32)
+#define SIZE_OF_IA_CSS_PTR		sizeof(uint32_t)
+
+/**
+ * The following macro can help to test the size of a struct at compile
+ * time rather than at run-time. It does not work for all compilers; see
+ * below.
+ *
+ * Depending on the value of 'condition', the following macro is expanded to:
+ * - condition==true:
+ *     an expression containing an array declaration with negative size,
+ *     usually resulting in a compilation error
+ * - condition==false:
+ *     (void) 1; // C statement with no effect
+ *
+ * example:
+ *  COMPILATION_ERROR_IF( sizeof(struct host_sp_queues) != SIZE_OF_HOST_SP_QUEUES_STRUCT);
+ *
+ * verify that the macro indeed triggers a compilation error with your compiler:
+ *  COMPILATION_ERROR_IF( sizeof(struct host_sp_queues) != (sizeof(struct host_sp_queues)+1) );
+ *
+ * Not all compilers will trigger an error with this macro; use a search engine to search for
+ * BUILD_BUG_ON to find other methods.
+ */
+#define COMPILATION_ERROR_IF( condition ) ((void)sizeof(char[1 - 2*!!(condition)]))
+
+/* Number of SP's */
+#if defined(IS_ISP_2500_SYSTEM)
+#define NUM_OF_SPS 2
+#else
+#define NUM_OF_SPS 1
+#endif
+
+/* Enum for Number of Binaries */
+enum sh_css_num_binaries {
+	SP_FIRMWARE = 0,
+	SP1_FIRMWARE,
+	ISP_FIRMWARE
+};
+
+ /*
+ * JB: keep next enum in sync with thread id's
+ * and pipe id's
+ */
+enum sh_css_pipe_config_override {
+	SH_CSS_PIPE_CONFIG_OVRD_NONE     = 0,
+	SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD  = 0xffff
+};
+
+enum host2sp_commands {
+	host2sp_cmd_error = 0,
+	/*
+	 * The host2sp_cmd_ready command is the only command written by the SP
+	 * It acknowledges that is previous command has been received.
+	 * (this does not mean that the command has been executed)
+	 * It also indicates that a new command can be send (it is a queue
+	 * with depth 1).
+	 */
+	host2sp_cmd_ready = 1,
+	/* Command written by the Host */
+	host2sp_cmd_dummy,		/* No action, can be used as watchdog */
+	host2sp_cmd_start_flash,	/* Request SP to start the flash */
+	host2sp_cmd_terminate,		/* SP should terminate itself */
+	N_host2sp_cmd
+};
+
+/** Enumeration used to indicate the events that are produced by
+ *  the SP and consumed by the Host.
+ */
+enum sh_css_sp_event_type {
+	SH_CSS_SP_EVENT_OUTPUT_FRAME_DONE,
+	SH_CSS_SP_EVENT_SECOND_OUTPUT_FRAME_DONE,
+	SH_CSS_SP_EVENT_VF_OUTPUT_FRAME_DONE,
+	SH_CSS_SP_EVENT_SECOND_VF_OUTPUT_FRAME_DONE,
+	SH_CSS_SP_EVENT_3A_STATISTICS_DONE,
+	SH_CSS_SP_EVENT_DIS_STATISTICS_DONE,
+	SH_CSS_SP_EVENT_PIPELINE_DONE,
+	SH_CSS_SP_EVENT_FRAME_TAGGED,
+	SH_CSS_SP_EVENT_INPUT_FRAME_DONE,
+	SH_CSS_SP_EVENT_METADATA_DONE,
+	SH_CSS_SP_EVENT_LACE_STATISTICS_DONE,
+	SH_CSS_SP_EVENT_PORT_EOF,
+	SH_CSS_SP_EVENT_NR_OF_TYPES		/* must be last */
+};
+
+#if !defined(IS_ISP_2500_SYSTEM)
+/* xmem address map allocation per pipeline, css pointers */
+struct sh_css_ddr_address_map {
+	hrt_vaddress isp_param;
+	hrt_vaddress isp_mem_param[SH_CSS_MAX_STAGES][IA_CSS_NUM_MEMORIES];
+	hrt_vaddress macc_tbl;
+	hrt_vaddress fpn_tbl;
+	hrt_vaddress sc_tbl;
+	hrt_vaddress sdis_hor_coef;
+	hrt_vaddress sdis_ver_coef;
+	hrt_vaddress tetra_r_x;
+	hrt_vaddress tetra_r_y;
+	hrt_vaddress tetra_gr_x;
+	hrt_vaddress tetra_gr_y;
+	hrt_vaddress tetra_gb_x;
+	hrt_vaddress tetra_gb_y;
+	hrt_vaddress tetra_b_x;
+	hrt_vaddress tetra_b_y;
+	hrt_vaddress tetra_ratb_x;
+	hrt_vaddress tetra_ratb_y;
+	hrt_vaddress tetra_batr_x;
+	hrt_vaddress tetra_batr_y;
+	hrt_vaddress dvs_6axis_params_y;
+	hrt_vaddress anr_thres;
+};
+#define SIZE_OF_SH_CSS_DDR_ADDRESS_MAP_STRUCT					\
+	(SIZE_OF_HRT_VADDRESS +							\
+	(SH_CSS_MAX_STAGES * IA_CSS_NUM_MEMORIES * SIZE_OF_HRT_VADDRESS) +	\
+	(19 * SIZE_OF_HRT_VADDRESS))
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+/* xmem address map allocation per pipeline */
+struct sh_css_ddr_address_map_size {
+	size_t isp_param;
+	size_t isp_mem_param[SH_CSS_MAX_STAGES][IA_CSS_NUM_MEMORIES];
+	size_t macc_tbl;
+	size_t fpn_tbl;
+	size_t sc_tbl;
+	size_t sdis_hor_coef;
+	size_t sdis_ver_coef;
+	size_t tetra_r_x;
+	size_t tetra_r_y;
+	size_t tetra_gr_x;
+	size_t tetra_gr_y;
+	size_t tetra_gb_x;
+	size_t tetra_gb_y;
+	size_t tetra_b_x;
+	size_t tetra_b_y;
+	size_t tetra_ratb_x;
+	size_t tetra_ratb_y;
+	size_t tetra_batr_x;
+	size_t tetra_batr_y;
+	size_t dvs_6axis_params_y;
+	size_t anr_thres;
+};
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+struct sh_css_ddr_address_map_compound {
+	struct sh_css_ddr_address_map		map;
+	struct sh_css_ddr_address_map_size	size;
+};
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+struct ia_css_isp_parameter_set_info {
+	struct sh_css_ddr_address_map  mem_map;/**< pointers to Parameters in ISP format IMPT: this should be first member of this struct */
+	uint32_t                       isp_parameters_id;/**< Unique ID to track which config was actually applied to a particular frame */
+	ia_css_ptr                     output_frame_ptr;/**< Output frame to which this config has to be applied (optional) */
+};
+#endif
+
+/* this struct contains all arguments that can be passed to
+   a binary. It depends on the binary which ones are used. */
+struct sh_css_binary_args {
+	struct ia_css_frame *cc_frame;       /* continuous capture frame */
+	struct ia_css_frame *in_frame;	     /* input frame */
+	struct ia_css_frame *delay_frames[NUM_VIDEO_DELAY_FRAMES];   /* reference input frame */
+	struct ia_css_frame *tnr_frames[NUM_VIDEO_TNR_FRAMES];   /* tnr frames */
+	struct ia_css_frame *out_frame[IA_CSS_BINARY_MAX_OUTPUT_PORTS];      /* output frame */
+	struct ia_css_frame *out_vf_frame;   /* viewfinder output frame */
+	bool                 copy_vf;
+	bool                 copy_output;
+	unsigned             vf_downscale_log2;
+};
+
+#if SP_DEBUG == SP_DEBUG_DUMP
+
+#define SH_CSS_NUM_SP_DEBUG 48
+
+struct sh_css_sp_debug_state {
+	unsigned int error;
+	unsigned int debug[SH_CSS_NUM_SP_DEBUG];
+};
+
+#elif SP_DEBUG == SP_DEBUG_COPY
+
+#define SH_CSS_SP_DBG_TRACE_DEPTH	(40)
+
+struct sh_css_sp_debug_trace {
+	uint16_t frame;
+	uint16_t line;
+	uint16_t pixel_distance;
+	uint16_t mipi_used_dword;
+	uint16_t sp_index;
+};
+
+struct sh_css_sp_debug_state {
+	uint16_t if_start_line;
+	uint16_t if_start_column;
+	uint16_t if_cropped_height;
+	uint16_t if_cropped_width;
+	unsigned int index;
+	struct sh_css_sp_debug_trace
+		trace[SH_CSS_SP_DBG_TRACE_DEPTH];
+};
+
+#elif SP_DEBUG == SP_DEBUG_TRACE
+
+#if 1
+/* Example of just one global trace */
+#define SH_CSS_SP_DBG_NR_OF_TRACES	(1)
+#define SH_CSS_SP_DBG_TRACE_DEPTH	(40)
+#else
+/* E.g. if you like seperate traces for 4 threads */
+#define SH_CSS_SP_DBG_NR_OF_TRACES	(4)
+#define SH_CSS_SP_DBG_TRACE_DEPTH	(10)
+#endif
+
+#define SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS (13)
+
+struct sh_css_sp_debug_trace {
+	uint16_t time_stamp;
+	uint16_t location;	/* bit 15..13 = file_id, 12..0 = line nr. */
+	uint32_t data;
+};
+
+struct sh_css_sp_debug_state {
+	struct sh_css_sp_debug_trace
+		trace[SH_CSS_SP_DBG_NR_OF_TRACES][SH_CSS_SP_DBG_TRACE_DEPTH];
+	uint16_t index_last[SH_CSS_SP_DBG_NR_OF_TRACES];
+	uint8_t index[SH_CSS_SP_DBG_NR_OF_TRACES];
+};
+
+#elif SP_DEBUG == SP_DEBUG_MINIMAL
+
+#define SH_CSS_NUM_SP_DEBUG 128
+
+struct sh_css_sp_debug_state {
+	unsigned int error;
+	unsigned int debug[SH_CSS_NUM_SP_DEBUG];
+};
+
+#endif
+
+
+struct sh_css_sp_debug_command {
+	/*
+	 * The DMA software-mask,
+	 *	Bit 31...24: unused.
+	 *	Bit 23...16: unused.
+	 *	Bit 15...08: reading-request enabling bits for DMA channel 7..0
+	 *	Bit 07...00: writing-reqeust enabling bits for DMA channel 7..0
+	 *
+	 * For example, "0...0 0...0 11111011 11111101" indicates that the
+	 * writing request through DMA Channel 1 and the reading request
+	 * through DMA channel 2 are both disabled. The others are enabled.
+	 */
+	uint32_t dma_sw_reg;
+};
+
+#if !defined(HAS_NO_INPUT_FORMATTER)
+/* SP input formatter configuration.*/
+struct sh_css_sp_input_formatter_set {
+	uint32_t				stream_format;
+	input_formatter_cfg_t	config_a;
+	input_formatter_cfg_t	config_b;
+};
+#endif
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#define IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT (3)
+#endif
+
+/* SP configuration information */
+struct sh_css_sp_config {
+	uint8_t			no_isp_sync; /* Signal host immediately after start */
+#if !defined(HAS_NO_INPUT_FORMATTER)
+	struct {
+		uint8_t					a_changed;
+		uint8_t					b_changed;
+		uint8_t					isp_2ppc;
+		struct sh_css_sp_input_formatter_set	set[SH_CSS_MAX_IF_CONFIGS]; /* CSI-2 port is used as index. */
+	} input_formatter;
+#endif
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+	sync_generator_cfg_t	sync_gen;
+	tpg_cfg_t				tpg;
+	prbs_cfg_t				prbs;
+	input_system_cfg_t		input_circuit;
+	uint8_t					input_circuit_cfg_changed;
+	uint32_t				mipi_sizes_for_check[N_CSI_PORTS][IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT];
+#endif
+};
+
+enum sh_css_stage_type {
+  SH_CSS_SP_STAGE_TYPE  = 0,
+  SH_CSS_ISP_STAGE_TYPE = 1
+};
+#define SH_CSS_NUM_STAGE_TYPES 2
+
+#define SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS 	(1 << 0)
+#define SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS_MASK \
+	((SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << SH_CSS_MAX_SP_THREADS)-1)
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2401)
+struct sh_css_sp_pipeline_terminal {
+	union {
+		/* Input System 2401 */
+		virtual_input_system_t		virtual_input_system;
+	} context;
+
+	/*
+	 * zhengjie.lu@intel.com:
+	 * TODO
+	 * - Remove "virtual_input_system_cfg" when the ISYS2401 DLI is ready.
+	 */
+	union {
+		/* Input System 2401 */
+		virtual_input_system_cfg_t	virtual_input_system_cfg;
+	} ctrl;
+};
+
+struct sh_css_sp_pipeline_io {
+	struct sh_css_sp_pipeline_terminal	input;
+	struct sh_css_sp_pipeline_terminal	output;
+};
+
+struct sh_css_sp_pipeline_io_status {
+	uint32_t	active[N_INPUT_SYSTEM_CSI_PORT];
+	uint32_t	running[N_INPUT_SYSTEM_CSI_PORT];
+};
+
+#endif
+enum sh_css_port_dir {
+	SH_CSS_PORT_INPUT  = 0,
+	SH_CSS_PORT_OUTPUT  = 1
+};
+
+enum sh_css_port_type {
+	SH_CSS_HOST_TYPE  = 0,
+	SH_CSS_COPYSINK_TYPE  = 1,
+	SH_CSS_TAGGERSINK_TYPE  = 2
+};
+
+/* Pipe inout settings: output port on 7-4bits, input port on 3-0bits */
+#define SH_CSS_PORT_FLD_WIDTH_IN_BITS (4)
+#define SH_CSS_PORT_TYPE_BIT_FLD(pt) (0x1 << (pt))
+#define SH_CSS_PORT_FLD(pd) ((pd) ? SH_CSS_PORT_FLD_WIDTH_IN_BITS : 0)
+#define SH_CSS_PIPE_PORT_CONFIG_ON(p,pd,pt) ( (p) |= (SH_CSS_PORT_TYPE_BIT_FLD(pt) << SH_CSS_PORT_FLD(pd)) )
+#define SH_CSS_PIPE_PORT_CONFIG_OFF(p,pd,pt) ( (p) &= ~(SH_CSS_PORT_TYPE_BIT_FLD(pt) << SH_CSS_PORT_FLD(pd)) )
+#define SH_CSS_PIPE_PORT_CONFIG_SET(p,pd,pt,val) ( (val)? SH_CSS_PIPE_PORT_CONFIG_ON(p,pd,pt):SH_CSS_PIPE_PORT_CONFIG_OFF(p,pd,pt) )
+#define SH_CSS_PIPE_PORT_CONFIG_GET(p,pd,pt) ( (p) & (SH_CSS_PORT_TYPE_BIT_FLD(pt) << SH_CSS_PORT_FLD(pd)) )
+#define SH_CSS_PIPE_PORT_CONFIG_IS_CONTINUOUS(p)  (!(SH_CSS_PIPE_PORT_CONFIG_GET(p,SH_CSS_PORT_INPUT,SH_CSS_HOST_TYPE) && \
+					       SH_CSS_PIPE_PORT_CONFIG_GET(p,SH_CSS_PORT_OUTPUT,SH_CSS_HOST_TYPE)))
+
+#define IA_CSS_ACQUIRE_ISP_POS	31
+
+/* Flags for metadata processing */
+#define SH_CSS_METADATA_ENABLED        0x01
+#define SH_CSS_METADATA_PROCESSED      0x02
+#define SH_CSS_METADATA_OFFLINE_MODE   0x04
+#define SH_CSS_METADATA_WAIT_INPUT     0x08
+
+/** @brief Free an array of metadata buffers.
+ *
+ * @param[in]	num_bufs	Number of metadata buffers to be freed.
+ * @param[in]	bufs		Pointer of array of metadata buffers.
+ *
+ * This function frees an array of metadata buffers.
+ */
+void
+ia_css_metadata_free_multiple(unsigned int num_bufs, struct ia_css_metadata **bufs);
+
+/* Information for a pipeline */
+struct sh_css_sp_pipeline {
+	uint32_t	pipe_id;	/* the pipe ID */
+	uint32_t	pipe_num;	/* the dynamic pipe number */
+	uint32_t	thread_id;	/* the sp thread ID */
+	uint32_t	pipe_config;	/* the pipe config */
+	uint32_t    inout_port_config;
+	uint32_t	required_bds_factor;
+#if !defined(HAS_NO_INPUT_SYSTEM)
+	uint32_t	input_system_mode;	/* enum ia_css_input_mode */
+	mipi_port_ID_t	port_id;	/* port_id for input system */
+#endif
+	uint32_t	num_stages;		/* the pipe config */
+	uint32_t	running;	/* needed for pipe termination */
+	hrt_vaddress	sp_stage_addr[SH_CSS_MAX_STAGES];
+	CSS_ALIGN(struct sh_css_sp_stage *stage, 8); /* Current stage for this pipeline */
+	CSS_ALIGN(int32_t num_execs, 8); /* number of times to run if this is
+					  an acceleration pipe. */
+#if defined (SH_CSS_ENABLE_METADATA)
+	struct {
+		uint32_t        format;   /* Metadata format in hrt format */
+		uint32_t        width;    /* Width of a line */
+		uint32_t        height;   /* Number of lines */
+		uint32_t        stride;   /* Stride (in bytes) per line */
+		uint32_t        size;     /* Total size (in bytes) */
+		hrt_vaddress    cont_buf; /* Address of continuous buffer */
+	} metadata;
+#endif
+	union {
+		struct {
+			CSS_ALIGN(unsigned int	bytes_available, 8);
+		} bin;
+		struct {
+			CSS_ALIGN(unsigned int	height, 8);
+			unsigned int	width;
+			unsigned int	padded_width;
+			unsigned int	max_input_width;
+			unsigned int	raw_bit_depth;
+		} raw;
+	} copy;
+};
+
+/*
+ * The first frames (with comment Dynamic) can be dynamic or static
+ * The other frames (ref_in and below) can only be static
+ * Static means that the data addres will not change during the life time
+ * of the associated pipe. Dynamic means that the data address can
+ * change with every (frame) iteration of the associated pipe
+ *
+ * s3a and dis are now also dynamic but (stil) handled seperately
+ */
+#define SH_CSS_NUM_DYNAMIC_FRAME_IDS (3)
+#define SH_CSS_INVALID_FRAME_ID (-1)
+
+struct ia_css_frames_sp {
+	struct ia_css_frame_sp	in;
+	struct ia_css_frame_sp	out[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_resolution effective_in_res;
+	struct ia_css_frame_sp	out_vf;
+	struct ia_css_frame_sp  delay_frames[NUM_VIDEO_DELAY_FRAMES];
+	struct ia_css_frame_sp_info internal_frame_info;
+	/* PQ TODO: should be a separate host-sp communication array which
+	is used for all dynamic objects through queue. */
+	hrt_vaddress static_frame_data[IA_CSS_NUM_BUFFER_TYPE];
+	enum ia_css_buffer_type buf_type[IA_CSS_NUM_DYNAMIC_BUFFER_TYPE];
+};
+
+/* Information for a single pipeline stage for an ISP */
+struct sh_css_isp_stage {
+	/*
+	 * For compatability and portabilty, only types
+	 * from "stdint.h" are allowed
+	 *
+	 * Use of "enum" and "bool" is prohibited
+	 * Multiple boolean flags can be stored in an
+	 * integer
+	 */
+	struct ia_css_blob_info	  blob_info;
+	struct ia_css_binary_info binary_info;
+	char			  binary_name[SH_CSS_MAX_BINARY_NAME];
+	struct ia_css_isp_param_css_segments mem_initializers;
+};
+
+/* Information for a single pipeline stage */
+struct sh_css_sp_stage {
+	/*
+	 * For compatability and portabilty, only types
+	 * from "stdint.h" are allowed
+	 *
+	 * Use of "enum" and "bool" is prohibited
+	 * Multiple boolean flags can be stored in an
+	 * integer
+	 */
+	uint8_t			num; /* Stage number */
+	uint8_t			isp_online;
+	uint8_t			isp_copy_vf;
+	uint8_t			isp_copy_output;
+	uint8_t			sp_enable_xnr;
+	uint8_t			isp_deci_log_factor;
+	uint8_t			isp_vf_downscale_bits;
+	uint8_t			deinterleaved;
+/*
+ * NOTE: Programming the input circuit can only be done at the
+ * start of a session. It is illegal to program it during execution
+ * The input circuit defines the connectivity
+ */
+	uint8_t			program_input_circuit;
+/* enum ia_css_pipeline_stage_sp_func	func; */
+	uint8_t			func;
+	/* The type of the pipe-stage */
+	/* enum sh_css_stage_type	stage_type; */
+	uint8_t			stage_type;
+	uint8_t			num_stripes;
+	uint8_t			isp_pipe_version;
+	struct {
+		uint8_t		vf_output;
+		uint8_t		s3a;
+		uint8_t		sdis;
+		uint8_t		dvs_stats;
+		uint8_t		lace_stats;
+	} enable;
+	/* Add padding to come to a word boundary */
+	/* unsigned char			padding[0]; */
+
+	struct sh_css_crop_pos		sp_out_crop_pos;
+	struct ia_css_frames_sp		frames;
+	struct ia_css_resolution	dvs_envelope;
+	uint32_t			dvs_frame_delay;
+	struct sh_css_uds_info		uds;
+	hrt_vaddress			isp_stage_addr;
+	hrt_vaddress			xmem_bin_addr;
+	hrt_vaddress			xmem_map_addr;
+
+	uint16_t		top_cropping;
+	uint16_t		row_stripes_height;
+	uint16_t		row_stripes_overlap_lines;
+	uint8_t			if_config_index; /* Which should be applied by this stage. */
+};
+
+/*
+ * Time: 2012-07-19, 17:40.
+ * Author: zhengjie.lu@intel.com
+ * Note: Add a new data memeber "debug" in "sh_css_sp_group". This
+ * data member is used to pass the debugging command from the
+ * Host to the SP.
+ *
+ * Time: Before 2012-07-19.
+ * Author: unknown
+ * Note:
+ * Group all host initialized SP variables into this struct.
+ * This is initialized every stage through dma.
+ * The stage part itself is transfered through sh_css_sp_stage.
+*/
+struct sh_css_sp_group {
+	struct sh_css_sp_config		config;
+	struct sh_css_sp_pipeline	pipe[SH_CSS_MAX_SP_THREADS];
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2401)
+	struct sh_css_sp_pipeline_io	pipe_io[SH_CSS_MAX_SP_THREADS];
+	struct sh_css_sp_pipeline_io_status	pipe_io_status;
+#endif
+	struct sh_css_sp_debug_command	debug;
+};
+
+/* Data in SP dmem that is set from the host every stage. */
+struct sh_css_sp_per_frame_data {
+	/* ddr address of sp_group and sp_stage */
+	hrt_vaddress			sp_group_addr;
+};
+
+#define SH_CSS_NUM_SDW_IRQS 3
+
+/* Output data from SP to css */
+struct sh_css_sp_output {
+	unsigned int			bin_copy_bytes_copied;
+#if SP_DEBUG != SP_DEBUG_NONE
+	struct sh_css_sp_debug_state	debug;
+#endif
+	unsigned int		sw_interrupt_value[SH_CSS_NUM_SDW_IRQS];
+};
+
+#if defined(IS_ISP_2500_SYSTEM)
+#define CONFIG_ON_FRAME_ENQUEUE() 1
+#else
+#define CONFIG_ON_FRAME_ENQUEUE() 0
+#endif
+
+#if CONFIG_ON_FRAME_ENQUEUE()
+/* On frame queue late configuration */
+struct sh_css_config_on_frame_enqueue {
+	uint32_t padded_width;
+};
+#endif
+
+/**
+ * @brief Data structure for the circular buffer.
+ * The circular buffer is empty if "start == end". The
+ * circular buffer is full if "(end + 1) % size == start".
+ */
+/* Variable Sized Buffer Queue Elements */
+
+#define  IA_CSS_NUM_ELEMS_HOST2SP_BUFFER_QUEUE    6
+#define  IA_CSS_NUM_ELEMS_HOST2SP_PARAM_QUEUE    3
+#define  IA_CSS_NUM_ELEMS_HOST2SP_TAG_CMD_QUEUE  6
+
+#if defined(HAS_SP_2400)
+#define  IA_CSS_NUM_ELEMS_HOST2SP_EVENT_QUEUE    13
+#define  IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE   13
+#define  IA_CSS_NUM_ELEMS_SP2HOST_EVENT_QUEUE    13
+#else
+#define  IA_CSS_NUM_ELEMS_HOST2SP_EVENT_QUEUE    6
+#define  IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE   6
+#define  IA_CSS_NUM_ELEMS_SP2HOST_EVENT_QUEUE    6
+#endif
+
+struct sh_css_hmm_buffer {
+	union {
+		struct ia_css_isp_3a_statistics  s3a;
+		struct ia_css_isp_dvs_statistics dis;
+		ia_css_ptr skc_dvs_statistics;
+		ia_css_ptr lace_stat;
+		struct ia_css_metadata	metadata;
+		struct frame_data_wrapper{
+			hrt_vaddress	frame_data;
+			uint32_t	flashed;
+			uint32_t	exp_id;
+			uint32_t	frame_nr;
+			uint32_t	isp_parameters_id; /**< Unique ID to track which config was actually applied to a particular frame */
+#if CONFIG_ON_FRAME_ENQUEUE()
+			struct sh_css_config_on_frame_enqueue config_on_frame_enqueue;
+#endif
+		} frame;
+		hrt_vaddress ddr_ptrs;
+	} payload;
+	/*
+	 * kernel_ptr is present for host administration purposes only.
+	 * type is uint64_t in order to be 64-bit host compatible.
+	 */
+	CSS_ALIGN(uint64_t cookie_ptr, 8);
+	CSS_ALIGN(uint64_t kernel_ptr, 8);
+};
+#define SIZE_OF_FRAME_STRUCT						\
+	(SIZE_OF_HRT_VADDRESS +						\
+	(2 * sizeof(uint32_t)))
+
+#define SIZE_OF_PAYLOAD_UNION						\
+	(MAX(MAX(MAX(MAX(						\
+	SIZE_OF_IA_CSS_ISP_3A_STATISTICS_STRUCT,			\
+	SIZE_OF_IA_CSS_ISP_DVS_STATISTICS_STRUCT),			\
+	SIZE_OF_IA_CSS_METADATA_STRUCT),				\
+	SIZE_OF_FRAME_STRUCT),						\
+	SIZE_OF_HRT_VADDRESS))
+
+#define SIZE_OF_SH_CSS_HMM_BUFFER_STRUCT				\
+	(SIZE_OF_PAYLOAD_UNION + 					\
+	CALC_ALIGNMENT_MEMBER(SIZE_OF_PAYLOAD_UNION, 8) +		\
+	sizeof(uint64_t) +						\
+	sizeof(uint64_t))
+
+enum sh_css_queue_type {
+	sh_css_invalid_queue_type = -1,
+	sh_css_host2sp_buffer_queue,
+	sh_css_sp2host_buffer_queue,
+	sh_css_host2sp_event_queue,
+	sh_css_sp2host_event_queue,
+	sh_css_host2sp_tag_cmd_queue,
+};
+
+struct sh_css_event_irq_mask {
+	uint16_t or_mask;
+	uint16_t and_mask;
+};
+#define SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT				\
+	(2 * sizeof(uint16_t))
+
+struct host_sp_communication {
+	/*
+	 * Don't use enum host2sp_commands, because the sizeof an enum is
+	 * compiler dependant and thus non-portable
+	 */
+	uint32_t host2sp_command;
+
+	/*
+	 * The frame buffers that are reused by the
+	 * copy pipe in the offline preview mode.
+	 *
+	 * host2sp_offline_frames[0]: the input frame of the preview pipe.
+	 * host2sp_offline_frames[1]: the output frame of the copy pipe.
+	 *
+	 * TODO:
+	 *   Remove it when the Host and the SP is decoupled.
+	 */
+	hrt_vaddress host2sp_offline_frames[NUM_CONTINUOUS_FRAMES];
+	hrt_vaddress host2sp_offline_metadata[NUM_CONTINUOUS_FRAMES];
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	hrt_vaddress host2sp_mipi_frames[NUM_MIPI_FRAMES];
+	uint32_t host2sp_num_mipi_frames;
+#endif
+	uint32_t host2sp_cont_avail_num_raw_frames;
+	uint32_t host2sp_cont_extra_num_raw_frames;
+	uint32_t host2sp_cont_target_num_raw_frames;
+	struct sh_css_event_irq_mask host2sp_event_irq_mask[NR_OF_PIPELINES];
+
+};
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+#define SIZE_OF_HOST_SP_COMMUNICATION_STRUCT				\
+	(sizeof(uint32_t) +						\
+	(NUM_CONTINUOUS_FRAMES * SIZE_OF_HRT_VADDRESS * 2) +		\
+	(NUM_MIPI_FRAMES * SIZE_OF_HRT_VADDRESS) +			\
+	(4 * sizeof(uint32_t) ) +						\
+	(NR_OF_PIPELINES * SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT))
+#else
+#define SIZE_OF_HOST_SP_COMMUNICATION_STRUCT				\
+	(sizeof(uint32_t) +						\
+	(NUM_CONTINUOUS_FRAMES * SIZE_OF_HRT_VADDRESS * 2) +		\
+	(3 * sizeof(uint32_t) ) +						\
+	(NR_OF_PIPELINES * SIZE_OF_SH_CSS_EVENT_IRQ_MASK_STRUCT))
+#endif
+
+struct host_sp_queues {
+	/*
+	 * Queues for the dynamic frame information,
+	 * i.e. the "in_frame" buffer, the "out_frame"
+	 * buffer and the "vf_out_frame" buffer.
+	 */
+	ia_css_circbuf_desc_t host2sp_buffer_queues_desc
+		[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES];
+	ia_css_circbuf_elem_t host2sp_buffer_queues_elems
+	[SH_CSS_MAX_SP_THREADS][SH_CSS_MAX_NUM_QUEUES]
+	[IA_CSS_NUM_ELEMS_HOST2SP_BUFFER_QUEUE];
+	ia_css_circbuf_desc_t sp2host_buffer_queues_desc
+		[SH_CSS_MAX_NUM_QUEUES];
+	ia_css_circbuf_elem_t sp2host_buffer_queues_elems
+	[SH_CSS_MAX_NUM_QUEUES][IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE];
+
+	/*
+	 * The queue for the events.
+	 */
+	ia_css_circbuf_desc_t host2sp_event_queue_desc;
+	ia_css_circbuf_elem_t host2sp_event_queue_elems
+	[IA_CSS_NUM_ELEMS_HOST2SP_EVENT_QUEUE];
+	ia_css_circbuf_desc_t sp2host_event_queue_desc;
+	ia_css_circbuf_elem_t sp2host_event_queue_elems
+	[IA_CSS_NUM_ELEMS_SP2HOST_EVENT_QUEUE];
+
+	/*
+	 * The queue for the tagger commands.
+	 */
+	ia_css_circbuf_desc_t host2sp_tag_cmd_queue_desc;
+	ia_css_circbuf_elem_t host2sp_tag_cmd_queue_elems[IA_CSS_NUM_ELEMS_HOST2SP_TAG_CMD_QUEUE];
+};
+
+#define SIZE_OF_QUEUES_ELEMS							\
+	(SIZE_OF_IA_CSS_CIRCBUF_ELEM_S_STRUCT * 				\
+	((SH_CSS_MAX_SP_THREADS * SH_CSS_MAX_NUM_QUEUES * IA_CSS_NUM_ELEMS_HOST2SP_BUFFER_QUEUE)	+		\
+	(SH_CSS_MAX_NUM_QUEUES * IA_CSS_NUM_ELEMS_SP2HOST_BUFFER_QUEUE) +	\
+	(IA_CSS_NUM_ELEMS_HOST2SP_EVENT_QUEUE) +				\
+	(IA_CSS_NUM_ELEMS_SP2HOST_EVENT_QUEUE) +				\
+	(IA_CSS_NUM_ELEMS_HOST2SP_TAG_CMD_QUEUE)))
+
+#define SIZE_OF_QUEUES_DESC										\
+	((SH_CSS_MAX_SP_THREADS * SH_CSS_MAX_NUM_QUEUES * SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT) +	\
+	(SH_CSS_MAX_NUM_QUEUES * SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT) +				\
+	(SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT) 	+							\
+	(SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT) + 							\
+	(SIZE_OF_IA_CSS_CIRCBUF_DESC_S_STRUCT))
+
+#define SIZE_OF_HOST_SP_QUEUES_STRUCT		\
+	(SIZE_OF_QUEUES_ELEMS) + (SIZE_OF_QUEUES_DESC)
+
+extern int (*sh_css_printf) (const char *fmt, va_list args);
+
+#ifndef __HIVECC
+STORAGE_CLASS_INLINE void
+sh_css_print(const char *fmt, ...)
+{
+	va_list ap;
+
+	if (sh_css_printf) {
+		va_start(ap, fmt);
+		sh_css_printf(fmt, ap);
+		va_end(ap);
+	}
+}
+
+STORAGE_CLASS_INLINE void
+sh_css_vprint(const char *fmt, va_list args)
+{
+	if (sh_css_printf)
+		sh_css_printf(fmt, args);
+}
+#endif
+
+hrt_vaddress
+sh_css_params_ddr_address_map(void);
+
+enum ia_css_err
+sh_css_params_init(void);
+
+void
+sh_css_params_uninit(void);
+
+void
+sh_css_params_reconfigure_gdc_lut(void);
+
+void *
+sh_css_malloc(size_t size);
+
+void *
+sh_css_calloc(size_t N, size_t size);
+
+void
+sh_css_free(void *ptr);
+
+/* For Acceleration API: Flush FW (shared buffer pointer) arguments */
+extern void
+sh_css_flush(struct ia_css_acc_fw *fw);
+
+
+void sh_css_binary_args_reset(struct sh_css_binary_args *args);
+
+/* Check two frames for equality (format, resolution, bits per element) */
+bool
+sh_css_frame_equal_types(const struct ia_css_frame *frame_a,
+			 const struct ia_css_frame *frame_b);
+
+bool
+sh_css_frame_info_equal_resolution(const struct ia_css_frame_info *info_a,
+				   const struct ia_css_frame_info *info_b);
+
+void
+sh_css_capture_enable_bayer_downscaling(bool enable);
+
+void
+sh_css_binary_print(const struct ia_css_binary *binary);
+
+void
+sh_css_frame_info_set_width(struct ia_css_frame_info *info,
+			    unsigned int width,
+			    unsigned int aligned); // this can be used for an extra alignemt requirement. when 0, no extra alignment is done.
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+
+unsigned int
+sh_css_get_mipi_sizes_for_check(const unsigned int port, const unsigned int idx);
+
+#endif
+
+hrt_vaddress
+sh_css_store_sp_group_to_ddr(void);
+
+hrt_vaddress
+sh_css_store_sp_stage_to_ddr(unsigned pipe, unsigned stage);
+
+hrt_vaddress
+sh_css_store_isp_stage_to_ddr(unsigned pipe, unsigned stage);
+
+
+void
+sh_css_update_uds_and_crop_info(
+		const struct ia_css_binary_info *info,
+		const struct ia_css_frame_info *in_frame_info,
+		const struct ia_css_frame_info *out_frame_info,
+		const struct ia_css_resolution *dvs_env,
+		bool preview_mode,
+		const struct ia_css_dz_config *zoom,
+		const struct ia_css_vector *motion_vector,
+		struct sh_css_uds_info *uds,		/* out */
+		struct sh_css_crop_pos *sp_out_crop_pos	/* out */
+		);
+
+void
+sh_css_invalidate_shading_tables(struct ia_css_stream *stream);
+
+#if defined(IS_ISP_2500_SYSTEM)
+void
+ia_css_pipe_get_bds_resolution(const struct ia_css_pipe *pipe, struct ia_css_resolution *res);
+
+void
+ia_css_pipe_get_dvs_envelope(const struct ia_css_pipe *pipe, struct ia_css_resolution *res);
+#endif
+
+struct ia_css_pipeline *
+ia_css_pipe_get_pipeline(const struct ia_css_pipe *pipe);
+
+unsigned int
+ia_css_pipe_get_pipe_num(const struct ia_css_pipe *pipe);
+
+unsigned int
+ia_css_pipe_get_isp_pipe_version(const struct ia_css_pipe *pipe);
+
+bool
+sh_css_continuous_is_enabled(uint8_t pipe_num);
+
+#endif /* _SH_CSS_INTERNAL_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_legacy.h b/drivers/media/atomisp2/css2400/sh_css_legacy.h
new file mode 100644
index 0000000..495acb1
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_legacy.h
@@ -0,0 +1,87 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_LEGACY_H_
+#define _SH_CSS_LEGACY_H_
+
+#include "ia_css.h"
+
+/** The pipe id type, distinguishes the kind of pipes that
+ *  can be run in parallel.
+ */
+enum ia_css_pipe_id {
+	IA_CSS_PIPE_ID_PREVIEW,
+	IA_CSS_PIPE_ID_COPY,
+	IA_CSS_PIPE_ID_VIDEO,
+	IA_CSS_PIPE_ID_CAPTURE,
+	IA_CSS_PIPE_ID_YUVPP,
+	IA_CSS_PIPE_ID_ACC,
+	IA_CSS_PIPE_ID_NUM
+};
+
+struct ia_css_pipe_extra_config {
+	bool enable_raw_binning;
+	bool enable_yuv_ds;
+	bool enable_high_speed;
+	bool enable_dvs_6axis;
+	bool enable_reduced_pipe;
+	bool enable_fractional_ds;
+	bool disable_vf_pp;
+};
+
+#define DEFAULT_PIPE_EXTRA_CONFIG \
+{ \
+	false,				/* enable_raw_binning */ \
+	false,				/* enable_yuv_ds */ \
+	false,				/* enable_high_speed */ \
+	false,				/* enable_dvs_6axis */ \
+	false,				/* enable_reduced_pipe */ \
+	false,				/* enable_fractional_ds */ \
+	false,				/* disable_vf_pp */ \
+}
+
+enum ia_css_err
+ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
+			 const struct ia_css_pipe_extra_config *extra_config,
+			 struct ia_css_pipe **pipe);
+
+void
+ia_css_pipe_extra_config_defaults(struct ia_css_pipe_extra_config *extra_config);
+
+enum ia_css_err
+ia_css_temp_pipe_to_pipe_id(const struct ia_css_pipe *pipe,
+			    enum ia_css_pipe_id *pipe_id);
+
+/** @brief Enable cont_capt mode (continuous preview+capture running together).
+ *
+ * @param	enable	Enabling value.
+ *
+ * Enable or disable continuous binaries if available. Default is disabled.
+ */
+void
+sh_css_enable_cont_capt(bool enable, bool stop_copy_preview);
+
+/* DEPRECATED. FPN is not supported. */
+enum ia_css_err
+sh_css_set_black_frame(struct ia_css_stream *stream,
+			const struct ia_css_frame *raw_black_frame);
+
+#endif /* _SH_CSS_LEGACY_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_metrics.c b/drivers/media/atomisp2/css2400/sh_css_metrics.c
new file mode 100644
index 0000000..1e47954
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_metrics.c
@@ -0,0 +1,192 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "assert_support.h"
+#include "sh_css_metrics.h"
+
+#include "sp.h"
+#include "isp.h"
+
+#include "sh_css_internal.h"
+
+#define MULTIPLE_PCS 0
+#define SUSPEND      0
+#define NOF_PCS      1
+#define RESUME_MASK  0x8
+#define STOP_MASK    0x0
+
+static bool pc_histogram_enabled;
+static struct sh_css_pc_histogram *isp_histogram;
+static struct sh_css_pc_histogram *sp_histogram;
+
+struct sh_css_metrics sh_css_metrics;
+
+void
+sh_css_metrics_start_frame(void)
+{
+	sh_css_metrics.frame_metrics.num_frames++;
+}
+
+static void
+clear_histogram(struct sh_css_pc_histogram *histogram)
+{
+	unsigned i;
+
+	assert(histogram != NULL);
+
+	for (i = 0; i < histogram->length; i++) {
+		histogram->run[i] = 0;
+		histogram->stall[i] = 0;
+		histogram->msink[i] = 0xFFFF;
+	}
+}
+
+void
+sh_css_metrics_enable_pc_histogram(bool enable)
+{
+	pc_histogram_enabled = enable;
+}
+
+static void
+make_histogram(struct sh_css_pc_histogram *histogram, unsigned length)
+{
+	assert(histogram != NULL);
+
+	if (histogram->length)
+		return;
+	if (histogram->run)
+		return;
+	histogram->run = sh_css_malloc(length * sizeof(*histogram->run));
+	if (!histogram->run)
+		return;
+	histogram->stall = sh_css_malloc(length * sizeof(*histogram->stall));
+	if (!histogram->stall)
+		return;
+	histogram->msink = sh_css_malloc(length * sizeof(*histogram->msink));
+	if (!histogram->msink)
+		return;
+
+	histogram->length = length;
+	clear_histogram(histogram);
+}
+
+static void
+insert_binary_metrics(struct sh_css_binary_metrics **l,
+			struct sh_css_binary_metrics *metrics)
+{
+	assert(l != NULL);
+	assert(*l != NULL);
+	assert(metrics != NULL);
+
+	for (; *l; l = &(*l)->next)
+		if (*l == metrics)
+			return;
+
+	*l = metrics;
+	metrics->next = NULL;
+}
+
+void
+sh_css_metrics_start_binary(struct sh_css_binary_metrics *metrics)
+{
+	assert(metrics != NULL);
+
+	if (!pc_histogram_enabled)
+		return;
+
+	isp_histogram = &metrics->isp_histogram;
+	sp_histogram = &metrics->sp_histogram;
+	make_histogram(isp_histogram, ISP_PMEM_DEPTH);
+#if !defined(IS_ISP_2500_SKYCAM_SYSTEM)
+	make_histogram(sp_histogram, SP_PMEM_DEPTH);
+#endif
+	insert_binary_metrics(&sh_css_metrics.binary_metrics, metrics);
+}
+
+void
+sh_css_metrics_sample_pcs(void)
+{
+	bool stall;
+	unsigned int pc;
+	unsigned int msink;
+
+#if SUSPEND
+	unsigned int sc = 0;
+	unsigned int stopped_sc = 0;
+	unsigned int resume_sc = 0;
+#endif
+
+
+#if MULTIPLE_PCS
+	int i;
+	unsigned int pc_tab[NOF_PCS] ;
+
+	for (i = 0; i < NOF_PCS; i++)
+		pc_tab[i] = 0;
+#endif
+
+	if (!pc_histogram_enabled)
+		return;
+
+	if (isp_histogram) {
+#if SUSPEND
+		/* STOP the ISP */
+		isp_ctrl_store(ISP0_ID, ISP_SC_REG, STOP_MASK);
+#endif
+		msink = isp_ctrl_load(ISP0_ID, ISP_CTRL_SINK_REG);
+#if MULTIPLE_PCS
+		for (i = 0; i < NOF_PCS; i++)
+			pc_tab[i] = isp_ctrl_load(ISP0_ID, ISP_PC_REG);
+#else
+		pc = isp_ctrl_load(ISP0_ID, ISP_PC_REG);
+#endif
+
+#if SUSPEND
+		/* RESUME the ISP */
+		isp_ctrl_store(ISP0_ID, ISP_SC_REG, RESUME_MASK);
+#endif
+		isp_histogram->msink[pc] &= msink;
+		stall = (msink != 0x7FF);
+
+		if (stall)
+			isp_histogram->stall[pc]++;
+		else
+			isp_histogram->run[pc]++;
+
+#if MULTIPLE_PCS
+		printk(KERN_INFO "msink = 0%X\n", msink);
+		for (i = 0; i < NOF_PCS; i++)
+			printk(KERN_INFO "PC = %d  ", pc_tab[i]);
+		printk(KERN_INFO "\n");
+#endif
+	}
+
+	if (sp_histogram && 0) {
+		msink = sp_ctrl_load(SP0_ID, SP_CTRL_SINK_REG);
+		pc = sp_ctrl_load(SP0_ID, SP_PC_REG);
+		sp_histogram->msink[pc] &= msink;
+		stall = (msink != 0x7FF);
+		if (stall)
+			sp_histogram->stall[pc]++;
+		else
+			sp_histogram->run[pc]++;
+	}
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_metrics.h b/drivers/media/atomisp2/css2400/sh_css_metrics.h
new file mode 100644
index 0000000..2b01d79
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_metrics.h
@@ -0,0 +1,83 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_METRICS_H_
+#define _SH_CSS_METRICS_H_
+
+#include <type_support.h>
+
+struct sh_css_pc_histogram {
+	unsigned length;
+	unsigned *run;
+	unsigned *stall;
+	unsigned *msink;
+};
+
+#if !defined(__USE_DESIGNATED_INITIALISERS__)
+#define DEFAULT_PC_HISTOGRAM \
+{ \
+	0, \
+	NULL, \
+	NULL, \
+	NULL \
+}
+#endif
+
+struct sh_css_binary_metrics {
+	unsigned mode;
+	unsigned id;
+	struct sh_css_pc_histogram isp_histogram;
+	struct sh_css_pc_histogram sp_histogram;
+	struct sh_css_binary_metrics *next;
+};
+
+#if !defined(__USE_DESIGNATED_INITIALISERS__)
+#define DEFAULT_BINARY_METRICS \
+{ \
+	0, \
+	0, \
+	DEFAULT_PC_HISTOGRAM, \
+	DEFAULT_PC_HISTOGRAM, \
+	NULL \
+}
+#endif
+
+struct ia_css_frame_metrics {
+	unsigned num_frames;
+};
+
+struct sh_css_metrics {
+	struct sh_css_binary_metrics *binary_metrics;
+	struct ia_css_frame_metrics   frame_metrics;
+};
+
+extern struct sh_css_metrics sh_css_metrics;
+
+/* includes ia_css_binary.h, which depends on sh_css_metrics.h */
+#include "ia_css_types.h"
+
+/* Sample ISP and SP pc and add to histogram */
+void sh_css_metrics_enable_pc_histogram(bool enable);
+void sh_css_metrics_start_frame(void);
+void sh_css_metrics_start_binary(struct sh_css_binary_metrics *metrics);
+void sh_css_metrics_sample_pcs(void);
+
+#endif /* _SH_CSS_METRICS_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_mipi.c b/drivers/media/atomisp2/css2400/sh_css_mipi.c
new file mode 100644
index 0000000..cb68356
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_mipi.c
@@ -0,0 +1,210 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_mipi.h"
+#include <type_support.h>
+#include "ia_css_err.h"
+#include "ia_css_stream_format.h"
+#include "ia_css_stream_public.h"
+#include "ia_css_frame_public.h"
+#include "ia_css_input_port.h"
+#include "ia_css_debug.h"
+#include "sh_css_struct.h"
+#include "sh_css_defs.h"
+
+enum ia_css_err
+ia_css_mipi_frame_specify(const unsigned int size_mem_words,
+				const bool contiguous)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	my_css.size_mem_words = size_mem_words;
+	my_css.contiguous = contiguous;
+
+	return err;
+}
+
+/* Assumptions:
+ *	- A line is multiple of 4 bytes = 1 word.
+ *	- Each frame has SOF and EOF (each 1 word).
+ *	- Each line has format header and optionally SOL and EOL (each 1 word).
+ *	- Odd and even lines of YUV420 format are different in bites per pixel size.
+ *	- Custom size of embedded data.
+ *  -- Interleaved frames are not taken into account.
+ *  -- Lines are multiples of 8B, and not necessary of (custom 3B, or 7B
+ *  etc.).
+ * Result is given in DDR mem words, 32B or 256 bits
+ */
+enum ia_css_err
+ia_css_mipi_frame_calculate_size(const unsigned int width,
+				const unsigned int height,
+				const enum ia_css_stream_format format,
+				const bool hasSOLandEOL,
+				const unsigned int embedded_data_size_words,
+				unsigned int *size_mem_words)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	unsigned int bits_per_pixel = 0;
+	unsigned int even_line_bytes = 0;
+	unsigned int odd_line_bytes = 0;
+	unsigned int words_per_odd_line = 0;
+	unsigned int words_for_first_line = 0;
+	unsigned int words_per_even_line = 0;
+	unsigned int mem_words_per_even_line = 0;
+	unsigned int mem_words_per_odd_line = 0;
+	unsigned int mem_words_for_first_line = 0;
+	unsigned int mem_words_for_EOF = 0;
+	unsigned int mem_words = 0;
+	unsigned int width_padded = width;
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* The changes will be reverted as soon as RAW
+	 * Buffers are deployed by the 2401 Input System
+	 * in the non-continuous use scenario.
+	 */
+	width_padded += (2 * ISP_VEC_NELEMS);
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_mipi_frame_calculate_size() "
+		"enter: padded_width=%d, height=%d, format=%d, hasSOLandEOL=%d, embedded_data_size_words=%d\n",
+		width_padded, height, format, hasSOLandEOL, embedded_data_size_words);
+
+	switch (format) {
+		case IA_CSS_STREAM_FORMAT_RAW_6:			/* 4p, 3B, 24bits */
+			bits_per_pixel = 6;	break;
+		case IA_CSS_STREAM_FORMAT_RAW_7:			/* 8p, 7B, 56bits */
+			bits_per_pixel = 7;		break;
+		case IA_CSS_STREAM_FORMAT_RAW_8:			/* 1p, 1B, 8bits */
+		case IA_CSS_STREAM_FORMAT_BINARY_8:      /*  8bits, TODO: check. */
+		case IA_CSS_STREAM_FORMAT_YUV420_8:		/* odd 2p, 2B, 16bits, even 2p, 4B, 32bits */
+			bits_per_pixel = 8;		break;
+		case IA_CSS_STREAM_FORMAT_YUV420_10:		/* odd 4p, 5B, 40bits, even 4p, 10B, 80bits */
+		case IA_CSS_STREAM_FORMAT_RAW_10:		/* 4p, 5B, 40bits */
+#if !defined(HAS_NO_PACKED_RAW_PIXELS)
+			/* The changes will be reverted as soon as RAW
+			 * Buffers are deployed by the 2401 Input System
+			 * in the non-continuous use scenario.
+			 */
+			bits_per_pixel = 10;
+#else
+			bits_per_pixel = 16;
+#endif
+			break;
+		case IA_CSS_STREAM_FORMAT_YUV420_8_LEGACY:	/* 2p, 3B, 24bits */
+		case IA_CSS_STREAM_FORMAT_RAW_12:			/* 2p, 3B, 24bits */
+			bits_per_pixel = 12;	break;
+		case IA_CSS_STREAM_FORMAT_RAW_14:		/* 4p, 7B, 56bits */
+			bits_per_pixel = 14;	break;
+		case IA_CSS_STREAM_FORMAT_RGB_444:		/* 1p, 2B, 16bits */
+		case IA_CSS_STREAM_FORMAT_RGB_555:		/* 1p, 2B, 16bits */
+		case IA_CSS_STREAM_FORMAT_RGB_565:		/* 1p, 2B, 16bits */
+		case IA_CSS_STREAM_FORMAT_YUV422_8:		/* 2p, 4B, 32bits */
+			bits_per_pixel = 16;	break;
+		case IA_CSS_STREAM_FORMAT_RGB_666:		/* 4p, 9B, 72bits */
+			bits_per_pixel = 18;	break;
+		case IA_CSS_STREAM_FORMAT_YUV422_10:		/* 2p, 5B, 40bits */
+			bits_per_pixel = 20;	break;
+		case IA_CSS_STREAM_FORMAT_RGB_888:		/* 1p, 3B, 24bits */
+			bits_per_pixel = 24;	break;
+
+		case IA_CSS_STREAM_FORMAT_RAW_16:        /* TODO: not specified in MIPI SPEC, check */
+		default:
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	odd_line_bytes = (width_padded * bits_per_pixel + 7) >> 3; /* ceil ( bits per line / 8 ) */
+
+	/* Even lines for YUV420 formats are double in bits_per_pixel. */
+	if (format == IA_CSS_STREAM_FORMAT_YUV420_8
+		|| format == IA_CSS_STREAM_FORMAT_YUV420_10) {
+		even_line_bytes = (width_padded * 2 * bits_per_pixel + 7) >> 3; /* ceil ( bits per line / 8 ) */
+	} else {
+		even_line_bytes = odd_line_bytes;
+	}
+
+   /*  a frame represented in memory:  ()- optional; data - payload words.
+	*  addr		0		1		2		3		4		5		6		7:
+	*  first	SOF		(SOL)	PACK_H	data	data	data	data	data
+	*	data	data	data	data	data	data	data	data
+	*           ...
+	*			data	data	0		0		0		0		0		0
+	*  second   (EOL)	(SOL)	PACK_H	data	data	data	data	data
+	*	data	data	data	data	data	data	data	data
+	*           ...
+	*			data	data	0		0		0		0		0		0
+	*  ...
+	*  last		(EOL)	EOF		0		0		0		0		0		0
+	*
+	*  Embedded lines are regular lines stored before the first and after
+	*  payload lines.
+	*/
+
+
+	words_per_odd_line	 = ((odd_line_bytes   + 3) >> 2 );		/* ceil(odd_line_bytes/4); word = 4 bytes */
+	words_per_even_line  = ((even_line_bytes  + 3) >> 2 );
+    words_for_first_line = words_per_odd_line + 2 + (hasSOLandEOL ? 1 : 0); /* + SOF +packet header + optionally (SOL), but (EOL) is not in the first line */
+	words_per_odd_line	+= (1 + (hasSOLandEOL ? 2 : 0));  /* each non-first line has format header, and optionally (SOL) and (EOL). */
+	words_per_even_line += (1 + (hasSOLandEOL ? 2 : 0));
+
+	mem_words_per_odd_line	 = ((words_per_odd_line + 7) >> 3);	/* ceil(words_per_odd_line/8); mem_word = 32 bytes, 8 words */
+	mem_words_for_first_line = ((words_for_first_line + 7) >> 3);
+	mem_words_per_even_line  = ((words_per_even_line + 7) >> 3);
+	mem_words_for_EOF        = 1; /* last line consisit of the optional (EOL) and EOF */
+
+	mem_words = ((embedded_data_size_words + 7) >> 3) +
+		mem_words_for_first_line +
+				(((height + 1) >> 1) - 1) * mem_words_per_odd_line + /* ceil (height/2) - 1 (first line is calculated separatelly) */
+				(  height      >> 1     ) * mem_words_per_even_line + /* floor(height/2) */
+				mem_words_for_EOF;
+
+	*size_mem_words = mem_words; /* ceil(words/8); mem word is 32B = 8words. */ //Check if this is still needed.
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_mipi_frame_calculate_size() leave: return_err=%d\n",err);
+	return err;
+}
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+enum ia_css_err
+ia_css_mipi_frame_enable_check_on_size(const enum ia_css_csi2_port port,
+				const unsigned int	size_mem_words)
+{
+	uint32_t idx;
+
+	enum ia_css_err err = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+
+	OP___assert(port < N_CSI_PORTS);
+	OP___assert(size_mem_words != 0);
+
+
+	for (idx = 0; idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT &&
+		my_css.mipi_sizes_for_check[port][idx] != 0;
+		idx++){}
+	if (idx < IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT) {
+		my_css.mipi_sizes_for_check[port][idx] = size_mem_words;
+		err = IA_CSS_SUCCESS;
+	}
+
+	return err;
+}
+#endif
diff --git a/drivers/media/atomisp2/css2400/sh_css_param_dvs.c b/drivers/media/atomisp2/css2400/sh_css_param_dvs.c
new file mode 100644
index 0000000..b465541
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_param_dvs.c
@@ -0,0 +1,244 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "sh_css_param_dvs.h"
+#include <assert_support.h>
+#include <type_support.h>
+#include <ia_css_err.h>
+#include <ia_css_types.h>
+#include "ia_css_debug.h"
+
+struct ia_css_dvs_6axis_config *
+generate_dvs_6axis_table(const struct ia_css_resolution	*frame_res, const struct ia_css_resolution *dvs_offset)
+{
+
+	unsigned int x,y;
+	unsigned int width_y;
+	unsigned int height_y;
+	unsigned int width_uv;
+	unsigned int height_uv;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_dvs_6axis_config  *dvs_config = NULL;
+
+	assert(frame_res != NULL);
+	assert(dvs_offset != NULL);
+
+	dvs_config = (struct ia_css_dvs_6axis_config *)sh_css_malloc(sizeof(struct ia_css_dvs_6axis_config));
+	if(dvs_config == NULL)
+	{
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "out of memory\n");
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+	else
+	{	/*Initialize new struct with latest config settings*/
+		dvs_config->width_y = width_y = DVS_TABLE_IN_BLOCKDIM_X_LUMA(frame_res->width);
+		dvs_config->height_y = height_y = DVS_TABLE_IN_BLOCKDIM_Y_LUMA(frame_res->height);
+		dvs_config->width_uv = width_uv = DVS_TABLE_IN_BLOCKDIM_X_CHROMA(frame_res->width / 2); /* UV = Y/2, depens on colour format YUV 4.2.0*/
+		dvs_config->height_uv = height_uv = DVS_TABLE_IN_BLOCKDIM_Y_CHROMA(frame_res->height / 2);/* UV = Y/2, depens on colour format YUV 4.2.0*/
+
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "generate_dvs_6axis_table: Env_X %d Env_Y %d\n",dvs_offset->width,dvs_offset->height);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "generate_dvs_6axis_table Y: W %d H %d\n",width_y,height_y);
+		/* Generate Y buffers  */
+		dvs_config->xcoords_y = (uint32_t *)sh_css_malloc( width_y * height_y * sizeof(uint32_t));
+		if(dvs_config->xcoords_y == NULL)
+		{
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "out of memory\n");
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+		else
+		{
+			for(y = 0; y < height_y; y++)
+			{
+				for(x=0;x<width_y;x++)
+				{
+					dvs_config->xcoords_y[y*width_y + x] =  (  ( dvs_offset->width + x*DVS_BLOCKDIM_X) << DVS_COORD_FRAC_BITS );
+				}
+			}
+		}
+
+		dvs_config->ycoords_y = (uint32_t *)sh_css_malloc( width_y * height_y * sizeof(uint32_t));
+		if(dvs_config->ycoords_y == NULL)
+		{
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "out of memory\n");
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+		else
+		{
+			for(y = 0; y < height_y; y++)
+			{
+				for(x=0;x<width_y;x++)
+				{
+					dvs_config->ycoords_y[y*width_y + x] =  (  ( dvs_offset->height + y*DVS_BLOCKDIM_Y_LUMA) << DVS_COORD_FRAC_BITS );
+				}
+			}
+		}
+
+		/* Generate UV buffers  */
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "generate_dvs_6axis_table UV W %d H %d\n",width_uv,height_uv);
+
+		dvs_config->xcoords_uv = (uint32_t *)sh_css_malloc( width_uv * height_uv * sizeof(uint32_t));
+		if(dvs_config->xcoords_uv == NULL)
+		{
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "out of memory\n");
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+		else
+		{
+			for(y = 0; y < height_uv; y++)
+			{
+				for(x=0;x<width_uv;x++)
+				{	/* Envelope dimesions set in Ypixels hence offset UV = offset Y/2 */
+					dvs_config->xcoords_uv[y*width_uv + x] =  (  ( (dvs_offset->width / 2) + x*DVS_BLOCKDIM_X) << DVS_COORD_FRAC_BITS );
+				}
+			}
+		}
+
+		dvs_config->ycoords_uv = (uint32_t *)sh_css_malloc( width_uv * height_uv * sizeof(uint32_t));
+		if(dvs_config->ycoords_uv == NULL)
+		{
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "out of memory\n");
+			err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+		else
+		{
+			for(y = 0; y < height_uv; y++)
+			{
+				for(x=0;x<width_uv;x++)
+				{ 	/* Envelope dimesions set in Ypixels hence offset UV = offset Y/2 */
+					dvs_config->ycoords_uv[y*width_uv + x] =  (  ( (dvs_offset->height / 2) + y*DVS_BLOCKDIM_Y_CHROMA) << DVS_COORD_FRAC_BITS );
+				}
+			}
+		}
+
+#if 0
+		for(y = 0; y < height_y; y++)
+		{
+			for(x=0;x<width_y;x++)
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "xcoords_y: %d \n",dvs_config->xcoords_y[y*width_y + x]);
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\n");
+		}
+
+		for(y = 0; y < height_y; y++)
+		{
+			for(x=0;x<width_y;x++)
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ycoords_y: %d \n",dvs_config->ycoords_y[y*width_y + x]);
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\n");
+		}
+
+				for(y = 0; y < height_y; y++)
+		{
+			for(x=0;x<width_uv;x++)
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "xcoords_uv: %d \n",dvs_config->xcoords_uv[y*width_uv + x]);
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\n");
+		}
+
+		for(y = 0; y < height_uv; y++)
+		{
+			for(x=0;x<width_uv;x++)
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ycoords_uv: %d \n",dvs_config->ycoords_uv[y*width_uv + x]);
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\n");
+		}
+#endif
+		if (err != IA_CSS_SUCCESS)
+		{
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "generate_dvs_6axis_table: err %d\n, leave() ",(int)err);
+			free_dvs_6axis_table(&dvs_config); /* we might have allocated some memory, release this */
+		}
+		else
+		{
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "generate_dvs_6axis_table leave() , dvs_config %p\n",dvs_config);
+		}
+	}
+
+	return dvs_config;
+}
+
+void
+free_dvs_6axis_table(struct ia_css_dvs_6axis_config  **dvs_6axis_config)
+{
+	assert(dvs_6axis_config != NULL);
+	assert(*dvs_6axis_config != NULL);
+
+	if( (dvs_6axis_config != NULL) && (*dvs_6axis_config != NULL) )
+	{
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "-> free_dvs_6axis_table dvs_6axis_config %p\n",(*dvs_6axis_config));
+		if((*dvs_6axis_config)->xcoords_y != NULL)
+		{
+			 sh_css_free((*dvs_6axis_config)->xcoords_y);
+			 (*dvs_6axis_config)->xcoords_y = NULL;
+		}
+
+		if((*dvs_6axis_config)->ycoords_y != NULL)
+		{
+			sh_css_free((*dvs_6axis_config)->ycoords_y);
+			(*dvs_6axis_config)->ycoords_y = NULL;
+		}
+
+		/* Free up UV buffers */
+		if((*dvs_6axis_config)->xcoords_uv != NULL)
+		{
+			sh_css_free((*dvs_6axis_config)->xcoords_uv);
+			(*dvs_6axis_config)->xcoords_uv = NULL;
+		}
+
+		if((*dvs_6axis_config)->ycoords_uv != NULL)
+		{
+			sh_css_free((*dvs_6axis_config)->ycoords_uv);
+			(*dvs_6axis_config)->ycoords_uv = NULL;
+		}
+
+		sh_css_free(*dvs_6axis_config);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "<- free_dvs_6axis_table dvs_6axis_config %p\n",(*dvs_6axis_config));
+		*dvs_6axis_config = NULL;
+	}
+}
+
+void copy_dvs_6axis_table(struct ia_css_dvs_6axis_config *dvs_config_dst,
+			const struct ia_css_dvs_6axis_config *dvs_config_src)
+{
+	unsigned int width_y;
+	unsigned int height_y;
+	unsigned int width_uv;
+	unsigned int height_uv;
+
+	assert(dvs_config_src!= NULL);
+	assert(dvs_config_dst != NULL);
+	assert(dvs_config_src->xcoords_y != NULL);
+	assert(dvs_config_src->xcoords_uv != NULL);
+	assert(dvs_config_src->ycoords_y != NULL);
+	assert(dvs_config_src->ycoords_uv != NULL);
+	assert(dvs_config_src->width_y == dvs_config_dst->width_y);
+	assert(dvs_config_src->width_uv == dvs_config_dst->width_uv);
+	assert(dvs_config_src->height_y == dvs_config_dst->height_y);
+	assert(dvs_config_src->height_uv == dvs_config_dst->height_uv);
+
+	width_y = dvs_config_src->width_y;
+	height_y = dvs_config_src->height_y;
+	width_uv = dvs_config_src->width_uv; /* = Y/2, depens on colour format YUV 4.2.0*/
+	height_uv = dvs_config_src->height_uv;
+
+	memcpy(dvs_config_dst->xcoords_y,dvs_config_src->xcoords_y, (width_y * height_y * sizeof(uint32_t)));
+	memcpy(dvs_config_dst->ycoords_y,dvs_config_src->ycoords_y, (width_y * height_y * sizeof(uint32_t)));
+
+	memcpy(dvs_config_dst->xcoords_uv,dvs_config_src->xcoords_uv, (width_uv * height_uv * sizeof(uint32_t)));
+	memcpy(dvs_config_dst->ycoords_uv,dvs_config_src->ycoords_uv, (width_uv * height_uv * sizeof(uint32_t)));
+
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_param_dvs.h b/drivers/media/atomisp2/css2400/sh_css_param_dvs.h
new file mode 100644
index 0000000..b454fe0
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_param_dvs.h
@@ -0,0 +1,72 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_PARAMS_DVS_H_
+#define _SH_CSS_PARAMS_DVS_H_
+
+#include <ia_css_types.h>
+
+#define DVS_ENV_MIN_X (12)
+#define DVS_ENV_MIN_Y (12)
+
+#define DVS_BLOCKDIM_X (64)        /* X block height*/
+#define DVS_BLOCKDIM_Y_LUMA (64)   /* Y block height*/
+#define DVS_BLOCKDIM_Y_CHROMA (32) /* UV height block size is half the Y block height*/
+
+#define DVS_NUM_BLOCKS_X(X)    (CEIL_MUL(CEIL_DIV((X), DVS_BLOCKDIM_X), 2))      // horizontal 64x64 blocks round up to DVS_BLOCKDIM_X, make even
+#define DVS_NUM_BLOCKS_Y(X)             (CEIL_DIV((X), DVS_BLOCKDIM_Y_LUMA))     // vertical   64x64 blocks round up to DVS_BLOCKDIM_Y
+#define DVS_NUM_BLOCKS_X_CHROMA(X)      (CEIL_DIV((X), DVS_BLOCKDIM_X))
+#define DVS_NUM_BLOCKS_Y_CHROMA(X)      (CEIL_DIV((X), DVS_BLOCKDIM_Y_CHROMA))
+
+
+#define DVS_TABLE_IN_BLOCKDIM_X_LUMA(X)   	(DVS_NUM_BLOCKS_X(X) + 1)  // N blocks have N + 1 set of coords
+#define DVS_TABLE_IN_BLOCKDIM_X_CHROMA(X)   (DVS_NUM_BLOCKS_X_CHROMA(X) + 1)
+#define DVS_TABLE_IN_BLOCKDIM_Y_LUMA(X)		(DVS_NUM_BLOCKS_Y(X) + 1)
+#define DVS_TABLE_IN_BLOCKDIM_Y_CHROMA(X)	(DVS_NUM_BLOCKS_Y_CHROMA(X) + 1)
+
+#define DVS_ENVELOPE_X(X) (((X) == 0) ? (DVS_ENV_MIN_X) : (X))
+#define DVS_ENVELOPE_Y(X) (((X) == 0) ? (DVS_ENV_MIN_Y) : (X))
+
+#define DVS_COORD_FRAC_BITS (10)
+#define DVS_INPUT_BYTES_PER_PIXEL (1)
+#define XMEM_ALIGN_LOG2 (5)
+
+#define DVS_6AXIS_COORDS_ELEMS CEIL_MUL(sizeof(gdc_warp_param_mem_t) \
+					, HIVE_ISP_DDR_WORD_BYTES)
+
+/* currently we only support two output with the same resolution, output 0 is th default one. */
+#define DVS_6AXIS_BYTES(binary) \
+	(DVS_6AXIS_COORDS_ELEMS \
+     *  DVS_NUM_BLOCKS_X((binary)->out_frame_info[0].res.width) \
+     *  DVS_NUM_BLOCKS_Y((binary)->out_frame_info[0].res.height)   )
+
+struct ia_css_dvs_6axis_config *
+generate_dvs_6axis_table(const struct ia_css_resolution	*frame_res, const struct ia_css_resolution *dvs_offset);
+
+void
+free_dvs_6axis_table(struct ia_css_dvs_6axis_config  **dvs_6axis_config);
+
+void
+copy_dvs_6axis_table(struct ia_css_dvs_6axis_config *dvs_config_dst,
+			 const struct ia_css_dvs_6axis_config *dvs_config_src);
+
+
+#endif
diff --git a/drivers/media/atomisp2/css2400/sh_css_param_shading.c b/drivers/media/atomisp2/css2400/sh_css_param_shading.c
new file mode 100644
index 0000000..3a95cba
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_param_shading.c
@@ -0,0 +1,351 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "sh_css_param_shading.h"
+#include "ia_css_shading.h"
+#include "assert_support.h"
+#include "ia_css.h"
+#include "sh_css_defs.h"
+#include "sh_css_internal.h"
+#include "ia_css_debug.h"
+
+#include "sh_css_hrt.h"
+
+#include "platform_support.h"
+
+/* Bilinear interpolation on shading tables:
+ * For each target point T, we calculate the 4 surrounding source points:
+ * ul (upper left), ur (upper right), ll (lower left) and lr (lower right).
+ * We then calculate the distances from the T to the source points: x0, x1,
+ * y0 and y1.
+ * We then calculate the value of T:
+ *   dx0*dy0*Slr + dx0*dy1*Sur + dx1*dy0*Sll + dx1*dy1*Sul.
+ * We choose a grid size of 1x1 which means:
+ *   dx1 = 1-dx0
+ *   dy1 = 1-dy0
+ *
+ *   Sul dx0         dx1      Sur
+ *    .<----->|<------------->.
+ *    ^
+ * dy0|
+ *    v        T
+ *    -        .
+ *    ^
+ *    |
+ * dy1|
+ *    v
+ *    .                        .
+ *   Sll                      Slr
+ *
+ * Padding:
+ * The area that the ISP operates on can include padding both on the left
+ * and the right. We need to padd the shading table such that the shading
+ * values end up on the correct pixel values. This means we must padd the
+ * shading table to match the ISP padding.
+ * We can have 5 cases:
+ * 1. All 4 points fall in the left padding.
+ * 2. The left 2 points fall in the left padding.
+ * 3. All 4 points fall in the cropped (target) region.
+ * 4. The right 2 points fall in the right padding.
+ * 5. All 4 points fall in the right padding.
+ * Cases 1 and 5 are easy to handle: we simply use the
+ * value 1 in the shading table.
+ * Cases 2 and 4 require interpolation that takes into
+ * account how far into the padding area the pixels
+ * fall. We extrapolate the shading table into the
+ * padded area and then interpolate.
+ */
+static void
+crop_and_interpolate(unsigned int cropped_width,
+		     unsigned int cropped_height,
+		     unsigned int left_padding,
+		     unsigned int right_padding,
+		     const struct ia_css_shading_table *in_table,
+		     struct ia_css_shading_table *out_table,
+		     enum ia_css_sc_color color)
+{
+	unsigned int i, j,
+		     sensor_width,
+		     sensor_height,
+		     table_width,
+		     table_height,
+		     table_cell_h,
+		     out_cell_size,
+		     in_cell_size,
+		     out_start_row,
+		     padded_width;
+	int out_start_col, /* can be negative to indicate padded space */
+	    table_cell_w;
+	unsigned short *in_ptr,
+		       *out_ptr;
+
+	assert(in_table != NULL);
+	assert(out_table != NULL);
+
+	sensor_width  = in_table->sensor_width;
+	sensor_height = in_table->sensor_height;
+	table_width   = in_table->width;
+	table_height  = in_table->height;
+	in_ptr = in_table->data[color];
+	out_ptr = out_table->data[color];
+
+	padded_width = cropped_width + left_padding + right_padding;
+	out_cell_size = CEIL_DIV(padded_width, out_table->width - 1);
+	in_cell_size  = CEIL_DIV(sensor_width, table_width - 1);
+
+	out_start_col = (sensor_width - cropped_width)/2 - left_padding;
+	out_start_row = (sensor_height - cropped_height)/2;
+	table_cell_w = (int)((table_width-1) * in_cell_size);
+	table_cell_h = (table_height-1) * in_cell_size;
+
+	for (i = 0; i < out_table->height; i++) {
+		unsigned int ty, src_y0, src_y1, sy0, sy1, dy0, dy1, divy;
+
+		/* calculate target point and make sure it falls within
+		   the table */
+		ty = out_start_row + i * out_cell_size;
+		ty = min(ty, sensor_height-1);
+		ty = min(ty, table_cell_h);
+
+		/* calculate closest source points in shading table and
+		   make sure they fall within the table */
+		src_y0 = ty / in_cell_size;
+		if (in_cell_size < out_cell_size)
+			src_y1 = (ty + out_cell_size) / in_cell_size;
+		else
+			src_y1 = src_y0 + 1;
+		src_y0 = min(src_y0, table_height-1);
+		src_y1 = min(src_y1, table_height-1);
+		/* calculate closest source points for distance computation */
+		sy0 = min(src_y0 * in_cell_size, sensor_height-1);
+		sy1 = min(src_y1 * in_cell_size, sensor_height-1);
+		/* calculate distance between source and target pixels */
+		dy0 = ty - sy0;
+		dy1 = sy1 - ty;
+		divy = sy1 - sy0;
+		if (divy == 0) {
+			dy0 = 1;
+			divy = 1;
+		}
+
+		for (j = 0; j < out_table->width; j++, out_ptr++) {
+			int tx, src_x0, src_x1;
+			unsigned int sx0, sx1, dx0, dx1, divx;
+			unsigned short s_ul, s_ur, s_ll, s_lr;
+
+			/* calculate target point */
+			tx = out_start_col + j * out_cell_size;
+			/* calculate closest source points. */
+			src_x0 = tx / (int)in_cell_size;
+			if (in_cell_size < out_cell_size) {
+				src_x1 = (tx + out_cell_size) /
+					 (int)in_cell_size;
+			} else {
+				src_x1 = src_x0 + 1;
+			}
+			/* if src points fall in padding, select closest ones.*/
+			src_x0 = clamp(src_x0, 0, (int)table_width-1);
+			src_x1 = clamp(src_x1, 0, (int)table_width-1);
+			tx = min(clamp(tx, 0, (int)sensor_width-1),
+				 (int)table_cell_w);
+			/* calculate closest source points for distance
+			   computation */
+			sx0 = min(src_x0 * in_cell_size, sensor_width-1);
+			sx1 = min(src_x1 * in_cell_size, sensor_width-1);
+			/* calculate distances between source and target
+			   pixels */
+			dx0 = tx - sx0;
+			dx1 = sx1 - tx;
+			divx = sx1 - sx0;
+			/* if we're at the edge, we just use the closest
+			   point still in the grid. We make up for the divider
+			   in this case by setting the distance to
+			   out_cell_size, since it's actually 0. */
+			if (divx == 0) {
+				dx0 = 1;
+				divx = 1;
+			}
+
+			/* get source pixel values */
+			s_ul = in_ptr[(table_width*src_y0)+src_x0];
+			s_ur = in_ptr[(table_width*src_y0)+src_x1];
+			s_ll = in_ptr[(table_width*src_y1)+src_x0];
+			s_lr = in_ptr[(table_width*src_y1)+src_x1];
+
+			*out_ptr = (unsigned short) ((dx0*dy0*s_lr + dx0*dy1*s_ur + dx1*dy0*s_ll + dx1*dy1*s_ul) / (divx*divy));
+		}
+	}
+}
+
+static void
+generate_id_shading_table(struct ia_css_shading_table **target_table,
+			  const struct ia_css_binary *binary)
+{
+	/* initialize table with ones, shift becomes zero */
+	unsigned int i, j, table_width, table_height;
+	struct ia_css_shading_table *result;
+
+	assert(target_table != NULL);
+	assert(binary != NULL);
+
+	table_width  = binary->sctbl_width_per_color;
+	table_height = binary->sctbl_height;
+	result = ia_css_shading_table_alloc(table_width, table_height);
+	if (result == NULL) {
+		*target_table = NULL;
+		return;
+	}
+
+	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
+		for (j = 0; j < table_height * table_width; j++)
+			result->data[i][j] = 1;
+	}
+	result->fraction_bits = 0;
+	*target_table = result;
+}
+
+void
+prepare_shading_table(const struct ia_css_shading_table *in_table,
+		      unsigned int sensor_binning,
+		      struct ia_css_shading_table **target_table,
+		      const struct ia_css_binary *binary)
+{
+	unsigned int input_width,
+		     input_height,
+		     table_width,
+		     table_height,
+		     left_padding,
+		     right_padding,
+		     i;
+	struct ia_css_shading_table *result;
+
+	assert(target_table != NULL);
+	assert(binary != NULL);
+
+	if (!in_table) {
+		generate_id_shading_table(target_table, binary);
+		return;
+	}
+
+	/* We use the ISP input resolution for the shading table because
+	   shading correction is performed in the bayer domain (before bayer
+	   down scaling). */
+	input_height  = binary->in_frame_info.res.height;
+	input_width   = binary->in_frame_info.res.width;
+	left_padding  = binary->left_padding;
+	right_padding = binary->in_frame_info.padded_width -
+			(input_width + left_padding);
+
+	/* We take into account the binning done by the sensor. We do this
+	   by cropping the non-binned part of the shading table and then
+	   increasing the size of a grid cell with this same binning factor. */
+	input_width  <<= sensor_binning;
+	input_height <<= sensor_binning;
+	/* We also scale the padding by the same binning factor. This will
+	   make it much easier later on to calculate the padding of the
+	   shading table. */
+	left_padding  <<= sensor_binning;
+	right_padding <<= sensor_binning;
+
+	/* during simulation, the used resolution can exceed the sensor
+	   resolution, so we clip it. */
+	input_width  = min(input_width,  in_table->sensor_width);
+	input_height = min(input_height, in_table->sensor_height);
+
+	table_width  = binary->sctbl_width_per_color;
+	table_height = binary->sctbl_height;
+
+	result = ia_css_shading_table_alloc(table_width, table_height);
+	if (result == NULL) {
+		*target_table = NULL;
+		return;
+	}
+	result->sensor_width  = in_table->sensor_width;
+	result->sensor_height = in_table->sensor_height;
+	result->fraction_bits = in_table->fraction_bits;
+
+	/* now we crop the original shading table and then interpolate to the
+	   requested resolution and decimation factor. */
+	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
+		crop_and_interpolate(input_width, input_height,
+				     left_padding, right_padding,
+				     in_table,
+				     result, i);
+	}
+	*target_table = result;
+}
+
+struct ia_css_shading_table *
+ia_css_shading_table_alloc(
+	unsigned int width,
+	unsigned int height)
+{
+	unsigned int i;
+	struct ia_css_shading_table *me = sh_css_malloc(sizeof(*me));
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_shading_table_alloc() enter:\n");
+
+	if (me == NULL) {
+		return me;
+	}
+	me->width		 = width;
+	me->height		= height;
+	me->sensor_width  = 0;
+	me->sensor_height = 0;
+	me->fraction_bits = 0;
+	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
+		me->data[i] =
+		    sh_css_malloc(width * height * sizeof(*me->data[0]));
+		if (me->data[i] == NULL) {
+			unsigned int j;
+			for (j = 0; j < i; j++)
+				sh_css_free(me->data[j]);
+			sh_css_free(me);
+			return NULL;
+		}
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_shading_table_alloc() leave:\n");
+
+	return me;
+}
+
+void
+ia_css_shading_table_free(struct ia_css_shading_table *table)
+{
+	unsigned int i;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_shading_table_free() enter:\n");
+
+	if (table == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_shading_table_free() leave:\n");
+		return;
+	}
+
+	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
+		if (table->data[i])
+			sh_css_free(table->data[i]);
+	}
+	sh_css_free(table);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_shading_table_free() leave:\n");
+}
+
diff --git a/drivers/media/atomisp2/css2400/sh_css_param_shading.h b/drivers/media/atomisp2/css2400/sh_css_param_shading.h
new file mode 100644
index 0000000..ab5366a
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_param_shading.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SH_CSS_PARAMS_SHADING_H
+#define __SH_CSS_PARAMS_SHADING_H
+
+#include <ia_css_types.h>
+#include <ia_css_binary.h>
+
+void
+prepare_shading_table(const struct ia_css_shading_table *in_table,
+		      unsigned int sensor_binning,
+		      struct ia_css_shading_table **target_table,
+		      const struct ia_css_binary *binary);
+
+#endif /* __SH_CSS_PARAMS_SHADING_H */
+
diff --git a/drivers/media/atomisp2/css2400/sh_css_params.c b/drivers/media/atomisp2/css2400/sh_css_params.c
new file mode 100644
index 0000000..cf26a68
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_params.c
@@ -0,0 +1,5032 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "gdc_device.h"		/* gdc_lut_store(), ... */
+#include "isp.h"			/* ISP_VEC_ELEMBITS */
+#include "vamem.h"
+#if !defined(HAS_NO_HMEM)
+#ifndef __INLINE_HMEM__
+#define __INLINE_HMEM__
+#endif
+#include "hmem.h"
+#endif /* !defined(HAS_NO_HMEM) */
+#define IA_CSS_INCLUDE_PARAMETERS
+#define IA_CSS_INCLUDE_ACC_PARAMETERS
+
+#include "sh_css_params.h"
+#include "ia_css_queue.h"
+#include "sw_event_global.h"		/* Event IDs */
+
+#include "assert_support.h"
+#include "math_support.h"	/* max(), min()  EVEN_FLOOR()*/
+
+#include "ia_css_stream.h"
+#include "sh_css_params_internal.h"
+#include "sh_css_param_shading.h"
+#include "sh_css_param_dvs.h"
+#include "ia_css_refcount.h"
+#include "sh_css_internal.h"
+#include "sh_css_defs.h"
+#include "sh_css_sp.h"
+#include "ia_css_pipeline.h"
+#include "ia_css_debug.h"
+#include "memory_access.h"
+#include "ia_css_isp_param.h"
+#include "ia_css_isp_params.h"
+#include "ia_css_mipi.h"
+#include "ia_css_morph.h"
+
+/* Include all kernel host interfaces for ISP1 */
+#include "anr/anr_1.0/ia_css_anr.host.h"
+#include "cnr/cnr_1.0/ia_css_cnr.host.h"
+#include "csc/csc_1.0/ia_css_csc.host.h"
+#include "de/de_1.0/ia_css_de.host.h"
+#include "dp/dp_1.0/ia_css_dp.host.h"
+#include "bnr/bnr_1.0/ia_css_bnr.host.h"
+#include "fpn/fpn_1.0/ia_css_fpn.host.h"
+#include "gc/gc_1.0/ia_css_gc.host.h"
+#include "macc/macc_1.0/ia_css_macc.host.h"
+#include "ctc/ctc_1.0/ia_css_ctc.host.h"
+#include "ob/ob_1.0/ia_css_ob.host.h"
+#include "raw/raw_1.0/ia_css_raw.host.h"
+#include "s3a/s3a_1.0/ia_css_s3a.host.h"
+#include "sc/sc_1.0/ia_css_sc.host.h"
+#include "tnr/tnr_1.0/ia_css_tnr.host.h"
+#include "uds/uds_1.0/ia_css_uds.host.h"
+#include "wb/wb_1.0/ia_css_wb.host.h"
+#include "ynr/ynr_1.0/ia_css_ynr.host.h"
+#include "xnr/xnr_1.0/ia_css_xnr.host.h"
+
+/* Include additional kernel host interfaces for ISP2 */
+#include "aa/aa_2/ia_css_aa2.host.h"
+#include "anr/anr_2/ia_css_anr2.host.h"
+#include "bh/bh_2/ia_css_bh.host.h"
+#include "cnr/cnr_2/ia_css_cnr2.host.h"
+#include "de/de_2/ia_css_de2.host.h"
+#include "gc/gc_2/ia_css_gc2.host.h"
+#include "ctc/ctc_2/ia_css_ctc2.host.h"
+#include "ynr/ynr_2/ia_css_ynr2.host.h"
+
+#include "platform_support.h"
+
+#if defined(IS_ISP_2500_SYSTEM)
+#include "product_specific.host.h"
+#include "components/stats_3a/src/stats_3a_private.h"
+#include "components/acc_cluster/acc_lace_stat/lace_stat_private.h"
+#include "components/acc_cluster/acc_lace_stat/host/lace_stat.host.h"
+#include <components/stats_3a/src/host/stats_3a.host.h>
+#include "components_types.host.h"                /* Skylake kernel settings structs */
+#endif
+
+#include "sh_css_frac.h"
+#include "ia_css_bufq.h"
+
+#define FPNTBL_BYTES(binary) \
+	(sizeof(char) * (binary)->in_frame_info.res.height * \
+	 (binary)->in_frame_info.padded_width)
+#define SCTBL_BYTES(binary) \
+	(sizeof(unsigned short) * (binary)->sctbl_height * \
+	 (binary)->sctbl_aligned_width_per_color * IA_CSS_SC_NUM_COLORS)
+#if 0
+#define S3ATBL_BYTES(binary) \
+	(sizeof(struct ia_css_3a_output) * (binary)->s3atbl_isp_width * \
+	 (binary)->s3atbl_isp_height)
+#endif
+/* TODO: check if the stride is always the same max value or whether
+ * it varies per resolution. */
+#if 0
+#define S3ATBL_HI_LO_BYTES(binary) \
+	(ISP_S3ATBL_HI_LO_STRIDE_BYTES * (binary)->s3atbl_isp_height)
+#endif
+/* SDIS */
+#define SDIS_VER_COEF_TBL__IN_DMEM(b) \
+	_SDIS_VER_COEF_TBL_USE_DMEM((b)->info->sp.mode, (b)->info->sp.enable.dis, (b)->info->sp.enable.ds,(b)->info->sp.isp_pipe_version)
+
+#define SH_CSS_DIS_VER_NUM_COEF_TYPES(b) \
+  (((b)->info->sp.isp_pipe_version == 2) ? IA_CSS_DVS2_NUM_COEF_TYPES : \
+	(SDIS_VER_COEF_TBL__IN_DMEM(b) ? \
+		IA_CSS_DVS_COEF_TYPES_ON_DMEM : \
+		IA_CSS_DVS_NUM_COEF_TYPES))
+
+#define SDIS_HOR_COEF_TBL_BYTES(b) \
+	(sizeof(short) * (((b)->info->sp.isp_pipe_version == 2) ? IA_CSS_DVS2_NUM_COEF_TYPES : IA_CSS_DVS_NUM_COEF_TYPES) * (b)->dis_hor_coef_num_isp)
+#define SDIS_VER_COEF_TBL_BYTES(b) \
+	(sizeof(short) * SH_CSS_DIS_VER_NUM_COEF_TYPES(b) * \
+		(b)->dis_ver_coef_num_isp)
+#if 0
+#define SDIS_HOR_PROJ_TBL_BYTES(b) \
+	(sizeof(int)   * IA_CSS_DVS_NUM_COEF_TYPES * (b)->dis_hor_proj_num_isp)
+#define SDIS_VER_PROJ_TBL_BYTES(b) \
+	(sizeof(int)   * IA_CSS_DVS_NUM_COEF_TYPES * (b)->dis_ver_proj_num_isp)
+#endif
+#define MORPH_PLANE_BYTES(binary) \
+	(SH_CSS_MORPH_TABLE_ELEM_BYTES * (binary)->morph_tbl_aligned_width * \
+	 (binary)->morph_tbl_height)
+
+#define PIX_SHIFT_FILTER_RUN_IN_X 12
+#define PIX_SHIFT_FILTER_RUN_IN_Y 12
+
+#if defined(IS_ISP_2500_SYSTEM)
+static struct isp_acc_param sh_css_acc_cluster_parameters;
+#endif
+
+/* We keep a second copy of the ptr struct for the SP to access.
+   Again, this would not be necessary on the chip. */
+static hrt_vaddress sp_ddr_ptrs;
+
+/* sp group address on DDR */
+static hrt_vaddress xmem_sp_group_ptrs;
+
+static hrt_vaddress xmem_sp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
+						[SH_CSS_MAX_STAGES];
+static hrt_vaddress xmem_isp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
+						[SH_CSS_MAX_STAGES];
+
+/* END DO NOT MOVE INTO VIMALS_WORLD */
+
+/* Digital Zoom lookup table. See documentation for more details about the
+ * contents of this table.
+ */
+#if !defined(IS_ISP_2500_SYSTEM)
+#if defined(HAS_GDC_VERSION_2)
+static const int zoom_table[4][HRT_GDC_N] = {
+		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
+		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4},
+		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
+		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
+		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
+		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
+		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
+		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
+		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
+		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
+		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
+		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
+		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
+		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
+		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
+		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
+		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
+		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
+		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
+		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
+		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
+		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
+		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
+		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
+		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
+		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
+		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
+		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
+		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
+		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
+		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
+		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
+		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
+		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
+		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
+		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
+		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
+		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
+		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
+		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
+		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
+		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
+		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
+		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
+		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
+		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
+		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
+		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
+		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
+		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
+		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
+		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
+		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
+		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
+		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
+		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
+		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
+		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
+		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
+		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
+		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
+		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
+		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
+		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
+		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
+		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
+		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
+		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
+		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
+		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
+		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
+		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
+		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
+		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
+		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
+		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
+		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
+		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
+		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
+		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
+		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
+		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
+		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
+		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
+		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
+		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
+		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
+		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
+		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
+		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
+		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
+		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
+		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
+		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
+		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
+		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
+		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
+		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
+		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
+		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
+		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
+		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
+		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
+		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
+		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
+		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
+		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
+		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
+		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
+		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
+		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
+		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
+		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
+		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
+		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
+		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
+		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
+		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
+		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
+		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
+		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
+		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
+		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
+		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+	 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4},
+	{256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4,
+		 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
+		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
+		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
+		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
+		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
+		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
+		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
+		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
+		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
+		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
+		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
+		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
+		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
+		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
+		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
+		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
+		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
+		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
+		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
+		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
+		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
+		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
+		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
+		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
+		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
+		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
+		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
+		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
+		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
+		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
+		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
+		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
+		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
+		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
+		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
+		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
+		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
+		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
+		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
+		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
+		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
+		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
+		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
+		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
+		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
+		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
+		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
+		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
+		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
+		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
+		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
+		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
+		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
+		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
+		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
+		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
+		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
+		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
+		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
+		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
+		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
+		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
+		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
+		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
+		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
+		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
+		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
+		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
+		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
+		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
+		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
+		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
+		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
+		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
+		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
+		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
+		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
+		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
+		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
+		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
+		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
+		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
+		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
+		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
+		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
+		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
+		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
+		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
+		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
+		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
+		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
+		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
+		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
+		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
+		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
+		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
+		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
+		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
+		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
+		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
+		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
+		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
+		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
+		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
+		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
+		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
+		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
+		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
+		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
+		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
+		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
+		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
+		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
+		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
+		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
+		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
+		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
+		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
+		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
+		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
+		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
+		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
+		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4},
+		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
+		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
+	    -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+	    -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+	     -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,
+		  1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
+		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4}
+};
+#else
+#error "sh_css_params.c: GDC version must be \
+	one of {GDC_VERSION_2}"
+#endif
+#endif
+
+static const struct ia_css_dz_config default_dz_config = {
+	HRT_GDC_N,
+	HRT_GDC_N
+};
+
+static const struct ia_css_vector default_motion_config = {
+	0,
+	0
+};
+
+static enum ia_css_err
+ref_sh_css_ddr_address_map(
+		struct sh_css_ddr_address_map *map,
+		struct sh_css_ddr_address_map *out);
+
+static enum ia_css_err
+write_ia_css_isp_parameter_set_info_to_ddr(
+	struct ia_css_isp_parameter_set_info *me,
+	hrt_vaddress *out);
+
+static enum ia_css_err
+free_ia_css_isp_parameter_set_info(hrt_vaddress ptr);
+
+static enum ia_css_err
+sh_css_params_write_to_ddr_internal(
+		unsigned pipe_id,
+		struct ia_css_isp_parameters *params,
+		const struct ia_css_pipeline_stage *stage,
+		struct sh_css_ddr_address_map *ddr_map,
+		struct sh_css_ddr_address_map_size *ddr_map_size);
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+ia_css_set_dvs_coefficients(struct ia_css_isp_parameters *params,
+				const struct ia_css_dvs_coefficients *coefs)
+{
+	if (coefs == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_set_dvs_coefficients() enter: \
+			    hcoef=%p, vcoef=%p",
+			    coefs->hor_coefs, coefs->ver_coefs);
+	params->dis_hor_coef_tbl = coefs->hor_coefs;
+	params->dis_ver_coef_tbl = coefs->ver_coefs;
+	params->dis_coef_table_changed = true;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_set_dvs_coefficients() leave: void\n");
+}
+#endif
+
+void
+ia_css_get_dvs_statistics(struct ia_css_dvs_statistics           *host_stats,
+			  const struct ia_css_isp_dvs_statistics *isp_stats)
+{
+	unsigned int hor_num_isp, ver_num_isp, hor_num_dvs, ver_num_dvs, i;
+	int *hor_ptr_dvs,
+	    *ver_ptr_dvs;
+	hrt_vaddress hor_ptr_isp,
+		     ver_ptr_isp;
+
+	assert(host_stats != NULL);
+	assert(host_stats->hor_proj != NULL);
+	assert(host_stats->ver_proj != NULL);
+	assert(isp_stats != NULL);
+	assert(isp_stats->hor_proj != 0);
+	assert(isp_stats->ver_proj != 0);
+
+	hor_num_isp = host_stats->grid.aligned_height;
+	ver_num_isp = host_stats->grid.aligned_width;
+	hor_ptr_isp = isp_stats->hor_proj;
+	ver_ptr_isp = isp_stats->ver_proj;
+	hor_ptr_dvs = host_stats->hor_proj;
+	ver_ptr_dvs = host_stats->ver_proj;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_get_dvs_statistics() enter: \
+		hproj=%p, vproj=%p, \
+		haddr=%x, vaddr=%x\n",
+		host_stats->hor_proj, host_stats->ver_proj,
+		isp_stats->hor_proj, isp_stats->ver_proj);
+
+	hor_num_dvs = host_stats->grid.height;
+	ver_num_dvs = host_stats->grid.width;
+	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
+		mmgr_load(hor_ptr_isp, hor_ptr_dvs, hor_num_dvs * sizeof(int));
+		hor_ptr_isp += hor_num_isp * sizeof(int);
+		hor_ptr_dvs += hor_num_dvs;
+
+		mmgr_load(ver_ptr_isp, ver_ptr_dvs, ver_num_dvs * sizeof(int));
+		ver_ptr_isp += ver_num_isp * sizeof(int);
+		ver_ptr_dvs += ver_num_dvs;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_get_dvs_statistics() leave: void\n");
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+ia_css_set_dvs2_coefficients(struct ia_css_isp_parameters *params,
+				const struct ia_css_dvs2_coefficients *coefs)
+{
+	if (coefs == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "sh_css_set_dvs2_coefficients() enter: \
+			    hor_coefs.odd_real=%p, hor_coefs.odd_imag=%p\
+			    hor_coefs.even_real=%p, hor_coefs.even_imag=%p\
+			    ver_coefs.odd_real=%p, ver_coefs.odd_imag=%p\
+			    ver_coefs.even_real=%p, ver_coefs.even_imag=%p",
+			    coefs->hor_coefs.odd_real,
+			    coefs->hor_coefs.odd_imag,
+			    coefs->hor_coefs.even_real,
+			    coefs->hor_coefs.even_imag,
+			    coefs->ver_coefs.odd_real,
+			    coefs->ver_coefs.odd_imag,
+			    coefs->ver_coefs.even_real,
+			    coefs->ver_coefs.even_imag);
+
+	params->dvs2_hor_coefs = coefs->hor_coefs;
+	params->dvs2_ver_coefs = coefs->ver_coefs;
+
+	params->dvs2_coef_table_changed = true;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_dvs2_coefficients() leave: void\n");
+}
+#endif
+
+void
+ia_css_get_dvs2_statistics(struct ia_css_dvs2_statistics           *host_stats,
+			  const struct ia_css_isp_dvs_statistics *isp_stats)
+{
+	unsigned int hor_num_isp, ver_num_isp, hor_bytes, ver_bytes;
+	hrt_vaddress hor_ptr_isp, ver_ptr_isp;
+
+	assert(host_stats != NULL);
+	assert(host_stats->hor_prod.odd_real  != NULL);
+	assert(host_stats->hor_prod.odd_imag  != NULL);
+	assert(host_stats->hor_prod.even_real != NULL);
+	assert(host_stats->hor_prod.even_imag != NULL);
+	assert(host_stats->ver_prod.odd_real  != NULL);
+	assert(host_stats->ver_prod.odd_imag  != NULL);
+	assert(host_stats->ver_prod.even_real != NULL);
+	assert(host_stats->ver_prod.even_imag != NULL);
+	assert(isp_stats != NULL);
+	assert(isp_stats->hor_proj != 0);
+	assert(isp_stats->ver_proj != 0);
+
+	hor_num_isp =
+	ver_num_isp = host_stats->grid.aligned_width
+		    * host_stats->grid.aligned_height;
+
+	hor_ptr_isp = isp_stats->hor_proj;
+	ver_ptr_isp = isp_stats->ver_proj;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_get_dvs2_statistics() enter: \
+		hor_coefs.odd_real=%p, hor_coefs.odd_imag=%p\
+		hor_coefs.even_real=%p, hor_coefs.even_imag=%p\
+		ver_coefs.odd_real=%p, ver_coefs.odd_imag=%p\
+		ver_coefs.even_real=%p, ver_coefs.even_imag=%p\
+		haddr=%x, vaddr=%x\n",
+		host_stats->hor_prod.odd_real, host_stats->hor_prod.odd_imag,
+		host_stats->hor_prod.even_real, host_stats->hor_prod.even_imag,
+		host_stats->ver_prod.odd_real, host_stats->ver_prod.odd_imag,
+		host_stats->ver_prod.even_real, host_stats->ver_prod.even_imag,
+		isp_stats->hor_proj, isp_stats->ver_proj);
+
+	hor_bytes = hor_num_isp * sizeof(int);
+	ver_bytes = ver_num_isp * sizeof(int);
+
+	mmgr_load(hor_ptr_isp, host_stats->hor_prod.odd_real, hor_bytes);
+	hor_ptr_isp += hor_bytes;
+	mmgr_load(hor_ptr_isp, host_stats->hor_prod.odd_imag, hor_bytes);
+	hor_ptr_isp += hor_bytes;
+	mmgr_load(hor_ptr_isp, host_stats->hor_prod.even_real, hor_bytes);
+	hor_ptr_isp += hor_bytes;
+	mmgr_load(hor_ptr_isp, host_stats->hor_prod.even_imag, hor_bytes);
+
+	mmgr_load(ver_ptr_isp, host_stats->ver_prod.odd_real, ver_bytes);
+	ver_ptr_isp += ver_bytes;
+	mmgr_load(ver_ptr_isp, host_stats->ver_prod.odd_imag, ver_bytes);
+	ver_ptr_isp += ver_bytes;
+	mmgr_load(ver_ptr_isp, host_stats->ver_prod.even_real, ver_bytes);
+	ver_ptr_isp += ver_bytes;
+	mmgr_load(ver_ptr_isp, host_stats->ver_prod.even_imag, ver_bytes);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"sh_css_get_dvs2_statistics() leave: void\n");
+}
+
+#if !defined(HAS_NO_HMEM) &&  !(defined(SYSTEM_css_skycam_a0t_system) || defined(SYSTEM_css_skycam_c0_system))
+static void get_3a_stats_from_hmem(struct ia_css_3a_statistics *host_stats,
+		hrt_vaddress ddr_ptr) {
+#if defined(IS_ISP_2500_SYSTEM)
+	(void)host_stats;
+	(void)ddr_ptr;
+#else
+	struct ia_css_3a_rgby_output	*out_ptr;
+	int			i;
+
+	/* pixel counts(BQ) for 3A area */
+	int count_for_3a;
+	int sum_r, diff;
+
+	assert(host_stats  != NULL);
+	assert(host_stats->rgby_data != NULL);
+	assert(ddr_ptr != mmgr_NULL);
+
+	count_for_3a = host_stats->grid.width * host_stats->grid.height
+	    * host_stats->grid.bqs_per_grid_cell
+	    * host_stats->grid.bqs_per_grid_cell;
+
+	out_ptr = host_stats->rgby_data;
+
+	ia_css_bh_hmem_decode(out_ptr, ddr_ptr);
+
+/* Calculate sum of histogram of R,
+   which should not be less than count_for_3a */
+	sum_r = 0;
+	for (i = 0; i < HMEM_UNIT_SIZE; i++) {
+		sum_r += out_ptr[i].r;
+	}
+	if (sum_r < count_for_3a) {
+		/* histogram is invalid */
+		return;
+	}
+
+/* Verify for sum of histogram of R/G/B/Y */
+#if 0
+{
+	int sum_g = 0;
+	int sum_b = 0;
+	int sum_y = 0;
+	for (i = 0; i < HMEM_UNIT_SIZE; i++) {
+		sum_g += out_ptr[i].g;
+		sum_b += out_ptr[i].b;
+		sum_y += out_ptr[i].y;
+	}
+	if (sum_g != sum_r || sum_b != sum_r || sum_y != sum_r) {
+		/* histogram is invalid */
+		return;
+	}
+}
+#endif
+
+/*
+ * Limit the histogram area only to 3A area.
+ * In DSP, the histogram of 0 is incremented for pixels
+ * which are outside of 3A area. That amount should be subtracted here.
+ *   hist[0] = hist[0] - ((sum of all hist[]) - (pixel count for 3A area))
+ */
+
+	diff = sum_r - count_for_3a;
+	out_ptr[0].r -= diff;
+	out_ptr[0].g -= diff;
+	out_ptr[0].b -= diff;
+	out_ptr[0].y -= diff;
+
+return;
+#endif
+}
+#endif
+
+#if !(defined(SYSTEM_css_skycam_a0t_system) || defined(SYSTEM_css_skycam_c0_system))
+static void get_3a_stats_from_dmem(struct ia_css_3a_statistics *host_stats,
+		hrt_vaddress ddr_ptr) {
+
+
+	int ddr_width, out_width, out_height, i;
+	struct ia_css_3a_output *out_ptr;
+
+	assert(host_stats != NULL);
+	assert(host_stats->data != NULL);
+	assert(ddr_ptr != mmgr_NULL);
+
+	ddr_width  = host_stats->grid.aligned_width;
+	out_width  = host_stats->grid.width;
+	out_height = host_stats->grid.height;
+	out_ptr    = host_stats->data;
+
+	for (i = 0; i < out_height; i++) {
+		mmgr_load(ddr_ptr, out_ptr, out_width * sizeof(*out_ptr));
+		ddr_ptr += ddr_width * sizeof(*out_ptr);
+		out_ptr += out_width;
+	}
+}
+#endif
+
+/* MW: this is an ISP function */
+STORAGE_CLASS_INLINE int
+merge_hi14bit_lo14bit(unsigned short hi, unsigned short lo)
+{
+	int val = (int) ((((unsigned int) hi << 14) & 0xfffc000) |
+			((unsigned int) lo & 0x3fff));
+	return val;
+}
+
+#if !(defined(SYSTEM_css_skycam_a0t_system) || defined(SYSTEM_css_skycam_c0_system))
+static void get_3a_stats_from_vmem(struct ia_css_3a_statistics *host_stats,
+		hrt_vaddress ddr_ptr_hi, hrt_vaddress ddr_ptr_lo) {
+
+
+	int out_width, out_height, chunk, rest, kmax, y, x, k, elm_start, elm, ofs,
+			bytes;
+	unsigned short *hi, *lo;
+	struct ia_css_3a_output *output;
+	/* struct size > 128 bytes should not be stored on stack (see checkpatch) */
+	static unsigned short s3a_tbl_hi_buf[ISP_S3ATBL_HI_LO_STRIDE *
+				     SH_CSS_MAX_BQ_GRID_HEIGHT],
+		      s3a_tbl_lo_buf[ISP_S3ATBL_HI_LO_STRIDE *
+				     SH_CSS_MAX_BQ_GRID_HEIGHT];
+
+	assert(host_stats!= NULL);
+	assert(host_stats->data != NULL);
+	assert(ddr_ptr_hi != mmgr_NULL);
+	assert(ddr_ptr_lo != mmgr_NULL);
+
+	output = host_stats->data;
+	out_width  = host_stats->grid.width;
+	out_height = host_stats->grid.height;
+	hi = s3a_tbl_hi_buf;
+	lo = s3a_tbl_lo_buf;
+
+	chunk = (ISP_VEC_NELEMS >> host_stats->grid.deci_factor_log2);
+	chunk = max(chunk, 1);
+	bytes = ISP_S3ATBL_HI_LO_STRIDE_BYTES * out_height;
+
+	mmgr_load(ddr_ptr_hi, hi, bytes);
+	mmgr_load(ddr_ptr_lo, lo, bytes);
+
+	for (y = 0; y < out_height; y++) {
+		elm_start = y * ISP_S3ATBL_HI_LO_STRIDE;
+		rest = out_width;
+		x = 0;
+		while (x < out_width) {
+			kmax = (rest > chunk) ? chunk : rest;
+			ofs = y * out_width + x;
+			elm = elm_start + x * sizeof(*output) / sizeof(int);
+			for (k = 0; k < kmax; k++, elm++) {
+				output[ofs + k].ae_y =
+				    merge_hi14bit_lo14bit
+				    (hi[elm], lo[elm]);
+				output[ofs + k].awb_cnt =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk], lo[elm + chunk]);
+				output[ofs + k].awb_gr =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 2],
+				     lo[elm + chunk * 2]);
+				output[ofs + k].awb_r =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 3],
+				     lo[elm + chunk * 3]);
+				output[ofs + k].awb_b =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 4],
+				     lo[elm + chunk * 4]);
+				output[ofs + k].awb_gb =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 5],
+				     lo[elm + chunk * 5]);
+				output[ofs + k].af_hpf1 =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 6],
+				     lo[elm + chunk * 6]);
+				output[ofs + k].af_hpf2 =
+				    merge_hi14bit_lo14bit
+				    (hi[elm + chunk * 7],
+				     lo[elm + chunk * 7]);
+			}
+			x += chunk;
+			rest -= chunk;
+		}
+	}
+}
+#endif
+hrt_vaddress
+sh_css_params_ddr_address_map(void)
+{
+	return sp_ddr_ptrs;
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+/*
+ * @GC:
+ */
+static void
+convert_coords_to_ispparams(
+	hrt_vaddress ddr_addr,
+	const struct ia_css_dvs_6axis_config *config,
+	unsigned int i_stride,
+	unsigned int o_width,
+	unsigned int o_height,
+	unsigned int uv_flag)
+{
+	unsigned int i, j;
+	gdc_warp_param_mem_t s;
+	unsigned int x00, x01, x10, x11,
+		     y00, y01, y10, y11;
+
+	unsigned int xmin, ymin;
+	unsigned int topleft_x, topleft_y,
+		     topleft_x_frac, topleft_y_frac;
+
+	/* number of blocks per height and width */
+	unsigned int num_blocks_y =  (uv_flag ? DVS_NUM_BLOCKS_Y_CHROMA(o_height) : DVS_NUM_BLOCKS_Y(o_height) );
+	unsigned int num_blocks_x =  (uv_flag ? DVS_NUM_BLOCKS_X_CHROMA(o_width)  : DVS_NUM_BLOCKS_X(o_width)  ); // round num_x up to blockdim_x, if it concerns the Y0Y1 block (uv_flag==0) round up to even
+
+
+	unsigned int in_stride = i_stride * DVS_INPUT_BYTES_PER_PIXEL << uv_flag;
+	unsigned width, height;
+	unsigned int *xbuff = NULL;
+	unsigned int *ybuff = NULL;
+
+	assert(config != NULL);
+	assert(ddr_addr != mmgr_NULL);
+
+	ddr_addr += (2* DVS_6AXIS_COORDS_ELEMS * uv_flag); /* format is Y0 Y1 UV, so UV starts at 3rd position */
+
+	if(uv_flag == 0)
+	{
+		xbuff = config->xcoords_y;
+		ybuff = config->ycoords_y;
+		width = config->width_y;
+		height = config->height_y;
+	}
+	else
+	{
+		xbuff = config->xcoords_uv;
+		ybuff = config->ycoords_uv;
+		width = config->width_uv;
+		height = config->height_uv;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "convert_coords_to_ispparams blockdim_x %d blockdim_y %d\n", DVS_BLOCKDIM_X, DVS_BLOCKDIM_Y_LUMA >> uv_flag);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "convert_coords_to_ispparams num_blocks_x %d num_blocks_y %d\n",num_blocks_x,num_blocks_y);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "convert_coords_to_ispparams width %d height %d\n",width,height);
+
+	assert(width == num_blocks_x + 1); // the width and height of the provided morphing table should be 1 more than the number of blocks
+	assert(height == num_blocks_y + 1);
+
+	for (j = 0; j < num_blocks_y; j++) {
+		for (i = 0; i < num_blocks_x; i++) {
+
+			x00 = xbuff[j * width + i];
+			x01 = xbuff[j * width + (i+1)];
+			x10 = xbuff[(j+1) * width + i];
+			x11 = xbuff[(j+1) * width + (i+1)];
+
+			y00 = ybuff[j * width + i];
+			y01 = ybuff[j * width + (i+1)];
+			y10 = ybuff[(j+1) * width + i];
+			y11 = ybuff[(j+1) * width + (i+1)];
+
+			xmin = min(x00, x10);
+			ymin = min(y00, y01);
+
+			/* Assert that right column's X is greater */
+			assert ( x01 >= xmin);
+			assert ( x11 >= xmin);
+			/* Assert that bottom row's Y is greater */
+			assert ( y10 >= ymin);
+			assert ( y11 >= ymin);
+
+#if 0
+			/* TODO: Round width to the multiple of bus width */
+			xmax = max(x01, x11);
+			ymax = max(y10, y11);
+			in_block_width  = xmax - xmin;
+			in_block_height = ymax - ymin;
+#else
+			/*
+			 * For initial testing, we are using constant input
+			 * block size
+			 * */
+			s.in_block_width  = 128;
+			s.in_block_height = 96 >> uv_flag;
+#endif
+
+			topleft_y = ymin >> DVS_COORD_FRAC_BITS;
+			topleft_x = ((xmin >> DVS_COORD_FRAC_BITS)
+					>> XMEM_ALIGN_LOG2)
+					<< (XMEM_ALIGN_LOG2);
+
+			s.in_addr_offset = topleft_y * in_stride + topleft_x;
+
+			topleft_x_frac = topleft_x << (DVS_COORD_FRAC_BITS);
+			topleft_y_frac = topleft_y << (DVS_COORD_FRAC_BITS);
+
+			s.p0_x = x00 - topleft_x_frac;
+			s.p1_x = x01 - topleft_x_frac;
+			s.p2_x = x10 - topleft_x_frac;
+			s.p3_x = x11 - topleft_x_frac;
+
+			s.p0_y = y00 - topleft_y_frac;
+			s.p1_y = y01 - topleft_y_frac;
+			s.p2_y = y10 - topleft_y_frac;
+			s.p3_y = y11 - topleft_y_frac;
+
+			// block should fit within the boundingbox.
+			assert(s.p0_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
+			assert(s.p1_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
+			assert(s.p2_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
+			assert(s.p3_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
+			assert(s.p0_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
+			assert(s.p1_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
+			assert(s.p2_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
+			assert(s.p3_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
+
+			// block size should be greater than zero.
+			assert(s.p0_x < s.p1_x);
+			assert(s.p2_x < s.p3_x);
+			assert(s.p0_y < s.p2_y);
+			assert(s.p1_y < s.p3_y);
+
+#if 0
+			printf("j: %d\ti:%d\n", j, i);
+			printf("offset: %d\n", s.in_addr_offset);
+			printf("p0_x: %d\n", s.p0_x);
+			printf("p0_y: %d\n", s.p0_y);
+			printf("p1_x: %d\n", s.p1_x);
+			printf("p1_y: %d\n", s.p1_y);
+			printf("p2_x: %d\n", s.p2_x);
+			printf("p2_y: %d\n", s.p2_y);
+			printf("p3_x: %d\n", s.p3_x);
+			printf("p3_y: %d\n", s.p3_y);
+
+			printf("p0_x_nofrac[0]: %d\n", s.p0_x>>DVS_COORD_FRAC_BITS);
+			printf("p0_y_nofrac[1]: %d\n", s.p0_y>>DVS_COORD_FRAC_BITS);
+			printf("p1_x_nofrac[2]: %d\n", s.p1_x>>DVS_COORD_FRAC_BITS);
+			printf("p1_y_nofrac[3]: %d\n", s.p1_y>>DVS_COORD_FRAC_BITS);
+			printf("p2_x_nofrac[0]: %d\n", s.p2_x>>DVS_COORD_FRAC_BITS);
+			printf("p2_y_nofrac[1]: %d\n", s.p2_y>>DVS_COORD_FRAC_BITS);
+			printf("p3_x_nofrac[2]: %d\n", s.p3_x>>DVS_COORD_FRAC_BITS);
+			printf("p3_y_nofrac[3]: %d\n", s.p3_y>>DVS_COORD_FRAC_BITS);
+			printf("\n");
+#endif
+
+			/* HMM STORE the struct "s" */
+			mmgr_store(ddr_addr,
+				   (void *)(&s),
+				   sizeof(gdc_warp_param_mem_t));
+
+			// storage format:
+			// Y0 Y1 UV0 Y2 Y3 UV1
+			if (uv_flag)
+				ddr_addr += DVS_6AXIS_COORDS_ELEMS * 3;
+			else
+			    /* increment with 2 incase x is odd, this to
+			       skip the uv position. */
+				ddr_addr += DVS_6AXIS_COORDS_ELEMS * (1 + (i&1));
+		}
+	}
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+store_dvs_6axis_config(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_binary *binary,
+	hrt_vaddress ddr_addr_y)
+{
+	unsigned int i_stride;
+	unsigned int o_width;
+	unsigned int o_height;
+
+	assert(params != NULL);
+	assert(binary != NULL);
+	assert(ddr_addr_y != mmgr_NULL);
+	assert(params->dvs_6axis_config != NULL);
+
+	/* bgz115: replaced binary->in_frame_info.res.width for
+	   'padded_width=stride' */
+	i_stride  = binary->internal_frame_info.padded_width;
+	/* currently we only support two output with the same resolution, output 0 is th default one. */
+	o_width  = binary->out_frame_info[0].res.width;
+	o_height = binary->out_frame_info[0].res.height;
+
+	/* Y plane */
+	convert_coords_to_ispparams(ddr_addr_y, params->dvs_6axis_config,
+				    i_stride, o_width, o_height, 0);
+	/* UV plane (packed inside the y plane) */
+	convert_coords_to_ispparams(ddr_addr_y, params->dvs_6axis_config,
+				    i_stride/2, o_width/2, o_height/2, 1);
+
+
+	params->isp_params_changed = true;
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+/* ****************************************************
+ * Each coefficient is stored as 7bits to fit 2 of them into one
+ * ISP vector element, so we will store 4 coefficents on every
+ * memory word (32bits)
+ *
+ * 0: Coefficient 0 used bits
+ * 1: Coefficient 1 used bits
+ * 2: Coefficient 2 used bits
+ * 3: Coefficient 3 used bit3
+ * x: not used
+ *
+ * xx33333332222222 | xx11111110000000
+ *
+ * ***************************************************
+ */
+static void
+store_fpntbl(struct ia_css_isp_parameters *params, hrt_vaddress ptr)
+{
+	unsigned int i, j;
+	short *data_ptr;
+
+	assert(params != NULL);
+	assert(ptr != mmgr_NULL);
+
+	data_ptr = params->fpn_config.data;
+
+	for (i = 0; i < params->fpn_config.height; i++) {
+		for (j = 0;
+		     j < params->fpn_config.width;
+		     j += 4, ptr += 4, data_ptr += 4) {
+			int data = data_ptr[0] << 0 |
+				   data_ptr[1] << 7 |
+				   data_ptr[2] << 16 |
+				   data_ptr[3] << 23;
+			mmgr_store(ptr, (void *)(&data), sizeof(data));
+		}
+	}
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+convert_raw_to_fpn(struct ia_css_isp_parameters *params)
+{
+	short maxval = 0;
+	unsigned int i;
+
+	assert(params != NULL);
+
+	/* Find the maximum value in the table */
+	for (i = 0; i < params->fpn_config.height * params->fpn_config.width; i++) {
+		short val = params->fpn_config.data[i];
+		/* Make sure FPN value can be represented in 13-bit unsigned
+		 * number (ISP precision - 1), but note that actual input range
+		 * depends on precision of input frame data.
+		 */
+		if (val < 0) {
+/* Checkpatch patch */
+			val = 0;
+		} else if (val >= (1 << 13)) {
+/* Checkpatch patch */
+/* MW: BUG, is "13" a system or application property */
+			val = (1 << 13) - 1;
+		}
+		maxval = max(maxval, val);
+	}
+	/* Find the lowest shift value to remap the values in the range
+	 * 0..maxval to 0..2^shiftval*63.
+	 */
+	params->fpn_config.shift = 0;
+	while (maxval > 63) {
+/* MW: BUG, is "63" a system or application property */
+		maxval /= 2;
+		params->fpn_config.shift++;
+	}
+	/* Adjust the values in the table for the shift value */
+	for (i = 0; i < params->fpn_config.height * params->fpn_config.width; i++)
+		((unsigned short *) params->fpn_config.data)[i] >>= params->fpn_config.shift;
+}
+
+static void
+ia_css_process_kernel(struct ia_css_stream *stream,
+		      struct ia_css_isp_parameters *params,
+		      void (*process)(unsigned pipe_id,
+				      const struct ia_css_pipeline_stage *stage,
+				      struct ia_css_isp_parameters *params))
+{
+	int i;
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		struct ia_css_pipeline *pipeline= ia_css_pipe_get_pipeline(pipe);
+		struct ia_css_pipeline_stage *stage;
+
+		/* update the other buffers to the pipe specific copies */
+		for (stage = pipeline->stages; stage; stage = stage->next) {
+			if (!stage || !stage->binary) continue;
+			process(pipeline->pipe_id, stage, params);
+		}
+	}
+}
+
+#endif
+
+enum ia_css_err
+sh_css_set_black_frame(struct ia_css_stream *stream,
+	const struct ia_css_frame *raw_black_frame)
+{
+	struct ia_css_isp_parameters *params;
+	/* this function desperately needs to be moved to the ISP or SP such
+	 * that it can use the DMA.
+	 */
+	unsigned int height, width, y, x, k, data;
+	hrt_vaddress ptr;
+
+	assert(stream != NULL);
+	assert(raw_black_frame != NULL);
+
+	params = stream->isp_params_configs;
+	height = raw_black_frame->info.res.height;
+	width = raw_black_frame->info.padded_width,
+
+	ptr = raw_black_frame->data
+		+ raw_black_frame->planes.raw.offset;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_black_frame() enter: \
+		black_frame=%p\n",raw_black_frame);
+
+#if defined(IS_ISP_2500_SYSTEM)
+	(void)ptr;
+	(void)data;
+	(void)k;
+	(void)x;
+	(void)y;
+	(void)width;
+	(void)height;
+	(void)params;
+#else
+	if (params->fpn_config.data &&
+	    (params->fpn_config.width != width || params->fpn_config.height != height)) {
+		sh_css_free(params->fpn_config.data);
+		params->fpn_config.data = NULL;
+	}
+	if (params->fpn_config.data == NULL) {
+		params->fpn_config.data = sh_css_malloc(height * width * sizeof(short));
+		if (!params->fpn_config.data) {
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_black_frame() leave: \
+		return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+		params->fpn_config.width = width;
+		params->fpn_config.height = height;
+		params->fpn_config.shift = 0;
+	}
+
+	/* store raw to fpntbl */
+	for (y = 0; y < height; y++) {
+		for (x = 0; x < width; x += (ISP_VEC_NELEMS * 2)) {
+			int ofs = y * width + x;
+			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
+				mmgr_load(ptr, (void *)(&data), sizeof(int));
+				params->fpn_config.data[ofs + 2 * k] =
+				    (short) (data & 0xFFFF);
+				params->fpn_config.data[ofs + 2 * k + 2] =
+				    (short) ((data >> 16) & 0xFFFF);
+				ptr += sizeof(int);	/* byte system address */
+			}
+			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
+				mmgr_load(ptr, (void *)(&data), sizeof(int));
+				params->fpn_config.data[ofs + 2 * k + 1] =
+				    (short) (data & 0xFFFF);
+				params->fpn_config.data[ofs + 2 * k + 3] =
+				    (short) ((data >> 16) & 0xFFFF);
+				ptr += sizeof(int);	/* byte system address */
+			}
+		}
+	}
+
+	/* raw -> fpn */
+	convert_raw_to_fpn(params);
+
+	/* overwrite isp parameter */
+	ia_css_process_kernel(stream, params, ia_css_kernel_process_param[IA_CSS_FPN_ID]);
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_black_frame() leave: \
+		return_err=%d\n",IA_CSS_SUCCESS);
+
+	return IA_CSS_SUCCESS;
+}
+
+bool
+sh_css_params_set_binning_factor(struct ia_css_stream *stream, unsigned int binning_fact)
+{
+	struct ia_css_isp_parameters *params;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_set_binning_factor() enter:\n");
+
+	assert(stream != NULL);
+
+	params = stream->isp_params_configs;
+
+	if (params->sensor_binning != binning_fact) {
+		params->sensor_binning = binning_fact;
+		params->sc_table_changed = true;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_set_binning_factor() leave:\n");
+
+	return params->sc_table_changed;
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_shading_table(struct ia_css_stream *stream,
+			 const struct ia_css_shading_table *table)
+{
+	struct ia_css_isp_parameters *params;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_shading_table() enter:\n");
+
+	if (table == NULL)
+		return;
+	assert(stream != NULL);
+
+	params = stream->isp_params_configs;
+
+	if (!table->enable)
+		table = NULL;
+
+	if (table != params->sc_table) {
+		params->sc_table = table;
+		params->sc_table_changed = true;
+		/* Not very clean, this goes to sh_css.c to invalidate the
+		 * shading table for all pipes. Should replaced by a loop
+		 * and a pipe-specific call.
+		 */
+		sh_css_invalidate_shading_tables(stream);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_shading_table() leave:\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+store_sctbl(
+	    const struct ia_css_pipeline_stage *stage,
+	    hrt_vaddress ddr_addr,
+	    const struct ia_css_shading_table *shading_table)
+{
+	const struct ia_css_binary *binary = stage->binary;
+	unsigned int i, j, aligned_width, row_padding;
+
+	assert(binary != NULL);
+	assert(shading_table != NULL);
+	assert(ddr_addr != mmgr_NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_sctbl() enter:\n");
+
+	if (shading_table == NULL) {
+/* Checkpatch patch */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_sctbl() leave:\n");
+		return;
+	}
+
+	aligned_width = binary->sctbl_aligned_width_per_color;
+	row_padding = aligned_width - shading_table->width;
+
+	for (i = 0; i < shading_table->height; i++) {
+		for (j = 0; j < IA_CSS_SC_NUM_COLORS; j++) {
+			mmgr_store(ddr_addr,
+				   &shading_table->data[j]
+					[i*shading_table->width],
+				   shading_table->width * sizeof(short));
+			ddr_addr += shading_table->width * sizeof(short);
+			mmgr_clear(ddr_addr,
+				   row_padding * sizeof(short));
+			ddr_addr += row_padding * sizeof(short);
+		}
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_sctbl() leave:\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_enable_pipeline(const struct ia_css_binary *binary)
+{
+	if (!binary) return;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_enable_pipeline() enter:\n");
+
+	ia_css_isp_param_enable_pipeline(&binary->mem_params);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_enable_pipeline() leave:\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void ia_css_process_zoom_and_motion(
+	struct ia_css_isp_parameters *params,
+	enum ia_css_pipe_id pipe_id,
+	const struct ia_css_pipeline_stage *first_stage)
+{
+	/* first_stage can be  NULL */
+	const struct ia_css_pipeline_stage *stage;
+
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_zoom_and_motion() enter:\n");
+
+	/* Go through all stages to udate uds and cropping */
+	for (stage = first_stage; stage; stage = stage->next) {
+
+		struct ia_css_binary *binary;
+		struct ia_css_binary tmp_binary;
+
+		const struct ia_css_binary_xinfo *info = NULL;
+
+		binary = stage->binary;
+		if (binary) {
+			info = binary->info;
+		} else {
+			const struct sh_css_binary_args *args = &stage->args;
+			const struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {NULL};
+			if (args->out_frame[0])
+				out_infos[0] = &args->out_frame[0]->info;
+			info = &stage->firmware->info.isp;
+			ia_css_binary_fill_info(info, false, false,
+				IA_CSS_STREAM_FORMAT_RAW_10,
+				args->in_frame  ? &args->in_frame->info  : NULL,
+				NULL,
+				out_infos,
+				args->out_vf_frame ? &args->out_vf_frame->info
+									: NULL,
+				&tmp_binary,
+				NULL,
+				-1, true);
+			binary = &tmp_binary;
+			binary->info = info;
+		}
+
+		assert(stage->stage_num < SH_CSS_MAX_STAGES);
+		sh_css_update_uds_and_crop_info(
+			&info->sp,
+			&binary->in_frame_info,
+			&binary->out_frame_info[0],
+			&binary->dvs_envelope,
+			pipe_id == IA_CSS_PIPE_ID_PREVIEW,
+			&params->dz_config,
+			&params->motion_config,
+			&params->uds[stage->stage_num].uds,
+			&params->uds[stage->stage_num].crop_pos);
+	}
+	params->isp_params_changed = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_zoom_and_motion() leave:\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_gamma_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_gamma_table *table)
+{
+	if (table == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_gamma_table() enter: "
+			    "table=%p\n", table);
+
+	assert(params != NULL);
+	assert(table != NULL);
+
+	params->gc_table = *table;
+	params->config_changed[IA_CSS_GC_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_gamma_table() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_get_gamma_table(const struct ia_css_isp_parameters *params,
+			struct ia_css_gamma_table *table)
+{
+	if (table == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_gamma_table() enter: "
+		"table=%p\n", table);
+
+	*table = params->gc_table;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_gamma_table() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_ctc_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_ctc_table *table)
+{
+	if (table == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_ctc_table() enter: "
+		"table=%p\n", table);
+
+	params->ctc_table = *table;
+	params->config_changed[IA_CSS_CTC_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_ctc_table() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_get_ctc_table(const struct ia_css_isp_parameters *params,
+			struct ia_css_ctc_table *table)
+{
+	if (table == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_ctc_table() enter: "
+		"table=%p\n", table);
+
+	*table = params->ctc_table;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_ctc_table() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_macc_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_macc_table *table)
+{
+	if (table == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_macc_table() enter: "
+		"table=%p\n", table);
+
+	params->macc_table = *table;
+	params->config_changed[IA_CSS_MACC_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_macc_table() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_get_macc_table(const struct ia_css_isp_parameters *params,
+			struct ia_css_macc_table *table)
+{
+	if (table == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_macc_table() enter: "
+		"table=%p\n", table);
+
+	*table = params->macc_table;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_macc_table() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_anr_thres(struct ia_css_isp_parameters *params,
+			const struct ia_css_anr_thres *thres)
+{
+	if (thres == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_anr_thres() enter: "
+		"thres=%p\n",thres);
+
+	params->anr_thres = *thres;
+	params->anr_thres_changed = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_anr_thres() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_get_anr_thres(const struct ia_css_isp_parameters *params,
+			struct ia_css_anr_thres *thres)
+{
+	if (thres == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_anr_thres() enter: "
+		"thres=%p\n",thres);
+
+	*thres = params->anr_thres;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_anr_thres() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+void ia_css_morph_table_free(
+	struct ia_css_morph_table *me)
+{
+	unsigned int i;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_morph_table_free() enter:\n");
+
+	if (me == NULL) {
+		return;
+	}
+
+	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+		if (me->coordinates_x[i])
+			sh_css_free(me->coordinates_x[i]);
+		if (me->coordinates_y[i])
+			sh_css_free(me->coordinates_y[i]);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_morph_table_free() leave:\n");
+
+	sh_css_free(me);
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+struct ia_css_morph_table *ia_css_morph_table_allocate(
+	unsigned int width,
+	unsigned int height)
+{
+	unsigned int i;
+	struct ia_css_morph_table *me = sh_css_malloc(sizeof(*me));
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_morph_table_allocate() enter:\n");
+
+	if (me == NULL) {
+		return me;
+	}
+
+	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+		me->coordinates_x[i] = NULL;
+		me->coordinates_y[i] = NULL;
+	}
+
+	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+		me->coordinates_x[i] =
+		    sh_css_malloc(height * width *
+				  sizeof(*me->coordinates_x[i]));
+		me->coordinates_y[i] =
+		    sh_css_malloc(height * width *
+				  sizeof(*me->coordinates_y[i]));
+
+		if ((me->coordinates_x[i] == NULL) ||
+			(me->coordinates_y[i] == NULL)) {
+			ia_css_morph_table_free(me);
+			me = NULL;
+			return me;
+		}
+	}
+	me->width = width;
+	me->height = height;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_morph_table_allocate() leave:\n");
+
+	return me;
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static enum ia_css_err sh_css_params_default_morph_table(
+	struct ia_css_morph_table **table,
+	const struct ia_css_binary *binary)
+{
+/* MW 2400 advanced requires different scaling */
+	unsigned int i, j, k, step, width, height;
+	short start_x[IA_CSS_MORPH_TABLE_NUM_PLANES] = { -8, 0, -8, 0, 0, -8 },
+	      start_y[IA_CSS_MORPH_TABLE_NUM_PLANES] = { 0, 0, -8, -8, -8, 0 };
+	struct ia_css_morph_table *tab;
+
+	assert(table != NULL);
+	assert(binary != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_params_default_morph_table() enter:\n");
+
+	step = (ISP_VEC_NELEMS / 16) * 128,
+	width = binary->morph_tbl_width,
+	height = binary->morph_tbl_height;
+
+	tab = ia_css_morph_table_allocate(width, height);
+	if (tab == NULL) {
+
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+
+	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+		short val_y = start_y[i];
+		for (j = 0; j < height; j++) {
+			short val_x = start_x[i];
+			unsigned short *x_ptr, *y_ptr;
+
+			x_ptr = &tab->coordinates_x[i][j * width];
+			y_ptr = &tab->coordinates_y[i][j * width];
+			for (k = 0; k < width;
+			     k++, x_ptr++, y_ptr++, val_x += (short)step) {
+				if (k == 0)
+					*x_ptr = 0;
+				else if (k == width - 1)
+					*x_ptr = val_x + 2 * start_x[i];
+				else
+					*x_ptr = val_x;
+				if (j == 0)
+					*y_ptr = 0;
+				else
+					*y_ptr = val_y;
+			}
+			val_y += (short)step;
+		}
+	}
+	*table = tab;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_params_default_morph_table() leave:\n");
+
+	return IA_CSS_SUCCESS;
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_morph_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_morph_table *table)
+{
+	if (table == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_morph_table() enter: "
+		"table=%p\n", table);
+
+	if (table->enable == false)
+		table = NULL;
+	params->morph_table = table;
+	params->morph_table_changed = true;
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_morph_table() leave: "
+		"return_void\n");
+}
+#if 0
+/* TODO: connect this properly. The table would have to be copied
+ * out.
+ * */
+static void
+sh_css_get_morph_table(struct ia_css_isp_parameters *params,
+			const struct ia_css_morph_table **table)
+{
+	if (table == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_morph_table() enter: "
+		"table=%p\n", table);
+
+	*table = params->morph_table;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_morph_table() leave: "
+		"return_void\n");
+}
+#endif
+#endif
+
+
+#if defined(IS_ISP_2500_SYSTEM)
+void
+ia_css_get_4a_statistics(struct ia_css_4a_statistics *host_stats,
+		const struct ia_css_isp_3a_statistics *isp_stats)
+{
+	int i , num_sets,size_of_set,index=0;
+
+	struct ia_css_4a_private_config stats_config;
+	struct stats_3a_bubble_info_per_stripe stats_bubble_info;
+
+	hrt_vaddress af_ddr_addr = (hrt_vaddress)(long int)&(((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->af_raw_buffer);
+	hrt_vaddress awb_ddr_addr = (hrt_vaddress)(long int)&((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->awb_raw_buffer;
+	hrt_vaddress ae_ddr_addr = (hrt_vaddress)(long int)&((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->ae_raw_buffer;
+	hrt_vaddress awb_fr_ddr_addr = (hrt_vaddress)(long int)&((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->awb_fr_raw_buffer;
+
+	hrt_vaddress stats_bubble_info_addr = (hrt_vaddress)(long int)
+	  &((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->stats_3a_bubble_per_stripe;
+
+	hrt_vaddress stats_config_addr = (hrt_vaddress)(long int)
+	  &((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->stats_4a_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_get_4a_statistics() enter: "
+			"host_stats=%p, isp_stats=%p\n",
+			host_stats, isp_stats);
+
+	/* load meta data */
+	mmgr_load(af_ddr_addr,
+		  (void*)&(host_stats->data->af_raw_buffer),
+		  sizeof(af_public_raw_buffer_t));
+	mmgr_load(awb_ddr_addr,
+		  (void*)&(host_stats->data->awb_raw_buffer),
+		  sizeof(awb_public_raw_buffer_t));
+	mmgr_load(ae_ddr_addr,
+		  (void*)&(host_stats->data->ae_raw_buffer),
+		  sizeof(ae_public_raw_buffer_t));
+	mmgr_load(awb_fr_ddr_addr,
+			  (void*)&(host_stats->data->awb_fr_raw_buffer),
+		  sizeof(awb_fr_public_raw_buffer_t));
+
+
+	/* load grid configuration */
+
+	mmgr_load(stats_config_addr,
+		  (void*)&(stats_config),
+		  sizeof(struct  ia_css_4a_private_config));
+
+	/* load bubble info */
+	mmgr_load(stats_bubble_info_addr,
+		  (void*)&(stats_bubble_info),
+		  sizeof(struct stats_3a_bubble_info_per_stripe ));
+
+	ia_css_3a_grid_config_ddr_decode(host_stats->stats_4a_config, &stats_config);
+
+	/* decode must be prior to debubbling! */
+	ia_css_3a_debubble(host_stats->data,
+			   &stats_bubble_info);
+
+	/* Debubble -  removes bubbles between sets of statistics for AWB, AWB_FR, AF caused by the ACC */
+		/**** AF ****/
+
+		if(host_stats->stats_4a_config->af_grd_config.grid_width) //Avoid division with 0
+		{
+			if(MAX_SIZE_OF_SET_AF % host_stats->stats_4a_config->af_grd_config.grid_width)
+			{
+				size_of_set = index =  (MAX_SIZE_OF_SET_AF / host_stats->stats_4a_config->af_grd_config.grid_width)* host_stats->stats_4a_config->af_grd_config.grid_width; //This removes the remainder
+				num_sets = (host_stats->stats_4a_config->af_grd_config.grid_width * host_stats->stats_4a_config->af_grd_config.grid_height) / size_of_set;
+				for(i=0; i < num_sets;i++)
+				{
+					memcpy((void *)&host_stats->data->af_raw_buffer.y_table[index],(void *)&host_stats->data->af_raw_buffer.y_table[(i+1)*MAX_SIZE_OF_SET_AF],sizeof(af_public_y_item_t)*size_of_set);
+					index += size_of_set;
+				}
+			}
+		}
+
+		/**** AWB_FR ****/
+
+		if(host_stats->stats_4a_config->awb_fr_grd_config.grid_width) //Avoid division with 0
+		{
+			if(MAX_SIZE_OF_SET_AWB_FR % host_stats->stats_4a_config->awb_fr_grd_config.grid_width)
+			{
+
+				size_of_set = index =  (MAX_SIZE_OF_SET_AWB_FR / host_stats->stats_4a_config->awb_fr_grd_config.grid_width) * host_stats->stats_4a_config->awb_fr_grd_config.grid_width; //This removes the remainder
+				num_sets = (host_stats->stats_4a_config->awb_fr_grd_config.grid_width * host_stats->stats_4a_config->awb_fr_grd_config.grid_height) / size_of_set;
+				for(i=0; i < num_sets;i++)
+				{
+					memcpy((void*)&host_stats->data->awb_fr_raw_buffer.bayer_table[index],(void *)&host_stats->data->awb_fr_raw_buffer.bayer_table[(i+1)*MAX_SIZE_OF_SET_AWB_FR],sizeof(awb_fr_public_bayer_item_t)*size_of_set);
+					index += size_of_set;
+				}
+
+			}
+		}
+
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_get_4a_statistics() leave: return_void\n");
+
+
+}
+
+void ia_css_get_lace_statistics(struct ia_css_lace_statistics *host_stats,
+				const ia_css_ptr isp_stats)
+{
+	lace_stat_private_cfg_t lace_stat_cfg;
+	hrt_vaddress lace_stat_ddr_addr;
+	hrt_vaddress lace_stat_cfg_ddr_addr;
+	unsigned int hist_size;
+
+
+	lace_stat_ddr_addr =
+		(hrt_vaddress)&(((lace_stat_private_raw_buffer_t*)
+			isp_stats)->lace_hist_vec);
+	lace_stat_cfg_ddr_addr =
+		(hrt_vaddress)&((lace_stat_private_raw_buffer_t*)
+			isp_stats)->lace_stat_cfg;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_get_acc_lace_statistics() enter: "
+			"host_stats=%p, isp_stats=%p\n",
+			host_stats, isp_stats);
+
+	/* Load configuration */
+	mmgr_load(lace_stat_cfg_ddr_addr,
+			(void*)&(lace_stat_cfg),
+			sizeof(lace_stat_private_cfg_t));
+
+	/* Translate between private and public configuration */
+	acc_lace_stat_private_to_public(&lace_stat_cfg,
+					&host_stats->lace_stat_cfg.lace_stat);
+
+	hist_size = host_stats->lace_stat_cfg.lace_stat.grd_vrt_cfg.grid_h *
+			host_stats->lace_stat_cfg.lace_stat.y_grd_hor_cfg.grid_width *
+			ACC_LACE_STAT_NUM_OF_BINS_PER_BLOCK;
+	host_stats->lace_stat_hist_p = (unsigned char*)malloc(hist_size);
+	if(host_stats->lace_stat_hist_p == NULL)
+	{
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_get_acc_lace_statistics() malloc error\n");
+		return;
+	}
+
+	mmgr_load(lace_stat_ddr_addr,
+		  (void*)host_stats->lace_stat_hist_p,
+		  hist_size);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_get_acc_lace_statistics() leave: return_void\n");
+}
+
+#endif
+
+#if !(defined(SYSTEM_css_skycam_a0t_system) || defined(SYSTEM_css_skycam_c0_system))
+void
+ia_css_get_3a_statistics(struct ia_css_3a_statistics           *host_stats,
+			 const struct ia_css_isp_3a_statistics *isp_stats)
+{
+	assert(host_stats != NULL);
+	assert(isp_stats != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_get_3a_statistics() enter: "
+		"host_stats=%p, isp_stats=%p\n",
+		host_stats, isp_stats);
+
+	if (host_stats->grid.use_dmem) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "3A: DMEM\n");
+		get_3a_stats_from_dmem(host_stats,
+				       isp_stats->data.dmem.s3a_tbl);
+	} else {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "3A: VMEM\n");
+		get_3a_stats_from_vmem(host_stats,
+				       isp_stats->data.vmem.s3a_tbl_hi,
+				       isp_stats->data.vmem.s3a_tbl_lo);
+	}
+#if !defined(HAS_NO_HMEM) && !(defined(SYSTEM_css_skycam_a0t_system) || defined(SYSTEM_css_skycam_c0_system))
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "3A: HMEM\n");
+	get_3a_stats_from_hmem(host_stats,
+			       isp_stats->data_hmem.rgby_tbl);
+#endif
+
+#if 0
+	/* The code below is written to dump the host_stats.
+	 * It is not intended to be used in daily operation
+	 * but it might be useful to debug problems so it is
+	 * proposed to leave it in
+	 */
+	{
+		int w, h;
+		int width = host_stats->grid.width;
+		int height = host_stats->grid.height;
+
+		for (h = 0; h < height; h++)
+		{
+			for (w = 0; w < width; w++)
+			{
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "3A: (%2d,%2d) %10d %10d %10d %10d %10d\n",
+						h, w,
+						host_stats->data[h*width + w].awb_r,
+						host_stats->data[h*width + w].awb_gr,
+						host_stats->data[h*width + w].awb_gb,
+						host_stats->data[h*width + w].awb_b,
+						host_stats->data[h*width + w].awb_cnt);
+			}
+		}
+	}
+#endif
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_get_3a_statistics() leave: return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+/* Parameter encoding is not yet orthogonal.
+   This function hnadles some of the exceptions.
+*/
+static void
+ia_css_set_param_exceptions(struct ia_css_isp_parameters *params)
+{
+	assert (params != NULL);
+
+	/* Copy also to DP. Should be done by the driver. */
+	params->dp_config.gr = params->wb_config.gr;
+	params->dp_config.r  = params->wb_config.r;
+	params->dp_config.b  = params->wb_config.b;
+	params->dp_config.gb = params->wb_config.gb;
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_nr_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_nr_config *config)
+{
+	if (config == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_nr_config() enter: ");
+	ia_css_nr_debug_dtrace(config, IA_CSS_DEBUG_TRACE_PRIVATE);
+	params->nr_config = *config;
+	params->yee_config.nr = *config;
+	params->config_changed[IA_CSS_NR_ID]  = true;
+	params->config_changed[IA_CSS_YEE_ID] = true;
+	params->config_changed[IA_CSS_BNR_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_set_nr_config() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_ee_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_ee_config *config)
+{
+	if (config == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_ee_config() enter: ");
+	ia_css_ee_debug_dtrace(config, IA_CSS_DEBUG_TRACE_PRIVATE);
+	params->ee_config = *config;
+	params->yee_config.ee = *config;
+	params->config_changed[IA_CSS_YEE_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_set_ee_config() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_get_ee_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_ee_config *config)
+{
+	if (config == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_ee_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->ee_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_ee_config() enter: ");
+	ia_css_ee_debug_dtrace(config, IA_CSS_DEBUG_TRACE_PRIVATE);
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_dvs_6axis_config(struct ia_css_isp_parameters *params,
+			   const struct ia_css_dvs_6axis_config  *dvs_config)
+{
+	if (dvs_config == NULL)
+		return;
+	assert(params != NULL);
+	assert(dvs_config->height_y == dvs_config->height_uv);
+	assert( (dvs_config->width_y - 1) == 2 * (dvs_config->width_uv - 1));
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_dvs_config() enter: "
+	"dvs_config=%p\n",dvs_config);
+
+	copy_dvs_6axis_table(params->dvs_6axis_config,dvs_config);
+
+	params->dvs_6axis_config_changed = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_set_dvs_6axis_config() leave: "
+		"return_void\n");
+
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_get_dvs_6axis_config(const struct ia_css_isp_parameters *params,
+				struct ia_css_dvs_6axis_config *dvs_config)
+{
+	if (dvs_config == NULL)
+		return;
+	assert(params != NULL);
+	assert(dvs_config->height_y == dvs_config->height_uv);
+	assert( (dvs_config->width_y - 1) == 2 * dvs_config->width_uv - 1);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_dvs_6axis_config() enter: "
+		"dvs_config=%p\n",dvs_config);
+
+	if ((dvs_config->width_y == params->dvs_6axis_config->width_y) &&
+	    (dvs_config->height_y == params->dvs_6axis_config->height_y) &&
+	    (dvs_config->width_uv == params->dvs_6axis_config->width_uv) &&
+	    (dvs_config->height_uv == params->dvs_6axis_config->height_uv) &&
+	     dvs_config->xcoords_y &&
+	     dvs_config->ycoords_y &&
+	     dvs_config->xcoords_uv &&
+	     dvs_config->ycoords_uv)
+	{
+		copy_dvs_6axis_table(dvs_config,params->dvs_6axis_config);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_get_dvs_6axis_config() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_baa_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_aa_config *config)
+{
+	if (config == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_baa_config() enter: ");
+	ia_css_aa_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+
+	params->raw_config = *config;
+	params->config_changed[IA_CSS_RAW_ID] = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_set_baa_config() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_get_baa_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_aa_config *config)
+{
+	if (config == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_get_baa_config() enter: "
+		"config=%p\n",config);
+
+	*config = params->raw_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_get_baa_config() leave: ");
+	ia_css_aa_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_dz_config(struct ia_css_isp_parameters *params,
+			const struct ia_css_dz_config *config)
+{
+	if (config == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_set_zoom_factor() enter: dx=%d, dy=%d\n",
+		config->dx, config->dy);
+
+	assert(config->dx <= HRT_GDC_N);
+	assert(config->dy <= HRT_GDC_N);
+
+	params->dz_config = *config;
+	params->dz_config_changed = true;
+	/* JK: Why isp params changed?? */
+	params->isp_params_changed = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_set_zoom_factor() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_get_dz_config(const struct ia_css_isp_parameters *params,
+			struct ia_css_dz_config *config)
+{
+	if (config == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_dz_config() enter:\n");
+
+	*config = params->dz_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_get_dz_config() leave: dx=%d, dy=%d\n",
+		config->dx, config->dy);
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_set_motion_vector(struct ia_css_isp_parameters *params,
+			const struct ia_css_vector *motion)
+{
+	if (motion == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_set_motion_vector() enter: x=%d, y=%d\n",
+		motion->x, motion->y);
+
+	params->motion_config = *motion;
+	/* JK: Why do isp params change? */
+	params->motion_config_changed = true;
+	params->isp_params_changed = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_set_motion_vector() leave: "
+		"return_void\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+sh_css_get_motion_vector(const struct ia_css_isp_parameters *params,
+			struct ia_css_vector *motion)
+{
+	if (motion == NULL)
+		return;
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_motion_vector() enter\n");
+
+	*motion = params->motion_config;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_get_motion_vector() leave: x=%d, y=%d\n",
+		motion->x, motion->y);
+}
+#endif
+
+enum ia_css_err
+ia_css_stream_set_isp_config(
+	struct ia_css_stream *stream,
+	const struct ia_css_isp_config *config)
+{
+	return ia_css_stream_set_isp_config_on_pipe(stream, config, NULL);
+}
+
+enum ia_css_err
+ia_css_stream_set_isp_config_on_pipe(
+	struct ia_css_stream *stream,
+	const struct ia_css_isp_config *config,
+	struct ia_css_pipe *pipe)
+{
+	struct ia_css_isp_parameters *params;
+
+	if ((stream == NULL) || (config == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	params = stream->isp_params_configs;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_set_isp_config_on_pipe() enter: "
+		"stream=%p, config=%p, pipe=%p\n", stream, config, pipe);
+
+#if !defined(IS_ISP_2500_SYSTEM)
+	sh_css_set_nr_config(params, config->nr_config);
+	sh_css_set_ee_config(params, config->ee_config);
+	sh_css_set_baa_config(params, config->baa_config);
+	sh_css_set_dvs_6axis_config(params, config->dvs_6axis_config);
+	sh_css_set_dz_config(params, config->dz_config);
+	sh_css_set_motion_vector(params, config->motion_vector);
+	sh_css_set_shading_table(stream, config->shading_table);
+	sh_css_set_morph_table(params, config->morph_table);
+	sh_css_set_macc_table(params, config->macc_table);
+	sh_css_set_gamma_table(params, config->gamma_table);
+	sh_css_set_ctc_table(params, config->ctc_table);
+	ia_css_set_dvs_coefficients(params, config->dvs_coefs);
+	ia_css_set_dvs2_coefficients(params, config->dvs2_coefs);
+
+	ia_css_set_configs(params, config);
+
+	params->output_frame = config->output_frame;
+	params->isp_parameters_id = config->isp_config_id;
+
+	ia_css_set_param_exceptions(params);
+	/*
+	   if (config->_config)
+	   ia_css_set_xnr_config(config->xnr_config);
+	*/
+#else /* defined(IS_ISP_2500_SYSTEM) */
+	(void)params;
+	sh_css_set_config_product_specific(config);
+#endif
+
+	/* Now commit all changes to the SP */
+	sh_css_param_update_isp_params(stream, sh_css_sp_is_running(), pipe);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_set_isp_config_on_pipe() leave: \n");
+
+	return IA_CSS_SUCCESS;
+}
+
+/* TODO: make a direct implementation and remove the partial ones */
+void
+ia_css_stream_get_isp_config(
+	const struct ia_css_stream *stream,
+	struct ia_css_isp_config *config)
+{
+	struct ia_css_isp_parameters *params = NULL;
+
+	assert(config != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_get_isp_config() enter: "
+		"config=%p\n", config);
+
+#if defined(IS_ISP_2500_SYSTEM)
+	(void) stream;
+	(void) params;
+
+	sh_css_get_config_product_specific(config);
+
+#else
+	params = stream->isp_params_configs;
+	assert(params != NULL);
+
+	sh_css_get_ee_config(params, config->ee_config);
+	sh_css_get_baa_config(params, config->baa_config);
+	sh_css_get_dvs_6axis_config(params, config->dvs_6axis_config);
+	sh_css_get_macc_table(params, config->macc_table);
+	sh_css_get_gamma_table(params, config->gamma_table);
+	sh_css_get_ctc_table(params, config->ctc_table);
+	sh_css_get_dz_config(params, config->dz_config);
+	sh_css_get_motion_vector(params, config->motion_vector);
+	sh_css_get_anr_thres(params, config->anr_thres);
+
+	ia_css_get_configs(params, config);
+
+	config->output_frame = params->output_frame;
+	config->isp_config_id = params->isp_parameters_id;
+#endif
+
+/*
+	if (config->xnr_config != NULL)
+		ia_css_get_xnr_config(config->xnr_config);
+*/
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_get_isp_config() leave: "
+		"return_void\n");
+}
+
+/*
+ * coding style says the return of "mmgr_NULL" is the error signal
+ *
+ * Deprecated: Implement mmgr_realloc()
+ */
+static bool realloc_isp_css_mm_buf(
+/* STORAGE_CLASS_INLINE bool realloc_isp_css_mm_buf( */
+	hrt_vaddress *curr_buf, size_t *curr_size,
+	size_t needed_size, bool force, enum ia_css_err *err,
+	uint16_t	mmgr_attribute)
+{
+	int32_t id;
+	*err = IA_CSS_SUCCESS;
+	/* Possible optimization: add a function sh_css_isp_css_mm_realloc()
+	 * and implement on top of hmm. */
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() enter:\n");
+
+	if (!force && *curr_size >= needed_size) {
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
+		return false;
+	}
+	/* don't reallocate if single ref to buffer and same size */
+	if (*curr_size == needed_size && ia_css_refcount_is_single(*curr_buf)) {
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
+		return false;
+	}
+
+	id = IA_CSS_REFCOUNT_PARAM_BUFFER;
+	ia_css_refcount_decrement(id, *curr_buf);
+	*curr_buf = ia_css_refcount_increment(id, mmgr_alloc_attr(needed_size,
+							mmgr_attribute));
+
+	if (!*curr_buf) {
+		*err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		*curr_size = 0;
+	} else {
+		*curr_size = needed_size;
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
+	return true;
+}
+
+static bool reallocate_buffer(
+/* STORAGE_CLASS_INLINE bool reallocate_buffer( */
+	hrt_vaddress *curr_buf,
+	size_t *curr_size,
+	size_t needed_size,
+	bool force,
+	enum ia_css_err *err)
+{
+	bool ret;
+	uint16_t	mmgr_attribute = MMGR_ATTRIBUTE_DEFAULT;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "reallocate_buffer() enter:\n");
+
+	ret = realloc_isp_css_mm_buf(curr_buf,
+		curr_size, needed_size, force, err, mmgr_attribute);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "reallocate_buffer() leave:\n");
+	return ret;
+}
+
+#if 0
+static bool reallocate_cached_buffer(
+/* STORAGE_CLASS_INLINE bool reallocate_cached_buffer( */
+	hrt_vaddress *curr_buf,
+	size_t *curr_size,
+	size_t needed_size,
+	enum ia_css_err *err)
+{
+	bool ret;
+	uint16_t	mmgr_attribute = MMGR_ATTRIBUTE_DEFAULT |
+		MMGR_ATTRIBUTE_CACHED;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "reallocate_cached_buffer() enter:\n");
+
+	ret = realloc_isp_css_mm_buf(curr_buf,
+		curr_size, needed_size, false, err, mmgr_attribute);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "reallocate_cached_buffer() leave:\n");
+
+	return ret;
+}
+#endif
+
+struct ia_css_isp_3a_statistics *
+ia_css_isp_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
+{
+	struct ia_css_isp_3a_statistics *me;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_3a_statistics_allocate() enter: grid=%p\n",grid);
+
+/* MW: Does "grid->enable" also control the histogram output ?? */
+#if !defined(IS_ISP_2500_SYSTEM)
+	assert(grid != NULL);
+	if (!grid->enable)
+		return NULL;
+#endif
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+#if !defined(IS_ISP_2500_SYSTEM)
+
+	if (grid->use_dmem) {
+		int s3a_table_size = sizeof(struct ia_css_3a_output) *
+					grid->aligned_width *
+					grid->aligned_height;
+		me->data.dmem.s3a_tbl = mmgr_malloc(s3a_table_size);
+		if (me->data.dmem.s3a_tbl == mmgr_NULL)
+			goto err;
+	} else {
+		int s3a_table_size = ISP_S3ATBL_HI_LO_STRIDE_BYTES *
+					grid->aligned_height;
+		me->data.vmem.s3a_tbl_hi = mmgr_malloc(s3a_table_size);
+		if (me->data.vmem.s3a_tbl_hi == mmgr_NULL)
+			goto err;
+		me->data.vmem.s3a_tbl_lo = mmgr_malloc(s3a_table_size);
+		if (me->data.vmem.s3a_tbl_lo == mmgr_NULL)
+			goto err;
+	}
+	#if !defined(HAS_NO_HMEM)
+		if ((me->data_hmem.rgby_tbl = mmgr_malloc(sizeof_hmem(HMEM0_ID))) == mmgr_NULL)
+			goto err;
+	#else
+		me->data_hmem.rgby_tbl = mmgr_NULL;
+	#endif
+
+#else //For SKC we don't use any of  above modes but we can use same pointer + buf size is different
+	me->data.dmem.s3a_tbl = mmgr_malloc(sizeof(struct stats_4a_private_raw_buffer));
+	me->data_hmem.rgby_tbl = mmgr_NULL;
+#endif
+
+
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_3a_statistics_allocate() leave: return=%p\n",me);
+
+	return me;
+
+err:
+	ia_css_isp_3a_statistics_free(me);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_3a_statistics_allocate() leave: return=%p\n",NULL);
+
+	return NULL;
+}
+
+void
+ia_css_isp_3a_statistics_free(struct ia_css_isp_3a_statistics *me)
+{
+	if (me != NULL) {
+/* mmgr_free() accepts (mmgr_)NULL, but the pointer are in a union, don't free twice */
+		mmgr_free(me->data.dmem.s3a_tbl);
+		me->data.dmem.s3a_tbl = mmgr_NULL;
+		mmgr_free(me->data.vmem.s3a_tbl_hi);
+		me->data.vmem.s3a_tbl_hi = mmgr_NULL;
+		mmgr_free(me->data.vmem.s3a_tbl_lo);
+		me->data.vmem.s3a_tbl_lo = mmgr_NULL;
+#if !defined(HAS_NO_HMEM)
+		mmgr_free(me->data_hmem.rgby_tbl);
+		me->data_hmem.rgby_tbl = mmgr_NULL;
+#endif
+		sh_css_free(me);
+	}
+}
+
+
+void
+ia_css_lace_statistics_free(ia_css_ptr me)
+{
+	if (me != 0) {
+		mmgr_free(me);
+		me = mmgr_NULL;
+	}
+}
+
+ia_css_ptr ia_css_lace_statistics_allocate(void)
+{
+#if defined(IS_ISP_2500_SYSTEM)
+	ia_css_ptr me = 0;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_lace_statistics_allocate() enter\n");
+
+	me = mmgr_malloc(sizeof(lace_stat_private_raw_buffer_t));
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_lace_statistics_allocate() leave: return=%p\n",NULL);
+	return me;
+#endif
+	return 0;
+}
+
+struct ia_css_isp_dvs_statistics *
+ia_css_isp_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_isp_dvs_statistics *me;
+	int hor_size, ver_size;
+
+	assert(grid != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs_statistics_allocate() enter: grid=%p\n",grid);
+
+	if (!grid->enable)
+		return NULL;
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	hor_size =
+		sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES * grid->aligned_height;
+	ver_size =
+		sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES * grid->aligned_width;
+
+	me->hor_size = hor_size;
+	me->hor_proj = mmgr_malloc(hor_size);
+	if (me->hor_proj == mmgr_NULL)
+		goto err;
+	me->ver_size = ver_size;
+	me->ver_proj = mmgr_malloc(ver_size);
+	if (me->ver_proj == mmgr_NULL)
+		goto err;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs_statistics_allocate() leave: return=%p\n",me);
+
+	return me;
+err:
+	ia_css_isp_dvs_statistics_free(me);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs_statistics_allocate() leave: return=%p\n",NULL);
+
+	return NULL;
+}
+
+void
+ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me)
+{
+	if (me != NULL) {
+		mmgr_free(me->hor_proj);
+		mmgr_free(me->ver_proj);
+		sh_css_free(me);
+	}
+}
+
+
+struct ia_css_isp_dvs_statistics *
+ia_css_isp_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_isp_dvs_statistics *me;
+	int hor_size, ver_size;
+
+	assert(grid != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs2_statistics_allocate() enter: grid=%p\n",grid);
+
+	if (!grid->enable)
+		return NULL;
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	hor_size =
+	ver_size = sizeof(int) * IA_CSS_DVS2_NUM_COEF_TYPES
+		* grid->aligned_width * grid->aligned_height;
+
+	me->hor_size = hor_size;
+	me->hor_proj = mmgr_malloc(hor_size);
+	if (me->hor_proj == mmgr_NULL)
+		goto err;
+	me->ver_size = ver_size;
+	me->ver_proj = mmgr_malloc(ver_size);
+	if (me->ver_proj == mmgr_NULL)
+		goto err;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs2_statistics_allocate() leave: return=%p\n",me);
+
+	return me;
+err:
+	ia_css_isp_dvs2_statistics_free(me);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs2_statistics_allocate() leave: return=%p\n",NULL);
+
+	return NULL;
+}
+
+void
+ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me)
+{
+	if (me != NULL) {
+		mmgr_free(me->hor_proj);
+		mmgr_free(me->ver_proj);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_metadata *
+ia_css_metadata_allocate(const struct ia_css_metadata_info *metadata_info)
+{
+	struct ia_css_metadata *md = NULL;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_metadata_allocate() enter\n");
+
+	if (metadata_info->size == 0)
+		return NULL;
+
+	md = sh_css_malloc(sizeof(*md));
+	if (md == NULL)
+		goto error;
+
+	md->info = *metadata_info;
+	md->exp_id = 0;
+	md->address = mmgr_malloc(metadata_info->size);
+	if (md->address == mmgr_NULL)
+		goto error;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_metadata_allocate() leave: return=%p\n", md);
+	return md;
+
+error:
+	ia_css_metadata_free(md);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_metadata_allocate() leave: return=%p\n", NULL);
+	return NULL;
+}
+
+void
+ia_css_metadata_free(struct ia_css_metadata *me)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_metadata_free() enter: me=%p\n", me);
+
+	if (me != NULL) {
+		mmgr_free(me->address);
+		sh_css_free(me);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_metadata_free() leave: return_void\n");
+}
+
+void
+ia_css_metadata_free_multiple(unsigned int num_bufs, struct ia_css_metadata **bufs)
+{
+	unsigned int i;
+
+	if (bufs != NULL) {
+		for (i = 0; i < num_bufs; i++)
+			ia_css_metadata_free(bufs[i]);
+	}
+}
+
+unsigned g_param_buffer_dequeue_count = 0;
+unsigned g_param_buffer_enqueue_count = 0;
+
+enum ia_css_err
+ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool succ = true;
+	unsigned isp_pipe_version = 1;
+	unsigned i;
+	struct sh_css_ddr_address_map *ddr_ptrs;
+	struct sh_css_ddr_address_map_size *ddr_ptrs_size;
+	struct ia_css_isp_parameters *params;
+	size_t params_size;
+
+	assert(stream != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			    "ia_css_stream_isp_parameters_init() enter: void\n");
+
+	/* TMP: tracking of paramsets */
+	g_param_buffer_dequeue_count = 0;
+	g_param_buffer_enqueue_count = 0;
+
+	isp_pipe_version = ia_css_pipe_get_isp_pipe_version(stream->pipes[0]);
+	// this code assuemes that all the pipes have the same pipeversion.
+	for (i = 1; i < (unsigned)stream->num_pipes; i++) {
+	    assert(isp_pipe_version == ia_css_pipe_get_isp_pipe_version(stream->pipes[i]));
+	}
+
+	stream->isp_params_configs = sh_css_malloc(sizeof(*stream->isp_params_configs));
+	if (!stream->isp_params_configs)
+	{
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_stream_isp_parameters_init() leave: "
+			"return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	} else {
+		memset(stream->isp_params_configs, 0, sizeof(*stream->isp_params_configs));
+	}
+
+	params = stream->isp_params_configs;
+	ddr_ptrs = &params->ddr_ptrs;
+	ddr_ptrs_size = &params->ddr_ptrs_size;
+
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		memset(&params->pipe_ddr_ptrs[i], 0,
+			sizeof(params->pipe_ddr_ptrs[i]));
+		memset(&params->pipe_ddr_ptrs_size[i], 0,
+			sizeof(params->pipe_ddr_ptrs_size[i]));
+	}
+
+	memset(ddr_ptrs, 0, sizeof(*ddr_ptrs));
+	memset(ddr_ptrs_size, 0, sizeof(*ddr_ptrs_size));
+
+#if !defined(IS_ISP_2500_SYSTEM)
+	params_size = sizeof(params->uds);
+#else
+	params_size = sizeof(struct sh_css_isp_params);
+#endif
+	ddr_ptrs_size->isp_param = params_size;
+	ddr_ptrs->isp_param = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
+				mmgr_malloc(params_size));
+	succ &= (ddr_ptrs->isp_param != mmgr_NULL);
+
+#if defined(IS_ISP_2500_SYSTEM)
+	ddr_ptrs_size->acc_cluster_params_for_sp = sizeof(struct isp_acc_param);
+	ddr_ptrs->acc_cluster_params_for_sp = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
+				mmgr_malloc(sizeof(struct isp_acc_param)));
+	succ &= (ddr_ptrs->acc_cluster_params_for_sp != mmgr_NULL);
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+	ddr_ptrs_size->macc_tbl = sizeof(struct ia_css_macc_table);
+	ddr_ptrs->macc_tbl = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
+				mmgr_malloc(sizeof(struct ia_css_macc_table)));
+	succ &= (ddr_ptrs->macc_tbl != mmgr_NULL);
+
+	ddr_ptrs_size->anr_thres = sizeof(struct ia_css_anr_thres);
+	ddr_ptrs->anr_thres = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
+			mmgr_malloc(sizeof(struct ia_css_anr_thres)));
+	succ &= (ddr_ptrs->anr_thres != mmgr_NULL);
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+
+	sh_css_set_nr_config(params, &default_nr_config);
+	sh_css_set_ee_config(params, &default_ee_config);
+	if (isp_pipe_version == 1)
+		sh_css_set_macc_table(params, &default_macc_table);
+	else
+		sh_css_set_macc_table(params, &default_macc2_table);
+	sh_css_set_gamma_table(params, &default_gamma_table);
+	sh_css_set_ctc_table(params, &default_ctc_table);
+	sh_css_set_anr_thres(params, &default_anr_thres);
+	sh_css_set_baa_config(params, &default_baa_config);
+	sh_css_set_dz_config(params, &default_dz_config);
+
+	ia_css_set_s3a_config(params, &default_3a_config);
+	ia_css_set_wb_config(params, &default_wb_config);
+	ia_css_set_csc_config(params, &default_cc_config);
+	ia_css_set_tnr_config(params, &default_tnr_config);
+	ia_css_set_ob_config(params, &default_ob_config);
+	ia_css_set_dp_config(params, &default_dp_config);
+	ia_css_set_de_config(params, &default_de_config);
+	ia_css_set_gc_config(params, &default_gc_config);
+	ia_css_set_anr_config(params, &default_anr_config);
+	ia_css_set_ce_config(params, &default_ce_config);
+	ia_css_set_xnr_table_config(params, &default_xnr_table);
+	ia_css_set_ecd_config(params, &default_ecd_config);
+	ia_css_set_ynr_config(params, &default_ynr_config);
+	ia_css_set_fc_config(params, &default_fc_config);
+	ia_css_set_cnr_config(params, &default_cnr_config);
+	ia_css_set_macc_config(params, &default_macc_config);
+	ia_css_set_ctc_config(params, &default_ctc_config);
+	ia_css_set_aa_config(params, &default_aa_config);
+	ia_css_set_r_gamma_config(params, &default_r_gamma_table);
+	ia_css_set_g_gamma_config(params, &default_g_gamma_table);
+	ia_css_set_b_gamma_config(params, &default_b_gamma_table);
+	ia_css_set_yuv2rgb_config(params, &default_yuv2rgb_cc_config);
+	ia_css_set_rgb2yuv_config(params, &default_rgb2yuv_cc_config);
+	ia_css_set_xnr_config(params, &default_xnr_config);
+
+	ia_css_set_param_exceptions(params);
+
+	for (i = 0; i < N_GDC_ID; i++)
+		gdc_lut_store((gdc_ID_t)i, zoom_table);
+	params->fpn_config.data = NULL;
+	params->config_changed[IA_CSS_FPN_ID] = true;
+	params->fpn_config.enabled = 0;
+	params->morph_table = NULL;
+	params->morph_table_changed = true;
+	params->sc_table = NULL;
+	params->sc_table_changed = true;
+	params->motion_config = default_motion_config;
+	params->motion_config_changed = true;
+	params->dvs2_hor_coefs.odd_real = NULL;
+	params->dvs2_hor_coefs.odd_imag = NULL;
+	params->dvs2_hor_coefs.even_real = NULL;
+	params->dvs2_hor_coefs.even_imag = NULL;
+	params->dvs2_ver_coefs.odd_real = NULL;
+	params->dvs2_ver_coefs.odd_imag = NULL;
+	params->dvs2_ver_coefs.even_real = NULL;
+	params->dvs2_ver_coefs.even_imag = NULL;
+	params->dvs2_coef_table_changed = true;
+
+	params->dis_hor_coef_tbl = NULL;
+	params->dis_ver_coef_tbl = NULL;
+	params->dis_coef_table_changed = true;
+
+	/*Initialise and generate table later in star*/
+	params->dvs_6axis_config = NULL;
+	params->dvs_6axis_config_changed = true;
+#endif
+
+#if defined(IS_ISP_2500_SYSTEM)
+	sh_css_set_default_product_specific();
+#endif
+
+	if (!succ)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	/* now commit to ddr */
+	err = sh_css_param_update_isp_params(stream, false, NULL);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	/* create per pipe reference to general ddr_ptrs */
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		ref_sh_css_ddr_address_map(ddr_ptrs, &params->pipe_ddr_ptrs[i]);
+		params->pipe_ddr_ptrs_size[i] = *ddr_ptrs_size;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"ia_css_stream_isp_parameters_init() leave: "
+		"return_err=%d\n",IA_CSS_SUCCESS);
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+sh_css_params_init(void)
+{
+	int i, p;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_init() enter: void\n");
+
+	/* TMP: tracking of paramsets */
+	g_param_buffer_dequeue_count = 0;
+	g_param_buffer_enqueue_count = 0;
+
+	for (p = 0; p < IA_CSS_PIPE_ID_NUM; p++) {
+		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
+			xmem_sp_stage_ptrs[p][i] =
+					ia_css_refcount_increment(-1,
+					    mmgr_calloc(1,
+					    sizeof(struct sh_css_sp_stage)));
+			xmem_isp_stage_ptrs[p][i] =
+					ia_css_refcount_increment(-1,
+					    mmgr_calloc(1,
+					    sizeof(struct sh_css_isp_stage)));
+
+			if ((xmem_sp_stage_ptrs[p][i] == mmgr_NULL) ||
+				(xmem_isp_stage_ptrs[p][i] == mmgr_NULL))
+			{
+				sh_css_params_uninit();
+				ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+					"sh_css_params_init() leave: "
+					"return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+				return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+			}
+		}
+	}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+	ia_css_config_gamma_table();
+	ia_css_config_ctc_table();
+	ia_css_config_rgb_gamma_tables();
+	ia_css_config_xnr_table();
+#endif
+
+	sp_ddr_ptrs = ia_css_refcount_increment(-1, mmgr_calloc(1,
+		CEIL_MUL(sizeof(struct sh_css_ddr_address_map),
+			 HIVE_ISP_DDR_WORD_BYTES)));
+	xmem_sp_group_ptrs = ia_css_refcount_increment(-1, mmgr_calloc(1,
+		sizeof(struct sh_css_sp_group)));
+
+	if ((sp_ddr_ptrs == mmgr_NULL) ||
+	    (xmem_sp_group_ptrs == mmgr_NULL)) {
+		ia_css_uninit();
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"sh_css_params_init() leave: "
+			"return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
+			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+		"sh_css_params_init() leave: "
+		"return_err=%d\n",IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+void sh_css_params_reconfigure_gdc_lut(void)
+{
+	unsigned i;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_reconfigure_gdc_lut() enter: void\n");
+
+	for (i = 0; i < N_GDC_ID; i++)
+		gdc_lut_store((gdc_ID_t)i, zoom_table);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_reconfigure_gdc_lut() leave: return_void\n");
+}
+#endif
+
+static void free_param_set_callback(
+	hrt_vaddress ptr)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_param_set_callback() enter:\n");
+
+	free_ia_css_isp_parameter_set_info(ptr);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_param_set_callback() leave:\n");
+}
+
+static void free_buffer_callback(
+	hrt_vaddress ptr)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_buffer_callback() enter:\n");
+
+	mmgr_free(ptr);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_buffer_callback() leave:\n");
+}
+
+void
+sh_css_param_clear_param_sets(void)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_param_clear_param_sets() enter:\n");
+
+	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_SET_POOL, &free_param_set_callback);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_param_clear_param_sets() leave:\n");
+}
+
+/*
+ * MW: we can define mmgr_free() to return a NULL
+ * then you can write ptr = mmgr_free(ptr);
+ */
+#define safe_free(id, x)      \
+	do {                  \
+		ia_css_refcount_decrement(id, x);     \
+		(x) = mmgr_NULL;  \
+	} while (0)
+
+static void free_map(struct sh_css_ddr_address_map *map)
+{
+	unsigned int i;
+
+	hrt_vaddress *addrs = (hrt_vaddress *)map;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_map() enter:\n");
+
+	/* free buffers */
+	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
+						sizeof(size_t)); i++) {
+		if (addrs[i] == mmgr_NULL)
+			continue;
+		safe_free(IA_CSS_REFCOUNT_PARAM_BUFFER, addrs[i]);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_map() leave:\n");
+}
+
+void
+ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
+{
+	int i;
+	struct ia_css_isp_parameters *params = stream->isp_params_configs;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_isp_parameters_uninit() enter\n");
+	/* free existing ddr_ptr maps */
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
+		free_map(&params->pipe_ddr_ptrs[i]);
+	free_map(&params->ddr_ptrs);
+
+#if !defined(IS_ISP_2500_SYSTEM)
+	if (params->fpn_config.data)
+		sh_css_free(params->fpn_config.data);
+#endif
+
+	/*Free up theDVS table memory blocks before recomputing new table  */
+	if(params->dvs_6axis_config)
+		free_dvs_6axis_table(&(params->dvs_6axis_config));
+
+	sh_css_free(params);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_isp_parameters_uninit() leave\n");
+}
+
+void
+sh_css_params_uninit(void)
+{
+	unsigned p, i;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_uninit() enter:\n");
+
+	ia_css_refcount_decrement(-1, sp_ddr_ptrs);
+	sp_ddr_ptrs = mmgr_NULL;
+	ia_css_refcount_decrement(-1, xmem_sp_group_ptrs);
+	xmem_sp_group_ptrs = mmgr_NULL;
+
+	for (p = 0; p < IA_CSS_PIPE_ID_NUM; p++)
+		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
+			ia_css_refcount_decrement(-1, xmem_sp_stage_ptrs[p][i]);
+			xmem_sp_stage_ptrs[p][i] = mmgr_NULL;
+			ia_css_refcount_decrement(-1, xmem_isp_stage_ptrs[p][i]);
+			xmem_isp_stage_ptrs[p][i] = mmgr_NULL;
+		}
+
+	/* go through the pools to clear references */
+	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_SET_POOL, &free_param_set_callback);
+	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_BUFFER, &free_buffer_callback);
+	ia_css_refcount_clear(-1, &free_buffer_callback);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_uninit() leave: return_void\n");
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void write_morph_plane(
+	unsigned short *data,
+	unsigned int width,
+	unsigned int height,
+	hrt_vaddress dest,
+	unsigned int aligned_width)
+{
+	unsigned int i, padding, w;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "write_morph_plane() enter:\n");
+
+	/* currently we don't have morph table interpolation yet,
+	 * so we allow a wider table to be used. This will be removed
+	 * in the future. */
+	if (width > aligned_width) {
+		padding = 0;
+		w = aligned_width;
+	} else {
+		padding = aligned_width - width;
+		w = width;
+	}
+
+	for (i = 0; i < height; i++) {
+		mmgr_store(dest, data, w * sizeof(short));
+		dest += w * sizeof(short);
+		mmgr_clear(dest, padding * sizeof(short));
+		dest += padding * sizeof(short);
+		data += width;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "write_morph_plane() leave:\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+/* Store the DIS coefficients from the 3A library to DDR where the ISP
+   will read them from. The ISP works on a grid that can be larger than
+   that of the 3a library. If that is the case, we padd the difference
+   with zeroes. */
+static void store_dis_coefficients(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_binary *binary,
+	hrt_vaddress ddr_addr_hor,
+	hrt_vaddress ddr_addr_ver)
+{
+	unsigned int hor_num_isp, ver_num_isp,
+		     hor_num_3a, ver_num_3a,
+		     hor_padding, ver_padding;
+	int i;
+	const short *hor_ptr_3a,
+		*ver_ptr_3a;
+	hrt_vaddress hor_ptr_isp = ddr_addr_hor,
+		ver_ptr_isp = ddr_addr_ver;
+
+	assert(params != NULL);
+	assert(binary != NULL);
+	assert(ddr_addr_hor != mmgr_NULL);
+	assert(ddr_addr_ver != mmgr_NULL);
+
+	hor_num_isp = binary->dis_hor_coef_num_isp,
+	ver_num_isp = binary->dis_ver_coef_num_isp,
+	hor_num_3a  = binary->dis_hor_coef_num_3a,
+	ver_num_3a  = binary->dis_ver_coef_num_3a,
+	hor_padding = hor_num_isp - hor_num_3a,
+	ver_padding = ver_num_isp - ver_num_3a;
+	hor_ptr_3a = params->dis_hor_coef_tbl,
+	ver_ptr_3a = params->dis_ver_coef_tbl;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_dis_coefficients() enter:\n");
+
+	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
+		if (params->dis_hor_coef_tbl != NULL) {
+			mmgr_store(hor_ptr_isp,
+				hor_ptr_3a, hor_num_3a * sizeof(*hor_ptr_3a));
+			hor_ptr_3a  += hor_num_3a;
+		} else {
+			mmgr_clear(hor_ptr_isp,
+				hor_num_3a * sizeof(*hor_ptr_3a));
+		}
+		hor_ptr_isp += hor_num_3a * sizeof(short);
+		mmgr_clear(hor_ptr_isp, hor_padding * sizeof(short));
+		hor_ptr_isp += hor_padding * sizeof(short);
+	}
+	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(binary); i++) {
+		if (params->dis_ver_coef_tbl != NULL) {
+			mmgr_store(ver_ptr_isp,
+				ver_ptr_3a, ver_num_3a * sizeof(*ver_ptr_3a));
+			ver_ptr_3a  += ver_num_3a;
+		} else {
+			mmgr_clear(ver_ptr_isp,
+				ver_num_3a * sizeof(*ver_ptr_3a));
+		}
+		ver_ptr_isp += ver_num_3a * sizeof(short);
+		mmgr_clear(ver_ptr_isp, ver_padding * sizeof(short));
+		ver_ptr_isp += ver_padding * sizeof(short);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_dis_coefficients() leave:\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void storedvs2_coef(const short *ptr_3a, hrt_vaddress ptr_isp, unsigned num_3a, unsigned padding)
+{
+	if (ptr_3a != NULL) {
+		mmgr_store(ptr_isp, ptr_3a, num_3a * sizeof(*ptr_3a));
+	} else {
+		mmgr_clear(ptr_isp, num_3a * sizeof(*ptr_3a));
+	}
+	ptr_isp += num_3a * sizeof(short);
+	mmgr_clear(ptr_isp, padding * sizeof(short));
+
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void store_dvs2_coefficients(
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_binary *binary,
+	hrt_vaddress ddr_addr_hor,
+	hrt_vaddress ddr_addr_ver)
+{
+	unsigned int hor_num_isp, ver_num_isp,
+		     hor_num_3a, ver_num_3a,
+		     hor_padding, ver_padding;
+	hrt_vaddress hor_ptr_isp = ddr_addr_hor,
+		ver_ptr_isp = ddr_addr_ver;
+
+	assert(binary != NULL);
+	assert(ddr_addr_hor != mmgr_NULL);
+	assert(ddr_addr_ver != mmgr_NULL);
+
+	hor_num_isp = binary->dis_hor_coef_num_isp,
+	ver_num_isp = binary->dis_ver_coef_num_isp,
+	hor_num_3a  = binary->dis_hor_coef_num_3a,
+	ver_num_3a  = binary->dis_ver_coef_num_3a,
+	hor_padding = hor_num_isp - hor_num_3a,
+	ver_padding = ver_num_isp - ver_num_3a;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_dvs2_coefficients() enter:\n");
+
+	storedvs2_coef(params->dvs2_hor_coefs.odd_real, hor_ptr_isp, hor_num_3a, hor_padding);
+	hor_ptr_isp += hor_num_isp * sizeof(short);
+	storedvs2_coef(params->dvs2_hor_coefs.odd_imag, hor_ptr_isp, hor_num_3a, hor_padding);
+	hor_ptr_isp += hor_num_isp * sizeof(short);
+	storedvs2_coef(params->dvs2_hor_coefs.even_real, hor_ptr_isp, hor_num_3a, hor_padding);
+	hor_ptr_isp += hor_num_isp * sizeof(short);
+	storedvs2_coef(params->dvs2_hor_coefs.even_imag, hor_ptr_isp, hor_num_3a, hor_padding);
+
+	storedvs2_coef(params->dvs2_ver_coefs.odd_real, ver_ptr_isp, ver_num_3a, ver_padding);
+	ver_ptr_isp += ver_num_isp * sizeof(short);
+	storedvs2_coef(params->dvs2_ver_coefs.odd_imag, ver_ptr_isp, ver_num_3a, ver_padding);
+	ver_ptr_isp += ver_num_isp * sizeof(short);
+	storedvs2_coef(params->dvs2_ver_coefs.even_real, ver_ptr_isp, ver_num_3a, ver_padding);
+	ver_ptr_isp += ver_num_isp * sizeof(short);
+	storedvs2_coef(params->dvs2_ver_coefs.even_imag, ver_ptr_isp, ver_num_3a, ver_padding);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_dvs2_coefficients() leave:\n");
+}
+#endif
+
+static void sh_css_update_isp_params_to_ddr(
+	struct ia_css_isp_parameters *params,
+	hrt_vaddress ddr_ptr)
+{
+#if !defined(IS_ISP_2500_SYSTEM)
+	size_t size = sizeof(params->uds);
+#else
+	size_t size = sizeof(struct sh_css_isp_params);
+#endif
+
+	assert(params != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "sh_css_update_isp_params_to_ddr() enter:\n");
+
+#ifdef HRT_CSIM
+	{
+		/* ispparm struct is read with DMA which reads
+		 * multiples of the DDR word with (32 bytes):
+		 * So we pad with zeroes to prevent warnings in csim.
+		 */
+		unsigned int aligned_width, padding_bytes;
+		hrt_vaddress pad_ptr;
+
+		aligned_width = CEIL_MUL(
+				  size,
+				  HIVE_ISP_DDR_WORD_BYTES);
+		padding_bytes = aligned_width - size;
+		pad_ptr = ddr_ptr +size;
+		mmgr_clear(pad_ptr, padding_bytes);
+	}
+#endif
+#if !defined(IS_ISP_2500_SYSTEM)
+	mmgr_store(ddr_ptr, &(params->uds), size);
+#else
+	mmgr_store(ddr_ptr, &(params->isp_parameters), size);
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_update_isp_params_to_ddr() leave:\n");
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void sh_css_update_isp_mem_params_to_ddr(
+	const struct ia_css_binary *binary,
+	hrt_vaddress ddr_mem_ptr,
+	size_t size,
+	enum ia_css_isp_memories mem)
+{
+	const struct ia_css_host_data *params;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_update_isp_mem_params_to_ddr() enter:\n");
+
+	params = ia_css_isp_param_get_mem_init(&binary->mem_params, IA_CSS_PARAM_CLASS_PARAM, mem);
+	mmgr_store(ddr_mem_ptr, params->address, size);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_update_isp_memparams_to_ddr() leave:\n");
+}
+#endif
+
+#if defined(IS_ISP_2500_SYSTEM)
+void
+sh_css_update_acc_cluster_params_to_ddr(hrt_vaddress ddr_ptr)
+{
+	size_t size = sizeof(struct isp_acc_param);
+#if defined(HRT_CSIM)
+	/* ispparm struct is read with DMA which reads
+	 * multiples of the DDR word with (32 bytes):
+	 * So we pad with zeroes to prevent warnings in csim.
+	 */
+	unsigned int aligned_width, padding_bytes;
+	hrt_vaddress pad_ptr;
+
+	aligned_width = CEIL_MUL(size, HIVE_ISP_DDR_WORD_BYTES);
+	padding_bytes = aligned_width - size;
+	pad_ptr = ddr_ptr + size;
+	mmgr_clear(pad_ptr, padding_bytes);
+#endif
+	mmgr_store(ddr_ptr,
+	     &sh_css_acc_cluster_parameters,
+	     size);
+}
+#endif
+
+void ia_css_dequeue_param_buffers(/*unsigned int pipe_num*/)
+{
+	hrt_vaddress cpy;
+	enum sh_css_queue_id queue_id;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_dequeue_param_buffers() enter\n");
+
+	if (!sh_css_sp_is_running()) {
+
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_dequeue_param_buffers() invalid args leave \n");
+		/* SP is not running. The queues are not valid */
+		return ;
+	}
+
+#if 0
+		/* Get queue instance */
+		ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+	 	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_PARAMETER_SET, thread_id, &queue_id);
+#else
+		/* use hard-coded value for backward compatibility, will enable above code later */
+		queue_id = IA_CSS_PARAMETER_SET_QUEUE_ID;
+#endif
+	/* clean-up old copy */
+	while (IA_CSS_SUCCESS == ia_css_bufq_dequeue_buffer(queue_id, (uint32_t *)&cpy)){
+		/* TMP: keep track of dequeued param set count
+		 */
+		g_param_buffer_dequeue_count++;
+		ia_css_bufq_enqueue_event(SP_SW_EVENT_ID_2,
+			0,
+			queue_id,
+			0);
+
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"ia_css_dequeue_param_buffers: "
+			"dequeued param set %x from %d\n",
+			cpy, 0);
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_dequeue_param_buffers: "
+				"release ref on param set %x\n",
+				cpy);
+			free_ia_css_isp_parameter_set_info(cpy);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_dequeue_param_buffers() leave\n");
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+static void
+process_kernel_parameters(unsigned int pipe_id,
+			  struct ia_css_pipeline_stage *stage,
+			  struct ia_css_isp_parameters *params,
+			  unsigned int isp_pipe_version,
+			  unsigned int raw_bit_depth)
+{
+	unsigned param_id;
+
+	sh_css_enable_pipeline(stage->binary);
+
+	if (params->config_changed[IA_CSS_OB_ID]) {
+		ia_css_ob_configure(&params->stream_configs.ob,
+			    isp_pipe_version, raw_bit_depth);
+	}
+	if (params->config_changed[IA_CSS_S3A_ID]) {
+		ia_css_s3a_configure(raw_bit_depth);
+	}
+	/* Copy stage uds parameters to config, since they can differ per stage.
+	 */
+	params->crop_config.crop_pos = params->uds[stage->stage_num].crop_pos;
+	params->uds_config.crop_pos  = params->uds[stage->stage_num].crop_pos;
+	params->uds_config.uds       = params->uds[stage->stage_num].uds;
+
+	/* Call parameter process functions for all kernels */
+	/* Skip SC, since that is called on a temp sc table */
+	for (param_id = 0; param_id < IA_CSS_NUM_PARAMETER_IDS; param_id++) {
+		if (param_id == IA_CSS_SC_ID) continue;
+		if (params->config_changed[param_id])
+			ia_css_kernel_process_param[param_id](pipe_id, stage, params);
+	}
+}
+#endif
+
+enum ia_css_err
+sh_css_param_update_isp_params(struct ia_css_stream *stream, bool commit, struct ia_css_pipe *pipe_in)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	hrt_vaddress cpy;
+	int i;
+	unsigned int raw_bit_depth = 10;
+	unsigned int isp_pipe_version = 1;
+	struct ia_css_isp_parameters *params;
+	bool acc_cluster_params_changed = false;
+
+	(void)acc_cluster_params_changed;
+
+	assert(stream != NULL);
+
+	params = stream->isp_params_configs;
+
+	raw_bit_depth = ia_css_stream_input_format_bits_per_pixel(stream);
+	isp_pipe_version = ia_css_pipe_get_isp_pipe_version(stream->pipes[0]);
+	// this code assuemes that all the pipes have the same pipeversion.
+	for(i=1; i< stream->num_pipes; i++) {
+		assert(isp_pipe_version == ia_css_pipe_get_isp_pipe_version(stream->pipes[i]));
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_param_update_isp_params() enter: "
+		"pipe=%p, isp_parameters_id=%d\n", pipe_in, params->isp_parameters_id);
+
+#if !defined(IS_ISP_2500_SYSTEM)
+#else /* defined(IS_ISP_2500_SYSTEM) */
+	sh_css_process_product_specific(&params->isp_parameters,&params->isp_params_changed);
+	sh_css_process_acc_cluster_parameters(stream, &sh_css_acc_cluster_parameters, &acc_cluster_params_changed);
+#endif
+
+	/* now make the map available to the sp */
+	if (!commit) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"sh_css_param_update_isp_params() leave:\n");
+		return err;
+	}
+	/* enqueue a copies of the mem_map to
+	   the designated pipelines */
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe;
+		struct sh_css_ddr_address_map *cur_map;
+		struct sh_css_ddr_address_map_size *cur_map_size;
+		struct ia_css_isp_parameter_set_info isp_params_info;
+		struct ia_css_pipeline *pipeline;
+		struct ia_css_pipeline_stage *stage;
+		unsigned int thread_id, pipe_num;
+
+		enum sh_css_queue_id queue_id;
+
+		(void)stage;
+		pipe = stream->pipes[i];
+		pipeline = ia_css_pipe_get_pipeline(pipe);
+		pipe_num = ia_css_pipe_get_pipe_num(pipe);
+		ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+
+		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_PARAMETER_SET, thread_id, &queue_id);
+		if (!sh_css_sp_is_running()) {
+			/* SP is not running. The queues are not valid */
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"sh_css_param_update_isp_params() leaving:"
+				"queue unavailable\n");
+			err = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+			break;
+		}
+		cur_map = &params->pipe_ddr_ptrs[pipeline->pipe_id];
+		cur_map_size = &params->pipe_ddr_ptrs_size[pipeline->pipe_id];
+
+#if !defined(IS_ISP_2500_SYSTEM)
+		/* TODO: Normally, zoom and motion parameters shouldn't
+		 * be part of "isp_params" as it is resolution/pipe dependant
+		 * Therefore, move the zoom config elsewhere (e.g. shading
+		 * table can be taken as an example! @GC
+		 * */
+#if 0
+		if (params->isp_params_changed || params->dz_config_changed ||
+				params->motion_config_changed) {
+#else
+		/* This should be unconditional, since the sh_css_params_write_to_ddr_internal below
+		 * is also unconditional. Otherwise, the old uds parameters, e.g. for
+		 * another pipeline, can be taken.
+		*/
+		{
+#endif
+			/* we have to do this per pipeline because */
+			/* the processing is a.o. resolution dependent */
+			ia_css_process_zoom_and_motion(params,
+							pipeline->pipe_id,
+							pipeline->stages);
+			params->isp_params_changed = true;
+		}
+#endif
+
+		/* BZ 125915, should be moved till after "update other buff" */
+		/* update the other buffers to the pipe specific copies */
+		for (stage = pipeline->stages; stage; stage = stage->next) {
+			unsigned mem;
+
+			if (!stage || !stage->binary) continue;
+#if !defined(IS_ISP_2500_SYSTEM)
+			process_kernel_parameters(pipeline->pipe_id,
+				stage, params,
+				isp_pipe_version, raw_bit_depth);
+#endif
+			err =
+			  sh_css_params_write_to_ddr_internal(
+						pipeline->pipe_id,
+						params,
+						stage,
+						cur_map,
+						cur_map_size);
+			if (err != IA_CSS_SUCCESS)
+				break;
+			for (mem = 0; mem < IA_CSS_NUM_MEMORIES; mem++) {
+				params->isp_mem_params_changed
+					[pipeline->pipe_id][stage->stage_num][mem] = false;
+			}
+		}
+		/* update isp_params to pipe specific copies */
+		if (params->isp_params_changed) {
+			reallocate_buffer(&cur_map->isp_param,
+				  &cur_map_size->isp_param,
+				  cur_map_size->isp_param,
+				  true,
+				  &err);
+			if (err != IA_CSS_SUCCESS)
+				break;
+			sh_css_update_isp_params_to_ddr(params, cur_map->isp_param);
+		}
+#if defined(IS_ISP_2500_SYSTEM)
+		if (acc_cluster_params_changed || params->isp_params_changed)
+		{
+			reallocate_buffer(&cur_map->acc_cluster_params_for_sp ,
+				  &cur_map_size->acc_cluster_params_for_sp ,
+				  cur_map_size->acc_cluster_params_for_sp ,
+				  true,
+				  &err);
+			sh_css_update_acc_cluster_params_to_ddr( cur_map->acc_cluster_params_for_sp );
+		}
+#endif
+
+		/* check if to actually update the parameters for this pipe */
+		if (pipe_in && (pipe != pipe_in)) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"sh_css_param_update_isp_params: "
+				"skipping pipe %x\n",
+				pipe);
+			continue;
+		}
+		/* last make referenced copy */
+		err = ref_sh_css_ddr_address_map(
+					cur_map,
+					&isp_params_info.mem_map);
+		if (err != IA_CSS_SUCCESS)
+			break;
+
+		/* Update Parameters ID */
+		isp_params_info.isp_parameters_id = params->isp_parameters_id;
+
+		/* Update output frame pointer */
+		isp_params_info.output_frame_ptr =
+                        (params->output_frame) ? params->output_frame->data : mmgr_NULL;
+
+		/* now write the copy to ddr */
+		err = write_ia_css_isp_parameter_set_info_to_ddr(&isp_params_info, &cpy);
+		if (err != IA_CSS_SUCCESS)
+			break;
+
+		/* enqueue the set to sp */
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"sh_css_param_update_isp_params: "
+			"queue param set %x to %d\n",
+			cpy, thread_id);
+
+			if (IA_CSS_SUCCESS != ia_css_bufq_enqueue_buffer(thread_id,queue_id,(uint32_t)cpy)) {
+				free_ia_css_isp_parameter_set_info(cpy);
+			}
+			else {
+			/* TMP: check discrepancy between nr of enqueued
+			 * parameter sets and dequeued sets
+			 */
+			g_param_buffer_enqueue_count++;
+			assert(g_param_buffer_enqueue_count < g_param_buffer_dequeue_count+50);
+
+			/*
+			 * Tell the SP which queues are not empty,
+			 * by sending the software event.
+			 */
+			if (!sh_css_sp_is_running()) {
+				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"sh_css_param_update_isp_params() error leave:\n");
+			/* SP is not running. The queues are not valid */
+				return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
+			}
+			 ia_css_bufq_enqueue_event(SP_SW_EVENT_ID_1,
+					(uint8_t)thread_id,
+					(uint8_t)queue_id,
+					0);
+		}
+		/* clean-up old copy */
+		ia_css_dequeue_param_buffers(/*pipe_num*/);
+	} /* end for each 'active' pipeline */
+	/* clear the changed flags after all params
+	   for all pipelines have been updated */
+	params->isp_params_changed = false;
+	params->sc_table_changed = false;
+	params->anr_thres_changed = false;
+	params->dis_coef_table_changed = false;
+	params->dvs2_coef_table_changed = false;
+	params->morph_table_changed = false;
+	params->dz_config_changed = false;
+	params->motion_config_changed = false;
+	params->dvs_6axis_config_changed = false;
+
+	memset(&params->config_changed[0], 0, sizeof(params->config_changed));
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_param_update_isp_params() leave:\n");
+	return err;
+}
+
+static enum ia_css_err
+sh_css_params_write_to_ddr_internal(
+	unsigned pipe_id,
+	struct ia_css_isp_parameters *params,
+	const struct ia_css_pipeline_stage *stage,
+	struct sh_css_ddr_address_map *ddr_map,
+	struct sh_css_ddr_address_map_size *ddr_map_size)
+{
+	enum ia_css_err err;
+	const struct ia_css_binary *binary;
+
+	unsigned stage_num;
+	unsigned mem;
+	bool buff_realloced;
+
+#if !defined(IS_ISP_2500_SYSTEM)
+	/* struct is > 128 bytes so it should not be on stack (see checkpatch) */
+	static struct ia_css_macc_table converted_macc_table;
+#endif
+
+	assert(params != NULL);
+	assert(ddr_map != NULL);
+	assert(ddr_map_size != NULL);
+	assert(stage != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "sh_css_params_write_to_ddr_internal() enter:\n");
+
+	binary = stage->binary;
+	assert(binary != NULL);
+
+#if defined(IS_ISP_2500_SYSTEM)
+	(void)pipe_id;
+	(void)stage;
+	(void)buff_realloced;
+	(void)mem;
+	(void)stage_num;
+	/* pass call to product specific to handle copying of tables to DDR */
+	err = sh_css_params_to_ddr( binary, ddr_map, ddr_map_size, &params->isp_parameters );
+	if (err != IA_CSS_SUCCESS) return err;
+#else  /* !defined(IS_ISP_2500_SYSTEM) */
+
+	stage_num = stage->stage_num;
+
+	for (mem = 0; mem < N_IA_CSS_MEMORIES; mem++) {
+		const struct ia_css_isp_data *isp_data =
+			ia_css_isp_param_get_isp_mem_init(&binary->info->sp.mem_initializers, IA_CSS_PARAM_CLASS_PARAM, mem);
+		size_t size = isp_data->size;
+		if (!size) continue;
+		buff_realloced = reallocate_buffer(&ddr_map->isp_mem_param[stage_num][mem],
+			&ddr_map_size->isp_mem_param[stage_num][mem],
+			size,
+			params->isp_mem_params_changed[pipe_id][stage_num][mem],
+			&err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (params->isp_mem_params_changed[pipe_id][stage_num][mem] || buff_realloced) {
+			sh_css_update_isp_mem_params_to_ddr(binary,
+				ddr_map->isp_mem_param[stage_num][mem],
+				ddr_map_size->isp_mem_param[stage_num][mem], mem);
+		}
+	}
+
+	if (binary->info->sp.enable.fpnr) {
+		buff_realloced = reallocate_buffer(&ddr_map->fpn_tbl,
+			&ddr_map_size->fpn_tbl,
+			(size_t)(FPNTBL_BYTES(binary)),
+			params->config_changed[IA_CSS_FPN_ID],
+			&err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (params->config_changed[IA_CSS_FPN_ID] || buff_realloced) {
+			if (params->fpn_config.enabled) {
+				store_fpntbl(params, ddr_map->fpn_tbl);
+			}
+#ifdef HRT_CSIM
+			else {
+				hrt_vaddress ptr =
+					(hrt_vaddress)ddr_map->fpn_tbl;
+				/* prevent warnings when reading fpn table
+				 * in csim.*/
+				/* Actual values are not used when fpn is
+				 * disabled. */
+				/* MW: fpn_tbl_size*sizeof(whatever)? */
+				mmgr_clear(ptr, ddr_map_size->fpn_tbl);
+			}
+#endif
+		}
+	}
+	if (binary->info->sp.enable.sc) {
+		buff_realloced = reallocate_buffer(&ddr_map->sc_tbl,
+			&ddr_map_size->sc_tbl,
+			(size_t)(SCTBL_BYTES(binary)),
+			params->sc_table_changed,
+			&err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (params->sc_table_changed || buff_realloced) {
+			/* shading table is full resolution, reduce */
+			prepare_shading_table(
+				(const struct ia_css_shading_table *)params->sc_table,
+				params->sensor_binning,
+				&params->sc_config,
+				binary);
+			if (params->sc_config == NULL)
+				return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+			store_sctbl(stage, ddr_map->sc_tbl, params->sc_config);
+			ia_css_kernel_process_param[IA_CSS_SC_ID](pipe_id, stage, params);
+
+			ia_css_shading_table_free(params->sc_config);
+			params->sc_config = NULL;
+		}
+	}
+
+	if (params->anr_thres_changed) {
+		reallocate_buffer(&ddr_map->anr_thres,
+				  &ddr_map_size->anr_thres,
+				  ddr_map_size->anr_thres,
+				  true,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		mmgr_store(ddr_map->anr_thres,
+				     &(params->anr_thres.data),
+				     ddr_map_size->anr_thres);
+	}
+	if (params->config_changed[IA_CSS_MACC_ID] && binary->info->sp.enable.macc) {
+		unsigned int i, j, idx;
+		unsigned int idx_map[] = {
+			0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8};
+
+		for (i = 0; i < IA_CSS_MACC_NUM_AXES; i++) {
+			idx = 4*idx_map[i];
+			j   = 4*i;
+
+			if (binary->info->sp.isp_pipe_version == 1) {
+				converted_macc_table.data[idx] =
+				  sDIGIT_FITTING(params->macc_table.data[j],
+				  13, SH_CSS_MACC_COEF_SHIFT);
+				converted_macc_table.data[idx+1] =
+				  sDIGIT_FITTING(params->macc_table.data[j+1],
+				  13, SH_CSS_MACC_COEF_SHIFT);
+				converted_macc_table.data[idx+2] =
+				  sDIGIT_FITTING(params->macc_table.data[j+2],
+				  13, SH_CSS_MACC_COEF_SHIFT);
+				converted_macc_table.data[idx+3] =
+				  sDIGIT_FITTING(params->macc_table.data[j+3],
+				  13, SH_CSS_MACC_COEF_SHIFT);
+			} else {
+				converted_macc_table.data[idx] =
+					params->macc_table.data[j];
+				converted_macc_table.data[idx+1] =
+					params->macc_table.data[j+1];
+				converted_macc_table.data[idx+2] =
+					params->macc_table.data[j+2];
+				converted_macc_table.data[idx+3] =
+					params->macc_table.data[j+3];
+			}
+		}
+		reallocate_buffer(&ddr_map->macc_tbl,
+				  &ddr_map_size->macc_tbl,
+				  ddr_map_size->macc_tbl,
+				  true,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		mmgr_store(ddr_map->macc_tbl,
+				     converted_macc_table.data,
+				     sizeof(converted_macc_table.data));
+	}
+
+	if (binary->info->sp.enable.dvs_6axis) {
+		buff_realloced = reallocate_buffer(
+				&ddr_map->dvs_6axis_params_y,
+				&ddr_map_size->dvs_6axis_params_y,
+				(size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3), // because UV is packed into the Y plane, calc total YYU size = /2 gives size of UV-only, total YYU size = UV-only * 3
+				params->dvs_6axis_config_changed,
+				&err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (params->dvs_6axis_config_changed || buff_realloced) {
+			if(params->dvs_6axis_config == NULL) /* Generate default DVS unity table on start up*/
+			{
+				struct ia_css_resolution dvs_offset;
+				dvs_offset.width  = (PIX_SHIFT_FILTER_RUN_IN_X + binary->dvs_envelope.width) / 2;
+				dvs_offset.height = (PIX_SHIFT_FILTER_RUN_IN_Y + binary->dvs_envelope.height) / 2;
+
+				params->dvs_6axis_config = generate_dvs_6axis_table(&binary->out_frame_info[0].res,
+										    &dvs_offset);
+				if(params->dvs_6axis_config == NULL)
+					return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+			}
+
+			store_dvs_6axis_config(params,
+						binary,
+						ddr_map->dvs_6axis_params_y);
+		}
+	}
+
+	if (binary->info->sp.enable.dis) {
+		buff_realloced = reallocate_buffer(&ddr_map->sdis_hor_coef,
+				  &ddr_map_size->sdis_hor_coef,
+				  (size_t)(SDIS_HOR_COEF_TBL_BYTES(binary)),
+				  params->dis_coef_table_changed,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		buff_realloced |= reallocate_buffer(&ddr_map->sdis_ver_coef,
+				  &ddr_map_size->sdis_ver_coef,
+				  (size_t)(SDIS_VER_COEF_TBL_BYTES(binary)),
+				  params->dis_coef_table_changed,
+				  &err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (binary->info->sp.isp_pipe_version == 2) {
+			if (params->dvs2_coef_table_changed || buff_realloced) {
+				store_dvs2_coefficients(params, binary,
+					ddr_map->sdis_hor_coef, ddr_map->sdis_ver_coef);
+			}
+		} else {
+			if (params->dis_coef_table_changed || buff_realloced) {
+				store_dis_coefficients(params, binary,
+					ddr_map->sdis_hor_coef, ddr_map->sdis_ver_coef);
+			}
+		}
+	}
+
+	if (binary->info->sp.enable.ca_gdc) {
+		unsigned int i;
+		hrt_vaddress *virt_addr_tetra_x[
+			IA_CSS_MORPH_TABLE_NUM_PLANES];
+		size_t *virt_size_tetra_x[
+			IA_CSS_MORPH_TABLE_NUM_PLANES];
+		hrt_vaddress *virt_addr_tetra_y[
+			IA_CSS_MORPH_TABLE_NUM_PLANES];
+		size_t *virt_size_tetra_y[
+			IA_CSS_MORPH_TABLE_NUM_PLANES];
+
+			virt_addr_tetra_x[0] = &ddr_map->tetra_r_x;
+			virt_addr_tetra_x[1] = &ddr_map->tetra_gr_x;
+			virt_addr_tetra_x[2] = &ddr_map->tetra_gb_x;
+			virt_addr_tetra_x[3] = &ddr_map->tetra_b_x;
+			virt_addr_tetra_x[4] = &ddr_map->tetra_ratb_x;
+			virt_addr_tetra_x[5] = &ddr_map->tetra_batr_x;
+
+			virt_size_tetra_x[0] = &ddr_map_size->tetra_r_x;
+			virt_size_tetra_x[1] = &ddr_map_size->tetra_gr_x;
+			virt_size_tetra_x[2] = &ddr_map_size->tetra_gb_x;
+			virt_size_tetra_x[3] = &ddr_map_size->tetra_b_x;
+			virt_size_tetra_x[4] = &ddr_map_size->tetra_ratb_x;
+			virt_size_tetra_x[5] = &ddr_map_size->tetra_batr_x;
+
+			virt_addr_tetra_y[0] = &ddr_map->tetra_r_y;
+			virt_addr_tetra_y[1] = &ddr_map->tetra_gr_y;
+			virt_addr_tetra_y[2] = &ddr_map->tetra_gb_y;
+			virt_addr_tetra_y[3] = &ddr_map->tetra_b_y;
+			virt_addr_tetra_y[4] = &ddr_map->tetra_ratb_y;
+			virt_addr_tetra_y[5] = &ddr_map->tetra_batr_y;
+
+			virt_size_tetra_y[0] = &ddr_map_size->tetra_r_y;
+			virt_size_tetra_y[1] = &ddr_map_size->tetra_gr_y;
+			virt_size_tetra_y[2] = &ddr_map_size->tetra_gb_y;
+			virt_size_tetra_y[3] = &ddr_map_size->tetra_b_y;
+			virt_size_tetra_y[4] = &ddr_map_size->tetra_ratb_y;
+			virt_size_tetra_y[5] = &ddr_map_size->tetra_batr_y;
+
+		buff_realloced = false;
+		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+			buff_realloced |=
+					reallocate_buffer(virt_addr_tetra_x[i],
+						virt_size_tetra_x[i],
+						(size_t)
+						  (MORPH_PLANE_BYTES(binary)),
+						params->morph_table_changed,
+						&err);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+			buff_realloced |=
+					reallocate_buffer(virt_addr_tetra_y[i],
+						virt_size_tetra_y[i],
+						(size_t)
+						  (MORPH_PLANE_BYTES(binary)),
+						params->morph_table_changed,
+						&err);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+		if (params->morph_table_changed || buff_realloced) {
+			const struct ia_css_morph_table *table = params->morph_table;
+			struct ia_css_morph_table *id_table = NULL;
+
+			if ((table != NULL) &&
+			    (table->width < binary->morph_tbl_width ||
+			     table->height < binary->morph_tbl_height)) {
+				table = NULL;
+			}
+			if (table == NULL) {
+				err = sh_css_params_default_morph_table(&id_table,
+								  binary);
+				if (err != IA_CSS_SUCCESS)
+					return err;
+				table = id_table;
+			}
+
+			for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
+				write_morph_plane(table->coordinates_x[i],
+					table->width,
+					table->height,
+					*virt_addr_tetra_x[i],
+					binary->morph_tbl_aligned_width);
+				write_morph_plane(table->coordinates_y[i],
+					table->width,
+					table->height,
+					*virt_addr_tetra_y[i],
+					binary->morph_tbl_aligned_width);
+			}
+			if (id_table != NULL)
+				ia_css_morph_table_free(id_table);
+		}
+	}
+
+	/* After special cases like SC, FPN since they may change parameters */
+	for (mem = 0; mem < N_IA_CSS_MEMORIES; mem++) {
+		const struct ia_css_isp_data *isp_data =
+			ia_css_isp_param_get_isp_mem_init(&binary->info->sp.mem_initializers, IA_CSS_PARAM_CLASS_PARAM, mem);
+		size_t size = isp_data->size;
+		if (!size) continue;
+		buff_realloced = reallocate_buffer(&ddr_map->isp_mem_param[stage_num][mem],
+			&ddr_map_size->isp_mem_param[stage_num][mem],
+			size,
+			params->isp_mem_params_changed[pipe_id][stage_num][mem],
+			&err);
+		if (err != IA_CSS_SUCCESS)
+			return err;
+		if (params->isp_mem_params_changed[pipe_id][stage_num][mem] || buff_realloced) {
+			sh_css_update_isp_mem_params_to_ddr(binary,
+				ddr_map->isp_mem_param[stage_num][mem],
+				ddr_map_size->isp_mem_param[stage_num][mem], mem);
+		}
+	}
+
+#endif
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_params_write_to_ddr_internal() leave:\n");
+
+return IA_CSS_SUCCESS;
+}
+
+/**
+ * Currently this function is called from:
+ *  - sh_css_commit_isp_config
+ *    (loops through the stages in a pipe to reconfigure settings)
+ */
+enum ia_css_err
+sh_css_params_write_to_ddr(struct ia_css_stream *stream,
+			   struct ia_css_pipeline_stage *stage)
+{
+	int i;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_isp_parameters *params;
+
+	assert(stream != NULL);
+
+	params = stream->isp_params_configs;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_params_write_to_ddr() enter:\n");
+
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		struct ia_css_pipeline *pipeline;
+		pipeline = ia_css_pipe_get_pipeline(pipe);
+		err = sh_css_params_write_to_ddr_internal(
+				pipeline->pipe_id,
+				params,
+				stage,
+				&params->pipe_ddr_ptrs[pipeline->pipe_id],
+				&params->pipe_ddr_ptrs_size[pipeline->pipe_id]);
+		if (err != IA_CSS_SUCCESS)
+			break;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_write_to_ddr() leave:\n");
+
+	return err;
+}
+
+const struct ia_css_fpn_table *ia_css_get_fpn_table(struct ia_css_stream *stream)
+{
+	struct ia_css_isp_parameters *params;
+
+	assert(stream != NULL);
+
+	params = stream->isp_params_configs;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_get_fpn_table() enter & leave:\n");
+	return &(params->fpn_config);
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+struct ia_css_shading_table * ia_css_get_shading_table(struct ia_css_stream *stream)
+{
+	struct ia_css_shading_table *sc_config = NULL;
+	struct ia_css_binary *binary = NULL;
+	struct ia_css_isp_parameters *params;
+	int i;
+
+	assert(stream != NULL);
+
+	params = stream->isp_params_configs;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_get_shading_table() enter:\n");
+
+	for (i = 0; i < stream->num_pipes; i++) {
+		struct ia_css_pipe *pipe = stream->pipes[i];
+		struct ia_css_pipeline *pipeline;
+		struct ia_css_pipeline_stage *stage;
+		//unsigned int thread_id;
+
+		pipeline = ia_css_pipe_get_pipeline(pipe);
+		assert(pipeline != NULL);
+
+		for (stage = pipeline->stages; stage; stage = stage->next) {
+			if (stage && stage->binary) {
+				if (stage->binary->info->sp.enable.sc) {
+					binary = stage->binary;
+					break;
+				}
+			}
+		}
+		if (binary)
+			break;
+	}
+	if (binary)
+		prepare_shading_table(
+			(const struct ia_css_shading_table *)params->sc_table,
+			params->sensor_binning,
+			&sc_config,
+			binary);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_get_shading_table() leave:\n");
+
+	return sc_config;
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+void ia_css_get_isp_dis_coefficients(
+	struct ia_css_stream *stream,
+	short *horizontal_coefficients,
+	short *vertical_coefficients)
+{
+	struct ia_css_isp_parameters *params;
+	unsigned int hor_num_isp, ver_num_isp;
+	int i;
+	short *hor_ptr = horizontal_coefficients,
+	      *ver_ptr = vertical_coefficients;
+	hrt_vaddress hor_ptr_isp;
+	hrt_vaddress ver_ptr_isp;
+	struct ia_css_binary *dvs_binary;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_get_isp_dis_coefficients() enter\n");
+	assert(horizontal_coefficients != NULL);
+	assert(vertical_coefficients != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_get_isp_dis_coefficients() enter\n");
+
+	params = stream->isp_params_configs;
+
+	/* Only video pipe supports DVS */
+	hor_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_hor_coef;
+	ver_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_ver_coef;
+	dvs_binary = ia_css_stream_get_dvs_binary(stream);
+	if (!dvs_binary)
+		return;
+
+	hor_num_isp = dvs_binary->dis_hor_coef_num_isp;
+	ver_num_isp = dvs_binary->dis_ver_coef_num_isp;
+
+	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
+		mmgr_load(hor_ptr_isp, hor_ptr, hor_num_isp * sizeof(short));
+		hor_ptr_isp += hor_num_isp * sizeof(short);
+		hor_ptr     += hor_num_isp;
+	}
+	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(dvs_binary); i++) {
+		mmgr_load(ver_ptr_isp, ver_ptr, ver_num_isp * sizeof(short));
+		ver_ptr_isp += ver_num_isp * sizeof(short);
+		ver_ptr     += ver_num_isp;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_get_isp_dis_coefficients() leave\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+void ia_css_get_isp_dvs2_coefficients(struct ia_css_stream *stream,
+	short *hor_coefs_odd_real,
+	short *hor_coefs_odd_imag,
+	short *hor_coefs_even_real,
+	short *hor_coefs_even_imag,
+	short *ver_coefs_odd_real,
+	short *ver_coefs_odd_imag,
+	short *ver_coefs_even_real,
+	short *ver_coefs_even_imag)
+{
+	struct ia_css_isp_parameters *params;
+	unsigned int hor_num_3a, ver_num_3a;
+	unsigned int hor_num_isp, ver_num_isp;
+	hrt_vaddress hor_ptr_isp;
+	hrt_vaddress ver_ptr_isp;
+	struct ia_css_binary *dvs_binary;
+
+	assert(stream != NULL);
+	assert(hor_coefs_odd_real != NULL);
+	assert(hor_coefs_odd_imag != NULL);
+	assert(hor_coefs_even_real != NULL);
+	assert(hor_coefs_even_imag != NULL);
+	assert(ver_coefs_odd_real != NULL);
+	assert(ver_coefs_odd_imag != NULL);
+	assert(ver_coefs_even_real != NULL);
+	assert(ver_coefs_even_imag != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ia_css_get_isp_dvs2_coefficients() enter\n");
+
+	params = stream->isp_params_configs;
+
+	/* Only video pipe supports DVS */
+	hor_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_hor_coef;
+	ver_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_ver_coef;
+	dvs_binary = ia_css_stream_get_dvs_binary(stream);
+	if (!dvs_binary)
+		return;
+
+	hor_num_3a  = dvs_binary->dis_hor_coef_num_3a;
+	ver_num_3a  = dvs_binary->dis_ver_coef_num_3a;
+	hor_num_isp = dvs_binary->dis_hor_coef_num_isp;
+	ver_num_isp = dvs_binary->dis_ver_coef_num_isp;
+
+	mmgr_load(hor_ptr_isp, hor_coefs_odd_real, hor_num_3a * sizeof(short));
+	hor_ptr_isp += hor_num_isp * sizeof(short);
+	mmgr_load(hor_ptr_isp, hor_coefs_odd_imag, hor_num_3a * sizeof(short));
+	hor_ptr_isp += hor_num_isp * sizeof(short);
+	mmgr_load(hor_ptr_isp, hor_coefs_even_real, hor_num_3a * sizeof(short));
+	hor_ptr_isp += hor_num_isp * sizeof(short);
+	mmgr_load(hor_ptr_isp, hor_coefs_even_imag, hor_num_3a * sizeof(short));
+
+	mmgr_load(ver_ptr_isp, ver_coefs_odd_real, ver_num_3a * sizeof(short));
+	ver_ptr_isp += ver_num_isp * sizeof(short);
+	mmgr_load(ver_ptr_isp, ver_coefs_odd_imag, ver_num_3a * sizeof(short));
+	ver_ptr_isp += ver_num_isp * sizeof(short);
+	mmgr_load(ver_ptr_isp, ver_coefs_even_real, ver_num_3a * sizeof(short));
+	ver_ptr_isp += ver_num_isp * sizeof(short);
+	mmgr_load(ver_ptr_isp, ver_coefs_even_imag, ver_num_3a * sizeof(short));
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_get_isp_dvs2_coefficients() leave\n");
+}
+#endif
+
+hrt_vaddress sh_css_store_sp_group_to_ddr(void)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_store_sp_group_to_ddr() enter & leave:\n");
+	mmgr_store(xmem_sp_group_ptrs,
+			     &sh_css_sp_group,
+			     sizeof(struct sh_css_sp_group));
+	return xmem_sp_group_ptrs;
+}
+
+hrt_vaddress sh_css_store_sp_stage_to_ddr(
+	unsigned pipe,
+	unsigned stage)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_store_sp_stage_to_ddr() enter & leave:\n");
+	mmgr_store(xmem_sp_stage_ptrs[pipe][stage],
+			     &sh_css_sp_stage,
+			     sizeof(struct sh_css_sp_stage));
+	return xmem_sp_stage_ptrs[pipe][stage];
+}
+
+hrt_vaddress sh_css_store_isp_stage_to_ddr(
+	unsigned pipe,
+	unsigned stage)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_store_isp_stage_to_ddr() enter & leave:\n");
+	mmgr_store(xmem_isp_stage_ptrs[pipe][stage],
+			     &sh_css_isp_stage,
+			     sizeof(struct sh_css_isp_stage));
+	return xmem_isp_stage_ptrs[pipe][stage];
+}
+
+static enum ia_css_err ref_sh_css_ddr_address_map(
+	struct sh_css_ddr_address_map *map,
+	struct sh_css_ddr_address_map *out)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	unsigned int i;
+
+	hrt_vaddress *in_addrs = (hrt_vaddress *)map;
+	hrt_vaddress *to_addrs = (hrt_vaddress *)out;
+
+	assert(map != NULL);
+	assert(out != NULL);
+
+	assert(sizeof(struct sh_css_ddr_address_map_size)/sizeof(size_t) ==
+	       sizeof(struct sh_css_ddr_address_map)/sizeof(hrt_vaddress));
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "ref_sh_css_ddr_address_map() enter:\n");
+
+	/* copy map using size info */
+	assert(sizeof(struct sh_css_ddr_address_map_size)/sizeof(size_t) ==
+	       sizeof(struct sh_css_ddr_address_map)/sizeof(hrt_vaddress));
+	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
+						sizeof(size_t)); i++) {
+		to_addrs[i] = mmgr_NULL;
+		if (in_addrs[i] == mmgr_NULL)
+			continue;
+
+		to_addrs[i] = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER, in_addrs[i]);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ref_sh_css_ddr_address_map() leave:\n");
+
+	return err;
+}
+
+static enum ia_css_err write_ia_css_isp_parameter_set_info_to_ddr(
+	struct ia_css_isp_parameter_set_info *me,
+	hrt_vaddress *out)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool succ;
+
+	assert(me != NULL);
+	assert(out != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "write_ia_css_isp_parameter_set_info_to_ddr() enter:\n");
+
+	*out = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_SET_POOL, mmgr_malloc(
+				sizeof(struct ia_css_isp_parameter_set_info)));
+	succ = (*out != mmgr_NULL);
+	if (succ)
+		mmgr_store(*out,
+			me, sizeof(struct ia_css_isp_parameter_set_info));
+	else
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "write_ia_css_isp_parameter_set_info_to_ddr() leave:\n");
+
+	return err;
+}
+
+static enum ia_css_err
+free_ia_css_isp_parameter_set_info(
+	hrt_vaddress ptr)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	struct ia_css_isp_parameter_set_info isp_params_info;
+	unsigned int i;
+	hrt_vaddress *addrs = (hrt_vaddress *)&isp_params_info.mem_map;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_ia_css_isp_parameter_set_info() enter:\n");
+
+	mmgr_load(ptr, &isp_params_info.mem_map, sizeof(struct sh_css_ddr_address_map));
+	/* copy map using size info */
+	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
+						sizeof(size_t)); i++) {
+		if (addrs[i] == mmgr_NULL)
+			continue;
+		ia_css_refcount_decrement(IA_CSS_REFCOUNT_PARAM_BUFFER, addrs[i]);
+	}
+	ia_css_refcount_decrement(IA_CSS_REFCOUNT_PARAM_SET_POOL, ptr);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_ia_css_isp_parameter_set_info() leave:\n");
+
+	return err;
+}
+
+/* Mark all parameters as changed to force recomputing the derived ISP parameters */
+void
+sh_css_invalidate_params(struct ia_css_stream *stream)
+{
+	struct	ia_css_isp_parameters *params;
+	unsigned i, j, mem;
+
+	assert(stream != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "sh_css_invalidate_params() enter:\n");
+
+	params = stream->isp_params_configs;
+	params->isp_params_changed = true;
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		for (j = 0; j < SH_CSS_MAX_STAGES; j++) {
+			for (mem = 0; mem < N_IA_CSS_MEMORIES; mem++) {
+				params->isp_mem_params_changed[i][j][mem] = true;
+			}
+		}
+	}
+
+	memset(&params->config_changed[0], 1, sizeof(params->config_changed));
+	params->dis_coef_table_changed = true;
+	params->dvs2_coef_table_changed = true;
+	params->morph_table_changed = true;
+	params->sc_table_changed = true;
+	params->anr_thres_changed = true;
+	params->dz_config_changed = true;
+	params->motion_config_changed = true;
+
+	/*Free up theDVS table memory blocks before recomputing new table  */
+	if(params->dvs_6axis_config)
+		free_dvs_6axis_table(&(params->dvs_6axis_config));
+	params->dvs_6axis_config_changed = true;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_invalidate_params() leave:\n");
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+void
+sh_css_update_uds_and_crop_info(
+	const struct ia_css_binary_info *info,
+	const struct ia_css_frame_info *in_frame_info,
+	const struct ia_css_frame_info *out_frame_info,
+	const struct ia_css_resolution *dvs_env,
+	bool preview_mode,
+	const struct ia_css_dz_config *zoom,
+	const struct ia_css_vector *motion_vector,
+	struct sh_css_uds_info *uds,		/* out */
+	struct sh_css_crop_pos *sp_out_crop_pos)/* out */
+{
+	assert(info != NULL);
+	assert(in_frame_info != NULL);
+	assert(out_frame_info != NULL);
+	assert(dvs_env != NULL);
+	assert(zoom != NULL);
+	assert(motion_vector != NULL);
+	assert(uds != NULL);
+	assert(sp_out_crop_pos != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+			    "sh_css_update_uds_and_crop_info() enter:\n");
+
+	if (info->mode == IA_CSS_BINARY_MODE_VF_PP && !preview_mode) {
+		/* in non-preview modes, VF_PP does not do
+		   the zooming, capture_pp or video do. */
+		uds->curr_dx = HRT_GDC_N;
+		uds->curr_dy = HRT_GDC_N;
+	} else {
+		uds->curr_dx   = (uint16_t)zoom->dx;
+		uds->curr_dy   = (uint16_t)zoom->dy;
+	}
+
+	if (info->enable.dvs_envelope) {
+		unsigned int crop_x = 0,
+			     crop_y = 0,
+			     uds_xc = 0,
+			     uds_yc = 0,
+			     env_width, env_height;
+		int half_env_x, half_env_y;
+		int motion_x = motion_vector->x;
+		int motion_y = motion_vector->y;
+		bool upscale_x = in_frame_info->res.width < out_frame_info->res.width;
+		bool upscale_y = in_frame_info->res.height < out_frame_info->res.height;
+
+		if (info->enable.uds && !info->enable.ds) {
+			/**
+			 * we calculate with the envelope that we can actually
+			 * use, the min dvs envelope is for the filter
+			 * initialization.
+			 */
+			env_width  = dvs_env->width -
+					SH_CSS_MIN_DVS_ENVELOPE;
+			env_height = dvs_env->height -
+					SH_CSS_MIN_DVS_ENVELOPE;
+			half_env_x = env_width / 2;
+			half_env_y = env_height / 2;
+			/**
+			 * for digital zoom, we use the dvs envelope and make
+			 * sure that we don't include the 8 leftmost pixels or
+			 * 8 topmost rows.
+			 */
+			if (upscale_x) {
+				uds_xc = (in_frame_info->res.width
+					+ env_width
+					+ SH_CSS_MIN_DVS_ENVELOPE) / 2;
+			} else {
+				uds_xc = (out_frame_info->res.width
+							+ env_width) / 2
+					+ SH_CSS_MIN_DVS_ENVELOPE;
+			}
+			if (upscale_y) {
+				uds_yc = (in_frame_info->res.height
+					+ env_height
+					+ SH_CSS_MIN_DVS_ENVELOPE) / 2;
+			} else {
+				uds_yc = (out_frame_info->res.height
+							+ env_height) / 2
+					+ SH_CSS_MIN_DVS_ENVELOPE;
+			}
+			/* clip the motion vector to +/- half the envelope */
+			motion_x = clamp(motion_x, -half_env_x, half_env_x);
+			motion_y = clamp(motion_y, -half_env_y, half_env_y);
+			uds_xc += motion_x;
+			uds_yc += motion_y;
+			/* uds can be pipelined, remove top lines */
+			crop_y = 2;
+		} else if (info->enable.ds) {
+			env_width  = dvs_env->width;
+			env_height = dvs_env->height;
+			half_env_x = env_width / 2;
+			half_env_y = env_height / 2;
+			/* clip the motion vector to +/- half the envelope */
+			motion_x = clamp(motion_x, -half_env_x, half_env_x);
+			motion_y = clamp(motion_y, -half_env_y, half_env_y);
+			/* for video with downscaling, the envelope is included
+			    in the input resolution. */
+			uds_xc = in_frame_info->res.width/2 + motion_x;
+			uds_yc = in_frame_info->res.height/2 + motion_y;
+			crop_x = info->left_cropping;
+			/* ds == 2 (yuv_ds) can be pipelined, remove top
+			   lines */
+			if (info->enable.ds & 1)
+				crop_y = info->top_cropping;
+			else
+				crop_y = 2;
+		} else {
+			/* video nodz: here we can only crop. We make sure we
+			   crop at least the first 8x8 pixels away. */
+			env_width  = dvs_env->width -
+					SH_CSS_MIN_DVS_ENVELOPE;
+			env_height = dvs_env->height -
+					SH_CSS_MIN_DVS_ENVELOPE;
+			half_env_x = env_width / 2;
+			half_env_y = env_height / 2;
+			motion_x = clamp(motion_x, -half_env_x, half_env_x);
+			motion_y = clamp(motion_y, -half_env_y, half_env_y);
+			crop_x = SH_CSS_MIN_DVS_ENVELOPE
+						+ half_env_x + motion_x;
+			crop_y = SH_CSS_MIN_DVS_ENVELOPE
+						+ half_env_y + motion_y;
+		}
+
+		/* Must enforce that the crop position is even */
+		crop_x = EVEN_FLOOR(crop_x);
+		crop_y = EVEN_FLOOR(crop_y);
+		uds_xc = EVEN_FLOOR(uds_xc);
+		uds_yc = EVEN_FLOOR(uds_yc);
+
+		uds->xc = (uint16_t)uds_xc;
+		uds->yc = (uint16_t)uds_yc;
+		sp_out_crop_pos->x = (uint16_t)crop_x;
+		sp_out_crop_pos->y = (uint16_t)crop_y;
+	}
+	else {
+		/* for down scaling, we always use the center of the image */
+		uds->xc = (uint16_t)in_frame_info->res.width / 2;
+		uds->yc = (uint16_t)in_frame_info->res.height / 2;
+		sp_out_crop_pos->x = (uint16_t)info->left_cropping;
+		sp_out_crop_pos->y = (uint16_t)info->top_cropping;
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_update_uds_and_crop_info() leave:\n");
+}
+#endif
+
+#if !defined(IS_ISP_2500_SYSTEM)
+struct ia_css_3a_statistics *
+ia_css_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
+{
+	struct ia_css_3a_statistics *me;
+	int grid_size;
+
+	assert(grid != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_3a_statistics_allocate() enter: grid=%p\n",grid);
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	me->grid = *grid;
+	grid_size = grid->width * grid->height;
+	me->data = sh_css_malloc(grid_size * sizeof(*me->data));
+	if (!me->data)
+		goto err;
+#if !defined(HAS_NO_HMEM)
+	/* No weighted histogram, no structure, treat the histogram data as a byte dump in a byte array */
+	me->rgby_data = (struct ia_css_3a_rgby_output *)sh_css_malloc(sizeof_hmem(HMEM0_ID));
+#else
+	me->rgby_data = NULL;
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_3a_statistics_allocate() leave: return=%p\n",me);
+
+	return me;
+err:
+	ia_css_3a_statistics_free(me);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_3a_statistics_allocate() leave: return=%p\n",NULL);
+
+	return NULL;
+}
+#endif
+
+void
+ia_css_3a_statistics_free(struct ia_css_3a_statistics *me)
+{
+	if (me) {
+		sh_css_free(me->rgby_data);
+		sh_css_free(me->data);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_dvs_statistics *
+ia_css_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_dvs_statistics *me;
+
+	assert(grid != NULL);
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	me->grid = *grid;
+	me->hor_proj = sh_css_malloc(grid->height * IA_CSS_DVS_NUM_COEF_TYPES *
+					sizeof(*me->hor_proj));
+	if (!me->hor_proj)
+		goto err;
+
+	me->ver_proj = sh_css_malloc(grid->width * IA_CSS_DVS_NUM_COEF_TYPES *
+					sizeof(*me->ver_proj));
+	if (!me->ver_proj)
+		goto err;
+
+	return me;
+err:
+	ia_css_dvs_statistics_free(me);
+	return NULL;
+
+}
+
+void
+ia_css_dvs_statistics_free(struct ia_css_dvs_statistics *me)
+{
+	if (me) {
+		sh_css_free(me->hor_proj);
+		sh_css_free(me->ver_proj);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_dvs_coefficients *
+ia_css_dvs_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_dvs_coefficients *me;
+
+	assert(grid != NULL);
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	me->grid = *grid;
+
+	me->hor_coefs = sh_css_malloc(grid->num_hor_coefs *
+				IA_CSS_DVS_NUM_COEF_TYPES *
+				sizeof(*me->hor_coefs));
+	if (!me->hor_coefs)
+		goto err;
+
+	me->ver_coefs = sh_css_malloc(grid->num_ver_coefs *
+				IA_CSS_DVS_NUM_COEF_TYPES *
+				sizeof(*me->ver_coefs));
+	if (!me->ver_coefs)
+		goto err;
+
+	return me;
+err:
+	ia_css_dvs_coefficients_free(me);
+	return NULL;
+}
+
+void
+ia_css_dvs_coefficients_free(struct ia_css_dvs_coefficients *me)
+{
+	if (me) {
+		sh_css_free(me->hor_coefs);
+		sh_css_free(me->ver_coefs);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_dvs2_statistics *
+ia_css_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_dvs2_statistics *me;
+
+	assert(grid != NULL);
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	me->grid = *grid;
+
+	me->hor_prod.odd_real = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->hor_prod.odd_real));
+	if (!me->hor_prod.odd_real)
+		goto err;
+
+	me->hor_prod.odd_imag = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->hor_prod.odd_imag));
+	if (!me->hor_prod.odd_imag)
+		goto err;
+
+	me->hor_prod.even_real = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->hor_prod.even_real));
+	if (!me->hor_prod.even_real)
+		goto err;
+
+	me->hor_prod.even_imag = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->hor_prod.even_imag));
+	if (!me->hor_prod.even_imag)
+		goto err;
+
+	me->ver_prod.odd_real = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->ver_prod.odd_real));
+	if (!me->ver_prod.odd_real)
+		goto err;
+
+	me->ver_prod.odd_imag = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->ver_prod.odd_imag));
+	if (!me->ver_prod.odd_imag)
+		goto err;
+
+	me->ver_prod.even_real = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->ver_prod.even_real));
+	if (!me->ver_prod.even_real)
+		goto err;
+
+	me->ver_prod.even_imag = sh_css_malloc(grid->aligned_width *
+		grid->aligned_height * sizeof(*me->ver_prod.even_imag));
+	if (!me->ver_prod.even_imag)
+		goto err;
+
+	return me;
+err:
+	ia_css_dvs2_statistics_free(me);
+	return NULL;
+
+}
+
+void
+ia_css_dvs2_statistics_free(struct ia_css_dvs2_statistics *me)
+{
+	if (me) {
+		sh_css_free(me->hor_prod.odd_real);
+		sh_css_free(me->hor_prod.odd_imag);
+		sh_css_free(me->hor_prod.even_real);
+		sh_css_free(me->hor_prod.even_imag);
+		sh_css_free(me->ver_prod.odd_real);
+		sh_css_free(me->ver_prod.odd_imag);
+		sh_css_free(me->ver_prod.even_real);
+		sh_css_free(me->ver_prod.even_imag);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_dvs2_coefficients *
+ia_css_dvs2_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
+{
+	struct ia_css_dvs2_coefficients *me;
+
+	assert(grid != NULL);
+
+	me = sh_css_calloc(1,sizeof(*me));
+	if (!me)
+		goto err;
+
+	me->grid = *grid;
+
+	me->hor_coefs.odd_real = sh_css_malloc(grid->num_hor_coefs *
+		sizeof(*me->hor_coefs.odd_real));
+	if (!me->hor_coefs.odd_real)
+		goto err;
+
+	me->hor_coefs.odd_imag = sh_css_malloc(grid->num_hor_coefs *
+		sizeof(*me->hor_coefs.odd_imag));
+	if (!me->hor_coefs.odd_imag)
+		goto err;
+
+	me->hor_coefs.even_real = sh_css_malloc(grid->num_hor_coefs *
+		sizeof(*me->hor_coefs.even_real));
+	if (!me->hor_coefs.even_real)
+		goto err;
+
+	me->hor_coefs.even_imag = sh_css_malloc(grid->num_hor_coefs *
+		sizeof(*me->hor_coefs.even_imag));
+	if (!me->hor_coefs.even_imag)
+		goto err;
+
+	me->ver_coefs.odd_real = sh_css_malloc(grid->num_ver_coefs *
+		sizeof(*me->ver_coefs.odd_real));
+	if (!me->ver_coefs.odd_real)
+		goto err;
+
+	me->ver_coefs.odd_imag = sh_css_malloc(grid->num_ver_coefs *
+		sizeof(*me->ver_coefs.odd_imag));
+	if (!me->ver_coefs.odd_imag)
+		goto err;
+
+	me->ver_coefs.even_real = sh_css_malloc(grid->num_ver_coefs *
+		sizeof(*me->ver_coefs.even_real));
+	if (!me->ver_coefs.even_real)
+		goto err;
+
+	me->ver_coefs.even_imag = sh_css_malloc(grid->num_ver_coefs *
+		sizeof(*me->ver_coefs.even_imag));
+	if (!me->ver_coefs.even_imag)
+		goto err;
+
+	return me;
+err:
+	ia_css_dvs2_coefficients_free(me);
+	return NULL;
+}
+
+void
+ia_css_dvs2_coefficients_free(struct ia_css_dvs2_coefficients *me)
+{
+	if (me) {
+		sh_css_free(me->hor_coefs.odd_real);
+		sh_css_free(me->hor_coefs.odd_imag);
+		sh_css_free(me->hor_coefs.even_real);
+		sh_css_free(me->hor_coefs.even_imag);
+		sh_css_free(me->ver_coefs.odd_real);
+		sh_css_free(me->ver_coefs.odd_imag);
+		sh_css_free(me->ver_coefs.even_real);
+		sh_css_free(me->ver_coefs.even_imag);
+		sh_css_free(me);
+	}
+}
+
+struct ia_css_dvs_6axis_config *
+ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream)
+{
+    struct ia_css_dvs_6axis_config *dvs_config = NULL;
+    struct ia_css_isp_parameters *params = NULL;
+    unsigned int width_y;
+    unsigned int height_y;
+    unsigned int width_uv;
+    unsigned int height_uv;
+
+    assert(stream != NULL);
+    params = stream->isp_params_configs;
+    assert(params != NULL);
+    assert(params->dvs_6axis_config != NULL);
+
+    dvs_config = (struct ia_css_dvs_6axis_config *)sh_css_calloc(1, sizeof(struct ia_css_dvs_6axis_config));
+    if(!dvs_config)
+          goto err;
+
+    dvs_config->width_y = width_y = params->dvs_6axis_config->width_y;
+    dvs_config->height_y = height_y = params->dvs_6axis_config->height_y;
+    dvs_config->width_uv = width_uv = params->dvs_6axis_config->width_uv;
+    dvs_config->height_uv = height_uv = params->dvs_6axis_config->height_uv;
+    ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "config_allocate table Y: W %d H %d\n",width_y,height_y);
+    ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "config_allocate table UV: W %d H %d\n",width_uv,height_uv);
+    dvs_config->xcoords_y = (uint32_t *)sh_css_malloc( width_y * height_y * sizeof(uint32_t));
+    if(!dvs_config->xcoords_y)
+        goto err;
+
+    dvs_config->ycoords_y = (uint32_t *)sh_css_malloc( width_y * height_y * sizeof(uint32_t));
+    if(!dvs_config->ycoords_y)
+        goto err;
+
+    dvs_config->xcoords_uv = (uint32_t *)sh_css_malloc( width_uv * height_uv * sizeof(uint32_t));
+    if(!dvs_config->xcoords_uv)
+        goto err;
+
+    dvs_config->ycoords_uv = (uint32_t *)sh_css_malloc( width_uv * height_uv * sizeof(uint32_t));
+    if(!dvs_config->ycoords_uv)
+        goto err;
+
+    return dvs_config;
+err:
+        ia_css_dvs2_6axis_config_free(dvs_config);
+        return NULL;
+}
+
+void
+ia_css_dvs2_6axis_config_free(struct ia_css_dvs_6axis_config *dvs_6axis_config)
+{
+    if(dvs_6axis_config)
+    {
+        sh_css_free(dvs_6axis_config->xcoords_y);
+        sh_css_free(dvs_6axis_config->ycoords_y);
+        sh_css_free(dvs_6axis_config->xcoords_uv);
+        sh_css_free(dvs_6axis_config->ycoords_uv);
+        sh_css_free(dvs_6axis_config);
+    }
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_params.h b/drivers/media/atomisp2/css2400/sh_css_params.h
new file mode 100644
index 0000000..f1fce87
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_params.h
@@ -0,0 +1,142 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_PARAMS_H_
+#define _SH_CSS_PARAMS_H_
+
+/*! \file */
+
+/* Forward declaration to break mutual dependency */
+struct ia_css_isp_parameters;
+
+#include "ia_css_types.h"
+#include "ia_css.h"
+#include "sh_css_internal.h"
+#include "sh_css_legacy.h"
+#if defined(IS_ISP_2500_SYSTEM)
+#include "product_specific.host.h"
+#endif
+#include "sh_css_defs.h"	/* SH_CSS_MAX_STAGES */
+#include "ia_css_pipeline.h"
+#include "ia_css_isp_params.h"
+#if defined(IS_ISP_2500_SYSTEM)
+#include "ia_css_isp_acc_params.h"
+#endif
+
+#include "ob/ob_1.0/ia_css_ob_param.h"
+#include "crop/crop_1.0/ia_css_crop_types.h"
+#include "uds/uds_1.0/ia_css_uds_param.h"
+
+/* Isp configurations per stream */
+struct sh_css_isp_param_configs {
+	/* OB (Optical Black) */
+	struct sh_css_isp_ob_stream_config ob;
+};
+
+/* Isp parameters per stream */
+struct ia_css_isp_parameters {
+	/* UDS */
+	struct sh_css_sp_uds_params uds[SH_CSS_MAX_STAGES];
+#if !defined(IS_ISP_2500_SYSTEM)
+	struct sh_css_isp_param_configs stream_configs;
+#else
+	struct sh_css_isp_params    isp_parameters;
+#endif
+
+	struct ia_css_fpn_table     fpn_config;
+	struct ia_css_vector	    motion_config;
+	const struct ia_css_morph_table   *morph_table;
+	const struct ia_css_shading_table *sc_table;
+	struct ia_css_shading_table *sc_config;
+	struct ia_css_macc_table    macc_table;
+	struct ia_css_gamma_table   gc_table;
+	struct ia_css_ctc_table     ctc_table;
+	struct ia_css_xnr_table     xnr_table;
+
+	struct ia_css_dz_config     dz_config;
+	struct ia_css_3a_config     s3a_config;
+	struct ia_css_wb_config     wb_config;
+	struct ia_css_cc_config     cc_config;
+	struct ia_css_cc_config     yuv2rgb_cc_config;
+	struct ia_css_cc_config     rgb2yuv_cc_config;
+	struct ia_css_tnr_config    tnr_config;
+	struct ia_css_ob_config     ob_config;
+	struct ia_css_dp_config     dp_config;
+	struct ia_css_nr_config     nr_config;
+	struct ia_css_ee_config     ee_config;
+	struct ia_css_de_config     de_config;
+	struct ia_css_gc_config     gc_config;
+	struct ia_css_anr_config    anr_config;
+	struct ia_css_ce_config     ce_config;
+
+	struct ia_css_dvs_6axis_config	*dvs_6axis_config;
+
+	struct ia_css_ecd_config    ecd_config;
+	struct ia_css_ynr_config    ynr_config;
+	struct ia_css_yee_config    yee_config;
+	struct ia_css_fc_config     fc_config;
+	struct ia_css_cnr_config    cnr_config;
+	struct ia_css_macc_config   macc_config;
+	struct ia_css_ctc_config    ctc_config;
+	struct ia_css_aa_config     aa_config;
+	struct ia_css_aa_config     raw_config;
+	struct ia_css_aa_config     raa_config;
+	struct ia_css_rgb_gamma_table     r_gamma_table;
+	struct ia_css_rgb_gamma_table     g_gamma_table;
+	struct ia_css_rgb_gamma_table     b_gamma_table;
+	struct ia_css_anr_thres     anr_thres;
+	struct ia_css_xnr_config    xnr_config;
+	struct ia_css_uds_config    uds_config;
+	struct ia_css_crop_config   crop_config;
+
+	bool isp_params_changed;
+	bool isp_mem_params_changed
+		[IA_CSS_PIPE_ID_NUM][SH_CSS_MAX_STAGES][IA_CSS_NUM_MEMORIES];
+	bool dz_config_changed;
+	bool motion_config_changed;
+	bool dis_coef_table_changed;
+	bool dvs2_coef_table_changed;
+	bool morph_table_changed;
+	bool sc_table_changed;
+	bool anr_thres_changed;
+	bool dvs_6axis_config_changed;
+
+	bool config_changed[IA_CSS_NUM_PARAMETER_IDS];
+
+	unsigned int sensor_binning;
+	/* local buffers, used to re-order the 3a statistics in vmem-format */
+	const short *dis_hor_coef_tbl;
+	const short *dis_ver_coef_tbl;
+	struct ia_css_dvs2_coef_types dvs2_hor_coefs;
+	struct ia_css_dvs2_coef_types dvs2_ver_coefs;
+	struct sh_css_ddr_address_map pipe_ddr_ptrs[IA_CSS_PIPE_ID_NUM];
+	struct sh_css_ddr_address_map_size pipe_ddr_ptrs_size[IA_CSS_PIPE_ID_NUM];
+	struct sh_css_ddr_address_map ddr_ptrs;
+	struct sh_css_ddr_address_map_size ddr_ptrs_size;
+	struct ia_css_frame *output_frame; /**< Output frame the config is to be applied to (optional) */
+	uint32_t isp_parameters_id; /**< Unique ID to track which config was actually applied to a particular frame */
+};
+
+enum ia_css_err
+sh_css_params_write_to_ddr(struct ia_css_stream *stream,
+			   struct ia_css_pipeline_stage *stage);
+
+#endif /* _SH_CSS_PARAMS_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_params_internal.h b/drivers/media/atomisp2/css2400/sh_css_params_internal.h
new file mode 100644
index 0000000..7382dba
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_params_internal.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_PARAMS_INTERNAL_H_
+#define _SH_CSS_PARAMS_INTERNAL_H_
+
+void
+sh_css_param_clear_param_sets(void);
+
+#endif /* _SH_CSS_PARAMS_INTERNAL_H_ */
diff --git a/drivers/media/atomisp2/css2400/sh_css_properties.c b/drivers/media/atomisp2/css2400/sh_css_properties.c
new file mode 100644
index 0000000..e018993
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_properties.c
@@ -0,0 +1,50 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_properties.h"
+#include <assert_support.h>
+#include "ia_css_types.h"
+#include "gdc_device.h"
+
+void
+ia_css_get_properties(struct ia_css_properties *properties)
+{
+	assert(properties != NULL);
+#if defined(HAS_GDC_VERSION_2) || defined(HAS_GDC_VERSION_3)
+/*
+ * MW: We don't want to store the coordinates
+ * full range in memory: Truncate
+ */
+	properties->gdc_coord_one = gdc_get_unity(GDC0_ID)/HRT_GDC_COORD_SCALE;
+#else
+#error "Unknown GDC version"
+#endif
+
+	properties->l1_base_is_index = true;
+
+#if defined(HAS_VAMEM_VERSION_1)
+	properties->vamem_type = IA_CSS_VAMEM_TYPE_1;
+#elif defined(HAS_VAMEM_VERSION_2)
+	properties->vamem_type = IA_CSS_VAMEM_TYPE_2;
+#else
+#error "Unknown VAMEM version"
+#endif
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_sp.c b/drivers/media/atomisp2/css2400/sh_css_sp.c
new file mode 100644
index 0000000..bac9ffb
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_sp.c
@@ -0,0 +1,1793 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "sh_css_sp.h"
+
+#if !defined(HAS_NO_INPUT_FORMATTER)
+#include "input_formatter.h"
+#endif
+
+#include "dma.h"	/* N_DMA_CHANNEL_ID */
+
+#include "ia_css.h"
+#include "ia_css_binary.h"
+#include "sh_css_hrt.h"
+#include "sh_css_defs.h"
+#include "sh_css_internal.h"
+#include "ia_css_debug.h"
+#include "ia_css_debug_pipe.h"
+#include "ia_css_stream.h"
+#include "ia_css_isp_param.h"
+#include "sh_css_params.h"
+#include "sh_css_legacy.h"
+#include "ia_css_frame_comm.h"
+#if !defined(HAS_NO_INPUT_SYSTEM)
+#include "ia_css_isys.h"
+#endif
+
+#include "gdc_device.h"				/* HRT_GDC_N */
+
+/*#include "sp.h"*/	/* host2sp_enqueue_frame_data() */
+
+#include "memory_access.h"
+
+#include "assert_support.h"
+#include "platform_support.h"	/* hrt_sleep() */
+
+#include "sw_event_global.h"   			/* Event IDs.*/
+#include "ia_css_event.h"
+#include "mmu_device.h"
+#include "ia_css_spctrl.h"
+
+#ifndef offsetof
+#define offsetof(T, x) ((unsigned)&(((T *)0)->x))
+#endif
+
+#define IA_CSS_INCLUDE_CONFIGURATIONS
+#include "ia_css_isp_configs.h"
+#define IA_CSS_INCLUDE_STATES
+#include "ia_css_isp_states.h"
+
+struct sh_css_sp_group		sh_css_sp_group;
+struct sh_css_sp_stage		sh_css_sp_stage;
+struct sh_css_isp_stage		sh_css_isp_stage;
+struct sh_css_sp_output		sh_css_sp_output;
+static struct sh_css_sp_per_frame_data per_frame_data;
+
+/* true if SP supports frame loop and host2sp_commands */
+/* For the moment there is only code that sets this bool to true */
+/* TODO: add code that sets this bool to false */
+static bool sp_running;
+#if defined(IS_ISP_2500_SYSTEM)
+static bool sp1_running;
+#endif
+
+static enum ia_css_err
+set_output_frame_buffer(const struct ia_css_frame *frame,
+			unsigned idx);
+
+/* This data is stored every frame */
+void
+store_sp_group_data(void)
+{
+	per_frame_data.sp_group_addr = sh_css_store_sp_group_to_ddr();
+}
+
+static void
+copy_isp_stage_to_sp_stage(void)
+{
+	sh_css_sp_stage.num_stripes = (uint8_t) sh_css_isp_stage.binary_info.num_stripes; // [WW07.5]type casting will cause potential issues
+	sh_css_sp_stage.row_stripes_height = (uint16_t) sh_css_isp_stage.binary_info.row_stripes_height; // [WW07.5]type casting will cause potential issues
+	sh_css_sp_stage.row_stripes_overlap_lines = (uint16_t) sh_css_isp_stage.binary_info.row_stripes_overlap_lines; // [WW07.5]type casting will cause potential issues
+	sh_css_sp_stage.top_cropping = (uint16_t) sh_css_isp_stage.binary_info.top_cropping; // [WW07.5]type casting will cause potential issues
+// moved to sh_css_sp_init_stage
+//	sh_css_sp_stage.enable.vf_output =
+//		sh_css_isp_stage.binary_info.enable.vf_veceven ||
+//		sh_css_isp_stage.binary_info.num_output_pins > 1;
+	sh_css_sp_stage.enable.sdis = sh_css_isp_stage.binary_info.enable.dis;
+	sh_css_sp_stage.enable.s3a = sh_css_isp_stage.binary_info.enable.s3a;
+#if defined(IS_ISP_2500_SYSTEM)
+	sh_css_sp_stage.enable.dvs_stats = sh_css_isp_stage.binary_info.enable.dvs_stats;
+	sh_css_sp_stage.enable.lace_stats = sh_css_isp_stage.binary_info.enable.lace_stats;
+#endif
+}
+
+void
+store_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num, unsigned stage)
+{
+	unsigned int thread_id;
+	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+	copy_isp_stage_to_sp_stage();
+	if (id != IA_CSS_PIPE_ID_COPY)
+		sh_css_sp_stage.isp_stage_addr =
+			sh_css_store_isp_stage_to_ddr(pipe_num, stage);
+	sh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] =
+		sh_css_store_sp_stage_to_ddr(pipe_num, stage);
+
+	/* Clear for next frame */
+	sh_css_sp_stage.program_input_circuit = false;
+}
+
+static void
+store_sp_per_frame_data(const struct ia_css_fw_info *fw)
+{
+	unsigned int HIVE_ADDR_sp_per_frame_data = 0;
+
+	assert(fw != NULL);
+
+	switch (fw->type) {
+	case ia_css_sp_firmware:
+		HIVE_ADDR_sp_per_frame_data = fw->info.sp.per_frame_data;
+		break;
+#if defined(IS_ISP_2500_SYSTEM)
+	case ia_css_sp1_firmware:
+		(void)fw;
+		break;
+#endif
+	case ia_css_acc_firmware:
+		HIVE_ADDR_sp_per_frame_data = fw->info.acc.per_frame_data;
+		break;
+	case ia_css_isp_firmware:
+		return;
+	}
+
+	sp_dmem_store(SP0_ID,
+		(unsigned int)sp_address_of(sp_per_frame_data),
+		&per_frame_data,
+			sizeof(per_frame_data));
+}
+
+static void
+sh_css_store_sp_per_frame_data(enum ia_css_pipe_id pipe_id,
+				   unsigned int pipe_num,
+			       const struct ia_css_fw_info *sp_fw)
+{
+	if (!sp_fw)
+		sp_fw = &sh_css_sp_fw;
+
+	store_sp_stage_data(pipe_id, pipe_num, 0);
+	store_sp_group_data();
+	store_sp_per_frame_data(sp_fw);
+}
+
+#if SP_DEBUG != SP_DEBUG_NONE
+
+void
+sh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
+	unsigned i;
+	unsigned o = offsetof(struct sh_css_sp_output, debug)/sizeof(int);
+
+	assert(state != NULL);
+
+	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
+	for (i = 0; i < sizeof(*state)/sizeof(int); i++)
+		((unsigned *)state)[i] = load_sp_array_uint(sp_output, i+o);
+}
+
+#endif
+
+void
+sh_css_sp_start_binary_copy(unsigned int pipe_num, struct ia_css_frame *out_frame,
+			    unsigned two_ppc)
+{
+	enum ia_css_pipe_id pipe_id;
+	unsigned int thread_id;
+	struct sh_css_sp_pipeline *pipe;
+	uint8_t stage_num = 0;
+
+	assert(out_frame != NULL);
+	pipe_id = IA_CSS_PIPE_ID_CAPTURE;
+	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+	pipe = &sh_css_sp_group.pipe[thread_id];
+
+	pipe->copy.bin.bytes_available = out_frame->data_bytes;
+	pipe->num_stages = 1;
+	pipe->pipe_id = pipe_id;
+	pipe->pipe_num = pipe_num;
+	pipe->thread_id = thread_id;
+	pipe->pipe_config = 0x0; /* No parameters */
+
+	if(pipe->inout_port_config == 0)
+	{
+		SH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,
+						(uint8_t)SH_CSS_PORT_INPUT,
+						(uint8_t)SH_CSS_HOST_TYPE,1);
+		SH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,
+						(uint8_t)SH_CSS_PORT_OUTPUT,
+						(uint8_t)SH_CSS_HOST_TYPE,1);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_sp_start_binary_copy pipe_id %d port_config %08x\n",pipe->pipe_id,pipe->inout_port_config);
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_sp_start_binary_copy pipe_id %d port_config %08x\n",pipe->pipe_id,pipe->inout_port_config);
+
+#if !defined(HAS_NO_INPUT_FORMATTER)
+	sh_css_sp_group.config.input_formatter.isp_2ppc = (uint8_t)two_ppc;
+#else
+	(void)two_ppc;
+#endif
+
+	sh_css_sp_stage.num = stage_num;
+	sh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;
+	sh_css_sp_stage.func =
+		(unsigned int)IA_CSS_PIPELINE_BIN_COPY;
+
+	set_output_frame_buffer(out_frame, 0);
+
+	/* sp_bin_copy_init on the SP does not deal with dynamica/static yet */
+	/* For now always update the dynamic data from out frames. */
+	sh_css_store_sp_per_frame_data(pipe_id, pipe_num, &sh_css_sp_fw);
+}
+
+static void
+sh_css_sp_start_raw_copy(struct ia_css_frame *out_frame,
+			 unsigned pipe_num,
+			 unsigned two_ppc,
+			 unsigned max_input_width,
+			 enum sh_css_pipe_config_override pipe_conf_override,
+			 unsigned int if_config_index)
+{
+	enum ia_css_pipe_id pipe_id;
+	unsigned int thread_id;
+	uint8_t stage_num = 0;
+	struct sh_css_sp_pipeline *pipe;
+
+	assert(out_frame != NULL);
+
+	{
+		/**
+		 * Clear sh_css_sp_stage for easy debugging.
+		 * program_input_circuit must be saved as it is set outside
+		 * this function.
+		 */
+		uint8_t program_input_circuit;
+		program_input_circuit = sh_css_sp_stage.program_input_circuit;
+		memset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));
+		sh_css_sp_stage.program_input_circuit = program_input_circuit;
+	}
+
+	pipe_id = IA_CSS_PIPE_ID_COPY;
+	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+	pipe = &sh_css_sp_group.pipe[thread_id];
+
+	pipe->copy.raw.height	    = out_frame->info.res.height;
+	pipe->copy.raw.width	    = out_frame->info.res.width;
+	pipe->copy.raw.padded_width  = out_frame->info.padded_width;
+	pipe->copy.raw.raw_bit_depth = out_frame->info.raw_bit_depth;
+	pipe->copy.raw.max_input_width = max_input_width;
+	pipe->num_stages = 1;
+	pipe->pipe_id = pipe_id;
+	/* TODO: next indicates from which queues parameters need to be
+		 sampled, needs checking/improvement */
+	if (pipe_conf_override == SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD)
+		pipe->pipe_config =
+			(SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id);
+	else
+		pipe->pipe_config = pipe_conf_override;
+
+
+	if(pipe->inout_port_config == 0)
+	{
+		SH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,
+						(uint8_t)SH_CSS_PORT_INPUT,
+						(uint8_t)SH_CSS_HOST_TYPE,1);
+		SH_CSS_PIPE_PORT_CONFIG_SET(pipe->inout_port_config,
+						(uint8_t)SH_CSS_PORT_OUTPUT,
+						(uint8_t)SH_CSS_HOST_TYPE,1);
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_sp_start_raw_copy pipe_id %d port_config %08x\n",pipe->pipe_id,pipe->inout_port_config);
+	}
+
+#if !defined(HAS_NO_INPUT_FORMATTER)
+	sh_css_sp_group.config.input_formatter.isp_2ppc = (uint8_t)two_ppc;
+#else
+	(void)two_ppc;
+#endif
+
+	sh_css_sp_stage.num = stage_num;
+#if 0
+	sh_css_sp_stage.xmem_bin_addr = binary->info->xmem_addr;
+#else
+	sh_css_sp_stage.xmem_bin_addr = 0x0;
+#endif
+	sh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;
+	sh_css_sp_stage.func = (unsigned int)IA_CSS_PIPELINE_RAW_COPY;
+	sh_css_sp_stage.if_config_index = (uint8_t) if_config_index;
+	set_output_frame_buffer(out_frame, 0);
+
+#if 0
+	/* sp_raw_copy_init on the SP does not deal with dynamica/static yet */
+	/* For now always update the dynamic data from out frames. */
+	sh_css_store_sp_per_frame_data(pipe_id, 0, &sh_css_sp_fw);
+#endif
+	ia_css_debug_pipe_graph_dump_sp_raw_copy(out_frame);
+}
+
+static void
+sh_css_sp_start_isys_copy(struct ia_css_frame *out_frame,
+	unsigned pipe_num, unsigned max_input_width)
+{
+	enum ia_css_pipe_id pipe_id;
+	unsigned int thread_id;
+	uint8_t stage_num = 0;
+	struct sh_css_sp_pipeline *pipe;
+	int i;
+#if defined SH_CSS_ENABLE_METADATA
+	int queue_id;
+#endif
+
+assert(out_frame != NULL);
+
+    {
+        /**
+         * Clear sh_css_sp_stage for easy debugging.
+         * program_input_circuit must be saved as it is set outside
+         * this function.
+         */
+        uint8_t program_input_circuit;
+        program_input_circuit = sh_css_sp_stage.program_input_circuit;
+        memset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));
+        sh_css_sp_stage.program_input_circuit = program_input_circuit;
+    }
+
+	pipe_id = IA_CSS_PIPE_ID_COPY;
+	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+	pipe = &sh_css_sp_group.pipe[thread_id];
+
+	pipe->copy.raw.height	    	= out_frame->info.res.height;
+	pipe->copy.raw.width	    	= out_frame->info.res.width;
+	pipe->copy.raw.padded_width  	= out_frame->info.padded_width;
+	pipe->copy.raw.raw_bit_depth 	= out_frame->info.raw_bit_depth;
+	pipe->copy.raw.max_input_width 	= max_input_width;
+	pipe->num_stages 		= 1;
+	pipe->pipe_id 			= pipe_id;
+	pipe->pipe_config 		= 0x0;	/* No parameters */
+
+	/* Clean static frame info before we update it */
+	/*
+	 * TODO: Initialize the static frame data with
+	 * "sh_css_frame_null".
+	 */
+	for (i = 0; i < IA_CSS_NUM_BUFFER_TYPE; i++)
+		/* Here, we do not initialize it to zero for now
+		 * to be able to recognize non-updated elements
+		 * This is what it should become:
+		 * sh_css_sp_stage.frames.static_frame_data[i] = mmgr_NULL;
+		 */
+		sh_css_sp_stage.frames.static_frame_data[i] = mmgr_EXCEPTION;
+
+	sh_css_sp_stage.num = stage_num;
+	sh_css_sp_stage.xmem_bin_addr = 0x0;
+	sh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;
+	sh_css_sp_stage.func = (unsigned int)IA_CSS_PIPELINE_ISYS_COPY;
+
+	set_output_frame_buffer(out_frame, 0);
+
+#if defined SH_CSS_ENABLE_METADATA
+	if (pipe->metadata.height > 0) {
+		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_METADATA, thread_id, &queue_id);
+		sh_css_sp_stage.frames.static_frame_data[IA_CSS_BUFFER_TYPE_METADATA] = queue_id;
+	}
+#endif
+
+	ia_css_debug_pipe_graph_dump_sp_raw_copy(out_frame);
+}
+
+unsigned int
+sh_css_sp_get_binary_copy_size(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
+	unsigned int o = offsetof(struct sh_css_sp_output,
+				bin_copy_bytes_copied) / sizeof(int);
+	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
+	return load_sp_array_uint(sp_output, o);
+}
+
+unsigned int
+sh_css_sp_get_sw_interrupt_value(unsigned int irq)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
+	unsigned int o = offsetof(struct sh_css_sp_output, sw_interrupt_value)
+				/ sizeof(int);
+	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
+	return load_sp_array_uint(sp_output, o+irq);
+}
+
+static void
+sh_css_copy_frame_to_spframe(struct ia_css_frame_sp *sp_frame_out,
+				const struct ia_css_frame *frame_in,
+				enum ia_css_buffer_type type)
+{
+	assert(frame_in != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
+		"sh_css_copy_frame_to_spframe frame id %d ptr 0x%08x\n",
+		type,
+		sh_css_sp_stage.frames.static_frame_data[type]);
+
+
+	if (frame_in->dynamic_data_index >= 0) {
+		assert((type == IA_CSS_BUFFER_TYPE_INPUT_FRAME) ||
+				(type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME) ||
+				(type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME) ||
+				(type == IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME) ||
+				(type == IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME));
+		/*
+		 * value >=0 indicates that function init_frame_pointers()
+		 * should use the dynamic data address
+		 */
+		assert(frame_in->dynamic_data_index <
+					SH_CSS_MAX_NUM_QUEUES);
+
+		/* Klocwork assumes assert can be disabled;
+		   Since we can get there with any type, and it does not
+		   know that frame_in->dynamic_data_index can only be set
+		   for one of the types in the assert) it has to assume we
+		   can get here for any type. however this could lead to an
+		   out of bounds reference when indexing buf_type about 10
+		   lines below. In order to satisfy KW an additional if
+		   has been added. This one will always yield true.
+		 */
+		if (((type == IA_CSS_BUFFER_TYPE_INPUT_FRAME) ||
+		     (type == IA_CSS_BUFFER_TYPE_OUTPUT_FRAME) ||
+		     (type == IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME) ||
+			 (type == IA_CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME) ||
+			 (type == IA_CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME))  &&
+		    (frame_in->dynamic_data_index < SH_CSS_MAX_NUM_QUEUES))
+		{
+			/*
+			 * static_frame_data is overloaded, small values (<3) are
+			 * the dynamic index, large values are the static address
+			 */
+			sh_css_sp_stage.frames.static_frame_data[type] =
+							frame_in->dynamic_data_index;
+			sh_css_sp_stage.frames.buf_type[type] = frame_in->buf_type;
+		}
+	} else {
+		sh_css_sp_stage.frames.static_frame_data[type] = frame_in->data;
+	}
+
+	if (!sp_frame_out)
+		return;
+
+	ia_css_frame_info_to_frame_sp_info(&sp_frame_out->info, &frame_in->info);
+
+	switch (frame_in->info.format) {
+	case IA_CSS_FRAME_FORMAT_RAW_PACKED:
+	case IA_CSS_FRAME_FORMAT_RAW:
+		sp_frame_out->planes.raw.offset = frame_in->planes.raw.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_RGB565:
+	case IA_CSS_FRAME_FORMAT_RGBA888:
+		sp_frame_out->planes.rgb.offset = frame_in->planes.rgb.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_PLANAR_RGB888:
+		sp_frame_out->planes.planar_rgb.r.offset =
+			frame_in->planes.planar_rgb.r.offset;
+		sp_frame_out->planes.planar_rgb.g.offset =
+			frame_in->planes.planar_rgb.g.offset;
+		sp_frame_out->planes.planar_rgb.b.offset =
+			frame_in->planes.planar_rgb.b.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_UYVY:
+	case IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+		sp_frame_out->planes.yuyv.offset = frame_in->planes.yuyv.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_NV11:
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV16:
+	case IA_CSS_FRAME_FORMAT_NV61:
+		sp_frame_out->planes.nv.y.offset =
+			frame_in->planes.nv.y.offset;
+		sp_frame_out->planes.nv.uv.offset =
+			frame_in->planes.nv.uv.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YUV422:
+	case IA_CSS_FRAME_FORMAT_YUV444:
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+	case IA_CSS_FRAME_FORMAT_YUV422_16:
+	case IA_CSS_FRAME_FORMAT_YV12:
+	case IA_CSS_FRAME_FORMAT_YV16:
+		sp_frame_out->planes.yuv.y.offset =
+			frame_in->planes.yuv.y.offset;
+		sp_frame_out->planes.yuv.u.offset =
+			frame_in->planes.yuv.u.offset;
+		sp_frame_out->planes.yuv.v.offset =
+			frame_in->planes.yuv.v.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+		sp_frame_out->planes.plane6.r.offset =
+			frame_in->planes.plane6.r.offset;
+		sp_frame_out->planes.plane6.r_at_b.offset =
+			frame_in->planes.plane6.r_at_b.offset;
+		sp_frame_out->planes.plane6.gr.offset =
+			frame_in->planes.plane6.gr.offset;
+		sp_frame_out->planes.plane6.gb.offset =
+			frame_in->planes.plane6.gb.offset;
+		sp_frame_out->planes.plane6.b.offset =
+			frame_in->planes.plane6.b.offset;
+		sp_frame_out->planes.plane6.b_at_r.offset =
+			frame_in->planes.plane6.b_at_r.offset;
+		break;
+	case IA_CSS_FRAME_FORMAT_BINARY_8:
+		sp_frame_out->planes.binary.data.offset =
+			frame_in->planes.binary.data.offset;
+		break;
+	default:
+		/* This should not happen, but in case it does,
+		 * nullify the planes
+		 */
+		memset(&sp_frame_out->planes, 0, sizeof(sp_frame_out->planes));
+		break;
+	}
+
+}
+
+static enum ia_css_err
+set_input_frame_buffer(const struct ia_css_frame *frame)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	switch (frame->info.format) {
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+	case IA_CSS_FRAME_FORMAT_RAW_PACKED:
+	case IA_CSS_FRAME_FORMAT_RAW:
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+	case IA_CSS_FRAME_FORMAT_NV12:
+		break;
+	default:
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.in, frame,
+					IA_CSS_BUFFER_TYPE_INPUT_FRAME);
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_output_frame_buffer(const struct ia_css_frame *frame,
+			unsigned idx)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	switch (frame->info.format) {
+	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YUV422:
+	case IA_CSS_FRAME_FORMAT_YUV444:
+	case IA_CSS_FRAME_FORMAT_YV12:
+	case IA_CSS_FRAME_FORMAT_YV16:
+	case IA_CSS_FRAME_FORMAT_YUV420_16:
+	case IA_CSS_FRAME_FORMAT_YUV422_16:
+	case IA_CSS_FRAME_FORMAT_NV11:
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV16:
+	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV61:
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_UYVY:
+	case IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+	case IA_CSS_FRAME_FORMAT_RGB565:
+	case IA_CSS_FRAME_FORMAT_RGBA888:
+	case IA_CSS_FRAME_FORMAT_PLANAR_RGB888:
+	case IA_CSS_FRAME_FORMAT_RAW:
+	case IA_CSS_FRAME_FORMAT_RAW_PACKED:
+	case IA_CSS_FRAME_FORMAT_QPLANE6:
+	case IA_CSS_FRAME_FORMAT_BINARY_8:
+		break;
+	default:
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.out[idx], frame,
+					IA_CSS_BUFFER_TYPE_OUTPUT_FRAME + idx);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_video_delay_frame_buffer(const struct ia_css_frame *frame, unsigned index)
+{
+	enum ia_css_buffer_type id = IA_CSS_BUFFER_TYPE_VIDEO_DELAY_0 + index;
+
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (frame->info.format != IA_CSS_FRAME_FORMAT_YUV420 && frame->info.format != IA_CSS_FRAME_FORMAT_YUV420_16)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	if (index >= NUM_VIDEO_DELAY_FRAMES) /* this cannot happen but Klocwork does not see this */
+		return IA_CSS_ERR_INTERNAL_ERROR;
+
+	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.delay_frames[index], frame, id);
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+set_view_finder_buffer(const struct ia_css_frame *frame)
+{
+	if (frame == NULL)
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+
+	switch (frame->info.format) {
+	// the dual output pin
+	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_YUYV:
+	case IA_CSS_FRAME_FORMAT_UYVY:
+	case IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:
+
+	// for vf_veceven
+	case IA_CSS_FRAME_FORMAT_YUV_LINE:
+		break;
+	default:
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.out_vf, frame,
+					IA_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME);
+	return IA_CSS_SUCCESS;
+}
+
+#if !defined(HAS_NO_INPUT_FORMATTER)
+void sh_css_sp_set_if_configs(
+	const input_formatter_cfg_t	*config_a,
+	const input_formatter_cfg_t	*config_b,
+	const uint8_t 		if_config_index
+	)
+{
+	assert(if_config_index < SH_CSS_MAX_IF_CONFIGS);
+	assert(config_a != NULL);
+
+	sh_css_sp_group.config.input_formatter.set[if_config_index].config_a = *config_a;
+	sh_css_sp_group.config.input_formatter.a_changed = true;
+
+	if (config_b != NULL) {
+		sh_css_sp_group.config.input_formatter.set[if_config_index].config_b = *config_b;
+		sh_css_sp_group.config.input_formatter.b_changed = true;
+	}
+
+	return;
+}
+#endif
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+void
+sh_css_sp_program_input_circuit(int fmt_type,
+				int ch_id,
+				enum ia_css_input_mode input_mode)
+{
+	sh_css_sp_group.config.input_circuit.no_side_band = false;
+	sh_css_sp_group.config.input_circuit.fmt_type     = fmt_type;
+	sh_css_sp_group.config.input_circuit.ch_id	      = ch_id;
+	sh_css_sp_group.config.input_circuit.input_mode   = input_mode;
+/*
+ * The SP group is only loaded at SP boot time and is read once
+ * change flags as "input_circuit_cfg_changed" must be reset on the SP
+ */
+	sh_css_sp_group.config.input_circuit_cfg_changed = true;
+	sh_css_sp_stage.program_input_circuit = true;
+}
+#endif
+
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+void
+sh_css_sp_configure_sync_gen(int width, int height,
+			     int hblank_cycles,
+			     int vblank_cycles)
+{
+	sh_css_sp_group.config.sync_gen.width	       = width;
+	sh_css_sp_group.config.sync_gen.height	       = height;
+	sh_css_sp_group.config.sync_gen.hblank_cycles = hblank_cycles;
+	sh_css_sp_group.config.sync_gen.vblank_cycles = vblank_cycles;
+}
+
+void
+sh_css_sp_configure_tpg(int x_mask,
+			int y_mask,
+			int x_delta,
+			int y_delta,
+			int xy_mask)
+{
+	sh_css_sp_group.config.tpg.x_mask  = x_mask;
+	sh_css_sp_group.config.tpg.y_mask  = y_mask;
+	sh_css_sp_group.config.tpg.x_delta = x_delta;
+	sh_css_sp_group.config.tpg.y_delta = y_delta;
+	sh_css_sp_group.config.tpg.xy_mask = xy_mask;
+}
+
+void
+sh_css_sp_configure_prbs(int seed)
+{
+	sh_css_sp_group.config.prbs.seed = seed;
+}
+#endif
+
+static enum ia_css_err
+sh_css_sp_write_frame_pointers(const struct sh_css_binary_args *args)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	int i;
+
+	assert(args != NULL);
+
+	if (args->in_frame)
+		err = set_input_frame_buffer(args->in_frame);
+	if (err == IA_CSS_SUCCESS && args->out_vf_frame)
+		err = set_view_finder_buffer(args->out_vf_frame);
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		if (err == IA_CSS_SUCCESS && args->out_frame[i])
+			err = set_output_frame_buffer(args->out_frame[i], i);
+	}
+	for (i = 0; i < NUM_VIDEO_DELAY_FRAMES; i++) {
+		if (err == IA_CSS_SUCCESS && args->delay_frames[i]) {
+			err = set_video_delay_frame_buffer(
+					args->delay_frames[i], i);
+		}
+	}
+
+
+	/* we don't pass this error back to the upper layer, so we add a assert here
+	   because we actually hit the error here but it still works by accident... */
+	if (err != IA_CSS_SUCCESS) assert(false);
+	return err;
+}
+
+void
+sh_css_sp_init_group(bool two_ppc,
+			enum ia_css_stream_format input_format,
+			bool no_isp_sync,
+			uint8_t if_config_index
+			)
+{
+#if !defined(HAS_NO_INPUT_FORMATTER)
+	sh_css_sp_group.config.input_formatter.isp_2ppc = two_ppc;
+#else
+	(void)two_ppc;
+#endif
+
+	sh_css_sp_group.config.no_isp_sync = (uint8_t)no_isp_sync;
+	/* decide whether the frame is processed online or offline */
+	if (if_config_index == SH_CSS_IF_CONFIG_NOT_NEEDED) return;
+#if !defined(HAS_NO_INPUT_FORMATTER)
+	assert(if_config_index < SH_CSS_MAX_IF_CONFIGS);
+	sh_css_sp_group.config.input_formatter.set[if_config_index].stream_format = input_format;
+#else
+	(void)input_format;
+#endif
+}
+
+void
+sh_css_stage_write_binary_info(struct ia_css_binary_info *info)
+{
+	assert(info != NULL);
+	sh_css_isp_stage.binary_info = *info;
+}
+
+static enum ia_css_err
+copy_isp_mem_if_to_ddr(struct ia_css_binary *binary)
+{
+	enum ia_css_err err;
+
+	err = ia_css_isp_param_copy_isp_mem_if_to_ddr(
+		&binary->css_params,
+		&binary->mem_params,
+		IA_CSS_PARAM_CLASS_CONFIG);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	err = ia_css_isp_param_copy_isp_mem_if_to_ddr(
+		&binary->css_params,
+		&binary->mem_params,
+		IA_CSS_PARAM_CLASS_STATE);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+	return IA_CSS_SUCCESS;
+}
+
+static bool
+is_sp_stage(struct ia_css_pipeline_stage *stage)
+{
+	assert(stage != NULL);
+	return stage->sp_func != IA_CSS_PIPELINE_NO_FUNC;
+}
+
+static void
+configure_isp_from_args(
+	const struct sh_css_sp_pipeline *pipe,
+	const struct ia_css_binary      *binary,
+	const struct sh_css_binary_args *args,
+	bool two_ppc,
+	bool deinterleaved)
+{
+#if !defined(IS_ISP_2500_SYSTEM)
+	ia_css_fpn_configure   (binary,  &binary->in_frame_info);
+	ia_css_crop_configure  (binary, &args->delay_frames[0]->info);
+	ia_css_qplane_configure(pipe, binary, &binary->in_frame_info);
+	ia_css_output0_configure(binary, &args->out_frame[0]->info);
+	ia_css_output1_configure(binary, &args->out_vf_frame->info);
+	ia_css_copy_output_configure(binary, &args->out_frame[0]->info);
+	ia_css_output0_configure(binary, &args->out_frame[0]->info);
+#endif
+	ia_css_iterator_configure (binary, &args->in_frame->info);
+	ia_css_ref_configure   (binary, &args->delay_frames[0]->info);
+	ia_css_dvs_configure   (binary, &args->out_frame[0]->info);
+	ia_css_output_configure(binary, &args->out_frame[0]->info);
+	ia_css_raw_configure   (pipe, binary, &args->in_frame->info, &binary->in_frame_info, two_ppc, deinterleaved);
+	ia_css_tnr_configure   (binary, (const struct ia_css_frame **)args->tnr_frames);
+}
+
+static void
+initialize_isp_states(const struct ia_css_binary *binary)
+{
+	unsigned int i;
+
+	for (i = 0; i < IA_CSS_NUM_STATE_IDS; i++) {
+		ia_css_kernel_init_state[i](binary);
+	}
+}
+
+static enum ia_css_err
+sh_css_sp_init_stage(struct ia_css_binary *binary,
+		    const char *binary_name,
+		    const struct ia_css_blob_info *blob_info,
+		    const struct sh_css_binary_args *args,
+		    unsigned int pipe_num,
+		    unsigned stage,
+		    bool xnr,
+		    const struct ia_css_isp_param_css_segments *isp_mem_if,
+		    unsigned int if_config_index,
+		    enum ia_css_frame_delay frame_delay,
+		    bool two_ppc)
+{
+	const struct ia_css_binary_xinfo *xinfo;
+	const struct ia_css_binary_info  *info;
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	int i;
+
+	unsigned int thread_id;
+	enum sh_css_queue_id queue_id;
+	bool continuous = sh_css_continuous_is_enabled((uint8_t)pipe_num);
+
+	assert(binary != NULL);
+	assert(blob_info != NULL);
+	assert(args != NULL);
+	assert(isp_mem_if != NULL);
+
+	xinfo = binary->info;
+	info  = &xinfo->sp;
+	{
+		/**
+		 * Clear sh_css_sp_stage for easy debugging.
+		 * program_input_circuit must be saved as it is set outside
+		 * this function.
+		 */
+		uint8_t program_input_circuit;
+		program_input_circuit = sh_css_sp_stage.program_input_circuit;
+		memset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));
+		sh_css_sp_stage.program_input_circuit = (uint8_t)program_input_circuit;
+	}
+
+	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+
+	if (info == NULL) {
+		sh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] = mmgr_NULL;
+		return IA_CSS_SUCCESS;
+	}
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+	(void)continuous;
+	sh_css_sp_stage.deinterleaved = 0;
+#else
+	sh_css_sp_stage.deinterleaved = ((stage == 0) && continuous);
+#endif
+
+	/*
+	 * TODO: Make the Host dynamically determine
+	 * the stage type.
+	 */
+	sh_css_sp_stage.stage_type = SH_CSS_ISP_STAGE_TYPE;
+	sh_css_sp_stage.num		= (uint8_t)stage;
+	sh_css_sp_stage.isp_online	= (uint8_t)binary->online;
+	sh_css_sp_stage.isp_copy_vf     = (uint8_t)args->copy_vf;
+	sh_css_sp_stage.isp_copy_output = (uint8_t)args->copy_output;
+	sh_css_sp_stage.enable.vf_output = (args->out_vf_frame != NULL);
+
+	/* Copy the frame infos first, to be overwritten by the frames,
+	   if these are present.
+	*/
+	sh_css_sp_stage.frames.effective_in_res.width = binary->effective_in_frame_res.width;
+	sh_css_sp_stage.frames.effective_in_res.height = binary->effective_in_frame_res.height;
+
+	ia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.in.info,
+				&binary->in_frame_info);
+	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
+		ia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.out[i].info,
+					&binary->out_frame_info[i]);
+	}
+	ia_css_frame_info_to_frame_sp_info(&sh_css_sp_stage.frames.internal_frame_info,
+				&binary->internal_frame_info);
+	sh_css_sp_stage.dvs_envelope.width    = binary->dvs_envelope.width;
+	sh_css_sp_stage.dvs_envelope.height   = binary->dvs_envelope.height;
+	sh_css_sp_stage.dvs_frame_delay       = (uint32_t)frame_delay;
+	sh_css_sp_stage.isp_pipe_version      = (uint8_t)info->isp_pipe_version;
+	sh_css_sp_stage.isp_deci_log_factor   = (uint8_t)binary->deci_factor_log2;
+	sh_css_sp_stage.isp_vf_downscale_bits = (uint8_t)binary->vf_downscale_log2;
+
+	sh_css_sp_stage.if_config_index = (uint8_t) if_config_index;
+
+	sh_css_sp_stage.sp_enable_xnr = (uint8_t)xnr;
+	sh_css_sp_stage.xmem_bin_addr = xinfo->xmem_addr;
+	sh_css_sp_stage.xmem_map_addr = sh_css_params_ddr_address_map();
+	sh_css_isp_stage.blob_info = *blob_info;
+	sh_css_stage_write_binary_info((struct ia_css_binary_info *)info);
+
+	// Make sure binary name is smaller than allowed string size
+	assert(strlen(binary_name) < SH_CSS_MAX_BINARY_NAME-1);
+	strncpy(sh_css_isp_stage.binary_name, binary_name, SH_CSS_MAX_BINARY_NAME);
+	sh_css_isp_stage.binary_name[SH_CSS_MAX_BINARY_NAME - 1] = 0;
+	sh_css_isp_stage.mem_initializers = *isp_mem_if;
+
+	/**
+	 * Even when a stage does not need uds and does not params,
+	 * ia_css_uds_sp_scale_params() seems to be called (needs
+	 * further investigation). This function can not deal with
+	 * dx, dy = {0, 0}
+	 */
+
+	/* Clean static frame info before we update it */
+	/*
+	 * TODO: Initialize the static frame data with
+	 * "sh_css_frame_null".
+	 */
+	for (i = 0; i < IA_CSS_NUM_BUFFER_TYPE; i++)
+		/* Here, we do not initialize it to zero for now
+		 * to be able to recognize non-updated elements
+		 * This is what it should become:
+		 * sh_css_sp_stage.frames.static_frame_data[i] = mmgr_NULL;
+		 */
+		sh_css_sp_stage.frames.static_frame_data[i] = mmgr_EXCEPTION;
+
+	err = sh_css_sp_write_frame_pointers(args);
+	//TODO: move it to a better place
+	if (binary->info->sp.enable.s3a) {
+		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_3A_STATISTICS, thread_id, &queue_id);
+		sh_css_sp_stage.frames.static_frame_data[IA_CSS_BUFFER_TYPE_3A_STATISTICS] = queue_id;
+	}
+	if (binary->info->sp.enable.dis) {
+		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_DIS_STATISTICS, thread_id, &queue_id);
+		sh_css_sp_stage.frames.static_frame_data[IA_CSS_BUFFER_TYPE_DIS_STATISTICS] = queue_id;
+	}
+#if defined(IS_ISP_2500_SYSTEM)
+	if (binary->info->sp.enable.lace_stats) {
+		ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_LACE_STATISTICS, thread_id, &queue_id);
+		sh_css_sp_stage.frames.static_frame_data[IA_CSS_BUFFER_TYPE_LACE_STATISTICS] = queue_id;
+	}
+#endif
+#if defined SH_CSS_ENABLE_METADATA
+	ia_css_query_internal_queue_id(IA_CSS_BUFFER_TYPE_METADATA, thread_id, &queue_id);
+	sh_css_sp_stage.frames.static_frame_data[IA_CSS_BUFFER_TYPE_METADATA] = queue_id;
+#endif
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	configure_isp_from_args(&sh_css_sp_group.pipe[thread_id],
+			binary, args, two_ppc, sh_css_sp_stage.deinterleaved);
+	initialize_isp_states(binary);
+
+	/* we do this only for preview pipe because in fill_binary_info function
+	 * we assign vf_out res to out res, but for ISP internal processing, we need
+	 * the original out res. for video pipe, it has two output pins --- out and
+	 * vf_out, so it can keep these two resolutions already. */
+	if (binary->info->sp.mode == IA_CSS_BINARY_MODE_PREVIEW &&
+		(binary->vf_downscale_log2 > 0)) {
+		/* TODO: Remove this after preview output decimation is fixed
+		 * by configuring out&vf info fiels properly */
+		sh_css_sp_stage.frames.out[0].info.padded_width
+			<<= binary->vf_downscale_log2;
+		sh_css_sp_stage.frames.out[0].info.res.width
+			<<= binary->vf_downscale_log2;
+		sh_css_sp_stage.frames.out[0].info.res.height
+			<<= binary->vf_downscale_log2;
+	}
+	err = copy_isp_mem_if_to_ddr(binary);
+	if (err != IA_CSS_SUCCESS)
+		return err;
+
+	return IA_CSS_SUCCESS;
+}
+
+static enum ia_css_err
+sp_init_stage(struct ia_css_pipeline_stage *stage,
+	      unsigned int pipe_num,
+	      bool xnr,
+	      unsigned int if_config_index,
+	      enum ia_css_frame_delay frame_delay,
+	      bool two_ppc)
+{
+	struct ia_css_binary *binary;
+	const struct ia_css_fw_info *firmware;
+	const struct sh_css_binary_args *args;
+	unsigned stage_num;
+/*
+ * Initialiser required because of the "else" path below.
+ * Is this a valid path ?
+ */
+	const char *binary_name = "";
+	const struct ia_css_binary_xinfo *info = NULL;
+	struct ia_css_binary tmp_binary;
+	const struct ia_css_blob_info *blob_info = NULL;
+	struct ia_css_isp_param_css_segments isp_mem_if;
+	/* LA: should be ia_css_data, should not contain host pointer.
+	   However, CSS/DDR pointer is not available yet.
+	   Hack is to store it in params->ddr_ptrs and then copy it late in the SP just before vmem init.
+	   TODO: Call this after CSS/DDR allocation and store that pointer.
+	   Best is to allocate it at stage creation time together with host pointer.
+	   Remove vmem from params.
+	*/
+	struct ia_css_isp_param_css_segments *mem_if = &isp_mem_if;
+
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
+	assert(stage != NULL);
+
+	binary = stage->binary;
+	firmware = stage->firmware;
+	args = &stage->args;
+	stage_num = stage->stage_num;;
+
+
+	if (binary) {
+		info = binary->info;
+		binary_name = (const char *)(info->blob->name);
+		blob_info = &info->blob->header.blob;
+		ia_css_init_memory_interface(mem_if, &binary->mem_params, &binary->css_params);
+	} else if (firmware) {
+		const struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS] = {NULL};
+		if (args->out_frame[0])
+			out_infos[0] = &args->out_frame[0]->info;
+		info = &firmware->info.isp;
+		ia_css_binary_fill_info(info, false, false,
+			    IA_CSS_STREAM_FORMAT_RAW_10,
+			    args->in_frame  ? &args->in_frame->info  : NULL,
+			    NULL,
+				out_infos,
+			    args->out_vf_frame ? &args->out_vf_frame->info
+						: NULL,
+			    &tmp_binary,
+			    NULL,
+			    -1, true);
+		binary = &tmp_binary;
+		binary->info = info;
+		binary_name = IA_CSS_EXT_ISP_PROG_NAME(firmware);
+		blob_info = &firmware->blob;
+		mem_if = (struct ia_css_isp_param_css_segments *)&firmware->mem_initializers;
+	} else {
+	    /* SP stage */
+	    assert (stage->sp_func != IA_CSS_PIPELINE_NO_FUNC);
+		/* binary and blob_info are now NULL.
+		   These will be passed to sh_css_sp_init_stage
+		   and dereferenced there, so passing a NULL
+		   pointer is no good. return an error */
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
+
+#ifdef __KERNEL__
+	printk(KERN_ERR "load binary: %s\n", binary_name);
+#endif
+
+	err = sh_css_sp_init_stage(binary,
+			     (const char *)binary_name,
+			     blob_info,
+			     args,
+			     pipe_num,
+			     stage_num,
+			     xnr,
+			     mem_if,
+			     if_config_index,
+			     frame_delay,
+			     two_ppc);
+	return err;
+}
+
+static void
+sp_init_sp_stage(struct ia_css_pipeline_stage *stage,
+		 unsigned pipe_num,
+		 bool two_ppc,
+		 enum sh_css_pipe_config_override copy_ovrd,
+		 unsigned int if_config_index)
+{
+	const struct sh_css_binary_args *args = &stage->args;
+
+	assert(stage != NULL);
+	switch (stage->sp_func) {
+	case IA_CSS_PIPELINE_RAW_COPY:
+		sh_css_sp_start_raw_copy(args->out_frame[0],
+				pipe_num, two_ppc,
+				stage->max_input_width,
+				copy_ovrd, if_config_index);
+		break;
+	case IA_CSS_PIPELINE_BIN_COPY:
+		assert(false); /* TBI */
+	case IA_CSS_PIPELINE_ISYS_COPY:
+		sh_css_sp_start_isys_copy(args->out_frame[0],
+				pipe_num, stage->max_input_width);
+		break;
+	case IA_CSS_PIPELINE_NO_FUNC:
+		assert(false);
+	}
+}
+
+void
+sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
+			enum ia_css_pipe_id id,
+			uint8_t pipe_num,
+			bool xnr,
+			bool two_ppc,
+			bool continuous,
+			bool offline,
+			unsigned int required_bds_factor,
+			enum sh_css_pipe_config_override copy_ovrd,
+			enum ia_css_input_mode input_mode,
+			const struct ia_css_metadata_config *md_config,
+			const struct ia_css_metadata_info *md_info
+#if !defined(IS_ISP_2500_SYSTEM)
+			, const mipi_port_ID_t port_id
+#endif
+			)
+{
+	/* Get first stage */
+	struct ia_css_pipeline_stage *stage        = NULL;
+	struct ia_css_binary	     *first_binary = NULL;
+	unsigned num;
+
+	enum ia_css_pipe_id pipe_id = id;
+	unsigned int thread_id;
+	uint8_t if_config_index, tmp_if_config_index;
+
+	assert(me != NULL);
+
+#if !defined(HAS_NO_INPUT_SYSTEM)
+	assert(me->stages != NULL);
+
+	first_binary = me->stages->binary;
+
+	if (input_mode == IA_CSS_INPUT_MODE_SENSOR
+		|| input_mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR) {
+			assert (port_id < N_MIPI_PORT_ID);
+			if (port_id >= N_MIPI_PORT_ID) /* should not happen but KW does not know */
+				return; /* we should be able to return an error */
+			if_config_index  = (uint8_t) (port_id - MIPI_PORT0_ID);
+	} else if (input_mode == IA_CSS_INPUT_MODE_MEMORY){
+		if_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;
+	} else if_config_index = 0x0;
+#else
+	(void)input_mode;
+	if_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;
+#endif
+
+	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+	memset(&sh_css_sp_group.pipe[thread_id], 0, sizeof(struct sh_css_sp_pipeline));
+
+	/* Count stages */
+	for (stage = me->stages, num = 0; stage; stage = stage->next, num++) {
+		stage->stage_num = num;
+		ia_css_debug_pipe_graph_dump_stage(stage, id);
+	}
+	me->num_stages = num;
+
+	if (first_binary != NULL) {
+	/* Init pipeline data */
+		sh_css_sp_init_group(two_ppc, first_binary->input_format, offline, if_config_index);
+	} /* if (first_binary != NULL) */
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+	/* Signal the host immediately after start for SP_ISYS_COPY only */
+	if ((me->num_stages == 1) && me->stages &&
+	    (me->stages->sp_func == IA_CSS_PIPELINE_ISYS_COPY))
+		sh_css_sp_group.config.no_isp_sync = true;
+#endif
+
+	/* Init stage data */
+	sh_css_init_host2sp_frame_data();
+
+	sh_css_sp_group.pipe[thread_id].num_stages = 0;
+	sh_css_sp_group.pipe[thread_id].pipe_id = pipe_id;
+	sh_css_sp_group.pipe[thread_id].thread_id = thread_id;
+	sh_css_sp_group.pipe[thread_id].pipe_num = pipe_num;
+	sh_css_sp_group.pipe[thread_id].num_execs = me->num_execs;
+	sh_css_sp_group.pipe[thread_id].required_bds_factor = required_bds_factor;
+#if !defined(HAS_NO_INPUT_SYSTEM)
+	sh_css_sp_group.pipe[thread_id].input_system_mode
+						= (uint32_t)input_mode;
+	sh_css_sp_group.pipe[thread_id].port_id = port_id;
+#endif
+
+	/* TODO: next indicates from which queues parameters need to be
+		 sampled, needs checking/improvement */
+	if (ia_css_pipeline_uses_params(me)) {
+		sh_css_sp_group.pipe[thread_id].pipe_config =
+			SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id;
+	}
+
+	/* For continuous use-cases, SP copy is responsible for sampling the
+	 * parameters */
+	if (continuous)
+		sh_css_sp_group.pipe[thread_id].pipe_config = 0;
+
+	sh_css_sp_group.pipe[thread_id].inout_port_config = me->inout_port_config;
+
+#if defined (SH_CSS_ENABLE_METADATA)
+	if (md_info != NULL && md_info->size > 0) {
+		sh_css_sp_group.pipe[thread_id].metadata.width  = md_info->resolution.width;
+		sh_css_sp_group.pipe[thread_id].metadata.height = md_info->resolution.height;
+		sh_css_sp_group.pipe[thread_id].metadata.stride = md_info->stride;
+		sh_css_sp_group.pipe[thread_id].metadata.size   = md_info->size;
+		ia_css_isys_convert_stream_format_to_mipi_format(
+				md_config->data_type, MIPI_PREDICTOR_NONE,
+				&sh_css_sp_group.pipe[thread_id].metadata.format);
+	}
+#else
+	(void)md_config;
+	(void)md_info;
+#endif
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_sp_init_pipeline pipe_id %d port_config %08x\n",pipe_id,sh_css_sp_group.pipe[thread_id].inout_port_config);
+
+	for (stage = me->stages, num = 0; stage; stage = stage->next, num++) {
+		sh_css_sp_group.pipe[thread_id].num_stages++;
+		if (is_sp_stage(stage)) {
+			sp_init_sp_stage(stage, pipe_num, two_ppc,
+				copy_ovrd, if_config_index);
+		} else {
+			enum ia_css_frame_delay frame_delay = me->dvs_frame_delay;
+			/* only the video binary has multiple stages */
+			if (stage->binary && stage->binary->info->sp.mode != IA_CSS_BINARY_MODE_VIDEO)
+				frame_delay = IA_CSS_FRAME_DELAY_0;
+			if ((stage->stage_num != 0) || SH_CSS_PIPE_PORT_CONFIG_IS_CONTINUOUS(me->inout_port_config))
+				tmp_if_config_index = SH_CSS_IF_CONFIG_NOT_NEEDED;
+			else
+				tmp_if_config_index = if_config_index;
+			sp_init_stage(stage, pipe_num,
+				      xnr, tmp_if_config_index, frame_delay, two_ppc);
+		}
+
+		store_sp_stage_data(pipe_id, pipe_num, num);
+	}
+	sh_css_sp_group.pipe[thread_id].pipe_config |= (uint32_t)
+		(me->acquire_isp_each_stage << IA_CSS_ACQUIRE_ISP_POS);
+	store_sp_group_data();
+
+}
+
+void
+sh_css_sp_uninit_pipeline(unsigned int pipe_num)
+{
+	unsigned int thread_id;
+	ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
+	/*memset(&sh_css_sp_group.pipe[thread_id], 0, sizeof(struct sh_css_sp_pipeline));*/
+	sh_css_sp_group.pipe[thread_id].num_stages = 0;
+}
+#if 0
+static void
+init_host2sp_command(void)
+{
+	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
+	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
+				/ sizeof(int);
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+	store_sp_array_uint(host_sp_com, o, host2sp_cmd_ready);
+}
+#endif
+
+#if defined(IS_ISP_2500_SYSTEM)
+void
+sh_css_write_host2sp1_command(enum host2sp_commands host2sp_command)
+{
+	unsigned int HIVE_ADDR_host_sp1_com = sh_css_sp1_fw.info.sp1.host_sp_com;
+	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
+				/ sizeof(int);
+	(void)HIVE_ADDR_host_sp1_com; /* Suppres warnings in CRUN */
+
+	/* Previous command must be handled by SP1 (by design) */
+	if(host2sp_command == host2sp_cmd_terminate)
+		assert(load_sp1_array_uint(host_sp1_com, o) == host2sp_cmd_ready);
+
+	store_sp1_array_uint(host_sp1_com, o, host2sp_command);
+}
+#endif
+
+void
+sh_css_write_host2sp_command(enum host2sp_commands host2sp_command)
+{
+	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
+	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
+				/ sizeof(int);
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	/* Previous command must be handled by SP (by design) */
+	assert(load_sp_array_uint(host_sp_com, o) == host2sp_cmd_ready);
+
+	store_sp_array_uint(host_sp_com, o, host2sp_command);
+}
+
+enum host2sp_commands
+sh_css_read_host2sp_command(void)
+{
+	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
+	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
+				/ sizeof(int);
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+	return (enum host2sp_commands)load_sp_array_uint(host_sp_com, o);
+}
+
+
+/*
+ * Frame data is no longer part of the sp_stage structure but part of a
+ * seperate structure. The aim is to make the sp_data struct static
+ * (it defines a pipeline) and that the dynamic (per frame) data is stored
+ * separetly.
+ *
+ * This function must be called first every where were you start constructing
+ * a new pipeline by defining one or more stages with use of variable
+ * sh_css_sp_stage. Even the special cases like accelerator and copy_frame
+ * These have a pipeline of just 1 stage.
+ */
+void
+sh_css_init_host2sp_frame_data(void)
+{
+	/* Clean table */
+	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+	/*
+	 * rvanimme: don't clean it to save static frame info line ref_in
+	 * ref_out, and tnr_frames. Once this static data is in a
+	 * seperate data struct, this may be enable (but still, there is
+	 * no need for it)
+	 */
+#if 0
+	unsigned i;
+	for (i = 0; i < SH_CSS_MAX_PIPELINES*SH_CSS_NUM_FRAME_IDS; i++)
+		store_sp_array_uint(host_sp_com, i+o, 0);
+#endif
+}
+
+
+/**
+ * @brief Update the offline frame information in host_sp_communication.
+ * Refer to "sh_css_sp.h" for more details.
+ */
+void
+sh_css_update_host2sp_offline_frame(
+				unsigned frame_num,
+				struct ia_css_frame *frame,
+				struct ia_css_metadata *metadata)
+{
+	unsigned int HIVE_ADDR_host_sp_com;
+	unsigned int o;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	assert(frame_num < NUM_CONTINUOUS_FRAMES);
+
+	/* Write new frame data into SP DMEM */
+	HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
+	o = offsetof(struct host_sp_communication, host2sp_offline_frames)
+		/ sizeof(int);
+	o += frame_num;
+	store_sp_array_uint(host_sp_com, o, frame ? frame->data : 0);
+
+	/* Write metadata buffer into SP DMEM */
+	o = offsetof(struct host_sp_communication, host2sp_offline_metadata)
+		/ sizeof(int);
+	o += frame_num;
+	store_sp_array_uint(host_sp_com, o, metadata ? metadata->address : 0);
+}
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+/**
+ * @brief Update the offline frame information in host_sp_communication.
+ * Refer to "sh_css_sp.h" for more details.
+ */
+void
+sh_css_update_host2sp_mipi_frame(
+				unsigned frame_num,
+				struct ia_css_frame *frame)
+{
+	unsigned int HIVE_ADDR_host_sp_com;
+	unsigned int o;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	assert(frame_num < NUM_MIPI_FRAMES);
+
+	/* Write new frame data into SP DMEM */
+	HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
+	o = offsetof(struct host_sp_communication, host2sp_mipi_frames)
+		/ sizeof(int);
+	o += frame_num;
+
+	store_sp_array_uint(host_sp_com, o,
+				frame ? frame->data : 0);
+}
+
+void
+sh_css_update_host2sp_num_mipi_frames(unsigned num_frames)
+{
+	unsigned int HIVE_ADDR_host_sp_com;
+	unsigned int o;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	/* Write new frame data into SP DMEM */
+	HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
+	o = offsetof(struct host_sp_communication, host2sp_num_mipi_frames)
+		/ sizeof(int);
+
+	store_sp_array_uint(host_sp_com, o, num_frames);
+}
+#endif
+
+void
+sh_css_update_host2sp_cont_num_raw_frames(unsigned num_frames, bool set_avail)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_host_sp_com;
+	unsigned int extra_num_frames, avail_num_frames;
+	unsigned int o, o_extra;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	/* Write new frame data into SP DMEM */
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
+	if (set_avail) {
+		o = offsetof(struct host_sp_communication, host2sp_cont_avail_num_raw_frames)
+			/ sizeof(int);
+		avail_num_frames = load_sp_array_uint(host_sp_com, o);
+		extra_num_frames = num_frames - avail_num_frames;
+		o_extra = offsetof(struct host_sp_communication, host2sp_cont_extra_num_raw_frames)
+			/ sizeof(int);
+		store_sp_array_uint(host_sp_com, o_extra, extra_num_frames);
+	} else
+		o = offsetof(struct host_sp_communication, host2sp_cont_target_num_raw_frames)
+			/ sizeof(int);
+
+	store_sp_array_uint(host_sp_com, o, num_frames);
+}
+
+void
+sh_css_event_init_irq_mask(void)
+{
+	int i;
+	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
+	unsigned int offset;
+	struct sh_css_event_irq_mask event_irq_mask_init;
+
+	event_irq_mask_init.or_mask  = IA_CSS_EVENT_TYPE_ALL;
+	event_irq_mask_init.and_mask = IA_CSS_EVENT_TYPE_NONE;
+	(void)HIVE_ADDR_host_sp_com; /* Suppress warnings in CRUN */
+
+	assert(sizeof(event_irq_mask_init) % HRT_BUS_BYTES == 0);
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		offset = offsetof(struct host_sp_communication,
+						host2sp_event_irq_mask[i]);
+		assert(offset % HRT_BUS_BYTES == 0);
+		sp_dmem_store(SP0_ID,
+			(unsigned int)sp_address_of(host_sp_com) + offset,
+			&event_irq_mask_init, sizeof(event_irq_mask_init));
+	}
+
+}
+
+enum ia_css_err
+ia_css_pipe_set_irq_mask(struct ia_css_pipe *pipe,
+			 unsigned int or_mask,
+			 unsigned int and_mask)
+{
+	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
+	unsigned int offset;
+	struct sh_css_event_irq_mask event_irq_mask;
+	unsigned int pipe_num;
+
+	assert(pipe != NULL);
+
+	assert(IA_CSS_PIPE_ID_NUM == NR_OF_PIPELINES);
+	/* Linux kernel does not have UINT16_MAX
+	 * Therefore decided to comment out these 2 asserts for Linux
+	 * Alternatives that were not chosen:
+	 * - add a conditional #define for UINT16_MAX
+	 * - compare with (uint16_t)~0 or 0xffff
+	 * - different assert for Linux and Windows
+	 */
+#ifndef __KERNEL__
+	assert(or_mask <= UINT16_MAX);
+	assert(and_mask <= UINT16_MAX);
+#endif
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_set_irq_mask("
+				"or_mask=%x, and_mask=%x)\n",
+				or_mask, and_mask);
+	event_irq_mask.or_mask  = (uint16_t)or_mask;
+	event_irq_mask.and_mask = (uint16_t)and_mask;
+
+	pipe_num = ia_css_pipe_get_pipe_num(pipe);
+	if (pipe_num >= IA_CSS_PIPE_ID_NUM)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	offset = offsetof(struct host_sp_communication,
+					host2sp_event_irq_mask[pipe_num]);
+	assert(offset % HRT_BUS_BYTES == 0);
+	sp_dmem_store(SP0_ID,
+		(unsigned int)sp_address_of(host_sp_com) + offset,
+		&event_irq_mask, sizeof(event_irq_mask));
+
+	return IA_CSS_SUCCESS;
+}
+
+enum ia_css_err
+ia_css_event_get_irq_mask(const struct ia_css_pipe *pipe,
+			  unsigned int *or_mask,
+			  unsigned int *and_mask)
+{
+	unsigned int HIVE_ADDR_host_sp_com = sh_css_sp_fw.info.sp.host_sp_com;
+	unsigned int offset;
+	struct sh_css_event_irq_mask event_irq_mask;
+	unsigned int pipe_num;
+
+	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_event_get_irq_mask()\n");
+
+	assert(pipe != NULL);
+	assert(IA_CSS_PIPE_ID_NUM == NR_OF_PIPELINES);
+
+	pipe_num = ia_css_pipe_get_pipe_num(pipe);
+	if (pipe_num >= IA_CSS_PIPE_ID_NUM)
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	offset = offsetof(struct host_sp_communication,
+					host2sp_event_irq_mask[pipe_num]);
+	assert(offset % HRT_BUS_BYTES == 0);
+	sp_dmem_load(SP0_ID,
+		(unsigned int)sp_address_of(host_sp_com) + offset,
+		&event_irq_mask, sizeof(event_irq_mask));
+
+	if (or_mask)
+		*or_mask = event_irq_mask.or_mask;
+
+	if (and_mask)
+		*and_mask = event_irq_mask.and_mask;
+
+	return IA_CSS_SUCCESS;
+}
+
+void
+sh_css_sp_set_sp_running(bool flag)
+{
+	sp_running = flag;
+}
+#if defined(IS_ISP_2500_SYSTEM)
+void
+sh_css_sp1_set_sp1_running(bool flag)
+{
+	sp1_running = flag;
+}
+#endif
+bool
+sh_css_sp_is_running(void)
+{
+	return sp_running;
+}
+
+#if defined(IS_ISP_2500_SYSTEM)
+void
+sh_css_sp1_start(void)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp1_sw_state;
+	fw = &sh_css_sp1_fw;
+	HIVE_ADDR_sp1_sw_state = fw->info.sp1.sw_state;
+
+	if (sp1_running)
+		return;
+
+	(void)HIVE_ADDR_sp1_sw_state; /* Suppres warnings in CRUN */
+
+	/* no longer here, sp started immediately */
+	/*ia_css_debug_pipe_graph_dump_epilogue();*/
+
+	/*store_sp_group_data();
+	store_sp_per_frame_data(fw);*/
+	sp_dmem_store_uint32(SP1_ID,
+		(unsigned int)sp1_address_of(sp1_sw_state),
+		(uint32_t)(IA_CSS_SP_SW_TERMINATED));
+
+	//init_host2sp_command();
+	/* Note 1: The sp_start_isp function contains a wait till
+	 * the input network is configured by the SP.
+	 * Note 2: Not all SP binaries supports host2sp_commands.
+	 * In case a binary does support it, the host2sp_command
+	 * will have status cmd_ready after return of the function
+	 * sh_css_hrt_sp_start_isp. There is no race-condition here
+	 * because only after the process_frame command has been
+	 * received, the SP starts configuring the input network.
+	 */
+
+	/* we need to set sp_running before we call ia_css_mmu_invalidate_cache
+	 * as ia_css_mmu_invalidate_cache checks on sp_running to
+	 * avoid that it accesses dmem while the SP is not powered
+	 */
+	sp1_running = true;
+	/* ia_css_mmu_invalidate_cache(); */
+	/* Invalidate all MMU caches */
+	/* mmu_invalidate_cache_all(); */
+
+	ia_css_spctrl_start_sp1(SP1_ID);
+
+}
+#endif
+
+void
+sh_css_sp_start_isp(void)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp_sw_state;
+
+	fw = &sh_css_sp_fw;
+	HIVE_ADDR_sp_sw_state = fw->info.sp.sw_state;
+
+
+	if (sp_running)
+		return;
+
+	(void)HIVE_ADDR_sp_sw_state; /* Suppres warnings in CRUN */
+
+	/* no longer here, sp started immediately */
+	/*ia_css_debug_pipe_graph_dump_epilogue();*/
+
+	store_sp_group_data();
+	store_sp_per_frame_data(fw);
+
+	sp_dmem_store_uint32(SP0_ID,
+		(unsigned int)sp_address_of(sp_sw_state),
+		(uint32_t)(IA_CSS_SP_SW_TERMINATED));
+
+
+	//init_host2sp_command();
+	/* Note 1: The sp_start_isp function contains a wait till
+	 * the input network is configured by the SP.
+	 * Note 2: Not all SP binaries supports host2sp_commands.
+	 * In case a binary does support it, the host2sp_command
+	 * will have status cmd_ready after return of the function
+	 * sh_css_hrt_sp_start_isp. There is no race-condition here
+	 * because only after the process_frame command has been
+	 * received, the SP starts configuring the input network.
+	 */
+
+	/* we need to set sp_running before we call ia_css_mmu_invalidate_cache
+	 * as ia_css_mmu_invalidate_cache checks on sp_running to
+	 * avoid that it accesses dmem while the SP is not powered
+	 */
+	sp_running = true;
+	ia_css_mmu_invalidate_cache();
+	/* Invalidate all MMU caches */
+	mmu_invalidate_cache_all();
+
+	ia_css_spctrl_start(SP0_ID);
+
+}
+
+bool
+ia_css_isp_has_started(void)
+{
+	const struct ia_css_fw_info *fw = &sh_css_sp_fw;
+	unsigned int HIVE_ADDR_ia_css_ispctrl_sp_isp_started = fw->info.sp.isp_started;
+	(void)HIVE_ADDR_ia_css_ispctrl_sp_isp_started; /* Suppres warnings in CRUN */
+
+	return (bool)load_sp_uint(ia_css_ispctrl_sp_isp_started);
+}
+
+
+/**
+ * @brief Initialize the DMA software-mask in the debug mode.
+ * Refer to "sh_css_sp.h" for more details.
+ */
+bool
+sh_css_sp_init_dma_sw_reg(int dma_id)
+{
+	int i;
+
+	/* enable all the DMA channels */
+	for (i = 0; i < N_DMA_CHANNEL_ID; i++) {
+		/* enable the writing request */
+		sh_css_sp_set_dma_sw_reg(dma_id,
+				i,
+				0,
+				true);
+		/* enable the reading request */
+		sh_css_sp_set_dma_sw_reg(dma_id,
+				i,
+				1,
+				true);
+	}
+
+	return true;
+}
+
+/**
+ * @brief Set the DMA software-mask in the debug mode.
+ * Refer to "sh_css_sp.h" for more details.
+ */
+bool
+sh_css_sp_set_dma_sw_reg(int dma_id,
+		int channel_id,
+		int request_type,
+		bool enable)
+{
+	uint32_t sw_reg;
+	uint32_t bit_val;
+	uint32_t bit_offset;
+	uint32_t bit_mask;
+
+	(void)dma_id;
+
+	assert(channel_id >= 0 && channel_id < N_DMA_CHANNEL_ID);
+	assert(request_type >= 0);
+
+	/* get the software-mask */
+	sw_reg =
+		sh_css_sp_group.debug.dma_sw_reg;
+
+	/* get the offest of the target bit */
+	bit_offset = (8 * request_type) + channel_id;
+
+	/* clear the value of the target bit */
+	bit_mask = ~(1 << bit_offset);
+	sw_reg &= bit_mask;
+
+	/* set the value of the bit for the DMA channel */
+	bit_val = enable ? 1 : 0;
+	bit_val <<= bit_offset;
+	sw_reg |= bit_val;
+
+	/* update the software status of DMA channels */
+	sh_css_sp_group.debug.dma_sw_reg = sw_reg;
+
+	return true;
+}
+
+void
+sh_css_sp_reset_global_vars(void)
+{
+	memset(&sh_css_sp_group, 0, sizeof(struct sh_css_sp_group));
+	memset(&sh_css_sp_stage, 0, sizeof(struct sh_css_sp_stage));
+	memset(&sh_css_isp_stage, 0, sizeof(struct sh_css_isp_stage));
+	memset(&sh_css_sp_output, 0, sizeof(struct sh_css_sp_output));
+	memset(&per_frame_data, 0, sizeof(struct sh_css_sp_per_frame_data));
+}
diff --git a/drivers/media/atomisp2/css2400/sh_css_sp.h b/drivers/media/atomisp2/css2400/sh_css_sp.h
new file mode 100644
index 0000000..db6b6b9
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_sp.h
@@ -0,0 +1,246 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_SP_H_
+#define _SH_CSS_SP_H_
+
+#include <system_global.h>
+#if !defined(HAS_NO_INPUT_FORMATTER)
+#include "input_formatter.h"
+#endif
+
+#include "ia_css_binary.h"
+#include "sh_css_internal.h"
+#include "ia_css_types.h"
+#include "ia_css_pipeline.h"
+
+/* Function to initialize the data and bss section descr of the binary */
+void
+sh_css_sp_store_init_dmem(const struct ia_css_fw_info *fw);
+
+void
+store_sp_stage_data(enum ia_css_pipe_id id, unsigned int pipe_num, unsigned stage);
+
+void
+sh_css_stage_write_binary_info(struct ia_css_binary_info *info);
+
+void
+sh_css_sp_init_group(bool two_ppc, enum ia_css_stream_format input_format,
+		     bool no_isp_sync, uint8_t if_config_index);
+
+void
+store_sp_group_data(void);
+
+/* Start binary (jpeg) copy on the SP */
+void
+sh_css_sp_start_binary_copy(unsigned int pipe_num, struct ia_css_frame *out_frame,
+			    unsigned two_ppc);
+
+unsigned int
+sh_css_sp_get_binary_copy_size(void);
+
+/* Return the value of a SW interrupt */
+unsigned int
+sh_css_sp_get_sw_interrupt_value(unsigned int irq);
+
+void
+sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
+			enum ia_css_pipe_id id,
+			uint8_t pipe_num,
+			bool xnr,
+			bool two_ppc,
+			bool continuous,
+			bool offline,
+			unsigned int required_bds_factor,
+			enum sh_css_pipe_config_override copy_ovrd,
+			enum ia_css_input_mode input_mode,
+			const struct ia_css_metadata_config *md_config,
+			const struct ia_css_metadata_info *md_info
+#if !defined(IS_ISP_2500_SYSTEM)
+			, const mipi_port_ID_t port_id
+#endif
+			);
+
+void
+sh_css_sp_uninit_pipeline(unsigned int pipe_num);
+
+void
+sh_css_write_host2sp_command(enum host2sp_commands host2sp_command);
+
+#if defined(IS_ISP_2500_SYSTEM)
+void
+sh_css_write_host2sp1_command(enum host2sp_commands host2sp_command);
+#endif
+
+enum host2sp_commands
+sh_css_read_host2sp_command(void);
+
+void
+sh_css_init_host2sp_frame_data(void);
+
+/**
+ * @brief Update the offline frame information in host_sp_communication.
+ *
+ * @param[in] frame_num The offline frame number.
+ * @param[in] frame The pointer to the offline frame.
+ */
+void
+sh_css_update_host2sp_offline_frame(
+				unsigned frame_num,
+				struct ia_css_frame *frame,
+				struct ia_css_metadata *metadata);
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+/**
+ * @brief Update the mipi frame information in host_sp_communication.
+ *
+ * @param[in] frame_num The mipi frame number.
+ * @param[in] frame The pointer to the mipi frame.
+ */
+void
+sh_css_update_host2sp_mipi_frame(
+				unsigned frame_num,
+				struct ia_css_frame *frame);
+
+/**
+ * @brief Update the nr of mipi frames to use in host_sp_communication.
+ *
+ * @param[in] num_frames The number of mipi frames to use.
+ */
+void
+sh_css_update_host2sp_num_mipi_frames(unsigned num_frames);
+#endif
+
+/**
+ * @brief Update the nr of offline frames to use in host_sp_communication.
+ *
+ * @param[in] num_frames The number of raw frames to use.
+ */
+void
+sh_css_update_host2sp_cont_num_raw_frames(unsigned num_frames, bool set_avail);
+
+void
+sh_css_event_init_irq_mask(void);
+
+void
+sh_css_sp_start_isp(void);
+#if defined(IS_ISP_2500_SYSTEM)
+void
+sh_css_sp1_start(void);
+#endif
+
+void
+sh_css_sp_set_sp_running(bool flag);
+
+#if defined(IS_ISP_2500_SYSTEM)
+void
+sh_css_sp1_set_sp1_running(bool flag);
+#endif
+
+bool
+sh_css_sp_is_running(void);
+
+#if SP_DEBUG != SP_DEBUG_NONE
+
+void
+sh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state);
+
+#endif
+
+#if !defined(HAS_NO_INPUT_FORMATTER)
+extern void sh_css_sp_set_if_configs(
+	const input_formatter_cfg_t	*config_a,
+	const input_formatter_cfg_t	*config_b,
+	const uint8_t		if_config_index);
+#endif
+
+void
+sh_css_sp_program_input_circuit(int fmt_type,
+				int ch_id,
+				enum ia_css_input_mode input_mode);
+
+void
+sh_css_sp_configure_sync_gen(int width,
+			     int height,
+			     int hblank_cycles,
+			     int vblank_cycles);
+
+void
+sh_css_sp_configure_tpg(int x_mask,
+			int y_mask,
+			int x_delta,
+			int y_delta,
+			int xy_mask);
+
+void
+sh_css_sp_configure_prbs(int seed);
+
+void
+sh_css_sp_reset_global_vars(void);
+
+/**
+ * @brief Initialize the DMA software-mask in the debug mode.
+ * This API should be ONLY called in the debugging mode.
+ * And it should be always called before the first call of
+ * "sh_css_set_dma_sw_reg(...)".
+ *
+ * @param[in]	dma_id		The ID of the target DMA.
+ *
+ * @return
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool sh_css_sp_init_dma_sw_reg(int dma_id);
+
+/**
+ * @brief Set the DMA software-mask in the debug mode.
+ * This API should be ONLYL called in the debugging mode. Must
+ * call "sh_css_set_dma_sw_reg(...)" before this
+ * API is called for the first time.
+ *
+ * @param[in]	dma_id		The ID of the target DMA.
+ * @param[in]	channel_id	The ID of the target DMA channel.
+ * @param[in]	request_type	The type of the DMA request.
+ *				For example:
+ *				- "0" indicates the writing request.
+ *				- "1" indicates the reading request.
+ *
+ * @param[in]	enable		If it is "true", the target DMA
+ *				channel is enabled in the software.
+ *				Otherwise, the target DMA channel
+ *				is disabled in the software.
+ *
+ * @return
+ *	- true, if it is successful.
+ *	- false, otherwise.
+ */
+extern bool sh_css_sp_set_dma_sw_reg(int dma_id,
+		int channel_id,
+		int request_type,
+		bool enable);
+
+
+extern struct sh_css_sp_group sh_css_sp_group;
+extern struct sh_css_sp_stage sh_css_sp_stage;
+extern struct sh_css_isp_stage sh_css_isp_stage;
+
+#endif /* _SH_CSS_SP_H_ */
+
diff --git a/drivers/media/atomisp2/css2400/sh_css_struct.h b/drivers/media/atomisp2/css2400/sh_css_struct.h
new file mode 100644
index 0000000..47d0684
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_struct.h
@@ -0,0 +1,74 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __SH_CSS_STRUCT_H
+#define __SH_CSS_STRUCT_H
+
+/* This header files contains the definition of the
+   sh_css struct and friends; locigally the file would
+   probably be called sh_css.h after the pattern
+   <type>.h but sh_css.h is the predecesssor of ia_css.h
+   so this could cause confusion; hence the _struct
+   in the filename
+*/
+
+#include <type_support.h>
+#include <system_types.h>
+#include "ia_css_pipeline.h"
+#include "ia_css_pipe_public.h"
+#include "ia_css_frame_public.h"
+#include "ia_css_queue.h"
+#include "ia_css_irq.h"
+
+struct sh_css {
+	struct ia_css_pipe            *active_pipes[IA_CSS_PIPELINE_NUM_MAX];
+	/* All of the pipes created at any point of time. At this moment there can
+	 * be no more than MAX_SP_THREADS of them because pipe_num is reused as SP
+	 * thread_id to which a pipe's pipeline is associated. At a later point, if
+	 * we support more pipe objects, we should add test code to test that
+	 * possibility. Also, active_pipes[] should be able to hold only
+	 * SH_CSS_MAX_SP_THREADS objects. Anything else is misleading. */
+	struct ia_css_pipe            *all_pipes[IA_CSS_PIPELINE_NUM_MAX];
+	void *(*malloc) (size_t bytes, bool zero_mem);
+	void (*free) (void *ptr);
+	void (*flush) (struct ia_css_acc_fw *fw);
+	bool                           check_system_idle;
+	bool                           stop_copy_preview;
+	unsigned int                   num_cont_raw_frames;
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	unsigned int                   num_mipi_frames;
+	struct ia_css_frame           *mipi_frames[NUM_MIPI_FRAMES];
+#endif
+	hrt_vaddress                   sp_bin_addr;
+	hrt_data                       page_table_base_index;
+	unsigned int                   size_mem_words;
+#if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
+	unsigned int                   mipi_sizes_for_check[N_CSI_PORTS][IA_CSS_MIPI_SIZE_CHECK_MAX_NOF_ENTRIES_PER_PORT];
+#endif
+	bool                           contiguous;
+	enum ia_css_irq_type           irq_type;
+	unsigned int                   pipe_counter;
+};
+
+extern struct sh_css my_css;
+
+#endif /* __SH_CSS_STRUCT_H */
+
diff --git a/drivers/media/atomisp2/css2400/sh_css_uds.h b/drivers/media/atomisp2/css2400/sh_css_uds.h
new file mode 100644
index 0000000..aaf771b
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/sh_css_uds.h
@@ -0,0 +1,41 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _SH_CSS_UDS_H_
+#define _SH_CSS_UDS_H_
+
+#include <type_support.h>
+
+/* Uds types, used in pipeline_global.h and sh_css_internal.h */
+
+struct sh_css_uds_info {
+	uint16_t curr_dx;
+	uint16_t curr_dy;
+	uint16_t xc;
+	uint16_t yc;
+};
+
+struct sh_css_crop_pos {
+	uint16_t x;
+	uint16_t y;
+};
+
+#endif /* _SH_CSS_UDS_H_ */
diff --git a/drivers/media/atomisp2/css2400/spmem_dump.c b/drivers/media/atomisp2/css2400/spmem_dump.c
new file mode 100644
index 0000000..0d1f859
--- /dev/null
+++ b/drivers/media/atomisp2/css2400/spmem_dump.c
@@ -0,0 +1,1943 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _sp_map_h_
+#define _sp_map_h_
+
+
+#ifndef _hrt_dummy_use_blob_sp
+#define _hrt_dummy_use_blob_sp()
+#endif
+
+#define _hrt_cell_load_program_sp(proc) _hrt_cell_load_program_embedded(proc, sp)
+
+/* function input_system_acquisition_stop: A9C */
+
+/* function longjmp: 5D75 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_HIVE_IF_SRST_MASK
+#define HIVE_MEM_HIVE_IF_SRST_MASK scalar_processor_2400_dmem
+#define HIVE_ADDR_HIVE_IF_SRST_MASK 0x18C
+#define HIVE_SIZE_HIVE_IF_SRST_MASK 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_HIVE_IF_SRST_MASK scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_HIVE_IF_SRST_MASK 0x18C
+#define HIVE_SIZE_sp_HIVE_IF_SRST_MASK 16
+
+/* function ia_css_isys_sp_token_map_receive_ack: 557A */
+
+/* function ia_css_dmaproxy_sp_set_addr_B: 2826 */
+
+/* function debug_buffer_set_ddr_addr: EE */
+
+/* function receiver_port_reg_load: A80 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_vbuf_mipi
+#define HIVE_MEM_vbuf_mipi scalar_processor_2400_dmem
+#define HIVE_ADDR_vbuf_mipi 0x31C
+#define HIVE_SIZE_vbuf_mipi 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_vbuf_mipi scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_vbuf_mipi 0x31C
+#define HIVE_SIZE_sp_vbuf_mipi 4
+
+/* function ia_css_event_sp_decode: 2A11 */
+
+/* function ia_css_queue_get_size: 4098 */
+
+/* function ia_css_queue_load: 4758 */
+
+/* function setjmp: 5D7E */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_rawcopy_sp_tgt_cp_fr_ct
+#define HIVE_MEM_ia_css_rawcopy_sp_tgt_cp_fr_ct scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_rawcopy_sp_tgt_cp_fr_ct 0x5788
+#define HIVE_SIZE_ia_css_rawcopy_sp_tgt_cp_fr_ct 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_rawcopy_sp_tgt_cp_fr_ct scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tgt_cp_fr_ct 0x5788
+#define HIVE_SIZE_sp_ia_css_rawcopy_sp_tgt_cp_fr_ct 4
+
+/* function __dmaproxy_sp_read_write_text: 293F */
+
+/* function ia_css_dmaproxy_sp_wait_for_ack: 63C4 */
+
+/* function ia_css_tagger_buf_sp_pop_marked: 2037 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_stage
+#define HIVE_MEM_isp_stage scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_stage 0x50C8
+#define HIVE_SIZE_isp_stage 832
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_stage scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_stage 0x50C8
+#define HIVE_SIZE_sp_isp_stage 832
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_vbuf_raw
+#define HIVE_MEM_vbuf_raw scalar_processor_2400_dmem
+#define HIVE_ADDR_vbuf_raw 0x318
+#define HIVE_SIZE_vbuf_raw 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_vbuf_raw scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_vbuf_raw 0x318
+#define HIVE_SIZE_sp_vbuf_raw 4
+
+/* function ia_css_sp_bin_copy_func: 48DF */
+
+/* function ia_css_queue_item_store: 442E */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs
+#define HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x4574
+#define HIVE_SIZE_ia_css_bufq_sp_pipe_private_metadata_bufs 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x4574
+#define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs
+#define HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x4584
+#define HIVE_SIZE_ia_css_bufq_sp_pipe_private_buffer_bufs 96
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x4584
+#define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 96
+
+/* function sp_start_isp: 412 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_binary_group
+#define HIVE_MEM_sp_binary_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_binary_group 0x54C0
+#define HIVE_SIZE_sp_binary_group 72
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_binary_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_binary_group 0x54C0
+#define HIVE_SIZE_sp_sp_binary_group 72
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_sw_state
+#define HIVE_MEM_sp_sw_state scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sw_state 0x57B0
+#define HIVE_SIZE_sp_sw_state 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_sw_state scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_sw_state 0x57B0
+#define HIVE_SIZE_sp_sp_sw_state 4
+
+/* function generate_sw_interrupt: 90D */
+
+/* function ia_css_thread_sp_main: CE9 */
+
+/* function ia_css_ispctrl_sp_init_internal_buffers: 2C4C */
+
+/* function ia_css_tagger_sp_propagate_frame: 1B44 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_stop_copy_preview
+#define HIVE_MEM_sp_stop_copy_preview scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_stop_copy_preview 0x578C
+#define HIVE_SIZE_sp_stop_copy_preview 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_stop_copy_preview scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_stop_copy_preview 0x578C
+#define HIVE_SIZE_sp_sp_stop_copy_preview 4
+
+/* function input_system_reg_load: AE2 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_vbuf_handles
+#define HIVE_MEM_vbuf_handles scalar_processor_2400_dmem
+#define HIVE_ADDR_vbuf_handles 0x5820
+#define HIVE_SIZE_vbuf_handles 600
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_vbuf_handles scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_vbuf_handles 0x5820
+#define HIVE_SIZE_sp_vbuf_handles 600
+
+/* function ia_css_isys_sp_token_map_destroy: 56F6 */
+
+/* function ia_css_queue_store: 45D1 */
+
+/* function ia_css_sp_flash_register: 2180 */
+
+/* function ia_css_isys_sp_backend_create: 5203 */
+
+/* function ia_css_pipeline_sp_init: 13BB */
+
+/* function ia_css_tagger_sp_configure: 1AD8 */
+
+/* function ia_css_ispctrl_sp_end_binary: 2A5B */
+
+/* function ia_css_s3a_sp_get_buffer_ddr_addr: 2548 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_lace_stat_bufs
+#define HIVE_MEM_ia_css_bufq_sp_pipe_private_lace_stat_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_lace_stat_bufs 0x45E4
+#define HIVE_SIZE_ia_css_bufq_sp_pipe_private_lace_stat_bufs 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_lace_stat_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_lace_stat_bufs 0x45E4
+#define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_lace_stat_bufs 16
+
+/* function receiver_port_reg_store: A87 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_event_is_pending_mask
+#define HIVE_MEM_event_is_pending_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_event_is_pending_mask 0x5C
+#define HIVE_SIZE_event_is_pending_mask 44
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_event_is_pending_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_event_is_pending_mask 0x5C
+#define HIVE_SIZE_sp_event_is_pending_mask 44
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_all_cb_elems_frame
+#define HIVE_MEM_sp_all_cb_elems_frame scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_all_cb_elems_frame 0x4298
+#define HIVE_SIZE_sp_all_cb_elems_frame 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_all_cb_elems_frame scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x4298
+#define HIVE_SIZE_sp_sp_all_cb_elems_frame 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host_sp_com
+#define HIVE_MEM_host_sp_com scalar_processor_2400_dmem
+#define HIVE_ADDR_host_sp_com 0x3DF0
+#define HIVE_SIZE_host_sp_com 180
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host_sp_com scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_host_sp_com 0x3DF0
+#define HIVE_SIZE_sp_host_sp_com 180
+
+/* function ia_css_queue_get_free_space: 41F0 */
+
+/* function exec_image_pipe: 60F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_init_dmem_data
+#define HIVE_MEM_sp_init_dmem_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_init_dmem_data 0x57B4
+#define HIVE_SIZE_sp_init_dmem_data 24
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_init_dmem_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_init_dmem_data 0x57B4
+#define HIVE_SIZE_sp_sp_init_dmem_data 24
+
+/* function ia_css_sp_metadata_start: 5037 */
+
+/* function ia_css_tagger_buf_sp_is_marked: 210E */
+
+/* function ia_css_bufq_sp_init_buffer_queues: 21F7 */
+
+/* function ia_css_pipeline_sp_stop: 139E */
+
+/* function ia_css_tagger_sp_connect_pipes: 1EF0 */
+
+/* function is_isp_debug_buffer_full: 3AB */
+
+/* function ia_css_dmaproxy_sp_configure_channel_from_info: 27A3 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_per_frame_data
+#define HIVE_MEM_sp_per_frame_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_per_frame_data 0x3EA4
+#define HIVE_SIZE_sp_per_frame_data 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_per_frame_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_per_frame_data 0x3EA4
+#define HIVE_SIZE_sp_sp_per_frame_data 4
+
+/* function ia_css_rmgr_sp_vbuf_dequeue: 5926 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_xmem_bin_addr
+#define HIVE_MEM_xmem_bin_addr scalar_processor_2400_dmem
+#define HIVE_ADDR_xmem_bin_addr 0x3EA8
+#define HIVE_SIZE_xmem_bin_addr 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_xmem_bin_addr scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_xmem_bin_addr 0x3EA8
+#define HIVE_SIZE_sp_xmem_bin_addr 4
+
+/* function ia_css_pipeline_sp_run: 10FF */
+
+/* function memcpy: 5E1E */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_GP_DEVICE_BASE
+#define HIVE_MEM_GP_DEVICE_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_GP_DEVICE_BASE 0x324
+#define HIVE_SIZE_GP_DEVICE_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_GP_DEVICE_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_GP_DEVICE_BASE 0x324
+#define HIVE_SIZE_sp_GP_DEVICE_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_thread_sp_ready_queue
+#define HIVE_MEM_ia_css_thread_sp_ready_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_thread_sp_ready_queue 0x1A4
+#define HIVE_SIZE_ia_css_thread_sp_ready_queue 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_thread_sp_ready_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_thread_sp_ready_queue 0x1A4
+#define HIVE_SIZE_sp_ia_css_thread_sp_ready_queue 12
+
+/* function input_system_reg_store: AE9 */
+
+/* function sp_dma_proxy_set_width_ab: 2640 */
+
+/* function ia_css_isys_sp_frontend_start: 5415 */
+
+/* function ia_css_uds_sp_scale_params: 5B67 */
+
+/* function __divu: 5D9C */
+
+/* function ia_css_thread_sp_get_state: C18 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_cont_capt_stop
+#define HIVE_MEM_sem_for_cont_capt_stop scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_cont_capt_stop 0x42A8
+#define HIVE_SIZE_sem_for_cont_capt_stop 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_cont_capt_stop scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x42A8
+#define HIVE_SIZE_sp_sem_for_cont_capt_stop 20
+
+/* function thread_fiber_sp_main: DC7 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_pipe_thread
+#define HIVE_MEM_sp_isp_pipe_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_pipe_thread 0x43D8
+#define HIVE_SIZE_sp_isp_pipe_thread 256
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_pipe_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x43D8
+#define HIVE_SIZE_sp_sp_isp_pipe_thread 256
+
+/* function ia_css_parambuf_sp_handle_parameter_sets: F9A */
+
+/* function ia_css_spctrl_sp_set_state: 505F */
+
+/* function ia_css_thread_sem_sp_signal: 6012 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_IRQ_BASE
+#define HIVE_MEM_IRQ_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_IRQ_BASE 0x2C
+#define HIVE_SIZE_IRQ_BASE 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_IRQ_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_IRQ_BASE 0x2C
+#define HIVE_SIZE_sp_IRQ_BASE 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_TIMED_CTRL_BASE
+#define HIVE_MEM_TIMED_CTRL_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_TIMED_CTRL_BASE 0x40
+#define HIVE_SIZE_TIMED_CTRL_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_TIMED_CTRL_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_TIMED_CTRL_BASE 0x40
+#define HIVE_SIZE_sp_TIMED_CTRL_BASE 4
+
+/* function ia_css_isys_sp_isr: 6547 */
+
+/* function ia_css_isys_sp_generate_exp_id: 576B */
+
+/* function ia_css_rmgr_sp_init: 5827 */
+
+/* function ia_css_thread_sem_sp_init: 60E5 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_is_isp_requested
+#define HIVE_MEM_is_isp_requested scalar_processor_2400_dmem
+#define HIVE_ADDR_is_isp_requested 0x330
+#define HIVE_SIZE_is_isp_requested 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_is_isp_requested scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_is_isp_requested 0x330
+#define HIVE_SIZE_sp_is_isp_requested 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_cb_frame
+#define HIVE_MEM_sem_for_reading_cb_frame scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_reading_cb_frame 0x42BC
+#define HIVE_SIZE_sem_for_reading_cb_frame 40
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_cb_frame scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x42BC
+#define HIVE_SIZE_sp_sem_for_reading_cb_frame 40
+
+/* function ia_css_dmaproxy_sp_execute: 26FB */
+
+/* function ia_css_queue_is_empty: 40D3 */
+
+/* function ia_css_pipeline_sp_has_stopped: 1394 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_verbosity
+#define HIVE_MEM_verbosity scalar_processor_2400_dmem
+#define HIVE_ADDR_verbosity 0x1F78
+#define HIVE_SIZE_verbosity 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_verbosity scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_verbosity 0x1F78
+#define HIVE_SIZE_sp_verbosity 4
+
+/* function ia_css_ispctrl_sp_swap_isp_buffers: 3E13 */
+
+/* function ia_css_circbuf_extract: DEF */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_current_sp_thread
+#define HIVE_MEM_current_sp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_current_sp_thread 0x1A0
+#define HIVE_SIZE_current_sp_thread 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_current_sp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_current_sp_thread 0x1A0
+#define HIVE_SIZE_sp_current_sp_thread 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_rawcopy_sp_cur_co_fr_ct
+#define HIVE_MEM_ia_css_rawcopy_sp_cur_co_fr_ct scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_rawcopy_sp_cur_co_fr_ct 0x5790
+#define HIVE_SIZE_ia_css_rawcopy_sp_cur_co_fr_ct 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_rawcopy_sp_cur_co_fr_ct scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_rawcopy_sp_cur_co_fr_ct 0x5790
+#define HIVE_SIZE_sp_ia_css_rawcopy_sp_cur_co_fr_ct 4
+
+/* function ia_css_spctrl_sp_get_spid: 5066 */
+
+/* function ia_css_dmaproxy_sp_read_byte_addr: 63F5 */
+
+/* function ia_css_rmgr_sp_uninit: 5820 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_threads_stack
+#define HIVE_MEM_sp_threads_stack scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_threads_stack 0x130
+#define HIVE_SIZE_sp_threads_stack 24
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_threads_stack scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_threads_stack 0x130
+#define HIVE_SIZE_sp_sp_threads_stack 24
+
+/* function ia_css_circbuf_peek: DCE */
+
+/* function ia_css_parambuf_sp_wait_for_in_param: EFE */
+
+/* function ia_css_isys_sp_token_map_get_exp_id: 5673 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_all_cb_elems_param
+#define HIVE_MEM_sp_all_cb_elems_param scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_all_cb_elems_param 0x42E4
+#define HIVE_SIZE_sp_all_cb_elems_param 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_all_cb_elems_param scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x42E4
+#define HIVE_SIZE_sp_sp_all_cb_elems_param 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_pipeline_sp_curr_binary_id
+#define HIVE_MEM_pipeline_sp_curr_binary_id scalar_processor_2400_dmem
+#define HIVE_ADDR_pipeline_sp_curr_binary_id 0x1B0
+#define HIVE_SIZE_pipeline_sp_curr_binary_id 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_pipeline_sp_curr_binary_id scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_pipeline_sp_curr_binary_id 0x1B0
+#define HIVE_SIZE_sp_pipeline_sp_curr_binary_id 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_all_cbs_frame_desc
+#define HIVE_MEM_sp_all_cbs_frame_desc scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_all_cbs_frame_desc 0x42F4
+#define HIVE_SIZE_sp_all_cbs_frame_desc 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_all_cbs_frame_desc scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x42F4
+#define HIVE_SIZE_sp_sp_all_cbs_frame_desc 8
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_ispctrl_sp_delay_in_idx
+#define HIVE_MEM_ia_css_ispctrl_sp_delay_in_idx scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_ispctrl_sp_delay_in_idx 0x5000
+#define HIVE_SIZE_ia_css_ispctrl_sp_delay_in_idx 96
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_ispctrl_sp_delay_in_idx scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_ispctrl_sp_delay_in_idx 0x5000
+#define HIVE_SIZE_sp_ia_css_ispctrl_sp_delay_in_idx 96
+
+/* function sp_isys_copy_func_v2: 726 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_cb_param
+#define HIVE_MEM_sem_for_reading_cb_param scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_reading_cb_param 0x42FC
+#define HIVE_SIZE_sem_for_reading_cb_param 40
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_cb_param scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x42FC
+#define HIVE_SIZE_sp_sem_for_reading_cb_param 40
+
+/* function ia_css_queue_get_used_space: 41A2 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_cont_capt_start
+#define HIVE_MEM_sem_for_cont_capt_start scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_cont_capt_start 0x4324
+#define HIVE_SIZE_sem_for_cont_capt_start 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_cont_capt_start scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x4324
+#define HIVE_SIZE_sp_sem_for_cont_capt_start 20
+
+/* function ia_css_tagger_buf_sp_mark: 2159 */
+
+/* function ia_css_ispctrl_sp_output_compute_dma_info: 3714 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs
+#define HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x45F4
+#define HIVE_SIZE_ia_css_bufq_sp_pipe_private_s3a_bufs 48
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x45F4
+#define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 48
+
+/* function ia_css_queue_is_full: 423F */
+
+/* function debug_buffer_init_isp: FB */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem
+#define HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x5A78
+#define HIVE_SIZE_ia_css_rmgr_sp_mipi_frame_sem 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x5A78
+#define HIVE_SIZE_sp_ia_css_rmgr_sp_mipi_frame_sem 20
+
+/* function ia_css_sp_raw_copy_func: 4990 */
+
+/* function ia_css_rmgr_sp_refcount_dump: 5901 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id
+#define HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4624
+#define HIVE_SIZE_ia_css_bufq_sp_pipe_private_isp_parameters_id 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4624
+#define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_pipe_threads
+#define HIVE_MEM_sp_pipe_threads scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_pipe_threads 0x120
+#define HIVE_SIZE_sp_pipe_threads 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_pipe_threads scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_pipe_threads 0x120
+#define HIVE_SIZE_sp_sp_pipe_threads 16
+
+/* function sp_event_proxy_func: 72D */
+
+/* function ia_css_thread_sp_yield: 5F88 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host2sp_event_queue_handle
+#define HIVE_MEM_host2sp_event_queue_handle scalar_processor_2400_dmem
+#define HIVE_ADDR_host2sp_event_queue_handle 0x4634
+#define HIVE_SIZE_host2sp_event_queue_handle 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host2sp_event_queue_handle scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_host2sp_event_queue_handle 0x4634
+#define HIVE_SIZE_sp_host2sp_event_queue_handle 12
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_all_cbs_param_desc
+#define HIVE_MEM_sp_all_cbs_param_desc scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_all_cbs_param_desc 0x4338
+#define HIVE_SIZE_sp_all_cbs_param_desc 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_all_cbs_param_desc scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x4338
+#define HIVE_SIZE_sp_sp_all_cbs_param_desc 8
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb
+#define HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x4FF8
+#define HIVE_SIZE_ia_css_dmaproxy_sp_invalidate_tlb 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x4FF8
+#define HIVE_SIZE_sp_ia_css_dmaproxy_sp_invalidate_tlb 4
+
+/* function ia_css_thread_sp_fork: CA5 */
+
+/* function ia_css_tagger_sp_destroy: 1EFA */
+
+/* function ia_css_dmaproxy_sp_vmem_read: 2684 */
+
+/* function ia_css_ifmtr_sp_init: 577F */
+
+/* function initialize_sp_group: 6FD */
+
+/* function __ia_css_sp_raw_copy_func_critical: 64EB */
+
+/* function ia_css_thread_sp_init: CD1 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_DMEM_BASE
+#define HIVE_MEM_ISP_DMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_DMEM_BASE 0x10
+#define HIVE_SIZE_ISP_DMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_DMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_DMEM_BASE 0x10
+#define HIVE_SIZE_sp_ISP_DMEM_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_SP_DMEM_BASE
+#define HIVE_MEM_SP_DMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_SP_DMEM_BASE 0x4
+#define HIVE_SIZE_SP_DMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_SP_DMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_SP_DMEM_BASE 0x4
+#define HIVE_SIZE_sp_SP_DMEM_BASE 4
+
+/* function ia_css_dmaproxy_sp_read: 271C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_raw_copy_line_count
+#define HIVE_MEM_raw_copy_line_count scalar_processor_2400_dmem
+#define HIVE_ADDR_raw_copy_line_count 0x2F0
+#define HIVE_SIZE_raw_copy_line_count 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_raw_copy_line_count scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_raw_copy_line_count 0x2F0
+#define HIVE_SIZE_sp_raw_copy_line_count 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host2sp_tag_cmd_queue_handle
+#define HIVE_MEM_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
+#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x4640
+#define HIVE_SIZE_host2sp_tag_cmd_queue_handle 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x4640
+#define HIVE_SIZE_sp_host2sp_tag_cmd_queue_handle 12
+
+/* function ia_css_queue_peek: 4117 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_flash_sp_frame_cnt
+#define HIVE_MEM_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x4568
+#define HIVE_SIZE_ia_css_flash_sp_frame_cnt 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x4568
+#define HIVE_SIZE_sp_ia_css_flash_sp_frame_cnt 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_event_can_send_token_mask
+#define HIVE_MEM_event_can_send_token_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_event_can_send_token_mask 0x88
+#define HIVE_SIZE_event_can_send_token_mask 44
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_event_can_send_token_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_event_can_send_token_mask 0x88
+#define HIVE_SIZE_sp_event_can_send_token_mask 44
+
+/* function ia_css_lace_stat_sp_get_buffer_ddr_addr: 2541 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_started
+#define HIVE_MEM_started scalar_processor_2400_dmem
+#define HIVE_ADDR_started 0x1F74
+#define HIVE_SIZE_started 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_started scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_started 0x1F74
+#define HIVE_SIZE_sp_started 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_thread
+#define HIVE_MEM_isp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_thread 0x5408
+#define HIVE_SIZE_isp_thread 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_thread 0x5408
+#define HIVE_SIZE_sp_isp_thread 4
+
+/* function ia_css_isys_sp_frontend_destroy: 5482 */
+
+/* function is_ddr_debug_buffer_full: 330 */
+
+/* function ia_css_isys_sp_frontend_stop: 53DE */
+
+/* function ia_css_isys_sp_token_map_init: 5737 */
+
+/* function sp_dma_proxy_isp_write_addr: 269C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_threads_fiber
+#define HIVE_MEM_sp_threads_fiber scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_threads_fiber 0x160
+#define HIVE_SIZE_sp_threads_fiber 24
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_threads_fiber scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_threads_fiber 0x160
+#define HIVE_SIZE_sp_sp_threads_fiber 24
+
+/* function encode_and_post_sp_event: A42 */
+
+/* function debug_enqueue_ddr: 10A */
+
+/* function ia_css_rmgr_sp_refcount_init_vbuf: 58CE */
+
+/* function dmaproxy_sp_read_write: 648D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer
+#define HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x4FFC
+#define HIVE_SIZE_ia_css_dmaproxy_isp_dma_cmd_buffer 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x4FFC
+#define HIVE_SIZE_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 4
+
+/* function ia_css_dmaproxy_sp_ack: 610D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host2sp_buffer_queue_handle
+#define HIVE_MEM_host2sp_buffer_queue_handle scalar_processor_2400_dmem
+#define HIVE_ADDR_host2sp_buffer_queue_handle 0x464C
+#define HIVE_SIZE_host2sp_buffer_queue_handle 288
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host2sp_buffer_queue_handle scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x464C
+#define HIVE_SIZE_sp_host2sp_buffer_queue_handle 288
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_flash_sp_in_service
+#define HIVE_MEM_ia_css_flash_sp_in_service scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_flash_sp_in_service 0x2EFC
+#define HIVE_SIZE_ia_css_flash_sp_in_service 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_flash_sp_in_service scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_flash_sp_in_service 0x2EFC
+#define HIVE_SIZE_sp_ia_css_flash_sp_in_service 4
+
+/* function ia_css_dmaproxy_sp_process: 613C */
+
+/* function ia_css_isys_sp_backend_rcv_acquire_ack: 50B3 */
+
+/* function ia_css_isys_sp_backend_pre_acquire_request: 50C9 */
+
+/* function ia_css_ispctrl_sp_init_cs: 2B55 */
+
+/* function ia_css_spctrl_sp_init: 5074 */
+
+/* function sp_event_proxy_init: 74F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_output
+#define HIVE_MEM_sp_output scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_output 0x3EAC
+#define HIVE_SIZE_sp_output 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_output scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_output 0x3EAC
+#define HIVE_SIZE_sp_sp_output 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues
+#define HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x476C
+#define HIVE_SIZE_ia_css_bufq_sp_sems_for_host2sp_buf_queues 480
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x476C
+#define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 480
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_CTRL_BASE
+#define HIVE_MEM_ISP_CTRL_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_CTRL_BASE 0x8
+#define HIVE_SIZE_ISP_CTRL_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_CTRL_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_CTRL_BASE 0x8
+#define HIVE_SIZE_sp_ISP_CTRL_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_INPUT_FORMATTER_BASE
+#define HIVE_MEM_INPUT_FORMATTER_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_INPUT_FORMATTER_BASE 0x4C
+#define HIVE_SIZE_INPUT_FORMATTER_BASE 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_INPUT_FORMATTER_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_INPUT_FORMATTER_BASE 0x4C
+#define HIVE_SIZE_sp_INPUT_FORMATTER_BASE 16
+
+/* function sp_dma_proxy_reset_channels: 2975 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_sp2host_event_queue
+#define HIVE_MEM_sem_for_sp2host_event_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_sp2host_event_queue 0x4284
+#define HIVE_SIZE_sem_for_sp2host_event_queue 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_sp2host_event_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_sp2host_event_queue 0x4284
+#define HIVE_SIZE_sp_sem_for_sp2host_event_queue 20
+
+/* function ia_css_isys_sp_backend_acquire: 51D9 */
+
+/* function ia_css_tagger_sp_update_size: 1F6D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_host_sp_queue
+#define HIVE_MEM_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x494C
+#define HIVE_SIZE_ia_css_bufq_host_sp_queue 1148
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x494C
+#define HIVE_SIZE_sp_ia_css_bufq_host_sp_queue 1148
+
+/* function thread_fiber_sp_create: D36 */
+
+/* function ia_css_dmaproxy_sp_set_increments: 2811 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_writing_cb_frame
+#define HIVE_MEM_sem_for_writing_cb_frame scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_writing_cb_frame 0x4340
+#define HIVE_SIZE_sem_for_writing_cb_frame 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_writing_cb_frame scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x4340
+#define HIVE_SIZE_sp_sem_for_writing_cb_frame 20
+
+/* function receiver_reg_store: A95 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_writing_cb_param
+#define HIVE_MEM_sem_for_writing_cb_param scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_writing_cb_param 0x4354
+#define HIVE_SIZE_sem_for_writing_cb_param 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_writing_cb_param scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x4354
+#define HIVE_SIZE_sp_sem_for_writing_cb_param 20
+
+/* function sp_start_isp_entry: 408 */
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifdef HIVE_ADDR_sp_start_isp_entry
+#endif
+#define HIVE_ADDR_sp_start_isp_entry 0x408
+#endif
+#define HIVE_ADDR_sp_sp_start_isp_entry 0x408
+
+/* function ia_css_dmaproxy_sp_channel_acquire: 29A4 */
+
+/* function ia_css_rmgr_sp_add_num_vbuf: 5AD1 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_ispctrl_sp_delay_out_idx
+#define HIVE_MEM_ia_css_ispctrl_sp_delay_out_idx scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_ispctrl_sp_delay_out_idx 0x5060
+#define HIVE_SIZE_ia_css_ispctrl_sp_delay_out_idx 96
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_ispctrl_sp_delay_out_idx scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_ispctrl_sp_delay_out_idx 0x5060
+#define HIVE_SIZE_sp_ia_css_ispctrl_sp_delay_out_idx 96
+
+/* function ia_css_isys_sp_token_map_create: 5764 */
+
+/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 2637 */
+
+/* function ia_css_tagger_buf_sp_push_marked: 20AC */
+
+/* function ia_css_bufq_sp_is_dynamic_buffer: 2526 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_group
+#define HIVE_MEM_sp_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_group 0x3EC0
+#define HIVE_SIZE_sp_group 960
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_group 0x3EC0
+#define HIVE_SIZE_sp_sp_group 960
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_event_proxy_thread
+#define HIVE_MEM_sp_event_proxy_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_event_proxy_thread 0x44D8
+#define HIVE_SIZE_sp_event_proxy_thread 64
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_event_proxy_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_event_proxy_thread 0x44D8
+#define HIVE_SIZE_sp_sp_event_proxy_thread 64
+
+/* function ia_css_thread_sp_kill: C6B */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_cur_loc
+#define HIVE_MEM_cur_loc scalar_processor_2400_dmem
+#define HIVE_ADDR_cur_loc 0x1F6C
+#define HIVE_SIZE_cur_loc 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_cur_loc scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_cur_loc 0x1F6C
+#define HIVE_SIZE_sp_cur_loc 4
+
+/* function ia_css_tagger_sp_create: 1F1B */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_MMU_BASE
+#define HIVE_MEM_MMU_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_MMU_BASE 0x24
+#define HIVE_SIZE_MMU_BASE 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_MMU_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_MMU_BASE 0x24
+#define HIVE_SIZE_sp_MMU_BASE 8
+
+/* function ia_css_dmaproxy_sp_channel_release: 298D */
+
+/* function ia_css_dmaproxy_sp_is_idle: 2960 */
+
+/* function isp_hmem_load: B29 */
+
+/* function ia_css_eventq_sp_send: 29E9 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_isys_sp_error_cnt
+#define HIVE_MEM_ia_css_isys_sp_error_cnt scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_isys_sp_error_cnt 0x57D8
+#define HIVE_SIZE_ia_css_isys_sp_error_cnt 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_isys_sp_error_cnt scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_isys_sp_error_cnt 0x57D8
+#define HIVE_SIZE_sp_ia_css_isys_sp_error_cnt 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_debug_buffer_ddr_address
+#define HIVE_MEM_debug_buffer_ddr_address scalar_processor_2400_dmem
+#define HIVE_ADDR_debug_buffer_ddr_address 0xBC
+#define HIVE_SIZE_debug_buffer_ddr_address 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_debug_buffer_ddr_address scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_debug_buffer_ddr_address 0xBC
+#define HIVE_SIZE_sp_debug_buffer_ddr_address 4
+
+/* function ia_css_rmgr_sp_refcount_retain_vbuf: 598C */
+
+/* function ia_css_thread_sp_set_priority: C63 */
+
+/* function sizeof_hmem: BD4 */
+
+/* function cnd_input_system_cfg: 61F */
+
+/* function __ia_css_dmaproxy_sp_process_text: 2594 */
+
+/* function ia_css_dmaproxy_sp_set_width_exception: 27FB */
+
+/* function ia_css_flash_sp_init_internal_params: 21EC */
+
+/* function sp_generate_events: 92A */
+
+/* function __modu: 5DE2 */
+
+/* function ia_css_dmaproxy_sp_init_isp_vector: 2656 */
+
+/* function isp_vamem_store: 0 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_counter
+#define HIVE_MEM_counter scalar_processor_2400_dmem
+#define HIVE_ADDR_counter 0x1F70
+#define HIVE_SIZE_counter 2
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_counter scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_counter 0x1F70
+#define HIVE_SIZE_sp_counter 2
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_major_masks
+#define HIVE_MEM_major_masks scalar_processor_2400_dmem
+#define HIVE_ADDR_major_masks 0x178
+#define HIVE_SIZE_major_masks 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_major_masks scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_major_masks 0x178
+#define HIVE_SIZE_sp_major_masks 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_GDC_BASE
+#define HIVE_MEM_GDC_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_GDC_BASE 0x44
+#define HIVE_SIZE_GDC_BASE 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_GDC_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_GDC_BASE 0x44
+#define HIVE_SIZE_sp_GDC_BASE 8
+
+/* function ia_css_queue_local_init: 4408 */
+
+/* function sp_event_proxy_callout_func: 5E61 */
+
+/* function ia_css_dmaproxy_sp_deregister_channel_from_port: 261E */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_thread_sp_num_ready_threads
+#define HIVE_MEM_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x455C
+#define HIVE_SIZE_ia_css_thread_sp_num_ready_threads 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x455C
+#define HIVE_SIZE_sp_ia_css_thread_sp_num_ready_threads 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_threads_stack_size
+#define HIVE_MEM_sp_threads_stack_size scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_threads_stack_size 0x148
+#define HIVE_SIZE_sp_threads_stack_size 24
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_threads_stack_size scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_threads_stack_size 0x148
+#define HIVE_SIZE_sp_sp_threads_stack_size 24
+
+/* function ia_css_ispctrl_sp_isp_done_row_striping: 365C */
+
+/* function __ia_css_isys_sp_isr_text: 54C7 */
+
+/* function ia_css_queue_dequeue: 4287 */
+
+/* function ia_css_dmaproxy_sp_configure_channel: 640C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_current_thread_fiber_sp
+#define HIVE_MEM_current_thread_fiber_sp scalar_processor_2400_dmem
+#define HIVE_ADDR_current_thread_fiber_sp 0x4564
+#define HIVE_SIZE_current_thread_fiber_sp 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_current_thread_fiber_sp scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_current_thread_fiber_sp 0x4564
+#define HIVE_SIZE_sp_current_thread_fiber_sp 4
+
+/* function ia_css_circbuf_pop: E87 */
+
+/* function irq_raise_set_token: B7 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_GPIO_BASE
+#define HIVE_MEM_GPIO_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_GPIO_BASE 0x3C
+#define HIVE_SIZE_GPIO_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_GPIO_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_GPIO_BASE 0x3C
+#define HIVE_SIZE_sp_GPIO_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_ph
+#define HIVE_MEM_isp_ph scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_ph 0x57E8
+#define HIVE_SIZE_isp_ph 28
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_ph scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_ph 0x57E8
+#define HIVE_SIZE_sp_isp_ph 28
+
+/* function ia_css_isys_sp_token_map_flush: 56D7 */
+
+/* function ia_css_ispctrl_sp_init_ds: 2D04 */
+
+/* function get_xmem_base_addr_raw: 309A */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_all_cbs_param
+#define HIVE_MEM_sp_all_cbs_param scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_all_cbs_param 0x4368
+#define HIVE_SIZE_sp_all_cbs_param 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_all_cbs_param scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_all_cbs_param 0x4368
+#define HIVE_SIZE_sp_sp_all_cbs_param 16
+
+/* function ia_css_circbuf_create: ED1 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_rawcopy_sp_tgt_co_fr_ct
+#define HIVE_MEM_ia_css_rawcopy_sp_tgt_co_fr_ct scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_rawcopy_sp_tgt_co_fr_ct 0x5794
+#define HIVE_SIZE_ia_css_rawcopy_sp_tgt_co_fr_ct 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_rawcopy_sp_tgt_co_fr_ct scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tgt_co_fr_ct 0x5794
+#define HIVE_SIZE_sp_ia_css_rawcopy_sp_tgt_co_fr_ct 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_sp_group
+#define HIVE_MEM_sem_for_sp_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_sp_group 0x4378
+#define HIVE_SIZE_sem_for_sp_group 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_sp_group scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_sp_group 0x4378
+#define HIVE_SIZE_sp_sem_for_sp_group 20
+
+/* function ia_css_framebuf_sp_wait_for_in_frame: 5AF5 */
+
+/* function ia_css_tagger_buf_sp_push_unmarked: 1FDF */
+
+/* function isp_hmem_clear: AF0 */
+
+/* function ia_css_framebuf_sp_release_in_frame: 5B38 */
+
+/* function ia_css_isys_sp_backend_snd_acquire_request: 5120 */
+
+/* function ia_css_isys_sp_token_map_is_full: 5549 */
+
+/* function input_system_acquisition_run: ABE */
+
+/* function ia_css_ispctrl_sp_start_binary: 2B33 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs
+#define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x4DC8
+#define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x4DC8
+#define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 16
+
+/* function ia_css_eventq_sp_recv: 29BB */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_pool
+#define HIVE_MEM_isp_pool scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_pool 0x310
+#define HIVE_SIZE_isp_pool 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_pool scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_pool 0x310
+#define HIVE_SIZE_sp_isp_pool 4
+
+/* function ia_css_rmgr_sp_rel_gen: 5869 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_event_any_pending_mask
+#define HIVE_MEM_event_any_pending_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_event_any_pending_mask 0x328
+#define HIVE_SIZE_event_any_pending_mask 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_event_any_pending_mask scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_event_any_pending_mask 0x328
+#define HIVE_SIZE_sp_event_any_pending_mask 8
+
+/* function ia_css_isys_sp_backend_push: 50DD */
+
+/* function sh_css_decode_tag_descr: 3C6 */
+
+/* function debug_enqueue_isp: 2DB */
+
+/* function ia_css_spctrl_sp_uninit: 506D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_HIVE_IF_SWITCH_CODE
+#define HIVE_MEM_HIVE_IF_SWITCH_CODE scalar_processor_2400_dmem
+#define HIVE_ADDR_HIVE_IF_SWITCH_CODE 0x19C
+#define HIVE_SIZE_HIVE_IF_SWITCH_CODE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_HIVE_IF_SWITCH_CODE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_HIVE_IF_SWITCH_CODE 0x19C
+#define HIVE_SIZE_sp_HIVE_IF_SWITCH_CODE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs
+#define HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x4DD8
+#define HIVE_SIZE_ia_css_bufq_sp_pipe_private_dis_bufs 80
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x4DD8
+#define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_dis_bufs 80
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_isp_idle
+#define HIVE_MEM_sem_for_isp_idle scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_isp_idle 0x438C
+#define HIVE_SIZE_sem_for_isp_idle 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_isp_idle scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_isp_idle 0x438C
+#define HIVE_SIZE_sp_sem_for_isp_idle 20
+
+/* function ia_css_dmaproxy_sp_write_byte_addr: 26CA */
+
+/* function ia_css_dmaproxy_sp_init: 25F0 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_VAMEM_BASE
+#define HIVE_MEM_ISP_VAMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_VAMEM_BASE 0x14
+#define HIVE_SIZE_ISP_VAMEM_BASE 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_VAMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_VAMEM_BASE 0x14
+#define HIVE_SIZE_sp_ISP_VAMEM_BASE 12
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_rawcopy_sp_tagger
+#define HIVE_MEM_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x5798
+#define HIVE_SIZE_ia_css_rawcopy_sp_tagger 24
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x5798
+#define HIVE_SIZE_sp_ia_css_rawcopy_sp_tagger 24
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids
+#define HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x4E28
+#define HIVE_SIZE_ia_css_bufq_sp_pipe_private_exp_ids 52
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x4E28
+#define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_exp_ids 52
+
+/* function ia_css_queue_item_load: 451D */
+
+/* function ia_css_spctrl_sp_get_state: 5058 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_callout_sp_thread
+#define HIVE_MEM_callout_sp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_callout_sp_thread 0x4558
+#define HIVE_SIZE_callout_sp_thread 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_callout_sp_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_callout_sp_thread 0x4558
+#define HIVE_SIZE_sp_callout_sp_thread 4
+
+/* function thread_fiber_sp_init: DBD */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_SP_PMEM_BASE
+#define HIVE_MEM_SP_PMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_SP_PMEM_BASE 0x0
+#define HIVE_SIZE_SP_PMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_SP_PMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_SP_PMEM_BASE 0x0
+#define HIVE_SIZE_sp_SP_PMEM_BASE 4
+
+/* function ia_css_isys_sp_token_map_snd_acquire_req: 565A */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_input_stream_format
+#define HIVE_MEM_sp_isp_input_stream_format scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_input_stream_format 0x3CB0
+#define HIVE_SIZE_sp_isp_input_stream_format 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_input_stream_format scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3CB0
+#define HIVE_SIZE_sp_sp_isp_input_stream_format 16
+
+/* function __mod: 5DCE */
+
+/* function ia_css_dmaproxy_sp_init_dmem_channel: 2736 */
+
+/* function ia_css_thread_sp_join: C94 */
+
+/* function ia_css_dmaproxy_sp_add_command: 64CF */
+
+/* function ia_css_sp_metadata_thread_func: 4F11 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_dmaproxy_sp_proxy_status
+#define HIVE_MEM_dmaproxy_sp_proxy_status scalar_processor_2400_dmem
+#define HIVE_ADDR_dmaproxy_sp_proxy_status 0x22C
+#define HIVE_SIZE_dmaproxy_sp_proxy_status 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_dmaproxy_sp_proxy_status scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_dmaproxy_sp_proxy_status 0x22C
+#define HIVE_SIZE_sp_dmaproxy_sp_proxy_status 4
+
+/* function ia_css_sp_metadata_wait: 5026 */
+
+/* function ia_css_event_sp_encode: 2A47 */
+
+/* function ia_css_thread_sp_run: D00 */
+
+/* function sp_isys_copy_func: 71F */
+
+/* function ia_css_isys_sp_backend_flush: 5140 */
+
+/* function ia_css_sp_input_system_token_map_reset_capturing_buffer_on_error: 551A */
+
+/* function ia_css_sp_isp_param_init_isp_memories: 3F63 */
+
+/* function register_isr: 854 */
+
+/* function irq_raise: C9 */
+
+/* function ia_css_dmaproxy_sp_mmu_invalidate: 254F */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_HIVE_IF_SRST_ADDRESS
+#define HIVE_MEM_HIVE_IF_SRST_ADDRESS scalar_processor_2400_dmem
+#define HIVE_ADDR_HIVE_IF_SRST_ADDRESS 0x17C
+#define HIVE_SIZE_HIVE_IF_SRST_ADDRESS 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_HIVE_IF_SRST_ADDRESS scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_HIVE_IF_SRST_ADDRESS 0x17C
+#define HIVE_SIZE_sp_HIVE_IF_SRST_ADDRESS 16
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp2host_event_queue_handle
+#define HIVE_MEM_sp2host_event_queue_handle scalar_processor_2400_dmem
+#define HIVE_ADDR_sp2host_event_queue_handle 0x4E5C
+#define HIVE_SIZE_sp2host_event_queue_handle 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp2host_event_queue_handle scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp2host_event_queue_handle 0x4E5C
+#define HIVE_SIZE_sp_sp2host_event_queue_handle 12
+
+/* function pipeline_sp_initialize_stage: 13DE */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_isys_sp_frontend_states
+#define HIVE_MEM_ia_css_isys_sp_frontend_states scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_isys_sp_frontend_states 0x57CC
+#define HIVE_SIZE_ia_css_isys_sp_frontend_states 12
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_isys_sp_frontend_states scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_isys_sp_frontend_states 0x57CC
+#define HIVE_SIZE_sp_ia_css_isys_sp_frontend_states 12
+
+/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 63DE */
+
+/* function ia_css_ispctrl_sp_done_ds: 2CE7 */
+
+/* function ia_css_sp_isp_param_get_mem_inits: 3F3E */
+
+/* function ia_css_parambuf_sp_init_buffer_queues: 10E9 */
+
+/* function ia_css_tagger_buf_sp_pop_unmarked: 1F78 */
+
+/* function input_system_cfg: A79 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_HMEM_BASE
+#define HIVE_MEM_ISP_HMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_HMEM_BASE 0x20
+#define HIVE_SIZE_ISP_HMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_HMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_HMEM_BASE 0x20
+#define HIVE_SIZE_sp_ISP_HMEM_BASE 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_frames
+#define HIVE_MEM_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x4E68
+#define HIVE_SIZE_ia_css_bufq_sp_pipe_private_frames 208
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x4E68
+#define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_frames 208
+
+/* function ia_css_isys_sp_backend_release: 51C0 */
+
+/* function ia_css_isys_sp_backend_destroy: 51EA */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp2host_buffer_queue_handle
+#define HIVE_MEM_sp2host_buffer_queue_handle scalar_processor_2400_dmem
+#define HIVE_ADDR_sp2host_buffer_queue_handle 0x4F38
+#define HIVE_SIZE_sp2host_buffer_queue_handle 72
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp2host_buffer_queue_handle scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x4F38
+#define HIVE_SIZE_sp_sp2host_buffer_queue_handle 72
+
+/* function ia_css_isys_sp_token_map_check_mipi_frame_size: 561A */
+
+/* function ia_css_ispctrl_sp_init_isp_vars: 3BA9 */
+
+/* function ia_css_isys_sp_frontend_has_empty_mipi_buffer_cb: 523D */
+
+/* function ia_css_rmgr_sp_vbuf_enqueue: 5954 */
+
+/* function ia_css_tagger_sp_tag_exp_id: 1A7C */
+
+/* function ia_css_dmaproxy_sp_write: 26E1 */
+
+/* function ia_css_parambuf_sp_release_in_param: F65 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_irq_sw_interrupt_token
+#define HIVE_MEM_irq_sw_interrupt_token scalar_processor_2400_dmem
+#define HIVE_ADDR_irq_sw_interrupt_token 0x3CAC
+#define HIVE_SIZE_irq_sw_interrupt_token 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_irq_sw_interrupt_token scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x3CAC
+#define HIVE_SIZE_sp_irq_sw_interrupt_token 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_isp_addresses
+#define HIVE_MEM_sp_isp_addresses scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_addresses 0x540C
+#define HIVE_SIZE_sp_isp_addresses 180
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_isp_addresses scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_isp_addresses 0x540C
+#define HIVE_SIZE_sp_sp_isp_addresses 180
+
+/* function ia_css_rmgr_sp_acq_gen: 588D */
+
+/* function receiver_reg_load: A8E */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isps
+#define HIVE_MEM_isps scalar_processor_2400_dmem
+#define HIVE_ADDR_isps 0x5804
+#define HIVE_SIZE_isps 28
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isps scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isps 0x5804
+#define HIVE_SIZE_sp_isps 28
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_host_sp_queues_initialized
+#define HIVE_MEM_host_sp_queues_initialized scalar_processor_2400_dmem
+#define HIVE_ADDR_host_sp_queues_initialized 0x3CC0
+#define HIVE_SIZE_host_sp_queues_initialized 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_host_sp_queues_initialized scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_host_sp_queues_initialized 0x3CC0
+#define HIVE_SIZE_sp_host_sp_queues_initialized 4
+
+/* function ia_css_queue_uninit: 43C6 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_ispctrl_sp_isp_started
+#define HIVE_MEM_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x50C0
+#define HIVE_SIZE_ia_css_ispctrl_sp_isp_started 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x50C0
+#define HIVE_SIZE_sp_ia_css_ispctrl_sp_isp_started 4
+
+/* function ia_css_bufq_sp_release_dynamic_buf: 2280 */
+
+/* function ia_css_sp_metadata_thread_terminate: 5013 */
+
+/* function ia_css_dmaproxy_sp_set_height_exception: 27E9 */
+
+/* function ia_css_dmaproxy_sp_init_vmem_channel: 276C */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_num_ready_threads
+#define HIVE_MEM_num_ready_threads scalar_processor_2400_dmem
+#define HIVE_ADDR_num_ready_threads 0x4560
+#define HIVE_SIZE_num_ready_threads 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_num_ready_threads scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_num_ready_threads 0x4560
+#define HIVE_SIZE_sp_num_ready_threads 4
+
+/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 26B3 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_vbuf_spref
+#define HIVE_MEM_vbuf_spref scalar_processor_2400_dmem
+#define HIVE_ADDR_vbuf_spref 0x314
+#define HIVE_SIZE_vbuf_spref 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_vbuf_spref scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_vbuf_spref 0x314
+#define HIVE_SIZE_sp_vbuf_spref 4
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_metadata_thread
+#define HIVE_MEM_sp_metadata_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_metadata_thread 0x4518
+#define HIVE_SIZE_sp_metadata_thread 64
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_metadata_thread scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_metadata_thread 0x4518
+#define HIVE_SIZE_sp_sp_metadata_thread 64
+
+/* function ia_css_queue_enqueue: 4311 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_flash_sp_request
+#define HIVE_MEM_ia_css_flash_sp_request scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_flash_sp_request 0x456C
+#define HIVE_SIZE_ia_css_flash_sp_request 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_flash_sp_request scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x456C
+#define HIVE_SIZE_sp_ia_css_flash_sp_request 4
+
+/* function ia_css_dmaproxy_sp_vmem_write: 266D */
+
+/* function ia_css_tagger_buf_sp_unmark: 2132 */
+
+/* function ia_css_isys_sp_token_map_snd_capture_req: 5680 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_reading_if
+#define HIVE_MEM_sem_for_reading_if scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_reading_if 0x43A0
+#define HIVE_SIZE_sem_for_reading_if 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_reading_if scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_reading_if 0x43A0
+#define HIVE_SIZE_sp_sem_for_reading_if 20
+
+/* function sp_generate_interrupts: 869 */
+
+/* function ia_css_pipeline_sp_start: 13A6 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_data
+#define HIVE_MEM_sp_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_data 0x5508
+#define HIVE_SIZE_sp_data 640
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_data scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_data 0x5508
+#define HIVE_SIZE_sp_sp_data 640
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_BAMEM_BASE
+#define HIVE_MEM_ISP_BAMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_BAMEM_BASE 0x320
+#define HIVE_SIZE_ISP_BAMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_BAMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_BAMEM_BASE 0x320
+#define HIVE_SIZE_sp_ISP_BAMEM_BASE 4
+
+/* function ia_css_isys_sp_frontend_rcv_capture_ack: 52EC */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues
+#define HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x4F80
+#define HIVE_SIZE_ia_css_bufq_sp_sems_for_sp2host_buf_queues 120
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x4F80
+#define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 120
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_mem_map
+#define HIVE_MEM_mem_map scalar_processor_2400_dmem
+#define HIVE_ADDR_mem_map 0x3CC4
+#define HIVE_SIZE_mem_map 296
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_mem_map scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_mem_map 0x3CC4
+#define HIVE_SIZE_sp_mem_map 296
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_all_cbs_frame
+#define HIVE_MEM_sp_all_cbs_frame scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_all_cbs_frame 0x43B4
+#define HIVE_SIZE_sp_all_cbs_frame 16
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_all_cbs_frame scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_all_cbs_frame 0x43B4
+#define HIVE_SIZE_sp_sp_all_cbs_frame 16
+
+/* function thread_sp_queue_print: D1D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sem_for_str2mem
+#define HIVE_MEM_sem_for_str2mem scalar_processor_2400_dmem
+#define HIVE_ADDR_sem_for_str2mem 0x43C4
+#define HIVE_SIZE_sem_for_str2mem 20
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sem_for_str2mem scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sem_for_str2mem 0x43C4
+#define HIVE_SIZE_sp_sem_for_str2mem 20
+
+/* function ia_css_bufq_sp_acquire_dynamic_buf: 2448 */
+
+/* function ia_css_circbuf_destroy: EC8 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ISP_PMEM_BASE
+#define HIVE_MEM_ISP_PMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_ISP_PMEM_BASE 0xC
+#define HIVE_SIZE_ISP_PMEM_BASE 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ISP_PMEM_BASE scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ISP_PMEM_BASE 0xC
+#define HIVE_SIZE_sp_ISP_PMEM_BASE 4
+
+/* function ia_css_sp_isp_param_mem_load: 3EC6 */
+
+/* function __div: 5D86 */
+
+/* function ia_css_isys_sp_frontend_create: 5498 */
+
+/* function ia_css_rmgr_sp_refcount_release_vbuf: 596B */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_ia_css_flash_sp_in_use
+#define HIVE_MEM_ia_css_flash_sp_in_use scalar_processor_2400_dmem
+#define HIVE_ADDR_ia_css_flash_sp_in_use 0x4570
+#define HIVE_SIZE_ia_css_flash_sp_in_use 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_ia_css_flash_sp_in_use scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x4570
+#define HIVE_SIZE_sp_ia_css_flash_sp_in_use 4
+
+/* function ia_css_thread_sem_sp_wait: 605D */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_sleep_mode
+#define HIVE_MEM_sp_sleep_mode scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sleep_mode 0x3DEC
+#define HIVE_SIZE_sp_sleep_mode 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_sleep_mode scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_sleep_mode 0x3DEC
+#define HIVE_SIZE_sp_sp_sleep_mode 4
+
+/* function mmu_invalidate_cache: E0 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_sp_max_cb_elems
+#define HIVE_MEM_sp_max_cb_elems scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_max_cb_elems 0x118
+#define HIVE_SIZE_sp_max_cb_elems 8
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_sp_max_cb_elems scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_sp_max_cb_elems 0x118
+#define HIVE_SIZE_sp_sp_max_cb_elems 8
+
+/* function ia_css_dmaproxy_sp_register_channel_to_port: 262B */
+
+/* function ia_css_queue_remote_init: 43E8 */
+
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_isp_stop_req
+#define HIVE_MEM_isp_stop_req scalar_processor_2400_dmem
+#define HIVE_ADDR_isp_stop_req 0x4280
+#define HIVE_SIZE_isp_stop_req 4
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_isp_stop_req scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_isp_stop_req 0x4280
+#define HIVE_SIZE_sp_isp_stop_req 4
+
+#define HIVE_ICACHE_sp_critical_SEGMENT_START 0
+#define HIVE_ICACHE_sp_critical_NUM_SEGMENTS  1
+
+#endif /* _sp_map_h_ */
+extern void sh_css_dump_sp_dmem(void);
+void sh_css_dump_sp_dmem(void)
+{
+}
diff --git a/drivers/media/atomisp2/hmm/hmm.c b/drivers/media/atomisp2/hmm/hmm.c
new file mode 100644
index 0000000..733202e
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm.c
@@ -0,0 +1,488 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * This file contains entry functions for memory management of ISP driver
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/highmem.h>	/* for kmap */
+#include <linux/io.h>		/* for page_to_phys */
+
+#include "hmm/hmm.h"
+#include "hmm/hmm_pool.h"
+#include "hmm/hmm_bo.h"
+#include "hmm/hmm_bo_dev.h"
+
+#include "mmu/isp_mmu.h"
+
+#include "mmu/sh_mmu_mrfld.h"
+#include "mmu/sh_mmu_mfld.h"
+
+#include "atomisp_internal.h"
+#include "asm/cacheflush.h"
+
+#include "atomisp_common.h"
+
+#ifdef USE_SSSE3
+#include <asm/ssse3.h>
+#endif
+
+static struct hmm_bo_device bo_device;
+struct hmm_pool	dynamic_pool;
+struct hmm_pool	reserved_pool;
+static ia_css_ptr dummy_ptr;
+
+int hmm_init(void)
+{
+	int ret;
+
+	if (IS_MRFLD)
+		ret = hmm_bo_device_init(&bo_device, &sh_mmu_mrfld,
+					 ISP_VM_START, ISP_VM_SIZE);
+	else
+		ret = hmm_bo_device_init(&bo_device, &sh_mmu_mfld,
+					 ISP_VM_START, ISP_VM_SIZE);
+
+	if (ret)
+		v4l2_err(&atomisp_dev,
+			    "hmm_bo_device_init failed.\n");
+
+	ret = hmm_pool_register((unsigned int)dypool_enable,
+						HMM_POOL_TYPE_DYNAMIC);
+	if (ret)
+		v4l2_dbg(3, dbg_level, &atomisp_dev,
+			    "Failed to register dynamic memory pool.\n");
+
+	/*
+	 * As hmm use NULL to indicate invalid ISP virtual address,
+	 * and ISP_VM_START is defined to 0 too, so we allocate
+	 * one piece of dummy memory, which should return value 0,
+	 * at the beginning, to avoid hmm_alloc return 0 in the
+	 * further allocation.
+	 */
+	dummy_ptr = hmm_alloc(1, HMM_BO_PRIVATE, 0, 0, HMM_UNCACHED, NULL);
+	return ret;
+}
+
+int hmm_get_mmu_base_addr(void)
+{
+	if (sh_mmu_mrfld.get_pd_base == NULL) {
+		v4l2_err(&atomisp_dev,
+			 "get mmu base address failed.\n");
+		return -EINVAL;
+	}
+	return sh_mmu_mrfld.get_pd_base(&bo_device.mmu,
+					bo_device.mmu.base_address);
+}
+
+void hmm_cleanup(void)
+{
+	/*
+	 * free dummy memory first
+	 */
+	hmm_free(dummy_ptr);
+	dummy_ptr = 0;
+
+	hmm_bo_device_exit(&bo_device);
+	hmm_pool_unregister(HMM_POOL_TYPE_DYNAMIC);
+}
+
+ia_css_ptr hmm_alloc(size_t bytes, enum hmm_bo_type type,
+		int from_highmem, void *userptr, bool cached,void *priv)
+{
+	unsigned int pgnr;
+	struct hmm_buffer_object *bo;
+	int ret;
+
+	/*Get page number from size*/
+	pgnr = size_to_pgnr_ceil(bytes);
+
+	/*Buffer object structure init*/
+	bo = hmm_bo_create(&bo_device, pgnr);
+	if (!bo) {
+		v4l2_err(&atomisp_dev, "hmm_bo_create failed.\n");
+		goto create_bo_err;
+	}
+
+	/*Allocate virtual address in ISP virtual space*/
+	ret = hmm_bo_alloc_vm(bo);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "hmm_bo_alloc_vm failed.\n");
+		goto alloc_vm_err;
+	}
+
+	/*Allocate pages for memory*/
+	ret = hmm_bo_alloc_pages(bo, type, from_highmem, userptr, cached, priv);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "hmm_bo_alloc_pages failed.\n");
+		goto alloc_page_err;
+	}
+
+	/*Combind the virtual address and pages togather*/
+	ret = hmm_bo_bind(bo);
+	if (ret) {
+		v4l2_err(&atomisp_dev, "hmm_bo_bind failed.\n");
+		goto bind_err;
+	}
+	return bo->vm_node->start;
+
+bind_err:
+	hmm_bo_free_pages(bo);
+alloc_page_err:
+	hmm_bo_free_vm(bo);
+alloc_vm_err:
+	hmm_bo_unref(bo);
+create_bo_err:
+	return 0;
+}
+
+void hmm_free(ia_css_ptr virt)
+{
+	struct hmm_buffer_object *bo;
+
+	bo = hmm_bo_device_search_start(&bo_device, (unsigned int)virt);
+
+	if (!bo) {
+		v4l2_err(&atomisp_dev,
+			    "can not find buffer object start with "
+			    "address 0x%x\n", (unsigned int)virt);
+		return;
+	}
+
+	hmm_bo_unbind(bo);
+
+	hmm_bo_free_pages(bo);
+
+	hmm_bo_free_vm(bo);
+
+	hmm_bo_unref(bo);
+}
+
+static inline int hmm_check_bo(struct hmm_buffer_object *bo, unsigned int ptr)
+{
+	if (!bo) {
+		v4l2_err(&atomisp_dev,
+			    "can not find buffer object contains "
+			    "address 0x%x\n", ptr);
+		return -EINVAL;
+	}
+
+	if (!hmm_bo_page_allocated(bo)) {
+		v4l2_err(&atomisp_dev,
+			    "buffer object has no page allocated.\n");
+		return -EINVAL;
+	}
+
+	if (!hmm_bo_vm_allocated(bo)) {
+		v4l2_err(&atomisp_dev,
+			    "buffer object has no virtual address"
+			    " space allocated.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*Read function in ISP memory management*/
+static int load_and_flush(ia_css_ptr virt, void *data, unsigned int bytes)
+{
+	unsigned int ptr;
+	struct hmm_buffer_object *bo;
+	unsigned int idx, offset, len;
+	char *src, *des;
+	int ret;
+
+	ptr = (unsigned int)virt;
+
+	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
+	ret = hmm_check_bo(bo, ptr);
+	if (ret)
+		return ret;
+
+	des = (char *)data;
+	while (bytes) {
+		idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
+		offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
+
+		src = (char *)kmap(bo->page_obj[idx].page);
+		if (!src) {
+			v4l2_err(&atomisp_dev,
+				    "kmap buffer object page failed: "
+				    "pg_idx = %d\n", idx);
+			return -EINVAL;
+		}
+
+		src += offset;
+
+		if ((bytes + offset) >= PAGE_SIZE) {
+			len = PAGE_SIZE - offset;
+			bytes -= len;
+		} else {
+			len = bytes;
+			bytes = 0;
+		}
+
+		ptr += len;	/* update ptr for next loop */
+
+		if (des) {
+
+#ifdef USE_SSSE3
+			_ssse3_memcpy(des, src, len);
+#else
+			memcpy(des, src, len);
+#endif
+			des += len;
+		}
+
+		clflush_cache_range(src, len);
+
+		kunmap(bo->page_obj[idx].page);
+	}
+
+	return 0;
+}
+
+/*Read function in ISP memory management*/
+int hmm_load(ia_css_ptr virt, void *data, unsigned int bytes)
+{
+	if (!data) {
+		v4l2_err(&atomisp_dev,
+			 "hmm_load NULL argument\n");
+		return -EINVAL;
+	}
+	return load_and_flush(virt, data, bytes);
+}
+
+/*Flush hmm data from the data cache*/
+int hmm_flush(ia_css_ptr virt, unsigned int bytes)
+{
+	return load_and_flush(virt, NULL, bytes);
+}
+
+/*Write function in ISP memory management*/
+int hmm_store(ia_css_ptr virt, const void *data, unsigned int bytes)
+{
+	unsigned int ptr;
+	struct hmm_buffer_object *bo;
+	unsigned int idx, offset, len;
+	char *src, *des;
+	int ret;
+
+	ptr = (unsigned int)virt;
+
+	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
+	ret = hmm_check_bo(bo, ptr);
+	if (ret)
+		return ret;
+
+	src = (char *)data;
+	while (bytes) {
+		idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
+		offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
+
+		if (in_atomic())
+			des = (char *)kmap_atomic(bo->page_obj[idx].page);
+		else
+			des = (char *)kmap(bo->page_obj[idx].page);
+
+		if (!des) {
+			v4l2_err(&atomisp_dev,
+				    "kmap buffer object page failed: "
+				    "pg_idx = %d\n", idx);
+			return -EINVAL;
+		}
+
+		des += offset;
+
+		if ((bytes + offset) >= PAGE_SIZE) {
+			len = PAGE_SIZE - offset;
+			bytes -= len;
+		} else {
+			len = bytes;
+			bytes = 0;
+		}
+
+		ptr += len;
+
+#ifdef USE_SSSE3
+		_ssse3_memcpy(des, src, len);
+#else
+		memcpy(des, src, len);
+#endif
+		src += len;
+
+		clflush_cache_range(des, len);
+
+		if (in_atomic())
+			/*
+			 * Note: kunmap_atomic requires return addr from
+			 * kmap_atomic, not the page. See linux/highmem.h
+			 */
+			kunmap_atomic(des - offset);
+		else
+			kunmap(bo->page_obj[idx].page);
+	}
+
+	return 0;
+}
+
+/*memset function in ISP memory management*/
+int hmm_set(ia_css_ptr virt, int c, unsigned int bytes)
+{
+	unsigned int ptr;
+	struct hmm_buffer_object *bo;
+	unsigned int idx, offset, len;
+	char *des;
+	int ret;
+
+	ptr = virt;
+
+	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
+	ret = hmm_check_bo(bo, ptr);
+	if (ret)
+		return ret;
+
+	while (bytes) {
+		idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
+		offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
+
+		des = (char *)kmap(bo->page_obj[idx].page);
+		if (!des) {
+			v4l2_err(&atomisp_dev,
+				    "kmap buffer object page failed: "
+				    "pg_idx = %d\n", idx);
+			return -EINVAL;
+		}
+		des += offset;
+
+		if ((bytes + offset) >= PAGE_SIZE) {
+			len = PAGE_SIZE - offset;
+			bytes -= len;
+		} else {
+			len = bytes;
+			bytes = 0;
+		}
+
+		ptr += len;
+
+		memset(des, c, len);
+
+		clflush_cache_range(des, len);
+
+		kunmap(bo->page_obj[idx].page);
+	}
+
+	return 0;
+}
+
+/*Virtual address to physical address convert*/
+phys_addr_t hmm_virt_to_phys(ia_css_ptr virt)
+{
+	unsigned int ptr = (unsigned int)virt;
+	unsigned int idx, offset;
+	struct hmm_buffer_object *bo;
+
+	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
+	if (!bo) {
+		v4l2_err(&atomisp_dev,
+			    "can not find buffer object contains "
+			    "address 0x%x\n", ptr);
+		return -1;
+	}
+
+	idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
+	offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
+
+	return page_to_phys(bo->page_obj[idx].page) + offset;
+}
+
+int hmm_mmap(struct vm_area_struct *vma, ia_css_ptr virt)
+{
+	struct hmm_buffer_object *bo;
+
+	bo = hmm_bo_device_search_start(&bo_device, virt);
+	if (!bo) {
+		v4l2_err(&atomisp_dev,
+			    "can not find buffer object start with "
+			    "address 0x%x\n", virt);
+		return -EINVAL;
+	}
+
+	return hmm_bo_mmap(vma, bo);
+}
+
+/*Map ISP virtual address into IA virtual address*/
+void *hmm_vmap(ia_css_ptr virt)
+{
+	struct hmm_buffer_object *bo;
+
+	bo = hmm_bo_device_search_start(&bo_device, virt);
+	if (!bo) {
+		v4l2_err(&atomisp_dev,
+			    "can not find buffer object start with "
+			    "address 0x%x\n", virt);
+		return NULL;
+	}
+
+	return hmm_bo_vmap(bo);
+}
+
+int hmm_pool_register(unsigned int pool_size,
+			enum hmm_pool_type pool_type)
+{
+	switch (pool_type) {
+	case HMM_POOL_TYPE_RESERVED:
+		reserved_pool.pops = &reserved_pops;
+		return reserved_pool.pops->pool_init(&reserved_pool.pool_info,
+							pool_size);
+	case HMM_POOL_TYPE_DYNAMIC:
+		dynamic_pool.pops = &dynamic_pops;
+		return dynamic_pool.pops->pool_init(&dynamic_pool.pool_info,
+							pool_size);
+	default:
+		v4l2_err(&atomisp_dev, "invalid pool type.\n");
+		return -EINVAL;
+	}
+}
+
+void hmm_pool_unregister(enum hmm_pool_type pool_type)
+{
+	switch (pool_type) {
+	case HMM_POOL_TYPE_RESERVED:
+		if (reserved_pool.pops->pool_exit)
+			reserved_pool.pops->pool_exit(&reserved_pool.pool_info);
+		break;
+	case HMM_POOL_TYPE_DYNAMIC:
+		if (dynamic_pool.pops->pool_exit)
+			dynamic_pool.pops->pool_exit(&dynamic_pool.pool_info);
+		break;
+	default:
+		v4l2_err(&atomisp_dev, "invalid pool type.\n");
+		break;
+	}
+
+	return;
+}
diff --git a/drivers/media/atomisp2/hmm/hmm_bo.c b/drivers/media/atomisp2/hmm/hmm_bo.c
new file mode 100644
index 0000000..c25b5c7
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm_bo.c
@@ -0,0 +1,1290 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * This file contains functions for buffer object structure management
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/gfp.h>		/* for GFP_ATOMIC */
+#include <linux/mm.h>
+#include <linux/mm_types.h>
+#include <linux/hugetlb.h>
+#include <linux/highmem.h>
+#include <linux/slab.h>		/* for kmalloc */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <asm/cacheflush.h>
+#include <linux/io.h>
+#include <asm/current.h>
+#include <linux/sched.h>
+#include "hmm/hmm_vm.h"
+#include "hmm/hmm_bo.h"
+#include "hmm/hmm_pool.h"
+#include "hmm/hmm_bo_dev.h"
+#include "hmm/hmm_common.h"
+#include "atomisp_internal.h"
+#include <linux/scatterlist.h>
+#ifdef CONFIG_ION
+#include <linux/ion.h>
+#endif
+
+static unsigned int order_to_nr(unsigned int order)
+{
+	return 1U << order;
+}
+
+static unsigned int nr_to_order_bottom(unsigned int nr)
+{
+	return fls(nr) - 1;
+}
+
+static void free_bo_internal(struct hmm_buffer_object *bo)
+{
+	kfree(bo);
+}
+
+/*
+ * use these functions to dynamically alloc hmm_buffer_object.
+ * hmm_bo_init will called for that allocated buffer object, and
+ * the release callback is set to kfree.
+ */
+struct hmm_buffer_object *hmm_bo_create(struct hmm_bo_device *bdev, int pgnr)
+{
+	struct hmm_buffer_object *bo;
+	int ret;
+
+	bo = kzalloc(sizeof(*bo), GFP_KERNEL);
+	if (!bo) {
+		v4l2_err(&atomisp_dev, "out of memory for bo\n");
+		return NULL;
+	}
+
+	ret = hmm_bo_init(bdev, bo, pgnr, free_bo_internal);
+	if (ret) {
+		v4l2_err(&atomisp_dev, "hmm_bo_init failed\n");
+		kfree(bo);
+		return NULL;
+	}
+
+	return bo;
+}
+
+/*
+ * use this function to initialize pre-allocated hmm_buffer_object.
+ * as hmm_buffer_object may be used as an embedded object in an upper
+ * level object, a release callback must be provided. if it is
+ * embedded in upper level object, set release call back to release
+ * function of that object. if no upper level object, set release
+ * callback to NULL.
+ *
+ * bo->kref is inited to 1.
+ */
+int hmm_bo_init(struct hmm_bo_device *bdev,
+		struct hmm_buffer_object *bo,
+		unsigned int pgnr, void (*release) (struct hmm_buffer_object *))
+{
+	unsigned long flags;
+
+	if (bdev == NULL) {
+		v4l2_warn(&atomisp_dev,
+			    "NULL hmm_bo_device.\n");
+		return -EINVAL;
+	}
+
+	/* hmm_bo_device must be already inited */
+	var_equal_return(hmm_bo_device_inited(bdev), 0, -EINVAL,
+			   "hmm_bo_device not inited yet.\n");
+
+	/* prevent zero size buffer object */
+	if (pgnr == 0) {
+		v4l2_err(&atomisp_dev,
+			    "0 size buffer is not allowed.\n");
+		return -EINVAL;
+	}
+
+	memset(bo, 0, sizeof(*bo));
+
+	kref_init(&bo->kref);
+
+	mutex_init(&bo->mutex);
+
+	INIT_LIST_HEAD(&bo->list);
+
+	bo->pgnr = pgnr;
+	bo->bdev = bdev;
+
+	bo->release = release;
+
+	if (!bo->release)
+		v4l2_warn(&atomisp_dev,
+			    "no release callback specified.\n");
+
+	/*
+	 * add to active_bo_list
+	 */
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_add_tail(&bo->list, &bdev->active_bo_list);
+	bo->status |= HMM_BO_ACTIVE;
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+
+	return 0;
+}
+
+static void hmm_bo_release(struct hmm_buffer_object *bo)
+{
+	struct hmm_bo_device *bdev;
+	unsigned long flags;
+
+	check_bo_null_return_void(bo);
+
+	bdev = bo->bdev;
+
+	/*
+	 * remove it from buffer device's buffer object list.
+	 */
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_del(&bo->list);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+
+	/*
+	 * FIX ME:
+	 *
+	 * how to destroy the bo when it is stilled MMAPED?
+	 *
+	 * ideally, this will not happened as hmm_bo_release
+	 * will only be called when kref reaches 0, and in mmap
+	 * operation the hmm_bo_ref will eventually be called.
+	 * so, if this happened, something goes wrong.
+	 */
+	if (bo->status & HMM_BO_MMAPED) {
+		v4l2_err(&atomisp_dev,
+			     "destroy bo which is MMAPED, do nothing\n");
+		goto err;
+	}
+
+	if (bo->status & HMM_BO_BINDED) {
+		v4l2_warn(&atomisp_dev,
+			     "the bo is still binded, unbind it first...\n");
+		hmm_bo_unbind(bo);
+	}
+	if (bo->status & HMM_BO_PAGE_ALLOCED) {
+		v4l2_warn(&atomisp_dev,
+			     "the pages is not freed, free pages first\n");
+		hmm_bo_free_pages(bo);
+	}
+	if (bo->status & HMM_BO_VM_ALLOCED) {
+		v4l2_warn(&atomisp_dev,
+			     "the vm is still not freed, free vm first...\n");
+		hmm_bo_free_vm(bo);
+	}
+
+	if (bo->release)
+		bo->release(bo);
+err:
+	return;
+}
+
+int hmm_bo_activated(struct hmm_buffer_object *bo)
+{
+	check_bo_null_return(bo, 0);
+
+	return bo->status & HMM_BO_ACTIVE;
+}
+
+void hmm_bo_unactivate(struct hmm_buffer_object *bo)
+{
+	struct hmm_bo_device *bdev;
+	unsigned long flags;
+
+	check_bo_null_return_void(bo);
+
+	check_bo_status_no_goto(bo, HMM_BO_ACTIVE, status_err);
+
+	bdev = bo->bdev;
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_del(&bo->list);
+	list_add_tail(&bo->list, &bdev->free_bo_list);
+	bo->status &= (~HMM_BO_ACTIVE);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+
+	return;
+
+status_err:
+	v4l2_err(&atomisp_dev,
+			"buffer object already unactivated.\n");
+	return;
+}
+
+int hmm_bo_alloc_vm(struct hmm_buffer_object *bo)
+{
+	struct hmm_bo_device *bdev;
+
+	check_bo_null_return(bo, -EINVAL);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_no_goto(bo, HMM_BO_VM_ALLOCED, status_err);
+
+	bdev = bo->bdev;
+	bo->vm_node = hmm_vm_alloc_node(&bdev->vaddr_space, bo->pgnr);
+	if (unlikely(!bo->vm_node)) {
+		v4l2_err(&atomisp_dev,
+				"hmm_vm_alloc_node err.\n");
+		goto null_vm;
+	}
+
+	bo->status |= HMM_BO_VM_ALLOCED;
+
+	mutex_unlock(&bo->mutex);
+
+	return 0;
+null_vm:
+	mutex_unlock(&bo->mutex);
+	return -ENOMEM;
+
+status_err:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+			"buffer object already has vm allocated.\n");
+	return -EINVAL;
+}
+
+void hmm_bo_free_vm(struct hmm_buffer_object *bo)
+{
+	struct hmm_bo_device *bdev;
+
+	check_bo_null_return_void(bo);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_yes_goto(bo, HMM_BO_VM_ALLOCED, status_err);
+
+	bdev = bo->bdev;
+
+	bo->status &= (~HMM_BO_VM_ALLOCED);
+	hmm_vm_free_node(bo->vm_node);
+	bo->vm_node = NULL;
+	mutex_unlock(&bo->mutex);
+
+	return;
+
+status_err:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+			"buffer object has no vm allocated.\n");
+}
+
+int hmm_bo_vm_allocated(struct hmm_buffer_object *bo)
+{
+	int ret;
+
+	check_bo_null_return(bo, 0);
+
+	ret = (bo->status & HMM_BO_VM_ALLOCED);
+
+	return ret;
+}
+
+static void free_private_bo_pages(struct hmm_buffer_object *bo,
+				  struct hmm_pool *dypool,
+				  struct hmm_pool *repool, int free_pgnr)
+{
+	int i, ret;
+
+	for (i = 0; i < free_pgnr; i++) {
+		switch (bo->page_obj[i].type) {
+		case HMM_PAGE_TYPE_RESERVED:
+			if (repool->pops->pool_free_pages)
+				repool->pops->pool_free_pages(repool->pool_info,
+							&bo->page_obj[i]);
+			break;
+		case HMM_PAGE_TYPE_DYNAMIC:
+			if (dypool->pops->pool_free_pages)
+				dypool->pops->pool_free_pages(dypool->pool_info,
+							&bo->page_obj[i]);
+			break;
+		/*
+		 * HMM_PAGE_TYPE_GENERAL indicates that pages are from system
+		 * memory, so when free them, they should be put into dynamic
+		 * pool.
+		 */
+		case HMM_PAGE_TYPE_GENERAL:
+			if (dypool->pops->pool_inited
+			    && dypool->pops->pool_inited(dypool->pool_info)) {
+				if (dypool->pops->pool_free_pages)
+					dypool->pops->pool_free_pages(
+							      dypool->pool_info,
+							      &bo->page_obj[i]);
+				break;
+			}
+
+			/*
+			 * if dynamic memory pool doesn't exist, need to free
+			 * pages to system directly.
+			 */
+		default:
+			ret = set_pages_wb(bo->page_obj[i].page, 1);
+			if (ret)
+				v4l2_err(&atomisp_dev,
+						"set page to WB err ...\n");
+			__free_pages(bo->page_obj[i].page, 0);
+			break;
+		}
+	}
+
+	return;
+}
+
+/*Allocate pages which will be used only by ISP*/
+static int alloc_private_pages(struct hmm_buffer_object *bo, int from_highmem,
+				bool cached, struct hmm_pool *dypool,
+				struct hmm_pool *repool,struct sg_table *sgt)
+{
+	int ret;
+	unsigned int pgnr, order, blk_pgnr, alloc_pgnr;
+	struct page *pages;
+	struct scatterlist *tmp;
+	gfp_t gfp = GFP_NOWAIT | __GFP_NOWARN; /* REVISIT: need __GFP_FS too? */
+	int i, j;
+	int k=0;
+	int failure_number = 0;
+	bool reduce_order = false;
+	bool lack_mem = true;
+
+	if (from_highmem)
+		gfp |= __GFP_HIGHMEM;
+
+	pgnr = bo->pgnr;
+
+	bo->page_obj = atomisp_kernel_malloc(
+				sizeof(struct hmm_page_object) * pgnr);
+	if (unlikely(!bo->page_obj)) {
+		v4l2_err(&atomisp_dev, "out of memory for bo->page_obj\n");
+		return -ENOMEM;
+	}
+
+	i = 0;
+	alloc_pgnr = 0;
+
+	/*
+	 * get physical pages from dynamic pages pool.
+	 */
+	if (dypool != NULL && dypool->pops != NULL && dypool->pops->pool_alloc_pages) {
+		alloc_pgnr = dypool->pops->pool_alloc_pages(dypool->pool_info,
+							bo->page_obj, pgnr,
+							cached);
+		if (alloc_pgnr == pgnr)
+			return 0;
+	}
+
+	pgnr -= alloc_pgnr;
+	i += alloc_pgnr;
+
+	/*
+	 * get physical pages from reserved pages pool for atomisp.
+	 */
+	if (repool != NULL && repool->pops != NULL && repool->pops->pool_alloc_pages) {
+		alloc_pgnr = repool->pops->pool_alloc_pages(repool->pool_info,
+							&bo->page_obj[i], pgnr,
+							cached);
+		if (alloc_pgnr == pgnr)
+			return 0;
+	}
+
+	pgnr -= alloc_pgnr;
+	i += alloc_pgnr;
+
+	while (pgnr) {
+		order = nr_to_order_bottom(pgnr);
+		/*
+		 * if be short of memory, we will set order to 0
+		 * everytime.
+		 */
+		if (lack_mem)
+			order = HMM_MIN_ORDER;
+		else if (order > HMM_MAX_ORDER)
+			order = HMM_MAX_ORDER;
+retry:
+		/*
+		 * When order > HMM_MIN_ORDER, for performance reasons we don't
+		 * want alloc_pages() to sleep. In case it fails and fallbacks
+		 * to HMM_MIN_ORDER or in case the requested order is originally
+		 * the minimum value, we can allow alloc_pages() to sleep for
+		 * robustness purpose.
+		 *
+		 * REVISIT: why __GFP_FS is necessary?
+		 */
+		if (order == HMM_MIN_ORDER) {
+			gfp &= ~GFP_NOWAIT;
+			gfp |= __GFP_WAIT | __GFP_FS;
+		}
+
+		pages = alloc_pages(gfp, order);
+		if (unlikely(!pages)) {
+			/*
+			 * in low memory case, if allocation page fails,
+			 * we turn to try if order=0 allocation could
+			 * succeed. if order=0 fails too, that means there is
+			 * no memory left.
+			 */
+			if (order == HMM_MIN_ORDER) {
+				v4l2_err(&atomisp_dev,
+					 "%s: cannot allocate pages\n",
+					 __func__);
+				goto cleanup;
+			}
+			order = HMM_MIN_ORDER;
+			failure_number++;
+			reduce_order = true;
+			/*
+			 * if fail two times continuously, we think be short
+			 * of memory now.
+			 */
+			if (failure_number == 2) {
+				lack_mem = true;
+				failure_number = 0;
+			}
+			goto retry;
+		} else {
+			blk_pgnr = order_to_nr(order);
+
+			if (!cached) {
+				/*
+				 * set memory to uncacheable -- UC_MINUS
+				 */
+				ret = set_pages_uc(pages, blk_pgnr);
+				if (ret) {
+					v4l2_err(&atomisp_dev,
+						     "set page uncacheable"
+							"failed.\n");
+
+					__free_pages(pages, order);
+
+					goto cleanup;
+				}
+			}
+
+			for (j = 0; j < blk_pgnr; j++) {
+				bo->page_obj[i].page = pages + j;
+				bo->page_obj[i++].type = HMM_PAGE_TYPE_GENERAL;
+			}
+
+			pgnr -= blk_pgnr;
+
+			/*
+			 * if order is not reduced this time, clear
+			 * failure_number.
+			 */
+			if (reduce_order)
+				reduce_order = false;
+			else
+				failure_number = 0;
+		}
+	}
+	/*
+	 * Creating a scatter-gather list with the pages created from ISP.
+	 * Creation is of sgl is required when Atomisp is an exporter of DMA Buffers
+	 */
+	if(sgt)
+		{
+			tmp = sgt->sgl;
+			for(k=0;k<bo->pgnr;k++){
+				sg_set_page(tmp,bo->page_obj[k].page,PAGE_SIZE,0);
+				tmp = sg_next(tmp);
+			}
+
+
+		}
+
+	return 0;
+cleanup:
+	alloc_pgnr = i;
+	free_private_bo_pages(bo, dypool, repool, alloc_pgnr);
+
+	atomisp_kernel_free(bo->page_obj);
+
+	return -ENOMEM;
+}
+
+static void free_private_pages(struct hmm_buffer_object *bo,
+				struct hmm_pool *dypool,
+				struct hmm_pool *repool)
+{
+	free_private_bo_pages(bo, dypool, repool, bo->pgnr);
+
+	atomisp_kernel_free(bo->page_obj);
+}
+
+/*
+ * Hacked from kernel function __get_user_pages in mm/memory.c
+ *
+ * Handle buffers allocated by other kernel space driver and mmaped into user
+ * space, function Ignore the VM_PFNMAP and VM_IO flag in VMA structure
+ *
+ * Get physical pages from user space virtual address and update into page list
+ */
+static int __get_pfnmap_pages(struct task_struct *tsk, struct mm_struct *mm,
+			      unsigned long start, int nr_pages,
+			      unsigned int gup_flags, struct page **pages,
+			      struct vm_area_struct **vmas)
+{
+	int i, ret;
+	unsigned long vm_flags;
+
+	if (nr_pages <= 0)
+		return 0;
+
+	VM_BUG_ON(!!pages != !!(gup_flags & FOLL_GET));
+
+	/*
+	 * Require read or write permissions.
+	 * If FOLL_FORCE is set, we only require the "MAY" flags.
+	 */
+	vm_flags  = (gup_flags & FOLL_WRITE) ?
+			(VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);
+	vm_flags &= (gup_flags & FOLL_FORCE) ?
+			(VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);
+	i = 0;
+
+	do {
+		struct vm_area_struct *vma;
+
+		vma = find_vma(mm, start);
+		if (!vma) {
+			v4l2_err(&atomisp_dev, "find_vma failed\n");
+			return i ? : -EFAULT;
+		}
+
+		if (is_vm_hugetlb_page(vma)) {
+			/*
+			i = follow_hugetlb_page(mm, vma, pages, vmas,
+					&start, &nr_pages, i, gup_flags);
+			*/
+			continue;
+		}
+
+		do {
+			struct page *page;
+			unsigned long pfn;
+
+			/*
+			 * If we have a pending SIGKILL, don't keep faulting
+			 * pages and potentially allocating memory.
+			 */
+			if (unlikely(fatal_signal_pending(current))) {
+				v4l2_err(&atomisp_dev,
+					"fatal_signal_pending in %s\n",
+					__func__);
+				return i ? i : -ERESTARTSYS;
+			}
+
+			ret = follow_pfn(vma, start, &pfn);
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+					"follow_pfn() failed\n");
+				return i ? : -EFAULT;
+			}
+
+			page = pfn_to_page(pfn);
+			if (IS_ERR(page))
+				return i ? i : PTR_ERR(page);
+			if (pages) {
+				pages[i] = page;
+
+				flush_anon_page(vma, page, start);
+				flush_dcache_page(page);
+			}
+			if (vmas)
+				vmas[i] = vma;
+			i++;
+			start += PAGE_SIZE;
+			nr_pages--;
+		} while (nr_pages && start < vma->vm_end);
+	} while (nr_pages);
+	return i;
+}
+
+static int get_pfnmap_pages(struct task_struct *tsk, struct mm_struct *mm,
+		     unsigned long start, int nr_pages, int write, int force,
+		     struct page **pages, struct vm_area_struct **vmas)
+{
+	int flags = FOLL_TOUCH;
+
+	if (pages)
+		flags |= FOLL_GET;
+	if (write)
+		flags |= FOLL_WRITE;
+	if (force)
+		flags |= FOLL_FORCE;
+
+	return __get_pfnmap_pages(tsk, mm, start, nr_pages, flags, pages, vmas);
+}
+
+static int alloc_dma_pages(struct hmm_buffer_object *bo, struct sg_table *sgt) {
+	struct scatterlist *tmp;
+	int ret, page_nr = 0;
+	if (sgt == NULL) {
+		return -EINVAL;
+	}
+
+	bo->page_obj = atomisp_kernel_malloc(
+			sizeof(struct hmm_page_object) * bo->pgnr);
+	if (unlikely(!bo->page_obj)) {
+		v4l2_err(&atomisp_dev, "out of memory for bo->page_obj...\n");
+		return -ENOMEM;
+	}
+	tmp = sgt->sgl;
+
+	do {
+		struct page *page = sg_page(tmp);
+		unsigned int n_pages = PAGE_ALIGN(tmp->offset + tmp->length)
+                        >> PAGE_SHIFT;
+                unsigned int j;
+
+                for (j = 0; j < n_pages; ++j, ++page, ++page_nr)
+			bo->page_obj[page_nr].page = page;
+		tmp = sg_next(tmp);
+	} while (tmp && (page_nr < bo->pgnr));
+
+	if (page_nr < bo->pgnr) {
+		v4l2_err(&atomisp_dev,
+			 "get_dma_pages err: bo->pgnr = %d, "
+			 "pgnr actually pinned = %d.\n",
+			 bo->pgnr, page_nr);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	return 0;
+
+error:
+	atomisp_kernel_free(bo->page_obj);
+	return ret;
+}
+
+#ifdef CONFIG_ION
+static int alloc_ion_pages(struct hmm_buffer_object *bo,
+			     unsigned int shared_fd)
+{
+	struct scatterlist *tmp;
+	int ret, page_nr = 0;
+
+	bo->page_obj = atomisp_kernel_malloc(
+			sizeof(struct hmm_page_object) * bo->pgnr);
+	if (unlikely(!bo->page_obj)) {
+		v4l2_err(&atomisp_dev, "out of memory for bo->page_obj...\n");
+		return -ENOMEM;
+	}
+
+	bo->ihandle = ion_import_fd(bo->bdev->iclient, shared_fd);
+	if (IS_ERR_OR_NULL(bo->ihandle)) {
+		v4l2_err(&atomisp_dev, "invalid shared fd to ion.\n");
+		ret = PTR_ERR(bo->ihandle);
+		if (!bo->ihandle)
+			ret = -EINVAL;
+		goto error;
+	}
+
+	tmp = ion_map_dma(bo->bdev->iclient, bo->ihandle);
+	if (IS_ERR_OR_NULL(tmp)) {
+		v4l2_err(&atomisp_dev, "ion map_dma error.\n");
+		ret = PTR_ERR(tmp);
+		if (!tmp)
+			ret = -EINVAL;
+		goto error;
+	}
+
+	do {
+		bo->page_obj[page_nr++].page = sg_page(tmp);
+		tmp = sg_next(tmp);
+	} while (tmp && (page_nr < bo->pgnr));
+
+	if (page_nr != bo->pgnr) {
+		v4l2_err(&atomisp_dev,
+			 "get_ion_pages err: bo->pgnr = %d, "
+			 "pgnr actually pinned = %d.\n",
+			 bo->pgnr, page_nr);
+		ret = -EINVAL;
+		goto error_unmap;
+	}
+
+	return 0;
+error_unmap:
+	ion_unmap_dma(bo->bdev->iclient, bo->ihandle);
+error:
+	atomisp_kernel_free(bo->page_obj);
+	return ret;
+
+
+}
+#endif
+/*
+ * Convert user space virtual address into pages list
+ */
+static int alloc_user_pages(struct hmm_buffer_object *bo,
+				void *userptr, bool cached)
+{
+	int page_nr;
+	int i;
+	struct vm_area_struct *vma;
+	struct page **pages;
+
+	pages = atomisp_kernel_malloc(sizeof(struct page *) * bo->pgnr);
+	if (unlikely(!pages)) {
+		v4l2_err(&atomisp_dev, "out of memory for pages...\n");
+		return -ENOMEM;
+	}
+
+	bo->page_obj = atomisp_kernel_malloc(
+				sizeof(struct hmm_page_object) * bo->pgnr);
+	if (unlikely(!bo->page_obj)) {
+		v4l2_err(&atomisp_dev, "out of memory for bo->page_obj...\n");
+		atomisp_kernel_free(pages);
+		return -ENOMEM;
+	}
+
+	mutex_unlock(&bo->mutex);
+	down_read(&current->mm->mmap_sem);
+	vma = find_vma(current->mm, (unsigned long)userptr);
+	up_read(&current->mm->mmap_sem);
+	if (vma == NULL) {
+		v4l2_err(&atomisp_dev, "find_vma failed\n");
+		atomisp_kernel_free(bo->page_obj);
+		atomisp_kernel_free(pages);
+		return -EFAULT;
+	}
+	mutex_lock(&bo->mutex);
+	/*
+	 * Handle frame buffer allocated in other kerenl space driver
+	 * and map to user space
+	 */
+	if (vma->vm_flags & (VM_IO | VM_PFNMAP)) {
+		page_nr = get_pfnmap_pages(current, current->mm,
+					   (unsigned long)userptr,
+					   (int)(bo->pgnr), 1, 0,
+					   pages, NULL);
+		bo->mem_type = HMM_BO_MEM_TYPE_PFN;
+	} else {
+		/*Handle frame buffer allocated in user space*/
+		mutex_unlock(&bo->mutex);
+		down_read(&current->mm->mmap_sem);
+		page_nr = get_user_pages(current, current->mm,
+					 (unsigned long)userptr,
+					 (int)(bo->pgnr), 1, 0, pages,
+					 NULL);
+		up_read(&current->mm->mmap_sem);
+		mutex_lock(&bo->mutex);
+		bo->mem_type = HMM_BO_MEM_TYPE_USER;
+	}
+
+	/* can be written by caller, not forced */
+	if (page_nr != bo->pgnr) {
+		v4l2_err(&atomisp_dev,
+				"get_user_pages err: bo->pgnr = %d, "
+				"pgnr actually pinned = %d.\n",
+				bo->pgnr, page_nr);
+		goto out_of_mem;
+	}
+
+	for (i = 0; i < bo->pgnr; i++) {
+		bo->page_obj[i].page = pages[i];
+		bo->page_obj[i].type = HMM_PAGE_TYPE_GENERAL;
+	}
+
+	atomisp_kernel_free(pages);
+
+	return 0;
+
+out_of_mem:
+	if (bo->mem_type == HMM_BO_MEM_TYPE_USER)
+		for (i = 0; i < page_nr; i++)
+			put_page(pages[i]);
+	atomisp_kernel_free(pages);
+	atomisp_kernel_free(bo->page_obj);
+
+	return -ENOMEM;
+}
+#ifdef CONFIG_ION
+static void free_ion_pages(struct hmm_buffer_object *bo)
+{
+	atomisp_kernel_free(bo->page_obj);
+	ion_unmap_dma(bo->bdev->iclient, bo->ihandle);
+}
+#endif
+
+static void free_dma_pages(struct hmm_buffer_object *bo)
+{
+	atomisp_kernel_free(bo->page_obj);
+}
+
+static void free_user_pages(struct hmm_buffer_object *bo)
+{
+	int i;
+
+	if (bo->mem_type == HMM_BO_MEM_TYPE_USER)
+		for (i = 0; i < bo->pgnr; i++)
+			put_page(bo->page_obj[i].page);
+
+	atomisp_kernel_free(bo->page_obj);
+}
+
+/*
+ * allocate/free physical pages for the bo.
+ *
+ * type indicate where are the pages from. currently we have 3 types
+ * of memory: HMM_BO_PRIVATE, HMM_BO_USER, HMM_BO_SHARE.
+ *
+ * from_highmem is only valid when type is HMM_BO_PRIVATE, it will
+ * try to alloc memory from highmem if from_highmem is set.
+ *
+ * userptr is only valid when type is HMM_BO_USER, it indicates
+ * the start address from user space task.
+ *
+ * from_highmem and userptr will both be ignored when type is
+ * HMM_BO_SHARE.
+ */
+int hmm_bo_alloc_pages(struct hmm_buffer_object *bo,
+		       enum hmm_bo_type type, int from_highmem,
+		       void *userptr, bool cached,void *priv)
+{
+	int ret;
+	struct sg_table *sgt = priv;
+
+	check_bo_null_return(bo, -EINVAL);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_no_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);
+
+	if (type == HMM_BO_PRIVATE)
+		ret = alloc_private_pages(bo, from_highmem,
+				cached, &dynamic_pool, &reserved_pool, sgt);
+	else if (type == HMM_BO_USER)
+		ret = alloc_user_pages(bo, userptr, cached);
+	else if (type == HMM_BO_DMA)
+		ret = alloc_dma_pages(bo, sgt);
+#ifdef CONFIG_ION
+	else if (type == HMM_BO_ION)
+		/*
+		 * TODO:
+		 * Add cache flag when ION support it
+		 */
+		ret = alloc_ion_pages(bo, userptr);
+#endif
+	else {
+		v4l2_err(&atomisp_dev, "invalid buffer type.\n");
+		ret = -EINVAL;
+	}
+
+	if (ret)
+		goto alloc_err;
+
+	bo->type = type;
+
+	bo->status |= HMM_BO_PAGE_ALLOCED;
+
+	mutex_unlock(&bo->mutex);
+
+	return 0;
+
+alloc_err:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev, "alloc pages err...\n");
+	return ret;
+status_err:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+			"buffer object has already page allocated.\n");
+	return -EINVAL;
+}
+
+/*
+ * free physical pages of the bo.
+ */
+void hmm_bo_free_pages(struct hmm_buffer_object *bo)
+{
+	check_bo_null_return_void(bo);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err2);
+
+	/* clear the flag anyway. */
+	bo->status &= (~HMM_BO_PAGE_ALLOCED);
+
+	if (bo->type == HMM_BO_PRIVATE)
+		free_private_pages(bo, &dynamic_pool, &reserved_pool);
+	else if (bo->type == HMM_BO_USER)
+		free_user_pages(bo);
+	else if (bo->type == HMM_BO_DMA)
+		free_dma_pages(bo);
+#ifdef CONFIG_ION
+	else if (bo->type == HMM_BO_ION)
+		free_ion_pages(bo);
+#endif
+	else
+		v4l2_err(&atomisp_dev, "invalid buffer type.\n");
+	mutex_unlock(&bo->mutex);
+
+	return;
+
+status_err2:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+			"buffer object not page allocated yet.\n");
+}
+
+int hmm_bo_page_allocated(struct hmm_buffer_object *bo)
+{
+	int ret;
+
+	check_bo_null_return(bo, 0);
+
+	ret = bo->status & HMM_BO_PAGE_ALLOCED;
+
+	return ret;
+}
+
+/*
+ * get physical page info of the bo.
+ */
+int hmm_bo_get_page_info(struct hmm_buffer_object *bo,
+			 struct hmm_page_object **page_obj, int *pgnr)
+{
+	check_bo_null_return(bo, -EINVAL);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);
+
+	*page_obj = bo->page_obj;
+	*pgnr = bo->pgnr;
+
+	mutex_unlock(&bo->mutex);
+
+	return 0;
+
+status_err:
+	v4l2_err(&atomisp_dev,
+			"buffer object not page allocated yet.\n");
+	mutex_unlock(&bo->mutex);
+	return -EINVAL;
+}
+
+/*
+ * bind the physical pages to a virtual address space.
+ */
+int hmm_bo_bind(struct hmm_buffer_object *bo)
+{
+	int ret;
+	unsigned int virt;
+	struct hmm_bo_device *bdev;
+	unsigned int i;
+
+	check_bo_null_return(bo, -EINVAL);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_yes_goto(bo,
+				   HMM_BO_PAGE_ALLOCED | HMM_BO_VM_ALLOCED,
+				   status_err1);
+
+	check_bo_status_no_goto(bo, HMM_BO_BINDED, status_err2);
+
+	bdev = bo->bdev;
+
+	virt = bo->vm_node->start;
+
+	for (i = 0; i < bo->pgnr; i++) {
+		ret =
+		    isp_mmu_map(&bdev->mmu, virt,
+				page_to_phys(bo->page_obj[i].page), 1);
+		if (ret)
+			goto map_err;
+		virt += (1 << PAGE_SHIFT);
+	}
+
+	/*
+	 * flush TBL here.
+	 *
+	 * theoretically, we donot need to flush TLB as we didnot change
+	 * any existed address mappings, but for Silicon Hive's MMU, its
+	 * really a bug here. I guess when fetching PTEs (page table entity)
+	 * to TLB, its MMU will fetch additional INVALID PTEs automatically
+	 * for performance issue. EX, we only set up 1 page address mapping,
+	 * meaning updating 1 PTE, but the MMU fetches 4 PTE at one time,
+	 * so the additional 3 PTEs are invalid.
+	 */
+#ifdef CSS_2
+	if (bo->vm_node->start != 0x0)
+#endif
+		isp_mmu_flush_tlb_range(&bdev->mmu, bo->vm_node->start,
+					(bo->pgnr << PAGE_SHIFT));
+
+	bo->status |= HMM_BO_BINDED;
+
+	mutex_unlock(&bo->mutex);
+
+	return 0;
+
+map_err:
+	/* unbind the physical pages with related virtual address space */
+	virt = bo->vm_node->start;
+	for ( ; i > 0; i--) {
+		isp_mmu_unmap(&bdev->mmu, virt, 1);
+		virt += pgnr_to_size(1);
+	}
+
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+			"setup MMU address mapping failed.\n");
+	return ret;
+
+status_err2:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev, "buffer object already binded.\n");
+	return -EINVAL;
+status_err1:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+		     "buffer object vm_node or page not allocated.\n");
+	return -EINVAL;
+}
+
+/*
+ * unbind the physical pages with related virtual address space.
+ */
+void hmm_bo_unbind(struct hmm_buffer_object *bo)
+{
+	unsigned int virt;
+	struct hmm_bo_device *bdev;
+	unsigned int i;
+
+	check_bo_null_return_void(bo);
+
+	mutex_lock(&bo->mutex);
+
+	check_bo_status_yes_goto(bo,
+				   HMM_BO_PAGE_ALLOCED |
+				   HMM_BO_VM_ALLOCED |
+				   HMM_BO_BINDED, status_err);
+
+	bdev = bo->bdev;
+
+	virt = bo->vm_node->start;
+
+	for (i = 0; i < bo->pgnr; i++) {
+		isp_mmu_unmap(&bdev->mmu, virt, 1);
+		virt += pgnr_to_size(1);
+	}
+
+	/*
+	 * flush TLB as the address mapping has been removed and
+	 * related TLBs should be invalidated.
+	 */
+#ifdef CSS_2
+	if (bo->vm_node->start != 0x0)
+#endif
+		isp_mmu_flush_tlb_range(&bdev->mmu, bo->vm_node->start,
+					(bo->pgnr << PAGE_SHIFT));
+
+	bo->status &= (~HMM_BO_BINDED);
+
+	mutex_unlock(&bo->mutex);
+
+	return;
+
+status_err:
+	mutex_unlock(&bo->mutex);
+	v4l2_err(&atomisp_dev,
+		     "buffer vm or page not allocated or not binded yet.\n");
+}
+
+int hmm_bo_binded(struct hmm_buffer_object *bo)
+{
+	int ret;
+
+	check_bo_null_return(bo, 0);
+
+	mutex_lock(&bo->mutex);
+
+	ret = bo->status & HMM_BO_BINDED;
+
+	mutex_unlock(&bo->mutex);
+
+	return ret;
+}
+
+void *hmm_bo_vmap(struct hmm_buffer_object *bo)
+{
+	struct page **pages;
+	void *vmap_addr;
+	int i;
+
+	check_bo_null_return(bo, NULL);
+
+	pages = atomisp_kernel_malloc(sizeof(*pages) * bo->pgnr);
+	if (unlikely(!pages)) {
+		v4l2_err(&atomisp_dev, "out of memory for pages...\n");
+		return NULL;
+	}
+
+	for (i = 0; i < bo->pgnr; i++)
+		pages[i] = bo->page_obj[i].page;
+
+	vmap_addr = vmap(pages, bo->pgnr, VM_MAP, PAGE_KERNEL_NOCACHE);
+
+	atomisp_kernel_free(pages);
+
+	return vmap_addr;
+}
+
+void hmm_bo_ref(struct hmm_buffer_object *bo)
+{
+	check_bo_null_return_void(bo);
+
+	kref_get(&bo->kref);
+}
+
+static void kref_hmm_bo_release(struct kref *kref)
+{
+	if (!kref)
+		return;
+
+	hmm_bo_release(kref_to_hmm_bo(kref));
+}
+
+void hmm_bo_unref(struct hmm_buffer_object *bo)
+{
+	check_bo_null_return_void(bo);
+
+	kref_put(&bo->kref, kref_hmm_bo_release);
+}
+
+static void hmm_bo_vm_open(struct vm_area_struct *vma)
+{
+	struct hmm_buffer_object *bo =
+	    (struct hmm_buffer_object *)vma->vm_private_data;
+
+	check_bo_null_return_void(bo);
+
+	hmm_bo_ref(bo);
+
+	mutex_lock(&bo->mutex);
+
+	bo->status |= HMM_BO_MMAPED;
+
+	bo->mmap_count++;
+
+	mutex_unlock(&bo->mutex);
+}
+
+static void hmm_bo_vm_close(struct vm_area_struct *vma)
+{
+	struct hmm_buffer_object *bo =
+	    (struct hmm_buffer_object *)vma->vm_private_data;
+
+	check_bo_null_return_void(bo);
+
+	hmm_bo_unref(bo);
+
+	mutex_lock(&bo->mutex);
+
+	bo->mmap_count--;
+
+	if (!bo->mmap_count) {
+		bo->status &= (~HMM_BO_MMAPED);
+		vma->vm_private_data = NULL;
+	}
+
+	mutex_unlock(&bo->mutex);
+}
+
+static const struct vm_operations_struct hmm_bo_vm_ops = {
+	.open = hmm_bo_vm_open,
+	.close = hmm_bo_vm_close,
+};
+
+/*
+ * mmap the bo to user space.
+ */
+int hmm_bo_mmap(struct vm_area_struct *vma, struct hmm_buffer_object *bo)
+{
+	unsigned int start, end;
+	unsigned int virt;
+	unsigned int pgnr, i;
+	unsigned int pfn;
+
+	check_bo_null_return(bo, -EINVAL);
+
+	check_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);
+
+	pgnr = bo->pgnr;
+	start = vma->vm_start;
+	end = vma->vm_end;
+
+	/*
+	 * check vma's virtual address space size and buffer object's size.
+	 * must be the same.
+	 */
+	if ((start + pgnr_to_size(pgnr)) != end) {
+		v4l2_warn(&atomisp_dev,
+			     "vma's address space size not equal"
+			     " to buffer object's size");
+		return -EINVAL;
+	}
+
+	virt = vma->vm_start;
+	for (i = 0; i < pgnr; i++) {
+		pfn = page_to_pfn(bo->page_obj[i].page);
+		if (remap_pfn_range(vma, virt, pfn, PAGE_SIZE, PAGE_SHARED)) {
+			v4l2_warn(&atomisp_dev,
+					"remap_pfn_range failed:"
+					" virt = 0x%x, pfn = 0x%x,"
+					" mapped_pgnr = %d\n", virt, pfn, 1);
+			return -EINVAL;
+		}
+		virt += PAGE_SIZE;
+	}
+
+	vma->vm_private_data = bo;
+
+	vma->vm_ops = &hmm_bo_vm_ops;
+	vma->vm_flags |= ((VM_DONTEXPAND | VM_DONTDUMP) | VM_IO);
+
+	/*
+	 * call hmm_bo_vm_open explictly.
+	 */
+	hmm_bo_vm_open(vma);
+
+	return 0;
+
+status_err:
+	v4l2_err(&atomisp_dev,
+			"buffer page not allocated yet.\n");
+	return -EINVAL;
+}
diff --git a/drivers/media/atomisp2/hmm/hmm_bo_dev.c b/drivers/media/atomisp2/hmm/hmm_bo_dev.c
new file mode 100644
index 0000000..a306528
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm_bo_dev.c
@@ -0,0 +1,309 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/gfp.h>
+#include <linux/mm.h>		/* for GFP_ATOMIC */
+#include <linux/slab.h>		/* for kmalloc */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+
+#ifdef CONFIG_ION
+#include <linux/ion.h>
+#endif
+
+#include "hmm/hmm_common.h"
+#include "hmm/hmm_bo_dev.h"
+#include "hmm/hmm_bo.h"
+#include "atomisp_internal.h"
+
+/*
+ * hmm_bo_device functions.
+ */
+int hmm_bo_device_init(struct hmm_bo_device *bdev,
+		       struct isp_mmu_client *mmu_driver,
+		       unsigned int vaddr_start, unsigned int size)
+{
+	int ret;
+
+	check_bodev_null_return(bdev, -EINVAL);
+
+	ret = isp_mmu_init(&bdev->mmu, mmu_driver);
+	if (ret) {
+		v4l2_err(&atomisp_dev, "isp_mmu_init failed.\n");
+		goto isp_mmu_init_err;
+	}
+
+	ret = hmm_vm_init(&bdev->vaddr_space, vaddr_start, size);
+	if (ret) {
+		v4l2_err(&atomisp_dev, "hmm_vm_init falied. "
+			     "vaddr_start = 0x%x, size = %d\n", vaddr_start,
+			     size);
+		goto vm_init_err;
+	}
+
+	INIT_LIST_HEAD(&bdev->free_bo_list);
+	INIT_LIST_HEAD(&bdev->active_bo_list);
+
+	spin_lock_init(&bdev->list_lock);
+#ifdef CONFIG_ION
+	/*
+	 * TODO:
+	 * ion driver global variable and heap mask
+	 * should be changed when mrfld ion is ready
+	 */
+	if (!mrfld_ion_driver)
+		goto vm_init_err;
+
+	bdev->iclient = ion_client_create(mrfld_ion_driver,
+					  ION_HEAP_TYPE_SYSTEM_CONTIG |
+					  ION_HEAP_TYPE_SYSTEM |
+					  ION_HEAP_TYPE_CARVEOUT,
+					  "atomisp");
+	if (IS_ERR_OR_NULL(bdev->iclient)) {
+		ret = PTR_ERR(bdev->iclient);
+		if (!bdev->iclient)
+			ret = -EINVAL;
+		goto vm_init_err;
+	}
+#endif
+	bdev->flag = HMM_BO_DEVICE_INITED;
+
+	return 0;
+
+vm_init_err:
+	isp_mmu_exit(&bdev->mmu);
+isp_mmu_init_err:
+	return ret;
+}
+
+void hmm_bo_device_exit(struct hmm_bo_device *bdev)
+{
+	check_bodev_null_return_void(bdev);
+
+	/*
+	 * destroy all bos in the bo list, even they are in use.
+	 */
+	if (!list_empty(&bdev->active_bo_list))
+		v4l2_warn(&atomisp_dev,
+			     "there're still activated bo in use. "
+			     "force to free them.\n");
+
+	while (!list_empty(&bdev->active_bo_list))
+		hmm_bo_unref(list_to_hmm_bo(bdev->active_bo_list.next));
+
+	if (!list_empty(&bdev->free_bo_list))
+		v4l2_warn(&atomisp_dev,
+				"there're still bo in free_bo_list. "
+				"force to free them.\n");
+
+	while (!list_empty(&bdev->free_bo_list))
+		hmm_bo_unref(list_to_hmm_bo(bdev->free_bo_list.next));
+
+	isp_mmu_exit(&bdev->mmu);
+	hmm_vm_clean(&bdev->vaddr_space);
+#ifdef CONFIG_ION
+	if (bdev->iclient != NULL)
+		ion_client_destroy(bdev->iclient);
+#endif
+}
+
+int hmm_bo_device_inited(struct hmm_bo_device *bdev)
+{
+	check_bodev_null_return(bdev, -EINVAL);
+
+	return bdev->flag == HMM_BO_DEVICE_INITED;
+}
+
+/*
+ * find the buffer object with virtual address vaddr.
+ * return NULL if no such buffer object found.
+ */
+struct hmm_buffer_object *hmm_bo_device_search_start(struct hmm_bo_device *bdev,
+								ia_css_ptr vaddr)
+{
+	struct list_head *pos;
+	struct hmm_buffer_object *bo;
+	unsigned long flags;
+
+	check_bodev_null_return(bdev, NULL);
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_for_each(pos, &bdev->active_bo_list) {
+		bo = list_to_hmm_bo(pos);
+		/* pass bo which has no vm_node allocated */
+		if (!hmm_bo_vm_allocated(bo))
+			continue;
+		if (bo->vm_node->start == vaddr)
+			goto found;
+	}
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return NULL;
+found:
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return bo;
+}
+
+static int in_range(unsigned int start, unsigned int size, unsigned int addr)
+{
+	return (start <= addr) && (start + size > addr);
+}
+
+struct hmm_buffer_object *hmm_bo_device_search_in_range(struct hmm_bo_device
+							*bdev,
+							unsigned int vaddr)
+{
+	struct list_head *pos;
+	struct hmm_buffer_object *bo;
+	unsigned long flags;
+
+	check_bodev_null_return(bdev, NULL);
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_for_each(pos, &bdev->active_bo_list) {
+		bo = list_to_hmm_bo(pos);
+		/* pass bo which has no vm_node allocated */
+		if (!hmm_bo_vm_allocated(bo))
+			continue;
+		if (in_range(bo->vm_node->start, bo->vm_node->size, vaddr))
+			goto found;
+	}
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return NULL;
+found:
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return bo;
+}
+
+/*
+ * find a buffer object with pgnr pages from free_bo_list and
+ * activate it (remove from free_bo_list and add to
+ * active_bo_list)
+ *
+ * return NULL if no such buffer object found.
+ */
+struct hmm_buffer_object *hmm_bo_device_get_bo(struct hmm_bo_device *bdev,
+					       unsigned int pgnr)
+{
+	struct list_head *pos;
+	struct hmm_buffer_object *bo;
+	unsigned long flags;
+
+	check_bodev_null_return(bdev, NULL);
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_for_each(pos, &bdev->free_bo_list) {
+		bo = list_to_hmm_bo(pos);
+		if (bo->pgnr == pgnr)
+			goto found;
+	}
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return NULL;
+found:
+	list_del(&bo->list);
+	list_add(&bo->list, &bdev->active_bo_list);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+
+	return bo;
+}
+
+/*
+ * destroy all buffer objects in the free_bo_list.
+ */
+void hmm_bo_device_destroy_free_bo_list(struct hmm_bo_device *bdev)
+{
+	struct hmm_buffer_object *bo, *tmp;
+	unsigned long flags;
+	struct list_head new_head;
+
+	check_bodev_null_return_void(bdev);
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_replace_init(&bdev->free_bo_list, &new_head);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+
+	list_for_each_entry_safe(bo, tmp, &new_head, list) {
+		list_del(&bo->list);
+		hmm_bo_unref(bo);
+	}
+}
+
+/*
+ * destroy buffer object with start virtual address vaddr.
+ */
+void hmm_bo_device_destroy_free_bo_addr(struct hmm_bo_device *bdev,
+					unsigned int vaddr)
+{
+	struct list_head *pos;
+	struct hmm_buffer_object *bo;
+	unsigned long flags;
+
+	check_bodev_null_return_void(bdev);
+
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_for_each(pos, &bdev->free_bo_list) {
+		bo = list_to_hmm_bo(pos);
+		/* pass bo which has no vm_node allocated */
+		if (!hmm_bo_vm_allocated(bo))
+			continue;
+		if (bo->vm_node->start == vaddr)
+			goto found;
+	}
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return;
+found:
+	list_del(&bo->list);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	hmm_bo_unref(bo);
+}
+
+/*
+ * destroy all buffer objects with pgnr pages.
+ */
+void hmm_bo_device_destroy_free_bo_size(struct hmm_bo_device *bdev,
+					unsigned int pgnr)
+{
+	struct list_head *pos;
+	struct hmm_buffer_object *bo;
+	unsigned long flags;
+
+	check_bodev_null_return_void(bdev);
+
+retry:
+	spin_lock_irqsave(&bdev->list_lock, flags);
+	list_for_each(pos, &bdev->free_bo_list) {
+		bo = list_to_hmm_bo(pos);
+		if (bo->pgnr == pgnr)
+			goto found;
+	}
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	return;
+found:
+	list_del(&bo->list);
+	spin_unlock_irqrestore(&bdev->list_lock, flags);
+	hmm_bo_unref(bo);
+	goto retry;
+}
diff --git a/drivers/media/atomisp2/hmm/hmm_dynamic_pool.c b/drivers/media/atomisp2/hmm/hmm_dynamic_pool.c
new file mode 100644
index 0000000..fa2016b
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm_dynamic_pool.c
@@ -0,0 +1,228 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * This file contains functions for dynamic memory pool management
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+
+#include "asm/cacheflush.h"
+
+#include "atomisp_internal.h"
+#include "atomisp_common.h"
+#include "hmm/hmm_pool.h"
+
+/*
+ * dynamic memory pool ops.
+ */
+static unsigned int get_pages_from_dynamic_pool(void *pool,
+					struct hmm_page_object *page_obj,
+					unsigned int size, bool cached)
+{
+	struct hmm_page *hmm_page;
+	unsigned long flags;
+	unsigned int i = 0;
+	struct hmm_dynamic_pool_info *dypool_info = pool;
+
+	if (!dypool_info)
+		return 0;
+
+	spin_lock_irqsave(&dypool_info->list_lock, flags);
+	if (dypool_info->initialized) {
+		while (!list_empty(&dypool_info->pages_list)) {
+			hmm_page = list_entry(dypool_info->pages_list.next,
+						struct hmm_page, list);
+
+			list_del(&hmm_page->list);
+			spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+
+			page_obj[i].page = hmm_page->page;
+			page_obj[i++].type = HMM_PAGE_TYPE_DYNAMIC;
+#ifdef USE_KMEM_CACHE
+			kmem_cache_free(dypool_info->pgptr_cache, hmm_page);
+#else
+			atomisp_kernel_free(hmm_page);
+#endif
+
+			if (i == size)
+				return i;
+
+			spin_lock_irqsave(&dypool_info->list_lock, flags);
+		}
+	}
+	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+
+	return i;
+}
+
+static void free_pages_to_dynamic_pool(void *pool,
+					struct hmm_page_object *page_obj)
+{
+	struct hmm_page *hmm_page;
+	unsigned long flags;
+	int ret;
+	struct hmm_dynamic_pool_info *dypool_info = pool;
+
+	if (!dypool_info)
+		return;
+
+	spin_lock_irqsave(&dypool_info->list_lock, flags);
+	if (!dypool_info->initialized) {
+		spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+		return;
+	}
+	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+
+	if (page_obj->type == HMM_PAGE_TYPE_RESERVED)
+		return;
+#ifdef USE_KMEM_CACHE
+	hmm_page = kmem_cache_zalloc(dypool_info->pgptr_cache,
+						GFP_KERNEL);
+#else
+	hmm_page = atomisp_kernel_malloc(sizeof(struct hmm_page));
+#endif
+	if (!hmm_page) {
+		v4l2_err(&atomisp_dev, "out of memory for hmm_page.\n");
+
+		/* free page directly */
+		ret = set_pages_wb(page_obj->page, 1);
+		if (ret)
+			v4l2_err(&atomisp_dev,
+					"set page to WB err ...\n");
+		__free_pages(page_obj->page, 0);
+
+		return;
+	}
+
+	hmm_page->page = page_obj->page;
+
+	/*
+	 * add to pages_list of pages_pool
+	 */
+	spin_lock_irqsave(&dypool_info->list_lock, flags);
+	list_add_tail(&hmm_page->list, &dypool_info->pages_list);
+	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+}
+
+static int hmm_dynamic_pool_init(void **pool, unsigned int pool_size)
+{
+	struct hmm_dynamic_pool_info *dypool_info;
+
+	if (pool_size == 0)
+		return -EINVAL;
+
+	dypool_info = atomisp_kernel_malloc(
+					sizeof(struct hmm_dynamic_pool_info));
+	if (unlikely(!dypool_info)) {
+		v4l2_err(&atomisp_dev,
+			"out of memory for repool_info.\n");
+		return -ENOMEM;
+	}
+
+#ifdef USE_KMEM_CACHE
+	dypool_info->pgptr_cache = kmem_cache_create("pgptr_cache",
+						sizeof(struct hmm_page), 0,
+						SLAB_HWCACHE_ALIGN, NULL);
+	if (!dypool_info->pgptr_cache) {
+		atomisp_kernel_free(dypool_info);
+		return -ENOMEM;
+	}
+#endif
+
+	INIT_LIST_HEAD(&dypool_info->pages_list);
+	spin_lock_init(&dypool_info->list_lock);
+	dypool_info->initialized = true;
+
+	*pool = dypool_info;
+
+	return 0;
+}
+
+static void hmm_dynamic_pool_exit(void **pool)
+{
+	struct hmm_dynamic_pool_info *dypool_info = *pool;
+	struct hmm_page *hmm_page;
+	unsigned long flags;
+	int ret;
+
+	if (!dypool_info)
+		return;
+
+	spin_lock_irqsave(&dypool_info->list_lock, flags);
+	if (!dypool_info->initialized) {
+		spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+		return;
+	}
+	dypool_info->initialized = false;
+
+	while (!list_empty(&dypool_info->pages_list)) {
+		hmm_page = list_entry(dypool_info->pages_list.next,
+					struct hmm_page, list);
+
+		list_del(&hmm_page->list);
+		spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+
+		/* can cause thread sleep, so cannot be put into spin_lock */
+		ret = set_pages_wb(hmm_page->page, 1);
+		if (ret)
+			v4l2_err(&atomisp_dev,
+				"set page to WB err...\n");
+		__free_pages(hmm_page->page, 0);
+
+#ifdef USE_KMEM_CACHE
+		kmem_cache_free(dypool_info->pgptr_cache, hmm_page);
+#else
+		atomisp_kernel_free(hmm_page);
+#endif
+		spin_lock_irqsave(&dypool_info->list_lock, flags);
+	}
+
+	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
+
+#ifdef USE_KMEM_CACHE
+	kmem_cache_destroy(dypool_info->pgptr_cache);
+#endif
+
+	atomisp_kernel_free(dypool_info);
+
+	*pool = NULL;
+}
+
+static int hmm_dynamic_pool_inited(void *pool)
+{
+	struct hmm_dynamic_pool_info *dypool_info = pool;
+
+	if (!dypool_info)
+		return 0;
+
+	return dypool_info->initialized;
+}
+
+struct hmm_pool_ops dynamic_pops = {
+	.pool_init		= hmm_dynamic_pool_init,
+	.pool_exit		= hmm_dynamic_pool_exit,
+	.pool_alloc_pages	= get_pages_from_dynamic_pool,
+	.pool_free_pages	= free_pages_to_dynamic_pool,
+	.pool_inited		= hmm_dynamic_pool_inited,
+};
diff --git a/drivers/media/atomisp2/hmm/hmm_reserved_pool.c b/drivers/media/atomisp2/hmm/hmm_reserved_pool.c
new file mode 100644
index 0000000..102f45e
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm_reserved_pool.c
@@ -0,0 +1,245 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * This file contains functions for reserved memory pool management
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+
+#include "asm/cacheflush.h"
+
+#include "atomisp_internal.h"
+#include "atomisp_common.h"
+#include "hmm/hmm_pool.h"
+
+/*
+ * reserved memory pool ops.
+ */
+static unsigned int get_pages_from_reserved_pool(void *pool,
+					struct hmm_page_object *page_obj,
+					unsigned int size, bool cached)
+{
+	unsigned long flags;
+	unsigned int i = 0;
+	unsigned int repool_pgnr;
+	int j;
+	struct hmm_reserved_pool_info *repool_info = pool;
+
+	if (!repool_info)
+		return 0;
+
+	spin_lock_irqsave(&repool_info->list_lock, flags);
+	if (repool_info->initialized) {
+		repool_pgnr = repool_info->index;
+
+		for (j = repool_pgnr-1; j >= 0; j--) {
+			page_obj[i].page = repool_info->pages[j];
+			page_obj[i].type = HMM_PAGE_TYPE_RESERVED;
+			i++;
+			repool_info->index--;
+			if (i == size)
+				break;
+		}
+	}
+	spin_unlock_irqrestore(&repool_info->list_lock, flags);
+	return i;
+}
+
+static void free_pages_to_reserved_pool(void *pool,
+					struct hmm_page_object *page_obj)
+{
+	unsigned long flags;
+	struct hmm_reserved_pool_info *repool_info = pool;
+
+	if (!repool_info)
+		return;
+
+	spin_lock_irqsave(&repool_info->list_lock, flags);
+
+	if (repool_info->initialized &&
+	    repool_info->index < repool_info->pgnr &&
+	    page_obj->type == HMM_PAGE_TYPE_RESERVED) {
+		repool_info->pages[repool_info->index++] = page_obj->page;
+	}
+
+	spin_unlock_irqrestore(&repool_info->list_lock, flags);
+}
+
+static int hmm_reserved_pool_setup(struct hmm_reserved_pool_info **repool_info,
+					unsigned int pool_size)
+{
+	struct hmm_reserved_pool_info *pool_info;
+
+	pool_info = atomisp_kernel_malloc(
+					sizeof(struct hmm_reserved_pool_info));
+	if (unlikely(!pool_info)) {
+		v4l2_err(&atomisp_dev,
+			"out of memory for repool_info.\n");
+		return -ENOMEM;
+	}
+
+	pool_info->pages = atomisp_kernel_malloc(
+					sizeof(struct page *) * pool_size);
+	if (unlikely(!pool_info->pages)) {
+		v4l2_err(&atomisp_dev,
+			"out of memory for repool_info->pages.\n");
+		atomisp_kernel_free(pool_info);
+		return -ENOMEM;
+	}
+
+	pool_info->index = 0;
+	pool_info->pgnr = 0;
+	spin_lock_init(&pool_info->list_lock);
+	pool_info->initialized = true;
+
+	*repool_info = pool_info;
+
+	return 0;
+}
+
+static int hmm_reserved_pool_init(void **pool, unsigned int pool_size)
+{
+	int ret;
+	unsigned int blk_pgnr;
+	unsigned int pgnr = pool_size;
+	unsigned int order = 0;
+	unsigned int i = 0;
+	int fail_number = 0;
+	struct page *pages;
+	int j;
+	struct hmm_reserved_pool_info *repool_info;
+
+	if (pool_size == 0)
+		return -EINVAL;
+
+	ret = hmm_reserved_pool_setup(&repool_info, pool_size);
+	if (ret) {
+		v4l2_err(&atomisp_dev,
+			    "hmm_reserved_pool_setup failed.\n");
+		return ret;
+	}
+
+	pgnr = pool_size;
+
+	i = 0;
+	order = 0;
+
+	while (pgnr) {
+		pages = alloc_pages(GFP_KERNEL | __GFP_NOWARN, order);
+		if (unlikely(!pages)) {
+			fail_number++;
+			v4l2_err(&atomisp_dev, "%s: alloc_pages failed: %d\n",
+					__func__, fail_number);
+			/* if fail five times, will goto end */
+
+			/* FIXME: whether is the mechanism is ok? */
+			if (fail_number == ALLOC_PAGE_FAIL_NUM)
+				goto end;
+		} else {
+			blk_pgnr = 1U << order;
+
+			ret = set_pages_uc(pages, blk_pgnr);
+			if (ret) {
+				v4l2_err(&atomisp_dev,
+						"set pages uncached failed\n");
+				__free_pages(pages, order);
+				goto end;
+			}
+
+			for (j = 0; j < blk_pgnr; j++)
+				repool_info->pages[i++] = pages + j;
+
+			repool_info->index += blk_pgnr;
+			repool_info->pgnr += blk_pgnr;
+
+			pgnr -= blk_pgnr;
+
+			fail_number = 0;
+		}
+	}
+
+end:
+	repool_info->initialized = true;
+
+	*pool = repool_info;
+
+	v4l2_info(&atomisp_dev,
+			"hmm_reserved_pool init successfully,"
+			"hmm_reserved_pool is with %d pages.\n",
+			repool_info->pgnr);
+	return 0;
+}
+
+static void hmm_reserved_pool_exit(void **pool)
+{
+	unsigned long flags;
+	int i, ret;
+	unsigned int pgnr;
+	struct hmm_reserved_pool_info *repool_info = *pool;
+
+	if (!repool_info)
+		return;
+
+	spin_lock_irqsave(&repool_info->list_lock, flags);
+	if (!repool_info->initialized) {
+		spin_unlock_irqrestore(&repool_info->list_lock, flags);
+		return;
+	}
+	pgnr = repool_info->pgnr;
+	repool_info->index = 0;
+	repool_info->pgnr = 0;
+	repool_info->initialized = false;
+	spin_unlock_irqrestore(&repool_info->list_lock, flags);
+
+	for (i = 0; i < pgnr; i++) {
+		ret = set_pages_wb(repool_info->pages[i], 1);
+		if (ret)
+			v4l2_err(&atomisp_dev,
+				"set page to WB err...\n");
+		__free_pages(repool_info->pages[i], 0);
+	}
+
+	atomisp_kernel_free(repool_info->pages);
+	atomisp_kernel_free(repool_info);
+
+	*pool = NULL;
+}
+
+static int hmm_reserved_pool_inited(void *pool)
+{
+	struct hmm_reserved_pool_info *repool_info = pool;
+
+	if (!repool_info)
+		return 0;
+
+	return repool_info->initialized;
+}
+
+struct hmm_pool_ops reserved_pops = {
+	.pool_init		= hmm_reserved_pool_init,
+	.pool_exit		= hmm_reserved_pool_exit,
+	.pool_alloc_pages	= get_pages_from_reserved_pool,
+	.pool_free_pages	= free_pages_to_reserved_pool,
+	.pool_inited		= hmm_reserved_pool_inited,
+};
diff --git a/drivers/media/atomisp2/hmm/hmm_vm.c b/drivers/media/atomisp2/hmm/hmm_vm.c
new file mode 100644
index 0000000..3884bab
--- /dev/null
+++ b/drivers/media/atomisp2/hmm/hmm_vm.c
@@ -0,0 +1,220 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * This file contains function for ISP virtual address management in ISP driver
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <asm/page.h>
+
+#include "mmu/isp_mmu.h"
+#include "hmm/hmm_vm.h"
+#include "hmm/hmm_common.h"
+#include "atomisp_internal.h"
+
+static unsigned int vm_node_end(unsigned int start, unsigned int pgnr)
+{
+	return start + pgnr_to_size(pgnr);
+}
+
+static int addr_in_vm_node(unsigned int addr,
+		struct hmm_vm_node *node)
+{
+	return (addr >= node->start) && (addr < (node->start + node->size));
+}
+
+int hmm_vm_init(struct hmm_vm *vm, unsigned int start,
+		unsigned int size)
+{
+	if (!vm)
+		return -1;
+
+	vm->start = start;
+	vm->pgnr = size_to_pgnr_ceil(size);
+	vm->size = pgnr_to_size(vm->pgnr);
+
+	INIT_LIST_HEAD(&vm->vm_node_list);
+	spin_lock_init(&vm->lock);
+	vm->cache = kmem_cache_create("atomisp_vm", sizeof(struct hmm_vm_node),
+				      0, 0, NULL);
+
+	return vm->cache != NULL ? 0 : -ENOMEM;
+}
+
+void hmm_vm_clean(struct hmm_vm *vm)
+{
+	struct hmm_vm_node *node, *tmp;
+	struct list_head new_head;
+
+	if (!vm)
+		return;
+
+	spin_lock(&vm->lock);
+	list_replace_init(&vm->vm_node_list, &new_head);
+	spin_unlock(&vm->lock);
+
+	list_for_each_entry_safe(node, tmp, &new_head, list) {
+		list_del(&node->list);
+		kmem_cache_free(vm->cache, node);
+	}
+
+	kmem_cache_destroy(vm->cache);
+}
+
+static struct hmm_vm_node *alloc_hmm_vm_node(unsigned int start,
+					       unsigned int pgnr,
+					       struct hmm_vm *vm)
+{
+	struct hmm_vm_node *node;
+
+	node = kmem_cache_alloc(vm->cache, GFP_KERNEL);
+	if (!node) {
+		v4l2_err(&atomisp_dev, "out of memory.\n");
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&node->list);
+	node->start = start;
+	node->pgnr = pgnr;
+	node->size = pgnr_to_size(pgnr);
+	node->vm = vm;
+
+	return node;
+}
+
+struct hmm_vm_node *hmm_vm_alloc_node(struct hmm_vm *vm, unsigned int pgnr)
+{
+	struct list_head *head;
+	struct hmm_vm_node *node, *cur, *next;
+	unsigned int vm_start, vm_end;
+	unsigned int addr;
+	unsigned int size;
+
+	if (!vm)
+		return NULL;
+
+	vm_start = vm->start;
+	vm_end = vm_node_end(vm->start, vm->pgnr);
+	size = pgnr_to_size(pgnr);
+
+	addr = vm_start;
+	head = &vm->vm_node_list;
+
+	spin_lock(&vm->lock);
+	/*
+	 * if list is empty, the loop code will not be executed.
+	 */
+	list_for_each_entry(cur, head, list) {
+		/* Add gap between vm areas as helper to not hide overflow */
+		addr = PAGE_ALIGN(vm_node_end(cur->start, cur->pgnr) + 1);
+
+		if (list_is_last(&cur->list, head)) {
+			if (addr + size > vm_end) {
+				/* vm area does not have space anymore */
+				spin_unlock(&vm->lock);
+				v4l2_info(&atomisp_dev,
+					  "no enough virtual address space.\n");
+				return NULL;
+			}
+
+			/* We still have vm space to add new node to tail */
+			break;
+		}
+
+		next = list_entry(cur->list.next, struct hmm_vm_node, list);
+		if ((next->start - addr) > size)
+			break;
+	}
+	spin_unlock(&vm->lock);
+
+	node = alloc_hmm_vm_node(addr, pgnr, vm);
+	if (!node) {
+		v4l2_info(&atomisp_dev, "no memory to allocate hmm vm node.\n");
+		return NULL;
+	}
+
+	spin_lock(&vm->lock);
+	list_add(&node->list, &cur->list);
+	spin_unlock(&vm->lock);
+
+	return node;
+}
+
+void hmm_vm_free_node(struct hmm_vm_node *node)
+{
+	struct hmm_vm *vm;
+
+	if (!node)
+		return;
+
+	vm = node->vm;
+
+	spin_lock(&vm->lock);
+	list_del(&node->list);
+	spin_unlock(&vm->lock);
+
+	kmem_cache_free(vm->cache, node);
+}
+
+struct hmm_vm_node *hmm_vm_find_node_start(struct hmm_vm *vm, unsigned int addr)
+{
+	struct hmm_vm_node *node;
+
+	if (!vm)
+		return NULL;
+
+	spin_lock(&vm->lock);
+
+	list_for_each_entry(node, &vm->vm_node_list, list) {
+		if (node->start == addr) {
+			spin_unlock(&vm->lock);
+			return node;
+		}
+	}
+
+	spin_unlock(&vm->lock);
+	return NULL;
+}
+
+struct hmm_vm_node *hmm_vm_find_node_in_range(struct hmm_vm *vm,
+					      unsigned int addr)
+{
+	struct hmm_vm_node *node;
+
+	if (!vm)
+		return NULL;
+
+	spin_lock(&vm->lock);
+
+	list_for_each_entry(node, &vm->vm_node_list, list) {
+		if (addr_in_vm_node(addr, node)) {
+			spin_unlock(&vm->lock);
+			return node;
+		}
+	}
+
+	spin_unlock(&vm->lock);
+	return NULL;
+}
diff --git a/drivers/media/atomisp2/hrt/device_access.c b/drivers/media/atomisp2/hrt/device_access.c
new file mode 100644
index 0000000..87a41c7
--- /dev/null
+++ b/drivers/media/atomisp2/hrt/device_access.c
@@ -0,0 +1,128 @@
+
+#include "device_access.h"
+#include "hive_isp_css_custom_host_hrt.h"
+
+#include "assert_support.h"
+
+//#include <hrt/master_port.h>	/* hrt_master_port_load() */
+#ifdef C_RUN
+#include <string.h>				/* memcpy() */
+#endif
+
+/*
+ * This is an HRT backend implementation for CSIM
+ */
+
+static sys_address		base_address = (sys_address)-1;
+
+void device_set_base_address(
+	const sys_address		base_addr)
+{
+	base_address = base_addr;
+return;
+}
+
+
+sys_address device_get_base_address(void)
+{
+return base_address;
+}
+
+uint8_t device_load_uint8(
+	const hrt_address		addr)
+{
+assert(base_address != (sys_address)-1);
+return hrt_master_port_uload_8(base_address + addr);
+}
+
+uint16_t device_load_uint16(
+	const hrt_address		addr)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x01) == 0);
+return hrt_master_port_uload_16(base_address + addr);
+}
+
+uint32_t device_load_uint32(
+	const hrt_address		addr)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x03) == 0);
+return hrt_master_port_uload_32(base_address + addr);
+}
+
+uint64_t device_load_uint64(
+	const hrt_address		addr)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x07) == 0);
+assert(0);
+return 0;
+}
+
+void device_store_uint8(
+	const hrt_address		addr,
+	const uint8_t			data)
+{
+assert(base_address != (sys_address)-1);
+hrt_master_port_store_8(base_address + addr, data);
+return;
+}
+
+void device_store_uint16(
+	const hrt_address		addr,
+	const uint16_t			data)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x01) == 0);
+hrt_master_port_store_16(base_address + addr, data);
+return;
+}
+
+void device_store_uint32(
+	const hrt_address		addr,
+	const uint32_t			data)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x03) == 0);
+hrt_master_port_store_32(base_address + addr, data);
+return;
+}
+
+void device_store_uint64(
+	const hrt_address		addr,
+	const uint64_t			data)
+{
+assert(base_address != (sys_address)-1);
+assert((addr & 0x07) == 0);
+assert(0);
+(void)data;
+return;
+}
+
+void device_load(
+	const hrt_address		addr,
+	void					*data,
+	const size_t			size)
+{
+assert(base_address != (sys_address)-1);
+#ifndef C_RUN
+	hrt_master_port_load((uint32_t)(base_address + addr), data, size);
+#else
+	memcpy(data, (void *)addr, size);
+#endif
+}
+
+void device_store(
+	const hrt_address		addr,
+	const void				*data,
+	const size_t			size)
+{
+assert(base_address != (sys_address)-1);
+#ifndef C_RUN
+	hrt_master_port_store((uint32_t)(base_address + addr), data, size);
+#else
+	memcpy((void *)addr, data, size);
+#endif
+return;
+}
diff --git a/drivers/media/atomisp2/hrt/hive_isp_css_custom_host_hrt.h b/drivers/media/atomisp2/hrt/hive_isp_css_custom_host_hrt.h
new file mode 100644
index 0000000..261022b
--- /dev/null
+++ b/drivers/media/atomisp2/hrt/hive_isp_css_custom_host_hrt.h
@@ -0,0 +1,105 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef _hive_isp_css_custom_host_hrt_h_
+#define _hive_isp_css_custom_host_hrt_h_
+
+//#include <linux/delay.h>
+#include "atomisp_helper.h"
+
+/*
+ * _hrt_master_port_store/load/uload -macros using __force attributed
+ * cast to intentional dereferencing __iomem attributed (noderef)
+ * pointer from atomisp_get_io_virt_addr
+ */
+#define _hrt_master_port_store_8(a, d) \
+	(*((s8 __force *)atomisp_get_io_virt_addr(a)) = (d))
+
+#define _hrt_master_port_store_16(a, d) \
+	(*((s16 __force *)atomisp_get_io_virt_addr(a)) = (d))
+
+#define _hrt_master_port_store_32(a, d) \
+	(*((s32 __force *)atomisp_get_io_virt_addr(a)) = (d))
+
+#define _hrt_master_port_load_8(a) \
+	(*(s8 __force *)atomisp_get_io_virt_addr(a))
+
+#define _hrt_master_port_load_16(a) \
+	(*(s16 __force *)atomisp_get_io_virt_addr(a))
+
+#define _hrt_master_port_load_32(a) \
+	(*(s32 __force *)atomisp_get_io_virt_addr(a))
+
+#define _hrt_master_port_uload_8(a) \
+	(*(u8 __force *)atomisp_get_io_virt_addr(a))
+
+#define _hrt_master_port_uload_16(a) \
+	(*(u16 __force *)atomisp_get_io_virt_addr(a))
+
+#define _hrt_master_port_uload_32(a) \
+	(*(u32 __force *)atomisp_get_io_virt_addr(a))
+
+#define _hrt_master_port_store_8_volatile(a, d)  _hrt_master_port_store_8(a, d)
+#define _hrt_master_port_store_16_volatile(a, d) _hrt_master_port_store_16(a, d)
+#define _hrt_master_port_store_32_volatile(a, d) _hrt_master_port_store_32(a, d)
+
+#define _hrt_master_port_load_8_volatile(a)      _hrt_master_port_load_8(a)
+#define _hrt_master_port_load_16_volatile(a)     _hrt_master_port_load_16(a)
+#define _hrt_master_port_load_32_volatile(a)     _hrt_master_port_load_32(a)
+
+#define _hrt_master_port_uload_8_volatile(a)     _hrt_master_port_uload_8(a)
+#define _hrt_master_port_uload_16_volatile(a)    _hrt_master_port_uload_16(a)
+#define _hrt_master_port_uload_32_volatile(a)    _hrt_master_port_uload_32(a)
+
+
+static inline uint32_t _hrt_mem_store(uint32_t to, const void *from, size_t n)
+{
+	unsigned i;
+	uint32_t _to = to;
+	const char *_from = (const char *)from;
+	for (i = 0; i < n; i++, _to++, _from++){
+		_hrt_master_port_store_8(_to, *_from);
+	}
+	return _to;
+}
+
+static inline void *_hrt_mem_load(uint32_t from, void *to, size_t n)
+{
+	unsigned i;
+	char *_to = (char *)to;
+	uint32_t _from = from;
+	for (i = 0; i < n; i++, _to++, _from++)
+		*_to = _hrt_master_port_load_8(_from);
+	return _to;
+}
+
+static inline uint32_t _hrt_mem_set(uint32_t to, int c, size_t n)
+{
+	unsigned i;
+	uint32_t _to = to;
+	for (i = 0; i < n; i++, _to++){
+		_hrt_master_port_store_8(_to, c);
+	}
+	return _to;
+}
+
+#endif /* _hive_isp_css_custom_host_hrt_h_ */
diff --git a/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c b/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c
new file mode 100644
index 0000000..4f56849
--- /dev/null
+++ b/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.c
@@ -0,0 +1,267 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <hmm/hmm.h>
+#include <ia_css.h>
+/* not sure if we need these two for page related macros,
+ * need to double check */
+
+//#include <linux/kernel.h>
+//#include <linux/slab.h>
+#include <hive_isp_css_mm_hrt.h>
+#include "atomisp_internal.h"
+
+#define __page_align(size)	(((size) + (PAGE_SIZE-1)) & (~(PAGE_SIZE-1)))
+
+static unsigned init_done;
+
+void hrt_isp_css_mm_init(void)
+{
+	if (!init_done) {
+		hmm_init();
+		init_done = 1;
+	}
+}
+
+int hrt_isp_get_mmu_base_address(void)
+{
+	if (init_done)
+		return hmm_get_mmu_base_addr();
+	return -EINVAL;
+
+}
+int hrt_isp_css_mm_set(ia_css_ptr virt_addr, int c, size_t bytes)
+{
+	if (virt_addr)
+		return hmm_set(virt_addr, c, bytes);
+
+	return -EINVAL;
+}
+
+int hrt_isp_css_mm_load(ia_css_ptr virt_addr, void *data, size_t bytes)
+{
+	if (virt_addr)
+		return hmm_load(virt_addr, data, bytes);
+	return -EINVAL;
+}
+
+int hrt_isp_css_mm_store(ia_css_ptr virt_addr, const void *data, size_t bytes)
+{
+	if (virt_addr)
+		return hmm_store(virt_addr, data, bytes);
+	return -EINVAL;
+}
+
+void hrt_isp_css_mm_free(ia_css_ptr virt_addr)
+{
+	if (virt_addr)
+		hmm_free(virt_addr);
+}
+
+void hrt_isp_css_mm_clear(void)
+{
+	if (init_done) {
+		hmm_cleanup();
+		init_done = 0;
+	}
+}
+
+static void *my_userptr;
+static unsigned my_num_pages;
+static enum hrt_userptr_type my_usr_type;
+
+void hrt_isp_css_mm_set_user_ptr(void *userptr,
+				 unsigned int num_pages,
+				 enum hrt_userptr_type type)
+{
+	my_userptr = userptr;
+	my_num_pages = num_pages;
+	my_usr_type = type;
+}
+
+static ia_css_ptr __hrt_isp_css_mm_alloc(size_t bytes, void *userptr,
+				    unsigned int num_pages,
+				    enum hrt_userptr_type type,
+						void *priv,
+				    bool cached)
+{
+	if (!init_done)
+		hrt_isp_css_mm_init();
+#ifdef CONFIG_ION
+	if (type == HRT_USR_ION)
+		return hmm_alloc(bytes, HMM_BO_ION, 0,
+					 userptr, cached, NULL);
+
+#endif
+	if (type == HRT_USR_PTR) {
+		if (userptr == NULL)
+					return hmm_alloc(bytes, HMM_BO_PRIVATE, 0,
+						 0, cached, priv);
+		else {
+			if (num_pages < ((__page_align(bytes)) >> PAGE_SHIFT))
+				v4l2_err(&atomisp_dev,
+					 "user space memory size is less"
+					 " than the expected size..\n");
+			/*HSD 4994598 - Below warning check is commented. EMGD rounding of pages allocating more page in DMABUF app. */
+			/*else if (num_pages > ((__page_align(bytes))
+					      >> PAGE_SHIFT))
+				v4l2_err(&atomisp_dev,
+					 "user space memory size is"
+					 " large than the expected size..\n");*/
+
+			return hmm_alloc(bytes, HMM_BO_USER, 0,
+						 userptr, cached, NULL);
+		}
+	} else if (type == HRT_KERNEL_PTR) {
+		if (num_pages < ((__page_align(bytes)) >> PAGE_SHIFT))
+        v4l2_err(&atomisp_dev,
+           "kernel space memory size is less"
+           " than the expected size..\n");
+/*HSD 4994598 - Below warning check is commented. EMGD rounding of pages allocating more page in DMABUF app. */
+      /*else if (num_pages > ((__page_align(bytes))
+                >> PAGE_SHIFT))
+        v4l2_err(&atomisp_dev,
+           "kernel space memory size is"
+           " large than the expected size..\n");*/
+
+      return hmm_alloc(bytes, HMM_BO_DMA, 0,
+             userptr, cached, priv);
+
+	} else {
+		v4l2_err(&atomisp_dev, "user ptr type is incorrect.\n");
+		return 0;
+	}
+}
+
+ia_css_ptr hrt_isp_css_mm_alloc(size_t bytes)
+{
+	return __hrt_isp_css_mm_alloc(bytes, my_userptr,
+				      my_num_pages, my_usr_type, NULL, false);
+}
+
+ia_css_ptr hrt_isp_css_mm_alloc_user_ptr(size_t bytes, void *userptr,
+				    unsigned int num_pages,
+				    enum hrt_userptr_type type,
+						void *priv,
+				    bool cached)
+{
+	return __hrt_isp_css_mm_alloc(bytes, userptr, num_pages,
+				      type, priv, cached);
+}
+
+ia_css_ptr hrt_isp_css_mm_alloc_cached(size_t bytes)
+{
+	if (!init_done)
+		hrt_isp_css_mm_init();
+
+	if (my_userptr == NULL)
+			return hmm_alloc(bytes, HMM_BO_PRIVATE, 0, 0,
+						HMM_CACHED, NULL);
+	else {
+		if (my_num_pages < ((__page_align(bytes)) >> PAGE_SHIFT))
+			v4l2_err(&atomisp_dev,
+					"user space memory size is less"
+					" than the expected size..\n");
+		else if (my_num_pages > ((__page_align(bytes)) >> PAGE_SHIFT))
+			v4l2_err(&atomisp_dev,
+					"user space memory size is"
+					" large than the expected size..\n");
+
+		return hmm_alloc(bytes, HMM_BO_USER, 0,
+						my_userptr, HMM_CACHED, NULL);
+	}
+}
+
+ia_css_ptr hrt_isp_css_mm_calloc(size_t bytes)
+{
+	ia_css_ptr ptr = hrt_isp_css_mm_alloc(bytes);
+	if (!ptr)
+		hmm_set(ptr, 0, bytes);
+	return ptr;
+}
+
+ia_css_ptr hrt_isp_css_mm_calloc_cached(size_t bytes)
+{
+	ia_css_ptr ptr = hrt_isp_css_mm_alloc_cached(bytes);
+	if (!ptr)
+		hmm_set(ptr, 0, bytes);
+	return ptr;
+}
+
+phys_addr_t hrt_isp_css_virt_to_phys(ia_css_ptr virt_addr)
+{
+	return hmm_virt_to_phys(virt_addr);
+}
+
+ia_css_ptr hrt_isp_css_mm_alloc_contiguous(size_t bytes)
+{
+	BUG_ON(false);
+	return 0;
+}
+ia_css_ptr hrt_isp_css_mm_calloc_contiguous(size_t bytes)
+{
+	BUG_ON(false);
+	return 0;
+}
+#ifdef CSS_2
+ia_css_ptr
+atomisp_css2_mm_alloc(size_t bytes, uint32_t attr)
+{
+	if (attr & IA_CSS_MEM_ATTR_CACHED)
+		return (ia_css_ptr) hrt_isp_css_mm_calloc_cached(bytes);
+	else if (attr & IA_CSS_MEM_ATTR_ZEROED)
+		return (ia_css_ptr) hrt_isp_css_mm_calloc(bytes);
+	else if (attr & IA_CSS_MEM_ATTR_CONTIGUOUS)
+		return (ia_css_ptr) hrt_isp_css_mm_calloc_contiguous(bytes);
+	else
+		return (ia_css_ptr) hrt_isp_css_mm_calloc(bytes);
+}
+
+void atomisp_css2_mm_free(ia_css_ptr ptr)
+{
+	hrt_isp_css_mm_free(ptr);
+}
+int atomisp_css2_mm_load(ia_css_ptr ptr, void *data, size_t bytes)
+{
+	return hrt_isp_css_mm_load(ptr, data, bytes);
+}
+int atomisp_css2_mm_store(ia_css_ptr ptr, const void *data, size_t bytes)
+{
+	return hrt_isp_css_mm_store(ptr, data, bytes);
+}
+int atomisp_css2_mm_set(ia_css_ptr ptr, int c, size_t bytes)
+{
+	return hrt_isp_css_mm_set(ptr, c, bytes);
+}
+
+ia_css_ptr atomisp_css2_mm_mmap(const void *ptr, const size_t size,
+		   uint16_t attribute, void *context)
+{
+	struct hrt_userbuffer_attr *userbuffer_attr = context;
+	return hrt_isp_css_mm_alloc_user_ptr(
+			size, (void *)ptr,
+			userbuffer_attr->pgnr,
+			userbuffer_attr->type,
+			userbuffer_attr->priv,
+			attribute & HRT_BUF_FLAG_CACHED);
+}
+#endif
diff --git a/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.h b/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.h
new file mode 100644
index 0000000..f83312a
--- /dev/null
+++ b/drivers/media/atomisp2/hrt/hive_isp_css_mm_hrt.h
@@ -0,0 +1,114 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _hive_isp_css_mm_hrt_h_
+#define _hive_isp_css_mm_hrt_h_
+
+#ifndef HRT_KERNEL
+/* size_t is defined already in kernel mode */
+#include <stdlib.h>
+#endif
+#include <hmm/hmm.h>
+#include <hrt/hive_isp_css_custom_host_hrt.h>
+
+#define HRT_BUF_FLAG_CACHED (1 << 0)
+
+enum hrt_userptr_type {
+	HRT_USR_PTR = 0,
+	HRT_KERNEL_PTR,
+#ifdef CONFIG_ION
+	HRT_USR_ION,
+#endif
+};
+
+struct hrt_userbuffer_attr {
+	enum hrt_userptr_type	type;
+	unsigned int		pgnr;
+	void *priv;
+};
+
+void hrt_isp_css_mm_init(void);
+int hrt_isp_get_mmu_base_address(void);
+void hrt_isp_css_mm_set_user_ptr(void *userptr,
+				unsigned int num_pages, enum hrt_userptr_type);
+
+int hrt_isp_css_mm_set(ia_css_ptr virt_addr, int c, size_t bytes);
+
+/* Allocate memory, returns a virtual address */
+ia_css_ptr hrt_isp_css_mm_alloc(size_t bytes);
+ia_css_ptr hrt_isp_css_mm_alloc_user_ptr(size_t bytes, void *userptr,
+				    unsigned int num_pages,
+				    enum hrt_userptr_type,
+						void *priv,
+				    bool cached);
+ia_css_ptr hrt_isp_css_mm_alloc_cached(size_t bytes);
+
+/* allocate memory and initialize with zeros,
+   returns a virtual address */
+ia_css_ptr hrt_isp_css_mm_calloc(size_t bytes);
+ia_css_ptr hrt_isp_css_mm_calloc_cached(size_t bytes);
+
+/* Free memory, given a virtual address */
+void hrt_isp_css_mm_free(ia_css_ptr virt_addr);
+
+/* Store data to a virtual address */
+int hrt_isp_css_mm_load(ia_css_ptr virt_addr, void *data, size_t bytes);
+
+/* Load data from a virtual address */
+int hrt_isp_css_mm_store(ia_css_ptr virt_addr, const void *data, size_t bytes);
+
+int hrt_isp_css_mm_load_int(ia_css_ptr virt_addr, int *data);
+int hrt_isp_css_mm_load_short(ia_css_ptr virt_addr, short *data);
+int hrt_isp_css_mm_load_char(ia_css_ptr virt_addr, char *data);
+
+int hrt_isp_css_mm_store_char(ia_css_ptr virt_addr, char data);
+int hrt_isp_css_mm_store_short(ia_css_ptr virt_addr, short data);
+int hrt_isp_css_mm_store_int(ia_css_ptr virt_addr, int data);
+
+/* translate a virtual to a physical address, used to program
+   the display driver on  the FPGA system */
+phys_addr_t hrt_isp_css_virt_to_phys(ia_css_ptr virt_addr);
+
+ia_css_ptr hrt_isp_css_mm_alloc_contiguous(size_t bytes);
+ia_css_ptr hrt_isp_css_mm_calloc_contiguous(size_t bytes);
+
+void hrt_isp_css_mm_clear(void);
+#ifdef CSS_2
+ia_css_ptr
+atomisp_css2_mm_alloc(size_t bytes, uint32_t attr);
+void atomisp_css2_mm_free(ia_css_ptr ptr);
+int atomisp_css2_mm_load(ia_css_ptr ptr, void *data, size_t bytes);
+int atomisp_css2_mm_store(ia_css_ptr ptr, const void *data, size_t bytes);
+int atomisp_css2_mm_set(ia_css_ptr ptr, int c, size_t bytes);
+ia_css_ptr atomisp_css2_mm_mmap(const void *ptr, const size_t size,
+		   uint16_t attribute, void *context);
+void atomisp_css2_hw_store_8(hrt_address addr, uint8_t data);
+void atomisp_css2_hw_store_16(hrt_address addr, uint16_t data);
+void atomisp_css2_hw_store_32(hrt_address addr, uint32_t data);
+uint8_t atomisp_css2_hw_load_8(hrt_address addr);
+uint16_t atomisp_css2_hw_load_16(hrt_address addr);
+uint32_t atomisp_css2_hw_load_32(hrt_address addr);
+void atomisp_css2_hw_store(hrt_address addr, const void *from, uint32_t n);
+void atomisp_css2_hw_load(hrt_address addr, void *to, uint32_t n);
+#endif
+#endif /* _hive_isp_css_mm_hrt_h_ */
diff --git a/drivers/media/atomisp2/hrt/memory_access.c b/drivers/media/atomisp2/hrt/memory_access.c
new file mode 100644
index 0000000..070d6db
--- /dev/null
+++ b/drivers/media/atomisp2/hrt/memory_access.c
@@ -0,0 +1,371 @@
+
+#include "memory_access.h"
+
+#include <stddef.h>		/* NULL */
+#include <stdbool.h>
+
+#include "device_access.h"
+
+#include "mmu_device.h"
+
+#include "assert_support.h"
+
+/* Presently system specific */
+#include <hmm/hmm.h>
+/* Presently system specific */
+#include "hive_isp_css_mm_hrt.h"
+
+/*
+ * This is an HRT backend implementation for CSIM
+ * 31 July 2012, rvanimme: this implementation is also used in Android context
+ */
+
+static sys_address	page_table_base_address = (sys_address)-1;
+const ia_css_ptr	mmgr_NULL = 0;
+
+#ifndef SH_CSS_MEMORY_GUARDING
+/* Choose default in case not defined */
+#ifdef HRT_CSIM
+#define SH_CSS_MEMORY_GUARDING (1)
+#else
+#define SH_CSS_MEMORY_GUARDING (0)
+#endif
+#endif
+
+#if SH_CSS_MEMORY_GUARDING
+#define CEIL_DIV(a, b)	((b) ? ((a)+(b)-1)/(b) : 0)
+#define CEIL_MUL(a, b)	(CEIL_DIV(a, b) * (b))
+#define DDR_ALIGN(a)	(CEIL_MUL((a), (HIVE_ISP_DDR_WORD_BYTES)))
+
+#define MEM_GUARD_START		0xABBAABBA
+#define MEM_GUARD_END		0xBEEFBEEF
+#define GUARD_SIZE		sizeof(unsigned long)
+#define GUARD_SIZE_ALIGNED	DDR_ALIGN(GUARD_SIZE)
+
+#define MAX_ALLOC_ENTRIES (256)
+#define INVALID_VBASE ((ia_css_ptr)-1)
+#define INVALID_SIZE ((unsigned long)-1)
+
+struct alloc_info {
+	ia_css_ptr  vbase;
+	unsigned long size;
+};
+
+static struct alloc_info alloc_admin[MAX_ALLOC_ENTRIES];
+
+static struct alloc_info const alloc_info_invalid
+					= { INVALID_VBASE, INVALID_SIZE };
+
+static void alloc_admin_init(void)
+{
+	int i;
+
+	for (i = 0; i < MAX_ALLOC_ENTRIES; i++)
+		alloc_admin[i] = alloc_info_invalid;
+}
+
+static struct alloc_info const *alloc_admin_find(ia_css_ptr vaddr)
+{
+	int i;
+	/**
+	 * Note that we use <= instead of < because we like to accept
+	 * zero-sized operations at the last allocated address
+	 * e.g. mmgr_set(vbase+alloc_size, data, 0)
+	 */
+	for (i = 0; i < MAX_ALLOC_ENTRIES; i++) {
+		if (alloc_admin[i].vbase != INVALID_VBASE &&
+					vaddr >= alloc_admin[i].vbase &&
+					vaddr <= alloc_admin[i].vbase +
+							alloc_admin[i].size) {
+			return &alloc_admin[i];
+		}
+	}
+	return &alloc_info_invalid;
+}
+
+static bool mem_guard_valid(ia_css_ptr vaddr, unsigned long size)
+{
+	unsigned long mem_guard;
+	struct alloc_info const *info;
+
+	info = alloc_admin_find(vaddr);
+	if (info->vbase == INVALID_VBASE) {
+		assert(false);
+		return false;
+	}
+
+	/* Check if end is in alloc range*/
+	if ((vaddr + size) > (info->vbase + info->size)) {
+		assert(false);
+		return false;
+	}
+
+	hrt_isp_css_mm_load((info->vbase - sizeof(mem_guard)),
+			&mem_guard, sizeof(mem_guard));
+	if (mem_guard != MEM_GUARD_START) {
+		assert(false);
+		return false;
+	}
+
+	hrt_isp_css_mm_load((info->vbase + info->size),
+					&mem_guard, sizeof(mem_guard));
+	if (mem_guard != MEM_GUARD_END) {
+		assert(false);
+		return false;
+	}
+
+	return true;
+
+}
+
+static void alloc_admin_add(ia_css_ptr vbase, unsigned long size)
+{
+	int i;
+	unsigned long mem_guard;
+
+	assert(alloc_admin_find(vbase)->vbase == INVALID_VBASE);
+
+	mem_guard = MEM_GUARD_START;
+	hrt_isp_css_mm_store((vbase - sizeof(mem_guard)),
+					&mem_guard, sizeof(mem_guard));
+
+	mem_guard = MEM_GUARD_END;
+	hrt_isp_css_mm_store((vbase + size),
+					&mem_guard, sizeof(mem_guard));
+
+	for (i = 0; i < MAX_ALLOC_ENTRIES; i++) {
+		if (alloc_admin[i].vbase == INVALID_VBASE) {
+			alloc_admin[i].vbase = vbase;
+			alloc_admin[i].size = size;
+			return;
+		}
+	}
+	assert(false);
+}
+
+static void alloc_admin_remove(ia_css_ptr vbase)
+{
+	int i;
+	assert(mem_guard_valid(vbase, 0));
+	for (i = 0; i < MAX_ALLOC_ENTRIES; i++) {
+		if (alloc_admin[i].vbase == vbase) {
+			alloc_admin[i] = alloc_info_invalid;
+			return;
+		}
+	}
+	assert(false);
+}
+
+#endif
+
+void mmgr_set_base_address(
+	const sys_address		base_addr)
+{
+	page_table_base_address = base_addr;
+
+#if SH_CSS_MEMORY_GUARDING
+	alloc_admin_init();
+#endif
+/*
+ * This is part of "device_access.h", but it may be
+ * that "hive_isp_css_mm_hrt.h" requires it
+ */
+/* hrt_isp_css_mm_set_ddr_address_offset(offset); */
+/*	mmu_set_page_table_base_index(MMU0_ID, page_table_base_address); */
+return;
+}
+
+sys_address mmgr_get_base_address(void)
+{
+return page_table_base_address;
+}
+
+void mmgr_set_base_index(
+	const hrt_data		base_index)
+{
+/* This system only defines the MMU base address */
+assert(0);
+(void)base_index;
+return;
+}
+
+hrt_data mmgr_get_base_index(void)
+{
+/* This system only defines the MMU base address */
+assert(0);
+return 0;
+}
+
+ia_css_ptr mmgr_malloc(
+	const size_t			size)
+{
+return mmgr_alloc_attr(size, MMGR_ATTRIBUTE_CACHED);
+}
+
+ia_css_ptr mmgr_calloc(
+	const size_t			N,
+	const size_t			size)
+{
+return mmgr_alloc_attr(N * size, MMGR_ATTRIBUTE_CLEARED|MMGR_ATTRIBUTE_CACHED);
+}
+
+ia_css_ptr mmgr_realloc(
+	ia_css_ptr			vaddr,
+	const size_t			size)
+{
+return mmgr_realloc_attr(vaddr, size, MMGR_ATTRIBUTE_DEFAULT);
+}
+
+void mmgr_free(
+	ia_css_ptr			vaddr)
+{
+/* "free()" should accept NULL, "hrt_isp_css_mm_free()" may not */
+	if (vaddr != mmgr_NULL) {
+#if SH_CSS_MEMORY_GUARDING
+		alloc_admin_remove(vaddr);
+		/* Reconstruct the "original" address used with the alloc */
+		vaddr -= GUARD_SIZE_ALIGNED;
+#endif
+		hrt_isp_css_mm_free(vaddr);
+	}
+return;
+}
+
+ia_css_ptr mmgr_alloc_attr(
+	const size_t			size,
+	const uint16_t			attribute)
+{
+	ia_css_ptr	ptr;
+	size_t	extra_space = 0;
+	size_t	aligned_size = size;
+
+assert(page_table_base_address != (sys_address)-1);
+assert((attribute & MMGR_ATTRIBUTE_UNUSED) == 0);
+
+#if SH_CSS_MEMORY_GUARDING
+	/* Add DDR aligned space for a guard at begin and end */
+	/* Begin guard must be DDR aligned, "end" guard not */
+	extra_space = GUARD_SIZE_ALIGNED + GUARD_SIZE;
+	/* SP DMA operates on multiple of 32 bytes, also with writes.
+	 * To prevent that the guard is being overwritten by SP DMA,
+	 * the "end" guard must start DDR aligned.
+	 */
+	aligned_size = DDR_ALIGN(aligned_size);
+#endif
+
+	if (attribute & MMGR_ATTRIBUTE_CLEARED) {
+		if (attribute & MMGR_ATTRIBUTE_CACHED) {
+			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
+				ptr = hrt_isp_css_mm_calloc_contiguous(
+						aligned_size + extra_space);
+			/* } */ else /* { */
+				ptr = hrt_isp_css_mm_calloc_cached(
+						aligned_size + extra_space);
+			/* } */
+		} else { /* !MMGR_ATTRIBUTE_CACHED */
+			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
+				ptr = hrt_isp_css_mm_calloc_contiguous(
+						aligned_size + extra_space);
+			/* } */ else /* { */
+				ptr = hrt_isp_css_mm_calloc(
+						aligned_size + extra_space);
+			/* } */
+		}
+	} else { /* MMGR_ATTRIBUTE_CLEARED */
+		if (attribute & MMGR_ATTRIBUTE_CACHED) {
+			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
+				ptr = hrt_isp_css_mm_alloc_contiguous(
+						aligned_size + extra_space);
+			/* } */ else /* { */
+				ptr = hrt_isp_css_mm_alloc_cached(
+						aligned_size + extra_space);
+			/* } */
+		} else { /* !MMGR_ATTRIBUTE_CACHED */
+			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
+				ptr = hrt_isp_css_mm_alloc_contiguous(
+						aligned_size + extra_space);
+			/* } */ else /* { */
+				ptr = hrt_isp_css_mm_alloc(
+						aligned_size + extra_space);
+			/* } */
+		}
+	}
+
+#if SH_CSS_MEMORY_GUARDING
+	/* ptr is the user pointer, so we need to skip the "begin" guard */
+	ptr += GUARD_SIZE_ALIGNED;
+	alloc_admin_add(ptr, aligned_size);
+#endif
+
+	return ptr;
+}
+
+ia_css_ptr mmgr_realloc_attr(
+	ia_css_ptr			vaddr,
+	const size_t			size,
+	const uint16_t			attribute)
+{
+assert(page_table_base_address != (sys_address)-1);
+assert((attribute & MMGR_ATTRIBUTE_UNUSED) == 0);
+/* assert(attribute == MMGR_ATTRIBUTE_DEFAULT); */
+/* Apparently we don't have this one */
+assert(0);
+(void)vaddr;
+(void)size;
+(void)attribute;
+return mmgr_NULL;
+}
+
+ia_css_ptr mmgr_mmap(const void *ptr, const size_t size, uint16_t attribute,
+		void *context)
+{
+	struct hrt_userbuffer_attr *userbuffer_attr = context;
+	return hrt_isp_css_mm_alloc_user_ptr(
+			size, (void *)ptr,
+			userbuffer_attr->pgnr,
+			userbuffer_attr->type,
+			attribute & HRT_BUF_FLAG_CACHED);
+}
+
+void mmgr_clear(
+	ia_css_ptr			vaddr,
+	const size_t			size)
+{
+	mmgr_set(vaddr, (uint8_t)0, size);
+}
+
+void mmgr_set(
+	ia_css_ptr			vaddr,
+	const uint8_t			data,
+	const size_t			size)
+{
+#if SH_CSS_MEMORY_GUARDING
+	assert(mem_guard_valid(vaddr, size));
+#endif
+	hrt_isp_css_mm_set(vaddr, (int)data, size);
+return;
+}
+
+void mmgr_load(
+	const ia_css_ptr		vaddr,
+	void				*data,
+	const size_t			size)
+{
+#if SH_CSS_MEMORY_GUARDING
+	assert(mem_guard_valid(vaddr, size));
+#endif
+	hrt_isp_css_mm_load(vaddr, data, size);
+return;
+}
+
+void mmgr_store(
+	const ia_css_ptr		vaddr,
+	const void				*data,
+	const size_t			size)
+{
+#if SH_CSS_MEMORY_GUARDING
+	assert(mem_guard_valid(vaddr, size));
+#endif
+	hrt_isp_css_mm_store(vaddr, data, size);
+return;
+}
diff --git a/drivers/media/atomisp2/include/hmm/hmm.h b/drivers/media/atomisp2/include/hmm/hmm.h
new file mode 100644
index 0000000..90ced40
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm.h
@@ -0,0 +1,88 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__HMM_H__
+#define	__HMM_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+
+#include "hmm/hmm_bo.h"
+#include "hmm/hmm_pool.h"
+#ifdef CSS_2
+#include "ia_css_types.h"
+#else /* CSS20 */
+#include "sh_css_types.h"
+#endif /* CSS20 */
+
+#define HMM_CACHED true
+#define HMM_UNCACHED false
+
+
+int hmm_pool_register(unsigned int pool_size, enum hmm_pool_type pool_type);
+void hmm_pool_unregister(enum hmm_pool_type pool_type);
+
+int hmm_init(void);
+void hmm_cleanup(void);
+
+ia_css_ptr hmm_alloc(size_t bytes, enum hmm_bo_type type,
+		int from_highmem, void *userptr, bool cached,void *priv);
+void hmm_free(ia_css_ptr ptr);
+int hmm_load(ia_css_ptr virt, void *data, unsigned int bytes);
+int hmm_store(ia_css_ptr virt, const void *data, unsigned int bytes);
+int hmm_set(ia_css_ptr virt, int c, unsigned int bytes);
+int hmm_flush(ia_css_ptr virt, unsigned int bytes);
+int hmm_get_mmu_base_addr(void);
+
+/*
+ * get kernel memory physical address from ISP virtual address.
+ */
+phys_addr_t hmm_virt_to_phys(ia_css_ptr virt);
+
+/*
+ * map ISP memory starts with virt to kernel virtual address
+ * by using vmap. return NULL if failed.
+ *
+ * !! user needs to use vunmap to unmap it manually before calling
+ * hmm_free to free the memory.
+ *
+ * virt must be the start address of ISP memory (return by hmm_alloc),
+ * do not pass any other address.
+ */
+void *hmm_vmap(ia_css_ptr virt);
+
+/*
+ * map ISP memory starts with virt to specific vma.
+ *
+ * used for mmap operation.
+ *
+ * virt must be the start address of ISP memory (return by hmm_alloc),
+ * do not pass any other address.
+ */
+int hmm_mmap(struct vm_area_struct *vma, ia_css_ptr virt);
+
+extern bool dypool_enable;
+
+#endif
diff --git a/drivers/media/atomisp2/include/hmm/hmm_bo.h b/drivers/media/atomisp2/include/hmm/hmm_bo.h
new file mode 100644
index 0000000..fb473bd
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm_bo.h
@@ -0,0 +1,310 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__HMM_BO_H__
+#define	__HMM_BO_H__
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <linux/kref.h>
+#include "hmm_common.h"
+#include "hmm/hmm_vm.h"
+
+#define	check_bo_status_yes_goto(bo, _status, label) \
+	var_not_equal_goto((bo->status & (_status)), (_status), \
+			label, \
+			"HMM buffer status not contain %s.\n", \
+			#_status)
+
+#define	check_bo_status_no_goto(bo, _status, label) \
+	var_equal_goto((bo->status & (_status)), (_status), \
+			label, \
+			"HMM buffer status contains %s.\n", \
+			#_status)
+#define	list_to_hmm_bo(list_ptr)	\
+	list_entry((list_ptr), struct hmm_buffer_object, list)
+
+#define	kref_to_hmm_bo(kref_ptr)	\
+	list_entry((kref_ptr), struct hmm_buffer_object, kref)
+
+#define	check_bo_null_return(bo, exp)	\
+	check_null_return(bo, exp, "NULL hmm buffer object.\n")
+
+#define	check_bo_null_return_void(bo)	\
+	check_null_return_void(bo, "NULL hmm buffer object.\n")
+
+#define	HMM_MAX_ORDER		3
+#define	HMM_MIN_ORDER		0
+
+struct hmm_bo_device;
+
+/*
+ * buffer object type.
+ *
+ *	HMM_BO_PRIVATE:
+ *	pages are allocated by driver itself.
+ *	HMM_BO_SHARE:
+ *	pages are allocated by other component. currently: video driver.
+ *	HMM_BO_USER:
+ *	pages are allocated in user space process.
+ *	HMM_BO_ION:
+ *	pages are allocated through ION.
+ *
+ */
+enum hmm_bo_type {
+	HMM_BO_PRIVATE,
+	HMM_BO_SHARE,
+	HMM_BO_USER,
+	HMM_BO_DMA,
+#ifdef CONFIG_ION
+	HMM_BO_ION,
+#endif
+};
+
+enum hmm_page_type {
+	HMM_PAGE_TYPE_RESERVED,
+	HMM_PAGE_TYPE_DYNAMIC,
+	HMM_PAGE_TYPE_GENERAL,
+};
+
+#define	HMM_BO_VM_ALLOCED	0x1
+#define	HMM_BO_PAGE_ALLOCED	0x2
+#define	HMM_BO_BINDED		0x4
+#define	HMM_BO_MMAPED		0x8
+#define	HMM_BO_ACTIVE		0x1000
+#define	HMM_BO_MEM_TYPE_USER     0x1
+#define	HMM_BO_MEM_TYPE_PFN      0x2
+
+struct hmm_page_object {
+	struct page		*page;
+	enum hmm_page_type	type;
+};
+
+struct hmm_buffer_object {
+	struct hmm_bo_device	*bdev;
+	struct list_head	list;
+	struct kref		kref;
+
+	/* mutex protecting this BO */
+	struct mutex		mutex;
+	enum hmm_bo_type	type;
+	struct hmm_page_object	*page_obj;	/* physical pages */
+	unsigned int		pgnr;	/* page number */
+	int			from_highmem;
+	int			mmap_count;
+	struct hmm_vm_node	*vm_node;
+#ifdef CONFIG_ION
+	struct ion_handle	*ihandle;
+#endif
+	int			status;
+	int         mem_type;
+
+	/*
+	 * release callback for releasing buffer object.
+	 *
+	 * usually set to the release function to release the
+	 * upper level buffer object which has hmm_buffer_object
+	 * embedded in. if the hmm_buffer_object is dynamically
+	 * created by hmm_bo_create, release will set to kfree.
+	 *
+	 */
+	void (*release)(struct hmm_buffer_object *bo);
+};
+
+/*
+ * use this function to initialize pre-allocated hmm_buffer_object.
+ *
+ * the hmm_buffer_object use reference count to manage its life cycle.
+ *
+ * bo->kref is inited to 1.
+ *
+ * use hmm_bo_ref/hmm_bo_unref increase/decrease the reference count,
+ * and hmm_bo_unref will free resource of buffer object (but not the
+ * buffer object itself as it can be both pre-allocated or dynamically
+ * allocated) when reference reaches 0.
+ *
+ * see detailed description of hmm_bo_ref/hmm_bo_unref below.
+ *
+ * as hmm_buffer_object may be used as an embedded object in an upper
+ * level object, a release callback must be provided. if it is
+ * embedded in upper level object, set release call back to release
+ * function of that object. if no upper level object, set release
+ * callback to NULL.
+ *
+ * ex:
+ *	struct hmm_buffer_object bo;
+ *	hmm_bo_init(bdev, &bo, pgnr, NULL);
+ *
+ * or
+ *	struct my_buffer_object {
+ *		struct hmm_buffer_object bo;
+ *		...
+ *	};
+ *
+ *	void my_buffer_release(struct hmm_buffer_object *bo)
+ *	{
+ *		struct my_buffer_object *my_bo =
+ *			container_of(bo, struct my_buffer_object, bo);
+ *
+ *		...	// release resource in my_buffer_object
+ *
+ *		kfree(my_bo);
+ *	}
+ *
+ *	struct my_buffer_object *my_bo =
+ *		kmalloc(sizeof(*my_bo), GFP_KERNEL);
+ *
+ *	hmm_bo_init(bdev, &my_bo->bo, pgnr, my_buffer_release);
+ *	...
+ *
+ *	hmm_bo_unref(&my_bo->bo);
+ */
+int hmm_bo_init(struct hmm_bo_device *bdev,
+		struct hmm_buffer_object *bo,
+		unsigned int pgnr,
+		void (*release)(struct hmm_buffer_object *));
+
+/*
+ * use these functions to dynamically alloc hmm_buffer_object.
+ *
+ * hmm_bo_init will called for that allocated buffer object, and
+ * the release callback is set to kfree.
+ *
+ * ex:
+ *	hmm_buffer_object *bo = hmm_bo_create(bdev, pgnr);
+ *	...
+ *	hmm_bo_unref(bo);
+ */
+struct hmm_buffer_object *hmm_bo_create(struct hmm_bo_device *bdev,
+		int pgnr);
+
+/*
+ * increse buffer object reference.
+ */
+void hmm_bo_ref(struct hmm_buffer_object *bo);
+
+/*
+ * decrese buffer object reference. if reference reaches 0,
+ * release function of the buffer object will be called.
+ *
+ * this call is also used to release hmm_buffer_object or its
+ * upper level object with it embedded in. you need to call
+ * this function when it is no longer used.
+ *
+ * Note:
+ *
+ * user dont need to care about internal resource release of
+ * the buffer object in the release callback, it will be
+ * handled internally.
+ *
+ * this call will only release internal resource of the buffer
+ * object but will not free the buffer object itself, as the
+ * buffer object can be both pre-allocated statically or
+ * dynamically allocated. so user need to deal with the release
+ * of the buffer object itself manually. below example shows
+ * the normal case of using the buffer object.
+ *
+ *	struct hmm_buffer_object *bo = hmm_bo_create(bdev, pgnr);
+ *	......
+ *	hmm_bo_unref(bo);
+ *
+ * or:
+ *
+ *	struct hmm_buffer_object bo;
+ *
+ *	hmm_bo_init(bdev, &bo, pgnr, NULL);
+ *	...
+ *	hmm_bo_unref(&bo);
+ */
+void hmm_bo_unref(struct hmm_buffer_object *bo);
+
+
+/*
+ * put buffer object to unactivated status, meaning put it into
+ * bo->bdev->free_bo_list, but not destroy it.
+ *
+ * this can be used to instead of hmm_bo_destroy if there are
+ * lots of petential hmm_bo_init/hmm_bo_destroy operations with
+ * the same buffer object size. using this with hmm_bo_device_get_bo
+ * can improve performace as lots of memory allocation/free are
+ * avoided..
+ */
+void hmm_bo_unactivate(struct hmm_buffer_object *bo);
+int hmm_bo_activated(struct hmm_buffer_object *bo);
+
+/*
+ * allocate/free virtual address space for the bo.
+ */
+int hmm_bo_alloc_vm(struct hmm_buffer_object *bo);
+void hmm_bo_free_vm(struct hmm_buffer_object *bo);
+int hmm_bo_vm_allocated(struct hmm_buffer_object *bo);
+
+/*
+ * allocate/free physical pages for the bo. will try to alloc mem
+ * from highmem if from_highmem is set, and type indicate that the
+ * pages will be allocated by using video driver (for share buffer)
+ * or by ISP driver itself.
+ */
+int hmm_bo_alloc_pages(struct hmm_buffer_object *bo,
+		enum hmm_bo_type type, int from_highmem,
+		void *userptr, bool cached, void *priv);
+void hmm_bo_free_pages(struct hmm_buffer_object *bo);
+int hmm_bo_page_allocated(struct hmm_buffer_object *bo);
+
+/*
+ * get physical page info of the bo.
+ */
+int hmm_bo_get_page_info(struct hmm_buffer_object *bo,
+		struct hmm_page_object **page_obj, int *pgnr);
+
+/*
+ * bind/unbind the physical pages to a virtual address space.
+ */
+int hmm_bo_bind(struct hmm_buffer_object *bo);
+void hmm_bo_unbind(struct hmm_buffer_object *bo);
+int hmm_bo_binded(struct hmm_buffer_object *bo);
+
+/*
+ * vmap buffer object's pages to contiguous kernel virtual address.
+ * user needs to call vunmap manually to unmap it.
+ */
+void *hmm_bo_vmap(struct hmm_buffer_object *bo);
+
+/*
+ * mmap the bo's physical pages to specific vma.
+ *
+ * vma's address space size must be the same as bo's size,
+ * otherwise it will return -EINVAL.
+ *
+ * vma->vm_flags will be set to (VM_RESERVED | VM_IO).
+ */
+int hmm_bo_mmap(struct vm_area_struct *vma,
+		struct hmm_buffer_object *bo);
+
+extern struct hmm_pool	dynamic_pool;
+extern struct hmm_pool	reserved_pool;
+
+#endif
diff --git a/drivers/media/atomisp2/include/hmm/hmm_bo_dev.h b/drivers/media/atomisp2/include/hmm/hmm_bo_dev.h
new file mode 100644
index 0000000..d57ad1e
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm_bo_dev.h
@@ -0,0 +1,124 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__HMM_BO_DEV_H__
+#define	__HMM_BO_DEV_H__
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include "mmu/isp_mmu.h"
+#include "hmm/hmm_common.h"
+#include "hmm/hmm_vm.h"
+#ifdef CSS_2
+#include "ia_css_types.h"
+#else /* CSS20 */
+#include "sh_css_types.h"
+#endif /* CSS20 */
+
+#define	check_bodev_null_return(bdev, exp)	\
+		check_null_return(bdev, exp, \
+			"NULL hmm_bo_device.\n")
+
+#define	check_bodev_null_return_void(bdev)	\
+		check_null_return_void(bdev, \
+			"NULL hmm_bo_device.\n")
+
+#define	HMM_BO_DEVICE_INITED	0x1
+
+struct hmm_buffer_object;
+
+struct hmm_bo_device {
+	/* isp_mmu provides lock itself */
+	struct isp_mmu		mmu;
+
+	/* hmm_vm provides lock itself */
+	struct hmm_vm		vaddr_space;
+
+	struct list_head	free_bo_list;
+	struct list_head	active_bo_list;
+
+	/* list lock is used to protect both of the buffer object lists */
+	struct spinlock		list_lock;
+#ifdef CONFIG_ION
+	struct ion_client	*iclient;
+#endif
+	int			flag;
+};
+
+int hmm_bo_device_init(struct hmm_bo_device *bdev,
+		       struct isp_mmu_client *mmu_driver,
+		       unsigned int vaddr_start, unsigned int size);
+
+/*
+ * clean up all hmm_bo_device related things.
+ */
+void hmm_bo_device_exit(struct hmm_bo_device *bdev);
+
+/*
+ * whether the bo device is inited or not.
+ */
+int hmm_bo_device_inited(struct hmm_bo_device *bdev);
+
+/*
+ * find the buffer object with virtual address vaddr.
+ * return NULL if no such buffer object found.
+ */
+struct hmm_buffer_object *hmm_bo_device_search_start(
+		struct hmm_bo_device *bdev, ia_css_ptr vaddr);
+
+/*
+ * find the buffer object with virtual address vaddr.
+ * return NULL if no such buffer object found.
+ */
+struct hmm_buffer_object *hmm_bo_device_search_in_range(
+		struct hmm_bo_device *bdev, ia_css_ptr vaddr);
+
+/*
+ * find a buffer object with pgnr pages from free_bo_list and
+ * activate it (remove from free_bo_list and add to
+ * active_bo_list)
+ *
+ * return NULL if no such buffer object found.
+ */
+struct hmm_buffer_object *hmm_bo_device_get_bo(
+		struct hmm_bo_device *bdev, unsigned int pgnr);
+
+/*
+ * destroy all buffer objects in the free_bo_list.
+ */
+void hmm_bo_device_destroy_free_bo_list(struct hmm_bo_device *bdev);
+/*
+ * destroy buffer object with start virtual address vaddr.
+ */
+void hmm_bo_device_destroy_free_bo_addr(struct hmm_bo_device *bdev,
+		ia_css_ptr vaddr);
+/*
+ * destroy all buffer objects with pgnr pages.
+ */
+void hmm_bo_device_destroy_free_bo_size(struct hmm_bo_device *bdev,
+		unsigned int pgnr);
+
+#endif
diff --git a/drivers/media/atomisp2/include/hmm/hmm_common.h b/drivers/media/atomisp2/include/hmm/hmm_common.h
new file mode 100644
index 0000000..c35f57f
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm_common.h
@@ -0,0 +1,81 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__HMM_BO_COMMON_H__
+#define	__HMM_BO_COMMON_H__
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-common.h>
+
+#define	HMM_BO_NAME	"HMM"
+
+/*
+ * some common use micros
+ */
+#define	var_equal_return(var1, var2, exp, fmt, arg ...)	\
+	do { \
+		if ((var1) == (var2)) { \
+			v4l2_err(&atomisp_dev, \
+			fmt, ## arg); \
+			return exp;\
+		} \
+	} while (0)
+
+#define	var_equal_return_void(var1, var2, fmt, arg ...)	\
+	do { \
+		if ((var1) == (var2)) { \
+			v4l2_err(&atomisp_dev, \
+			fmt, ## arg); \
+			return;\
+		} \
+	} while (0)
+
+#define	var_equal_goto(var1, var2, label, fmt, arg ...)	\
+	do { \
+		if ((var1) == (var2)) { \
+			v4l2_err(&atomisp_dev, \
+			fmt, ## arg); \
+			goto label;\
+		} \
+	} while (0)
+
+#define	var_not_equal_goto(var1, var2, label, fmt, arg ...)	\
+	do { \
+		if ((var1) != (var2)) { \
+			v4l2_err(&atomisp_dev, \
+			fmt, ## arg); \
+			goto label;\
+		} \
+	} while (0)
+
+#define	check_null_return(ptr, exp, fmt, arg ...)	\
+		var_equal_return(ptr, NULL, exp, fmt, ## arg)
+
+#define	check_null_return_void(ptr, fmt, arg ...)	\
+		var_equal_return_void(ptr, NULL, fmt, ## arg)
+
+
+
+#endif
diff --git a/drivers/media/atomisp2/include/hmm/hmm_pool.h b/drivers/media/atomisp2/include/hmm/hmm_pool.h
new file mode 100644
index 0000000..3d278be
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm_pool.h
@@ -0,0 +1,119 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef __HMM_POOL_H__
+#define __HMM_POOL_H__
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <linux/kref.h>
+#include "hmm_common.h"
+#include "hmm/hmm_vm.h"
+#include "hmm/hmm_bo.h"
+
+#define ALLOC_PAGE_FAIL_NUM		5
+
+enum hmm_pool_type {
+	HMM_POOL_TYPE_RESERVED,
+	HMM_POOL_TYPE_DYNAMIC,
+};
+
+/**
+ * struct hmm_pool_ops  -  memory pool callbacks.
+ *
+ * @pool_init:		   initialize the memory pool.
+ * @pool_exit:		   uninitialize the memory pool.
+ * @pool_alloc_pages:	   allocate pages from memory pool.
+ * @pool_free_pages:	   free pages to memory pool.
+ * @pool_inited:	   check whether memory pool is initialized.
+ */
+struct hmm_pool_ops {
+	int (*pool_init)(void **pool, unsigned int pool_size);
+	void (*pool_exit)(void **pool);
+	unsigned int (*pool_alloc_pages)(void *pool,
+					struct hmm_page_object *page_obj,
+					unsigned int size, bool cached);
+	void (*pool_free_pages)(void *pool,
+				struct hmm_page_object *page_obj);
+	int (*pool_inited)(void *pool);
+};
+
+struct hmm_pool {
+	struct hmm_pool_ops	*pops;
+
+	void			*pool_info;
+};
+
+/**
+ * struct hmm_reserved_pool_info  - represents reserved pool private data.
+ * @pages:			    a array that store physical pages.
+ *				    The array is as reserved memory pool.
+ * @index:			    to indicate the first blank page number
+ *				    in reserved memory pool(pages array).
+ * @pgnr:			    the valid page amount in reserved memory
+ *				    pool.
+ * @list_lock:			    list lock is used to protect the operation
+ *				    to reserved memory pool.
+ * @flag:			    reserved memory pool state flag.
+ */
+struct hmm_reserved_pool_info {
+	struct page		**pages;
+
+	unsigned int		index;
+	unsigned int		pgnr;
+	struct spinlock		list_lock;
+	bool			initialized;
+};
+
+/**
+ * struct hmm_dynamic_pool_info  -  represents dynamic pool private data.
+ * @pages_list:			    a list that store physical pages.
+ *				    The pages list is as dynamic memory pool.
+ * @list_lock:			    list lock is used to protect the operation
+ *				    to dynamic memory pool.
+ * @flag:			    dynamic memory pool state flag.
+ * @pgptr_cache:		    struct kmem_cache, manages a cache.
+ */
+struct hmm_dynamic_pool_info {
+	struct list_head	pages_list;
+
+	/* list lock is used to protect the free pages block lists */
+	struct spinlock		list_lock;
+
+#ifdef USE_KMEM_CACHE
+	struct kmem_cache	*pgptr_cache;
+#endif
+	bool			initialized;
+};
+
+struct hmm_page {
+	struct page		*page;
+	struct list_head	list;
+};
+
+extern struct hmm_pool_ops	reserved_pops;
+extern struct hmm_pool_ops	dynamic_pops;
+
+#endif
diff --git a/drivers/media/atomisp2/include/hmm/hmm_vm.h b/drivers/media/atomisp2/include/hmm/hmm_vm.h
new file mode 100644
index 0000000..07d4066
--- /dev/null
+++ b/drivers/media/atomisp2/include/hmm/hmm_vm.h
@@ -0,0 +1,68 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__HMM_VM_H__
+#define	__HMM_VM_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/list.h>
+
+struct hmm_vm {
+	unsigned int start;
+	unsigned int pgnr;
+	unsigned int size;
+	struct list_head vm_node_list;
+	spinlock_t lock;
+	struct kmem_cache *cache;
+};
+
+struct hmm_vm_node {
+	struct list_head list;
+	unsigned int start;
+	unsigned int pgnr;
+	unsigned int size;
+	struct hmm_vm *vm;
+};
+#define	ISP_VM_START	0x0
+#define	ISP_VM_SIZE	(0x7FFFFFFF)	/* 2G address space */
+#define	ISP_PTR_NULL	NULL
+
+int hmm_vm_init(struct hmm_vm *vm, unsigned int start,
+		unsigned int size);
+
+void hmm_vm_clean(struct hmm_vm *vm);
+
+struct hmm_vm_node *hmm_vm_alloc_node(struct hmm_vm *vm,
+		unsigned int pgnr);
+
+void hmm_vm_free_node(struct hmm_vm_node *node);
+
+struct hmm_vm_node *hmm_vm_find_node_start(struct hmm_vm *vm,
+		unsigned int addr);
+
+struct hmm_vm_node *hmm_vm_find_node_in_range(struct hmm_vm *vm,
+		unsigned int addr);
+
+#endif
diff --git a/drivers/media/atomisp2/include/mmu/isp_mmu.h b/drivers/media/atomisp2/include/mmu/isp_mmu.h
new file mode 100644
index 0000000..4d3cb25
--- /dev/null
+++ b/drivers/media/atomisp2/include/mmu/isp_mmu.h
@@ -0,0 +1,178 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * ISP MMU driver for classic two-level page tables
+ */
+#ifndef	__ISP_MMU_H__
+#define	__ISP_MMU_H__
+
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+/*
+ * do not change these values, the page size for ISP must be the
+ * same as kernel's page size.
+ */
+#define	ISP_PAGE_OFFSET		12
+#define	ISP_PAGE_SIZE		(1UL << ISP_PAGE_OFFSET)
+#define	ISP_PAGE_MASK		(~(phys_addr_t)(ISP_PAGE_SIZE - 1))
+#define	ISP_PHYSICAL_PAGE_MASK	(~(phys_addr_t)((1ULL << ISP_PAGE_OFFSET) - 1))
+
+#define	ISP_L1PT_OFFSET		22
+#define	ISP_L1PT_MASK		(~((1U << ISP_L1PT_OFFSET) - 1))
+
+#define	ISP_L2PT_OFFSET		12
+#define	ISP_L2PT_MASK		(~(ISP_L1PT_MASK|(~(ISP_PAGE_MASK))))
+
+#define	ISP_L1PT_PTES		1024
+#define	ISP_L2PT_PTES		1024
+
+#define	ISP_PTR_TO_L1_IDX(x)	((((x) & ISP_L1PT_MASK)) \
+					>> ISP_L1PT_OFFSET)
+
+#define	ISP_PTR_TO_L2_IDX(x)	((((x) & ISP_L2PT_MASK)) \
+					>> ISP_L2PT_OFFSET)
+
+#define	ISP_PAGE_ALIGN(x)	(((x) + (ISP_PAGE_SIZE-1)) \
+					& ISP_PAGE_MASK)
+
+#define	ISP_PT_TO_VIRT(l1_idx, l2_idx, offset) do {\
+		((l1_idx) << ISP_L1PT_OFFSET) | \
+		((l2_idx) << ISP_L2PT_OFFSET) | \
+		(offset)\
+} while (0)
+
+#define	pgnr_to_size(pgnr)	((pgnr) << ISP_PAGE_OFFSET)
+#define	size_to_pgnr_ceil(size)	(((size) + (1 << ISP_PAGE_OFFSET) - 1)\
+						>> ISP_PAGE_OFFSET)
+#define	size_to_pgnr_bottom(size)	((size) >> ISP_PAGE_OFFSET)
+
+struct isp_mmu;
+
+struct isp_mmu_client {
+	/*
+	 * const value
+	 *
+	 * @name:
+	 *      driver name
+	 * @pte_valid_mask:
+	 *      should be 1 bit valid data, meaning the value should
+	 *      be power of 2.
+	 */
+	char *name;
+	unsigned int pte_valid_mask;
+	unsigned int null_pte;
+
+	/*
+	 * set page directory base address (physical address).
+	 *
+	 * must be provided.
+	 */
+	int (*set_pd_base) (struct isp_mmu *mmu,
+			phys_addr_t pd_base);
+	unsigned int (*get_pd_base) (struct isp_mmu *mmu,
+			phys_addr_t pd_base);
+	/*
+	 * callback to flush tlb.
+	 *
+	 * tlb_flush_range will at least flush TLBs containing
+	 * address mapping from addr to addr + size.
+	 *
+	 * tlb_flush_all will flush all TLBs.
+	 *
+	 * tlb_flush_all is must be provided. if tlb_flush_range is
+	 * not valid, it will set to tlb_flush_all by default.
+	 */
+	void (*tlb_flush_range) (struct isp_mmu *mmu,
+				 unsigned int addr, unsigned int size);
+	void (*tlb_flush_all) (struct isp_mmu *mmu);
+	unsigned int (*phys_to_pte) (struct isp_mmu *mmu,
+				     phys_addr_t phys);
+	phys_addr_t (*pte_to_phys) (struct isp_mmu *mmu,
+				    unsigned int pte);
+
+};
+
+struct isp_mmu {
+	struct isp_mmu_client *driver;
+	unsigned int l1_pte;
+	phys_addr_t base_address;
+
+	struct mutex pt_mutex;
+#ifdef USE_KMEM_CACHE
+	struct kmem_cache *tbl_cache;
+#endif
+};
+
+/* flags for PDE and PTE */
+#define	ISP_PTE_VALID_MASK(mmu)	\
+	((mmu)->driver->pte_valid_mask)
+
+#define	ISP_PTE_VALID(mmu, pte)	\
+	((pte) & ISP_PTE_VALID_MASK(mmu))
+
+#define	NULL_PAGE	((phys_addr_t)(-1) & ISP_PAGE_MASK)
+#define	PAGE_VALID(page)	((page) != NULL_PAGE)
+
+/*
+ * init mmu with specific mmu driver.
+ */
+int isp_mmu_init(struct isp_mmu *mmu, struct isp_mmu_client *driver);
+/*
+ * cleanup all mmu related things.
+ */
+void isp_mmu_exit(struct isp_mmu *mmu);
+
+/*
+ * setup/remove address mapping for pgnr continous physical pages
+ * and isp_virt.
+ *
+ * map/unmap is mutex lock protected, and caller does not have
+ * to do lock/unlock operation.
+ *
+ * map/unmap will not flush tlb, and caller needs to deal with
+ * this itself.
+ */
+int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
+		phys_addr_t phys, unsigned int pgnr);
+
+void isp_mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
+		   unsigned int pgnr);
+
+static inline void isp_mmu_flush_tlb_all(struct isp_mmu *mmu)
+{
+	if (mmu->driver && mmu->driver->tlb_flush_all)
+		mmu->driver->tlb_flush_all(mmu);
+}
+
+#define isp_mmu_flush_tlb isp_mmu_flush_tlb_all
+
+static inline void isp_mmu_flush_tlb_range(struct isp_mmu *mmu,
+		unsigned int start, unsigned int size)
+{
+	if (mmu->driver && mmu->driver->tlb_flush_range)
+		mmu->driver->tlb_flush_range(mmu, start, size);
+}
+
+#endif /* ISP_MMU_H_ */
diff --git a/drivers/media/atomisp2/include/mmu/sh_mmu.h b/drivers/media/atomisp2/include/mmu/sh_mmu.h
new file mode 100644
index 0000000..06041e9
--- /dev/null
+++ b/drivers/media/atomisp2/include/mmu/sh_mmu.h
@@ -0,0 +1,76 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef	SH_MMU_H_
+#define	SH_MMU_H_
+
+
+#include <sh_css.h>
+
+#include "mmu/isp_mmu.h"
+
+
+/*
+ * include SH header file here
+ */
+
+/*
+ * set page directory base address (physical address).
+ *
+ * must be provided.
+ */
+static int sh_set_pd_base(struct isp_mmu *mmu,
+		unsigned int phys)
+{
+	sh_css_mmu_set_page_table_base_address((void *)phys);
+	return 0;
+}
+
+/*
+ * callback to flush tlb.
+ *
+ * tlb_flush_range will at least flush TLBs containing
+ * address mapping from addr to addr + size.
+ *
+ * tlb_flush_all will flush all TLBs.
+ *
+ * tlb_flush_all is must be provided. if tlb_flush_range is
+ * not valid, it will set to tlb_flush_all by default.
+ */
+static void sh_tlb_flush(struct isp_mmu *mmu)
+{
+	sh_css_mmu_invalidate_cache();
+}
+
+static struct isp_mmu_driver sh_mmu_driver = {
+	.name = "Silicon Hive ISP3000 MMU",
+	.pte_valid_mask = 0x1,
+	.set_pd_base = sh_set_pd_base,
+	.tlb_flush_all = sh_tlb_flush,
+};
+
+#define	ISP_VM_START	0x0
+#define	ISP_VM_SIZE	(1 << 30)	/* 1G address space */
+#define	ISP_PTR_NULL	NULL
+
+#endif /* SH_MMU_H_ */
+
diff --git a/drivers/media/atomisp2/include/mmu/sh_mmu_mfld.h b/drivers/media/atomisp2/include/mmu/sh_mmu_mfld.h
new file mode 100644
index 0000000..359deb2
--- /dev/null
+++ b/drivers/media/atomisp2/include/mmu/sh_mmu_mfld.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__SH_MMU_MFLD_H__
+#define	__SH_MMU_MFLD_H__
+
+extern struct isp_mmu_client sh_mmu_mfld;
+#endif
diff --git a/drivers/media/atomisp2/include/mmu/sh_mmu_mrfld.h b/drivers/media/atomisp2/include/mmu/sh_mmu_mrfld.h
new file mode 100644
index 0000000..b9bad9f
--- /dev/null
+++ b/drivers/media/atomisp2/include/mmu/sh_mmu_mrfld.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Merrifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef	__SH_MMU_MRFLD_H__
+#define	__SH_MMU_MRFLD_H__
+
+extern struct isp_mmu_client sh_mmu_mrfld;
+#endif
diff --git a/drivers/media/atomisp2/mmu/isp_mmu.c b/drivers/media/atomisp2/mmu/isp_mmu.c
new file mode 100644
index 0000000..75361eb
--- /dev/null
+++ b/drivers/media/atomisp2/mmu/isp_mmu.c
@@ -0,0 +1,588 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+/*
+ * ISP MMU management wrap code
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/gfp.h>
+#include <linux/mm.h>		/* for GFP_ATOMIC */
+#include <linux/slab.h>		/* for kmalloc */
+#include <linux/list.h>
+#include <linux/io.h>
+#include <asm/cacheflush.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+
+#include "mmu/isp_mmu.h"
+#include "atomisp_internal.h"
+
+static void free_mmu_map(struct isp_mmu *mmu, unsigned int start_isp_virt,
+				unsigned int end_isp_virt);
+
+static unsigned int atomisp_get_pte(phys_addr_t pt, unsigned int idx)
+{
+	unsigned int *pt_virt = phys_to_virt(pt);
+		return *(pt_virt + idx);
+}
+
+static void atomisp_set_pte(phys_addr_t pt,
+			    unsigned int idx, unsigned int pte)
+{
+	unsigned int *pt_virt = phys_to_virt(pt);
+		*(pt_virt + idx) = pte;
+}
+
+static void *isp_pt_phys_to_virt(phys_addr_t phys)
+{
+	return phys_to_virt(phys);
+}
+
+static phys_addr_t isp_pte_to_pgaddr(struct isp_mmu *mmu,
+				     unsigned int pte)
+{
+	return mmu->driver->pte_to_phys(mmu, pte);
+}
+
+static unsigned int isp_pgaddr_to_pte_valid(struct isp_mmu *mmu,
+					    phys_addr_t phys)
+{
+	unsigned int pte = mmu->driver->phys_to_pte(mmu, phys);
+	return (unsigned int) (pte | ISP_PTE_VALID_MASK(mmu));
+}
+
+/*
+ * allocate a uncacheable page table.
+ * return physical address.
+ */
+static phys_addr_t alloc_page_table(struct isp_mmu *mmu)
+{
+	int i;
+	phys_addr_t page;
+	gfp_t gfp = GFP_KERNEL;
+
+#ifdef CONFIG_64BIT
+	gfp |= GFP_DMA32;
+#endif
+
+	/*page table lock may needed here*/
+#ifdef USE_KMEM_CACHE
+	void *virt = kmem_cache_zalloc(mmu->tbl_cache, GFP_KERNEL);
+#else
+	void *virt = (void *)__get_free_page(gfp);
+#endif
+	if (!virt)
+		return (phys_addr_t)NULL_PAGE;
+
+	/*
+	 * we need a uncacheable page table.
+	 */
+#ifdef	CONFIG_X86
+	set_memory_uc((unsigned long)virt, 1);
+#endif
+
+	page = virt_to_phys(virt);
+
+	for (i = 0; i < 1024; i++) {
+		/* NEED CHECK */
+		atomisp_set_pte(page, i, mmu->driver->null_pte);
+	}
+
+	return page;
+}
+
+static void free_page_table(struct isp_mmu *mmu, phys_addr_t page)
+{
+	void *virt;
+	page &= ISP_PAGE_MASK;
+	/*
+	 * reset the page to write back before free
+	 */
+	virt = phys_to_virt(page);
+
+#ifdef	CONFIG_X86
+	set_memory_wb((unsigned long)virt, 1);
+#endif
+
+#ifdef USE_KMEM_CACHE
+	kmem_cache_free(mmu->tbl_cache, virt);
+#else
+	free_page((unsigned long)virt);
+#endif
+}
+
+static void mmu_remap_error(struct isp_mmu *mmu,
+			    phys_addr_t l1_pt, unsigned int l1_idx,
+			    phys_addr_t l2_pt, unsigned int l2_idx,
+			    unsigned int isp_virt, phys_addr_t old_phys,
+			    phys_addr_t new_phys)
+{
+	v4l2_err(&atomisp_dev, "address remap:\n\n"
+			"\tL1 PT: virt = %p, phys = 0x%llx, "
+		     "idx = %d\n"
+			"\tL2 PT: virt = %p, phys = 0x%llx, "
+		     "idx = %d\n"
+		     "\told: isp_virt = 0x%x, phys = 0x%llx\n"
+		     "\tnew: isp_virt = 0x%x, phys = 0x%llx\n",
+		     isp_pt_phys_to_virt(l1_pt),
+		     (u64)l1_pt, l1_idx,
+		     isp_pt_phys_to_virt(l2_pt),
+		     (u64)l2_pt, l2_idx, isp_virt,
+		     (u64)old_phys, isp_virt,
+		     (u64)new_phys);
+}
+
+static void mmu_unmap_l2_pte_error(struct isp_mmu *mmu,
+				   phys_addr_t l1_pt, unsigned int l1_idx,
+				   phys_addr_t l2_pt, unsigned int l2_idx,
+				   unsigned int isp_virt, unsigned int pte)
+{
+	v4l2_err(&atomisp_dev, "unmap unvalid L2 pte:\n\n"
+			"\tL1 PT: virt = %p, phys = 0x%llx, "
+		     "idx = %d\n"
+			"\tL2 PT: virt = %p, phys = 0x%llx, "
+		     "idx = %d\n"
+		     "\tisp_virt = 0x%x, pte(page phys) = 0x%x\n",
+		     isp_pt_phys_to_virt(l1_pt),
+		     (u64)l1_pt, l1_idx,
+		     isp_pt_phys_to_virt(l2_pt),
+		     (u64)l2_pt, l2_idx, isp_virt,
+		     pte);
+}
+
+static void mmu_unmap_l1_pte_error(struct isp_mmu *mmu,
+				   phys_addr_t l1_pt, unsigned int l1_idx,
+				   unsigned int isp_virt, unsigned int pte)
+{
+	v4l2_err(&atomisp_dev, "unmap unvalid L1 pte (L2 PT):\n\n"
+			"\tL1 PT: virt = %p, phys = 0x%llx, "
+		     "idx = %d\n"
+		     "\tisp_virt = 0x%x, l1_pte(L2 PT) = 0x%x\n",
+		     isp_pt_phys_to_virt(l1_pt),
+		     (u64)l1_pt, l1_idx, (unsigned int)isp_virt,
+		     pte);
+}
+
+static void mmu_unmap_l1_pt_error(struct isp_mmu *mmu, unsigned int pte)
+{
+	v4l2_err(&atomisp_dev, "unmap unvalid L1PT:\n\n"
+		     "L1PT = 0x%x\n", (unsigned int)pte);
+}
+
+/*
+ * Update L2 page table according to isp virtual address and page physical
+ * address
+ */
+static int mmu_l2_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
+		      unsigned int l1_idx, phys_addr_t l2_pt,
+		      unsigned int start, unsigned int end, phys_addr_t phys)
+{
+	unsigned int ptr;
+	unsigned int idx;
+	unsigned int pte;
+
+	l2_pt &= ISP_PAGE_MASK;
+
+	start = start & ISP_PAGE_MASK;
+	end = ISP_PAGE_ALIGN(end);
+	phys &= ISP_PHYSICAL_PAGE_MASK;
+
+	ptr = start;
+	do {
+		idx = ISP_PTR_TO_L2_IDX(ptr);
+
+		pte = atomisp_get_pte(l2_pt, idx);
+
+		if (ISP_PTE_VALID(mmu, pte)) {
+			mmu_remap_error(mmu, l1_pt, l1_idx,
+					  l2_pt, idx, ptr, pte, phys);
+
+			/* free all mapped pages */
+			free_mmu_map(mmu, start, ptr);
+
+			return -EINVAL;
+		}
+
+		pte = isp_pgaddr_to_pte_valid(mmu, phys);
+
+		atomisp_set_pte(l2_pt, idx, pte);
+		ptr += (1U << ISP_L2PT_OFFSET);
+		phys += (1U << ISP_L2PT_OFFSET);
+	} while (ptr < end && idx < ISP_L2PT_PTES - 1);
+
+	return 0;
+}
+
+/*
+ * Update L1 page table according to isp virtual address and page physical
+ * address
+ */
+static int mmu_l1_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
+		      unsigned int start, unsigned int end,
+		      phys_addr_t phys)
+{
+	phys_addr_t l2_pt;
+	unsigned int ptr, l1_aligned;
+	unsigned int idx;
+	unsigned int l2_pte;
+	int ret;
+
+	l1_pt &= ISP_PAGE_MASK;
+
+	start = start & ISP_PAGE_MASK;
+	end = ISP_PAGE_ALIGN(end);
+
+	ptr = start;
+	do {
+		idx = ISP_PTR_TO_L1_IDX(ptr);
+
+		l2_pte = atomisp_get_pte(l1_pt, idx);
+
+		if (!ISP_PTE_VALID(mmu, l2_pte)) {
+			l2_pt = alloc_page_table(mmu);
+			if (l2_pt == NULL_PAGE) {
+				v4l2_err(&atomisp_dev,
+					     "alloc page table fail.\n");
+
+				/* free all mapped pages */
+				free_mmu_map(mmu, start, ptr);
+
+				return -ENOMEM;
+			}
+
+			l2_pte = isp_pgaddr_to_pte_valid(mmu, l2_pt);
+
+			atomisp_set_pte(l1_pt, idx, l2_pte);
+		}
+
+		l2_pt = isp_pte_to_pgaddr(mmu, l2_pte);
+
+		l1_aligned = (ptr & ISP_PAGE_MASK) + (1U << ISP_L1PT_OFFSET);
+
+		if (l1_aligned < end) {
+			ret = mmu_l2_map(mmu, l1_pt, idx,
+					   l2_pt, ptr, l1_aligned, phys);
+			phys += (l1_aligned - ptr);
+			ptr = l1_aligned;
+		} else {
+			ret = mmu_l2_map(mmu, l1_pt, idx,
+					   l2_pt, ptr, end, phys);
+			phys += (end - ptr);
+			ptr = end;
+		}
+
+		if (ret) {
+			v4l2_err(&atomisp_dev,
+				    "setup mapping in L2PT fail.\n");
+
+			/* free all mapped pages */
+			free_mmu_map(mmu, start, ptr);
+
+			return -EINVAL;
+		}
+	} while (ptr < end && idx < ISP_L1PT_PTES - 1);
+
+	return 0;
+}
+
+/*
+ * Update page table according to isp virtual address and page physical
+ * address
+ */
+static int mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
+		   phys_addr_t phys, unsigned int pgnr)
+{
+	unsigned int start, end;
+	phys_addr_t l1_pt;
+	int ret;
+
+	mutex_lock(&mmu->pt_mutex);
+	if (!ISP_PTE_VALID(mmu, mmu->l1_pte)) {
+		/*
+		 * allocate 1 new page for L1 page table
+		 */
+		l1_pt = alloc_page_table(mmu);
+		if (l1_pt == NULL_PAGE) {
+			v4l2_err(&atomisp_dev,
+				    "alloc page table fail.\n");
+			return -ENOMEM;
+		}
+
+		/*
+		 * setup L1 page table physical addr to MMU
+		 */
+		ret = mmu->driver->set_pd_base(mmu, l1_pt);
+		if (ret) {
+			v4l2_err(&atomisp_dev,
+				     "set page directory base address "
+				     "fail.\n");
+			return ret;
+		}
+		mmu->base_address = l1_pt;
+		mmu->l1_pte = isp_pgaddr_to_pte_valid(mmu, l1_pt);
+	}
+
+	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
+
+	start = (isp_virt) & ISP_PAGE_MASK;
+	end = start + (pgnr << ISP_PAGE_OFFSET);
+
+	ret = mmu_l1_map(mmu, l1_pt, start, end, phys);
+
+	if (ret)
+		v4l2_err(&atomisp_dev,
+			    "setup mapping in L1PT fail.\n");
+
+	mutex_unlock(&mmu->pt_mutex);
+	return ret;
+}
+
+/*
+ * Free L2 page table according to isp virtual address and page physical
+ * address
+ */
+static void mmu_l2_unmap(struct isp_mmu *mmu, phys_addr_t l1_pt,
+			   unsigned int l1_idx, phys_addr_t l2_pt,
+			   unsigned int start, unsigned int end)
+{
+
+	unsigned int ptr;
+	unsigned int idx;
+	unsigned int pte;
+
+	l2_pt &= ISP_PAGE_MASK;
+
+	start = start & ISP_PAGE_MASK;
+	end = ISP_PAGE_ALIGN(end);
+
+	ptr = start;
+	do {
+		idx = ISP_PTR_TO_L2_IDX(ptr);
+
+		pte = atomisp_get_pte(l2_pt, idx);
+
+		if (!ISP_PTE_VALID(mmu, pte))
+			mmu_unmap_l2_pte_error(mmu, l1_pt, l1_idx,
+						 l2_pt, idx, ptr, pte);
+
+		atomisp_set_pte(l2_pt, idx, mmu->driver->null_pte);
+
+		ptr += (1U << ISP_L2PT_OFFSET);
+	} while (ptr < end && idx < ISP_L2PT_PTES - 1);
+}
+
+/*
+ * Free L1 page table according to isp virtual address and page physical
+ * address
+ */
+static void mmu_l1_unmap(struct isp_mmu *mmu, phys_addr_t l1_pt,
+			   unsigned int start, unsigned int end)
+{
+	phys_addr_t l2_pt;
+	unsigned int ptr, l1_aligned;
+	unsigned int idx;
+	unsigned int l2_pte;
+
+	l1_pt &= ISP_PAGE_MASK;
+
+	start = start & ISP_PAGE_MASK;
+	end = ISP_PAGE_ALIGN(end);
+
+	ptr = start;
+	do {
+		idx = ISP_PTR_TO_L1_IDX(ptr);
+
+		l2_pte = atomisp_get_pte(l1_pt, idx);
+
+		if (!ISP_PTE_VALID(mmu, l2_pte)) {
+			mmu_unmap_l1_pte_error(mmu, l1_pt, idx, ptr, l2_pte);
+			continue;
+		}
+
+		l2_pt = isp_pte_to_pgaddr(mmu, l2_pte);
+
+		l1_aligned = (ptr & ISP_PAGE_MASK) + (1U << ISP_L1PT_OFFSET);
+
+		if (l1_aligned < end) {
+			mmu_l2_unmap(mmu, l1_pt, idx, l2_pt, ptr, l1_aligned);
+			ptr = l1_aligned;
+		} else {
+			mmu_l2_unmap(mmu, l1_pt, idx, l2_pt, ptr, end);
+			ptr = end;
+		}
+		/*
+		 * use the same L2 page next time, so we dont
+		 * need to invalidate and free this PT.
+		 */
+		/*      atomisp_set_pte(l1_pt, idx, NULL_PTE); */
+	} while (ptr < end && idx < ISP_L1PT_PTES - 1);
+}
+
+/*
+ * Free page table according to isp virtual address and page physical
+ * address
+ */
+static void mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
+			unsigned int pgnr)
+{
+	unsigned int start, end;
+	phys_addr_t l1_pt;
+
+	mutex_lock(&mmu->pt_mutex);
+	if (!ISP_PTE_VALID(mmu, mmu->l1_pte)) {
+		mmu_unmap_l1_pt_error(mmu, mmu->l1_pte);
+		mutex_unlock(&mmu->pt_mutex);
+		return;
+	}
+
+	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
+
+	start = (isp_virt) & ISP_PAGE_MASK;
+	end = start + (pgnr << ISP_PAGE_OFFSET);
+
+	mmu_l1_unmap(mmu, l1_pt, start, end);
+	mutex_unlock(&mmu->pt_mutex);
+}
+
+/*
+ * Free page tables according to isp start virtual address and end virtual
+ * address.
+ */
+static void free_mmu_map(struct isp_mmu *mmu, unsigned int start_isp_virt,
+				unsigned int end_isp_virt)
+{
+	unsigned int pgnr;
+	unsigned int start, end;
+
+	start = (start_isp_virt) & ISP_PAGE_MASK;
+	end = (end_isp_virt) & ISP_PAGE_MASK;
+	pgnr = (end - start) >> ISP_PAGE_OFFSET;
+	mmu_unmap(mmu, start, pgnr);
+}
+
+int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
+		phys_addr_t phys, unsigned int pgnr)
+{
+	return mmu_map(mmu, isp_virt, phys, pgnr);
+}
+
+void isp_mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
+		   unsigned int pgnr)
+{
+	mmu_unmap(mmu, isp_virt, pgnr);
+}
+
+static void isp_mmu_flush_tlb_range_default(struct isp_mmu *mmu,
+					      unsigned int start,
+					      unsigned int size)
+{
+	isp_mmu_flush_tlb(mmu);
+}
+
+/*MMU init for internal structure*/
+int isp_mmu_init(struct isp_mmu *mmu, struct isp_mmu_client *driver)
+{
+	if (!mmu)		/* error */
+		return -EINVAL;
+	if (!driver)		/* error */
+		return -EINVAL;
+
+	if (!driver->name)
+		v4l2_warn(&atomisp_dev,
+			    "NULL name for MMU driver...\n");
+
+	mmu->driver = driver;
+
+	if (!driver->set_pd_base ||
+		!driver->get_pd_base || !driver->tlb_flush_all) {
+		v4l2_err(&atomisp_dev,
+			    "set_pd_base or tlb_flush_all operation "
+			     "not provided.\n");
+		return -EINVAL;
+	}
+
+	if (!driver->tlb_flush_range)
+		driver->tlb_flush_range = isp_mmu_flush_tlb_range_default;
+
+	if (!driver->pte_valid_mask) {
+		v4l2_err(&atomisp_dev,
+			 "PTE_MASK is missing from mmu driver\n");
+		return -EINVAL;
+	}
+
+	mmu->l1_pte = driver->null_pte;
+
+	mutex_init(&mmu->pt_mutex);
+#ifndef CSS_2
+	isp_mmu_flush_tlb(mmu);
+#endif
+
+#ifdef USE_KMEM_CACHE
+	mmu->tbl_cache = kmem_cache_create("iopte_cache", ISP_PAGE_SIZE,
+						//ISP_L1PT_PTES, SLAB_HWCACHE_ALIGN,
+					   ISP_PAGE_SIZE, SLAB_HWCACHE_ALIGN,
+					   NULL);
+	if (!mmu->tbl_cache)
+		return -ENOMEM;
+#endif
+
+	return 0;
+}
+
+/*Free L1 and L2 page table*/
+void isp_mmu_exit(struct isp_mmu *mmu)
+{
+	unsigned int idx;
+	unsigned int pte;
+	phys_addr_t l1_pt, l2_pt;
+
+	if (!mmu)
+		return;
+
+	if (!ISP_PTE_VALID(mmu, mmu->l1_pte)) {
+		v4l2_warn(&atomisp_dev,
+			    "invalid L1PT: pte = 0x%x\n",
+			    (unsigned int)mmu->l1_pte);
+		return;
+	}
+
+	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
+
+	for (idx = 0; idx < ISP_L1PT_PTES; idx++) {
+		pte = atomisp_get_pte(l1_pt, idx);
+
+		if (ISP_PTE_VALID(mmu, pte)) {
+			l2_pt = isp_pte_to_pgaddr(mmu, pte);
+
+			free_page_table(mmu, l2_pt);
+		}
+	}
+
+	free_page_table(mmu, l1_pt);
+
+#ifdef USE_KMEM_CACHE
+	kmem_cache_destroy(mmu->tbl_cache);
+#endif
+}
diff --git a/drivers/media/atomisp2/mmu/sh_mmu_mfld.c b/drivers/media/atomisp2/mmu/sh_mmu_mfld.c
new file mode 100644
index 0000000..6f90bbb
--- /dev/null
+++ b/drivers/media/atomisp2/mmu/sh_mmu_mfld.c
@@ -0,0 +1,83 @@
+/*
+ * Support for Medfield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+
+#include <host/mmu_local.h>
+#include <atomisp_internal.h>
+#include <atomisp_compat.h>
+#include "mmu/isp_mmu.h"
+#include "mmu/sh_mmu_mfld.h"
+#include "memory_access/memory_access.h"
+/*
+ * include SH header file here
+ */
+
+static unsigned int sh_phys_to_pte(struct isp_mmu *mmu,
+				   phys_addr_t phys)
+{
+	return (unsigned int)phys;
+}
+
+static phys_addr_t sh_pte_to_phys(struct isp_mmu *mmu,
+				  unsigned int pte)
+{
+	return (phys_addr_t)(pte & ISP_PAGE_MASK);
+}
+/*
+ * set page directory base address (physical address).
+ *
+ * must be provided.
+ */
+static int sh_set_pd_base(struct isp_mmu *mmu,
+			  phys_addr_t phys)
+{
+	/*mmgr_set_base_address(HOST_ADDRESS(u32)phys);*/
+	//atomisp_sh_css_mmu_set_page_table_base_index(HOST_ADDRESS(u32)phys);
+	return 0;
+}
+
+/*
+ * callback to flush tlb.
+ *
+ * tlb_flush_range will at least flush TLBs containing
+ * address mapping from addr to addr + size.
+ *
+ * tlb_flush_all will flush all TLBs.
+ *
+ * tlb_flush_all is must be provided. if tlb_flush_range is
+ * not valid, it will set to tlb_flush_all by default.
+ */
+static void sh_tlb_flush(struct isp_mmu *mmu)
+{
+	ia_css_mmu_invalidate_cache();
+}
+
+struct isp_mmu_client sh_mmu_mfld = {
+	.name = "Silicon Hive ISP3000 MMU",
+	.pte_valid_mask = 0x1,
+	.null_pte = (u32)NULL_PAGE,
+	.set_pd_base = sh_set_pd_base,
+	.tlb_flush_all = sh_tlb_flush,
+	.phys_to_pte = sh_phys_to_pte,
+	.pte_to_phys = sh_pte_to_phys,
+};
diff --git a/drivers/media/atomisp2/mmu/sh_mmu_mrfld.c b/drivers/media/atomisp2/mmu/sh_mmu_mrfld.c
new file mode 100644
index 0000000..0dc7985
--- /dev/null
+++ b/drivers/media/atomisp2/mmu/sh_mmu_mrfld.c
@@ -0,0 +1,91 @@
+/*
+ * Support for Merrifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * Copyright (c) 2012 Silicon Hive www.siliconhive.com.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <host/mmu_local.h>
+#include <atomisp_internal.h>
+#include <atomisp_compat.h>
+#include "mmu/isp_mmu.h"
+#include "mmu/sh_mmu_mrfld.h"
+#include "memory_access/memory_access.h"
+
+#define MERR_VALID_PTE_MASK	0x80000000
+/*
+ * include SH header file here
+ */
+
+static unsigned int sh_phys_to_pte(struct isp_mmu *mmu,
+				   phys_addr_t phys)
+{
+	return phys >> ISP_PAGE_OFFSET;
+}
+
+static phys_addr_t sh_pte_to_phys(struct isp_mmu *mmu,
+				  unsigned int pte)
+{
+	unsigned int mask = mmu->driver->pte_valid_mask;
+	return (phys_addr_t)((pte & ~mask) << ISP_PAGE_OFFSET);
+}
+
+/*
+ * set page directory base address (physical address).
+ *
+ * must be provided.
+ */
+static int sh_set_pd_base(struct isp_mmu *mmu,
+			  phys_addr_t phys)
+{
+	return 0;
+}
+
+static unsigned int sh_get_pd_base(struct isp_mmu *mmu,
+			  phys_addr_t phys)
+{
+	unsigned int pte = sh_phys_to_pte(mmu, phys);
+	return HOST_ADDRESS(pte);
+}
+
+/*
+ * callback to flush tlb.
+ *
+ * tlb_flush_range will at least flush TLBs containing
+ * address mapping from addr to addr + size.
+ *
+ * tlb_flush_all will flush all TLBs.
+ *
+ * tlb_flush_all is must be provided. if tlb_flush_range is
+ * not valid, it will set to tlb_flush_all by default.
+ */
+static void sh_tlb_flush(struct isp_mmu *mmu)
+{
+	ia_css_mmu_invalidate_cache();
+}
+
+struct isp_mmu_client sh_mmu_mrfld = {
+	.name = "Silicon Hive ISP3000 MMU",
+	.pte_valid_mask = MERR_VALID_PTE_MASK,
+	.null_pte = ~MERR_VALID_PTE_MASK,
+	.set_pd_base = sh_set_pd_base,
+	.get_pd_base = sh_get_pd_base,
+	.tlb_flush_all = sh_tlb_flush,
+	.phys_to_pte = sh_phys_to_pte,
+	.pte_to_phys = sh_pte_to_phys,
+};

diff --git a/drivers/media/i2c/mt9m114.c b/drivers/media/i2c/mt9m114.c
new file mode 100644
index 0000000..b34a74c
--- /dev/null
+++ b/drivers/media/i2c/mt9m114.c
@@ -0,0 +1,1627 @@
+/*
+ * Support for mt9m114 Camera Sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "mt9m114.h"
+
+#define to_mt9m114_sensor(sd) container_of(sd, struct mt9m114_device, sd)
+#define CAMERA_FORMAT 0xc86c //colour format output from the sensor
+
+/*
+ * TODO: use debug parameter to actually define when debug messages should
+ * be printed.
+ */
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-1)");
+
+static int mt9m114_t_vflip(struct v4l2_subdev *sd, int value);
+static int mt9m114_t_hflip(struct v4l2_subdev *sd, int value);
+static int mt9m114_wait_state(struct i2c_client *client, int timeout);
+
+static const struct sensor_format {
+         enum media_bus_format mbus_code;
+ } mt9m114_formats[] = {
+	 {
+                 .mbus_code      = MEDIA_BUS_FMT_FIXED,
+         },
+	 {
+                 .mbus_code      = 0x8003,
+         },
+         {
+                 .mbus_code      = MEDIA_BUS_FMT_UYVY8_1X16,
+         },
+         {
+                 .mbus_code      = MEDIA_BUS_FMT_UYVY8_2X8,
+         },
+         {
+                 .mbus_code      = MEDIA_BUS_FMT_RGB565_2X8_LE,
+         },
+         {
+        		 .mbus_code		 = MEDIA_BUS_FMT_SBGGR10_1X10,
+         },
+
+ };
+
+static int
+mt9m114_read_reg(struct i2c_client *client, u16 data_length, u32 reg, u32 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		v4l2_err(client, "%s error, no client->adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		v4l2_err(client, "%s error, invalid data length\n", __func__);
+		return -EINVAL;
+	}
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u16) (reg >> 8);
+	data[1] = (u16) (reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	if (err >= 0) {
+		*val = 0;
+		/* high byte comes first */
+		if (data_length == MISENSOR_8BIT)
+			*val = data[0];
+		else if (data_length == MISENSOR_16BIT)
+			*val = data[1] + (data[0] << 8);
+		else
+			*val = data[3] + (data[2] << 8) +
+			    (data[1] << 16) + (data[0] << 24);
+
+		return 0;
+	}
+
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int
+mt9m114_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+
+	if (!client->adapter) {
+		v4l2_err(client, "%s error, no client->adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		v4l2_err(client, "%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = be16_to_cpu((u16)val);
+	} else {
+		/* MISENSOR_32BIT */
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = be32_to_cpu(val);
+	}
+
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * HACK: Need some delay here for Rev 2 sensors otherwise some
+	 * registers do not seem to load correctly.
+	 */
+	mdelay(1);
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return num_msg;
+}
+
+/**
+ * misensor_rmw_reg - Read/Modify/Write a value to a register in the sensor
+ * device
+ * @client: i2c driver client structure
+ * @data_length: 8/16/32-bits length
+ * @reg: register address
+ * @mask: masked out bits
+ * @set: bits set
+ *
+ * Read/modify/write a value to a register in the  sensor device.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int
+misensor_rmw_reg(struct i2c_client *client, u16 data_length, u16 reg,
+		     u32 mask, u32 set)
+{
+	int err;
+	u32 val;
+
+	/* Exit when no mask */
+	if (mask == 0)
+		return 0;
+
+	/* @mask must not exceed data length */
+	switch (data_length) {
+	case MISENSOR_8BIT:
+		if (mask & ~0xff)
+			return -EINVAL;
+		break;
+	case MISENSOR_16BIT:
+		if (mask & ~0xffff)
+			return -EINVAL;
+		break;
+	case MISENSOR_32BIT:
+		break;
+	default:
+		/* Wrong @data_length */
+		return -EINVAL;
+	}
+
+	err = mt9m114_read_reg(client, data_length, reg, &val);
+	if (err) {
+		v4l2_err(client, "misensor_rmw_reg error exit, read failed\n");
+		return -EINVAL;
+	}
+
+	val &= ~mask;
+
+	/*
+	 * Perform the OR function if the @set exists.
+	 * Shift @set value to target bit location. @set should set only
+	 * bits included in @mask.
+	 *
+	 * REVISIT: This function expects @set to be non-shifted. Its shift
+	 * value is then defined to be equal to mask's LSB position.
+	 * How about to inform values in their right offset position and avoid
+	 * this unneeded shift operation?
+	 */
+	set <<= ffs(mask) - 1;
+	val |= set & mask;
+
+	err = mt9m114_write_reg(client, data_length, reg, val);
+	if (err) {
+		v4l2_err(client, "misensor_rmw_reg error exit, write failed\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int __mt9m114_flush_reg_array(struct i2c_client *client,
+				     struct mt9m114_write_ctrl *ctrl)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+	int retry = 0;
+
+	if (ctrl->index == 0)
+		return 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + ctrl->index;
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	msg.buf = (u8 *)&ctrl->buffer;
+
+	ret = i2c_transfer(client->adapter, &msg, num_msg);
+	if (ret != num_msg) {
+		if (++retry <= I2C_RETRY_COUNT) {
+			dev_dbg(&client->dev, "retrying... %d\n", retry);
+			msleep(20);
+			goto again;
+		}
+		dev_err(&client->dev, "%s: i2c transfer error\n", __func__);
+		return -EIO;
+	}
+
+	ctrl->index = 0;
+
+	/*
+	 * REVISIT: Previously we had a delay after writing data to sensor.
+	 * But it was removed as our tests have shown it is not necessary
+	 * anymore.
+	 */
+
+	return 0;
+}
+
+static int __mt9m114_buf_reg_array(struct i2c_client *client,
+				   struct mt9m114_write_ctrl *ctrl,
+				   const struct misensor_reg *next)
+{
+	u16 *data16;
+	u32 *data32;
+	int err;
+
+	/* Insufficient buffer? Let's flush and get more free space. */
+	if (ctrl->index + next->length >= MT9M114_MAX_WRITE_BUF_SIZE) {
+		err = __mt9m114_flush_reg_array(client, ctrl);
+		if (err)
+			return err;
+	}
+
+	switch (next->length) {
+	case MISENSOR_8BIT:
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case MISENSOR_16BIT:
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	case MISENSOR_32BIT:
+		data32 = (u32 *)&ctrl->buffer.data[ctrl->index];
+		*data32 = cpu_to_be32(next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += next->length;
+
+	return 0;
+}
+
+static int
+__mt9m114_write_reg_is_consecutive(struct i2c_client *client,
+				   struct mt9m114_write_ctrl *ctrl,
+				   const struct misensor_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+/*
+ * mt9m114_write_reg_array - Initializes a list of mt9m114 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ * @poll: completion polling requirement
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __mt9m114_flush_reg_array, __mt9m114_buf_reg_array() and
+ * __mt9m114_write_reg_is_consecutive() are internal functions to
+ * mt9m114_write_reg_array() and should be not used anywhere else.
+ *
+ */
+static int mt9m114_write_reg_array(struct i2c_client *client,
+				const struct misensor_reg *reglist,
+				int poll)
+{
+	const struct misensor_reg *next = reglist;
+	struct mt9m114_write_ctrl ctrl;
+	int err;
+
+	if (poll == PRE_POLLING) {
+		err = mt9m114_wait_state(client, MT9M114_WAIT_STAT_TIMEOUT);
+		if (err)
+			return err;
+	}
+
+	ctrl.index = 0;
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		switch (next->length & MISENSOR_TOK_MASK) {
+		case MISENSOR_TOK_DELAY:
+			err = __mt9m114_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		case MISENSOR_TOK_RMW:
+			err = __mt9m114_flush_reg_array(client, &ctrl);
+			err |= misensor_rmw_reg(client,
+						next->length &
+							~MISENSOR_TOK_RMW,
+						next->reg, next->val,
+						next->val2);
+			if (err) {
+				dev_err(&client->dev, "%s read err. aborted\n",
+					__func__);
+				return -EINVAL;
+			}
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__mt9m114_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __mt9m114_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __mt9m114_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				v4l2_err(client, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	err = __mt9m114_flush_reg_array(client, &ctrl);
+	if (err)
+		return err;
+
+	if (poll == POST_POLLING)
+		return mt9m114_wait_state(client, MT9M114_WAIT_STAT_TIMEOUT);
+
+	return 0;
+}
+
+
+static int mt9m114_wait_3a(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int timeout = 135;
+	int ret;
+	unsigned int status_exp, status_wb;
+
+	while (timeout--) {
+		ret = mt9m114_read_reg(client, MISENSOR_16BIT,
+			MISENSOR_AE_TRACK_STATUS, &status_exp);
+		if (ret)
+			return ret;
+		if (!(status_exp & MISENSOR_AE_READY)) {
+			msleep(20);
+			continue;
+		}
+		ret = mt9m114_read_reg(client,
+			MISENSOR_16BIT, MISENSOR_AWB_STATUS, &status_wb);
+		if (ret)
+			return ret;
+		if (status_wb & MISENSOR_AWB_STEADY) {
+			dev_dbg(&client->dev, "ae/awb stablize retry count  %d.\n",
+				  (135-timeout));
+			printk(KERN_ALERT "ae/awb stablize retry count  %d.\n", (135-timeout));
+			return 0;
+		}
+		msleep(20);
+	}
+
+	return -EINVAL;
+}
+
+static int mt9m114_wait_state(struct i2c_client *client, int timeout)
+{
+	int ret;
+	unsigned int val;
+
+	while (timeout-- > 0) {
+		ret = mt9m114_read_reg(client, MISENSOR_16BIT, 0x0080, &val);
+		if (ret)
+			return ret;
+		if ((val & 0x2) == 0)
+			return 0;
+		msleep(20);
+	}
+
+	return -EINVAL;
+
+}
+
+static int mt9m114_set_suspend(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return mt9m114_write_reg_array(client, mt9m114_suspend, POST_POLLING);
+}
+
+static int mt9m114_set_streaming(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return mt9m114_write_reg_array(client, mt9m114_streaming, POST_POLLING);
+}
+
+static int mt9m114_init_common(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = mt9m114_write_reg_array(client, mt9m114_common, PRE_POLLING);
+	if (ret)
+		return ret;
+	ret = mt9m114_write_reg_array(client, mt9m114_iq, NO_POLLING);
+
+	return ret;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+	/*
+	 * according to DS, 44ms is needed between power up and first i2c
+	 * commend
+	 */
+	msleep(50);
+
+	return 0;
+
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	/*according to DS, 20ms is needed after power down*/
+	msleep(20);
+
+	return ret;
+}
+
+static int mt9m114_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+	else {
+		if (power_up(sd))
+			return -EINVAL;
+
+		return mt9m114_init_common(sd);
+	}
+}
+
+static int mt9m114_try_res(u32 *w, u32 *h)
+{
+	int i;
+
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if ((mt9m114_res[i].width >= *w) &&
+		    (mt9m114_res[i].height >= *h))
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = mt9m114_res[i].width;
+	*h = mt9m114_res[i].height;
+
+	return 0;
+}
+
+static struct mt9m114_res_struct *mt9m114_to_res(u32 w, u32 h)
+{
+	int  index;
+
+	for (index = 0; index < N_RES; index++) {
+		if ((mt9m114_res[index].width == w) &&
+		    (mt9m114_res[index].height == h))
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		return NULL;
+
+	return &mt9m114_res[index];
+}
+
+static int mt9m114_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	int count = 0;
+
+        for (count = 0; count < ARRAY_SIZE(mt9m114_formats); count++)
+	{
+                if (mt9m114_formats[count].mbus_code == fmt->code)
+		{
+                        break;
+		}
+		else
+		  count = ARRAY_SIZE(mt9m114_formats) + 1; //unsupported format
+	}
+        if (count >= ARRAY_SIZE(mt9m114_formats))
+	{
+                /* default to first format */
+                count = 0;
+                fmt->code = mt9m114_formats[0].mbus_code;
+        }
+
+	return mt9m114_try_res(&fmt->width, &fmt->height);
+}
+
+static int mt9m114_res2size(unsigned int res, int *h_size, int *v_size)
+{
+	unsigned short hsize;
+	unsigned short vsize;
+
+	switch (res) {
+	case MT9M114_RES_QCIF:
+		hsize = MT9M114_RES_QCIF_SIZE_H;
+		vsize = MT9M114_RES_QCIF_SIZE_V;
+		break;
+	case MT9M114_RES_QVGA:
+		hsize = MT9M114_RES_QVGA_SIZE_H;
+		vsize = MT9M114_RES_QVGA_SIZE_V;
+		break;
+	case MT9M114_RES_VGA:
+		hsize = MT9M114_RES_VGA_SIZE_H;
+		vsize = MT9M114_RES_VGA_SIZE_V;
+		break;
+	case MT9M114_RES_480P:
+		hsize = MT9M114_RES_480P_SIZE_H;
+		vsize = MT9M114_RES_480P_SIZE_V;
+		break;
+	case MT9M114_RES_720P:
+		hsize = MT9M114_RES_720P_SIZE_H;
+		vsize = MT9M114_RES_720P_SIZE_V;
+		break;
+	case MT9M114_RES_960P:
+		hsize = MT9M114_RES_960P_SIZE_H;
+		vsize = MT9M114_RES_960P_SIZE_V;
+		break;
+	case MT9M114_RES_PAL:
+		hsize = MT9M114_RES_PAL_SIZE_H;
+		vsize = MT9M114_RES_PAL_SIZE_V;
+		break;
+	case MT9M114_RES_800x480:
+		hsize = MT9M114_RES_800x480_SIZE_H;
+		vsize = MT9M114_RES_800x480_SIZE_V;
+		break;
+	case MT9M114_RES_960x540:
+		hsize = MT9M114_RES_960x540_SIZE_H;
+		vsize = MT9M114_RES_960x540_SIZE_V;
+		break;
+	case MT9M114_RES_720x480:
+		hsize = MT9M114_RES_720x480_SIZE_H;
+		vsize = MT9M114_RES_720x480_SIZE_V;
+		break;
+	case MT9M114_RES_736x480:
+		hsize = MT9M114_RES_736x480_SIZE_H;
+		vsize = MT9M114_RES_736x480_SIZE_V;
+		break;
+	case MT9M114_RES_736x576:
+		hsize = MT9M114_RES_736x576_SIZE_H;
+		vsize = MT9M114_RES_736x576_SIZE_V;
+		break;
+	case MT9M114_RES_1280x768:
+		hsize = MT9M114_RES_1280x768_SIZE_H;
+		vsize = MT9M114_RES_1280x768_SIZE_V;
+		break;
+	case MT9M114_RES_1280x800:
+			hsize = MT9M114_RES_1280x800_SIZE_H;
+			vsize = MT9M114_RES_1280x800_SIZE_V;
+			break;
+
+	default:
+		WARN(1, "%s: Resolution 0x%08x unknown\n", __func__, res);
+		return -EINVAL;
+	}
+	printk(KERN_ALERT "mt9m114_res2size: hsize=%d, vsize=%d\n", hsize, vsize);
+
+	if (h_size != NULL)
+		*h_size = hsize;
+	if (v_size != NULL)
+		*v_size = vsize;
+
+	return 0;
+}
+
+static int mt9m114_get_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	int width, height;
+	int ret;
+
+	ret = mt9m114_res2size(dev->res, &width, &height);
+	if (ret)
+		return ret;
+	fmt->width = width;
+	fmt->height = height;
+
+	return 0;
+}
+
+static int mt9m114_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct mt9m114_res_struct *res_index;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	u32 colour_fmt;
+	int ret;
+
+	printk(KERN_ALERT "ENTER mt9m114_set_mbus_fmt, width=%d, height=%d\n", width, height);
+
+	mt9m114_try_res(&width, &height);
+	printk(KERN_ALERT "return from mt9m114_try_res, width=%d, height=%d\n", width, height);
+	res_index = mt9m114_to_res(width, height);
+
+	/* Sanity check */
+	if (unlikely(!res_index)) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+	switch (res_index->res) {
+	case MT9M114_RES_QCIF:
+		ret = mt9m114_write_reg_array(c, mt9m114_qcif_init, NO_POLLING);
+		break;
+	case MT9M114_RES_QVGA:
+		ret = mt9m114_write_reg_array(c, mt9m114_qvga_init, NO_POLLING);
+		/* set sensor read_mode to Skipping */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_SKIPPING_SET);
+		break;
+	case MT9M114_RES_VGA:
+		ret = mt9m114_write_reg_array(c, mt9m114_vga_init, NO_POLLING);
+		/* set sensor read_mode to Summing */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_SUMMING_SET);
+		break;
+	case MT9M114_RES_480P:
+		ret = mt9m114_write_reg_array(c, mt9m114_480p_init, NO_POLLING);
+		break;
+	case MT9M114_RES_720P:
+		ret = mt9m114_write_reg_array(c, mt9m114_720p_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_960P:
+		ret = mt9m114_write_reg_array(c, mt9m114_960P_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_PAL:
+		ret = mt9m114_write_reg_array(c, mt9m114_pal_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_800x480:
+		ret = mt9m114_write_reg_array(c, mt9m114_800x480_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_960x540:
+		ret = mt9m114_write_reg_array(c, mt9m114_960x540_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_720x480:
+		ret = mt9m114_write_reg_array(c, mt9m114_720x480_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_736x480:
+		ret = mt9m114_write_reg_array(c, mt9m114_736x480_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_736x576:
+		ret = mt9m114_write_reg_array(c, mt9m114_736x576_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_1280x768:
+		ret = mt9m114_write_reg_array(c, mt9m114_1280x768_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		printk(KERN_ALERT "Case MT9M114_RES_1280x768, ret=%d\n", ret);
+		break;
+	case MT9M114_RES_1280x800:
+			ret = mt9m114_write_reg_array(c, mt9m114_1280x800_init, NO_POLLING);
+			/* set sensor read_mode to Normal */
+			ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+			printk(KERN_ALERT "Case MT9M114_RES_1280x800, ret=%d\n", ret);
+			break;
+	default:
+		v4l2_err(sd, "set resolution: %d failed!\n", res_index->res);
+		printk(KERN_ALERT "ERROR set resolution %d failed!\n", res_index->res);
+		return -EINVAL;
+	}
+
+	if (ret)
+	{
+		return -EINVAL;
+	}
+
+        /* set image format */
+	ret = mt9m114_read_reg(c, MISENSOR_16BIT, (u32)CAMERA_FORMAT, &colour_fmt);
+        if (ret)
+	{
+               return -EINVAL;
+	}
+
+	colour_fmt &= 0xc0fc;
+
+        switch (fmt->code)
+	{
+	  case MEDIA_BUS_FMT_FIXED:
+	  case 0x8003:
+	  case MEDIA_BUS_FMT_UYVY8_1X16:
+	  case MEDIA_BUS_FMT_UYVY8_2X8:
+		colour_fmt = 0x0010;
+                break;
+
+	  case MEDIA_BUS_FMT_RGB565_2X8_LE:
+                 colour_fmt = 0x0100;
+              break;
+	  case MEDIA_BUS_FMT_SGRBG10_1X10:
+	  		  	 colour_fmt = 0x0210;
+	  		  break;
+	  default:
+		printk("fmt->code default!!\n");
+                 return -EINVAL;
+        }
+  printk("writing CAMERA_FORMAT register = 0x%X\n", colour_fmt);
+	ret = mt9m114_write_reg(c, MISENSOR_16BIT, (u32)CAMERA_FORMAT, colour_fmt);
+        if (ret)
+               return -EINVAL;
+
+	ret = mt9m114_write_reg_array(c, mt9m114_chgstat_reg, POST_POLLING);
+	if (ret < 0)
+		return ret;
+
+	if (mt9m114_set_suspend(sd))
+		return -EINVAL;
+
+	if (dev->res != res_index->res) {
+		int index;
+
+		/* Switch to different size */
+		if (width <= 640) {
+			dev->nctx = 0x00; /* Set for context A */
+		} else {
+			/*
+			 * Context B is used for resolutions larger than 640x480
+			 * Using YUV for Context B.
+			 */
+			dev->nctx = 0x01; /* set for context B */
+		}
+
+		/*
+		 * Marked current sensor res as being "used"
+		 *
+		 * REVISIT: We don't need to use an "used" field on each mode
+		 * list entry to know which mode is selected. If this
+		 * information is really necessary, how about to use a single
+		 * variable on sensor dev struct?
+		 */
+		for (index = 0; index < N_RES; index++) {
+			if ((width == mt9m114_res[index].width) &&
+			    (height == mt9m114_res[index].height)) {
+				mt9m114_res[index].used = 1;
+				continue;
+			}
+			mt9m114_res[index].used = 0;
+		}
+	}
+
+	/*
+	 * mt9m114 - we don't poll for context switch
+	 * because it does not happen with streaming disabled.
+	 */
+	dev->res = res_index->res;
+
+	fmt->width = width;
+	fmt->height = height;
+	printk(KERN_ALERT "EXIT mt9m114_set_mbus_fmt(), width=%d, height=%d\n", fmt->width, fmt->height);
+	return 0;
+}
+
+/* TODO: Update to SOC functions, remove exposure and gain */
+static int mt9m114_g_focal(struct v4l2_subdev *sd, s32 * val)
+{
+	*val = (MT9M114_FOCAL_LENGTH_NUM << 16) | MT9M114_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int mt9m114_g_fnumber(struct v4l2_subdev *sd, s32 * val)
+{
+	/*const f number for mt9m114*/
+	*val = (MT9M114_F_NUMBER_DEFAULT_NUM << 16) | MT9M114_F_NUMBER_DEM;
+	return 0;
+}
+
+static int mt9m114_g_fnumber_range(struct v4l2_subdev *sd, s32 * val)
+{
+	*val = (MT9M114_F_NUMBER_DEFAULT_NUM << 24) |
+		(MT9M114_F_NUMBER_DEM << 16) |
+		(MT9M114_F_NUMBER_DEFAULT_NUM << 8) | MT9M114_F_NUMBER_DEM;
+	return 0;
+}
+
+/* Horizontal flip the image. */
+static int mt9m114_g_hflip(struct v4l2_subdev *sd, s32 * val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int ret;
+	u32 data;
+	ret = mt9m114_read_reg(c, MISENSOR_16BIT,
+			(u32)MISENSOR_READ_MODE, &data);
+	if (ret)
+		return ret;
+	*val = !!(data & MISENSOR_HFLIP_MASK);
+
+	return 0;
+}
+
+static int mt9m114_g_vflip(struct v4l2_subdev *sd, s32 * val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int ret;
+	u32 data;
+
+	ret = mt9m114_read_reg(c, MISENSOR_16BIT,
+			(u32)MISENSOR_READ_MODE, &data);
+	if (ret)
+		return ret;
+	*val = !!(data & MISENSOR_VFLIP_MASK);
+
+	return 0;
+}
+
+static int mt9m114_s_freq(struct v4l2_subdev *sd, s32  val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	int ret;
+
+	if (val != MT9M114_FLICKER_MODE_50HZ &&
+			val != MT9M114_FLICKER_MODE_60HZ)
+		return -EINVAL;
+
+	if (val == MT9M114_FLICKER_MODE_50HZ) {
+		ret = mt9m114_write_reg_array(c, mt9m114_antiflicker_50hz,
+					POST_POLLING);
+		if (ret < 0)
+			return ret;
+	} else {
+		ret = mt9m114_write_reg_array(c, mt9m114_antiflicker_60hz,
+					POST_POLLING);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (ret == 0)
+		dev->lightfreq = val;
+
+	return ret;
+}
+
+static struct mt9m114_control mt9m114_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image v-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = mt9m114_g_vflip,
+		.tweak = mt9m114_t_vflip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image h-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = mt9m114_g_hflip,
+		.tweak = mt9m114_t_hflip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = MT9M114_FOCAL_LENGTH_DEFAULT,
+			.maximum = MT9M114_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9M114_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9m114_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = MT9M114_F_NUMBER_DEFAULT,
+			.maximum = MT9M114_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9M114_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9m114_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = MT9M114_F_NUMBER_RANGE,
+			.maximum =  MT9M114_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = MT9M114_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = mt9m114_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_POWER_LINE_FREQUENCY,
+			.type = V4L2_CTRL_TYPE_MENU,
+			.name = "Light frequency filter",
+			.minimum = 1,
+			.maximum =  2, /* 1: 50Hz, 2:60Hz */
+			.step = 1,
+			.default_value = 1,
+			.flags = 0,
+		},
+		.tweak = mt9m114_s_freq,
+	},
+
+};
+#define N_CONTROLS (ARRAY_SIZE(mt9m114_controls))
+
+static struct mt9m114_control *mt9m114_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (mt9m114_controls[i].qc.id == id)
+			return &mt9m114_controls[i];
+	}
+	return NULL;
+}
+
+static int mt9m114_detect(struct mt9m114_device *dev, struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 retvalue;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+	mt9m114_read_reg(client, MISENSOR_16BIT, (u32)MT9M114_PID, &retvalue);
+	dev->real_model_id = retvalue;
+
+	if (retvalue != MT9M114_MOD_ID) {
+		dev_err(&client->dev, "%s: failed: client->addr = %x\n",
+			__func__, client->addr);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int
+mt9m114_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			v4l2_err(client, "mt9m114 platform init err\n");
+			return ret;
+		}
+	}
+	ret = mt9m114_s_power(sd, 1);
+	if (ret) {
+		v4l2_err(client, "mt9m114 power-up err");
+		return ret;
+	}
+
+	/* config & detect sensor */
+	ret = mt9m114_detect(dev, client);
+	if (ret) {
+		v4l2_err(client, "mt9m114_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = mt9m114_set_suspend(sd);
+	if (ret) {
+		v4l2_err(client, "mt9m114 suspend err");
+		return ret;
+	}
+
+	ret = mt9m114_s_power(sd, 0);
+	if (ret) {
+		v4l2_err(client, "mt9m114 power down err");
+		return ret;
+	}
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	mt9m114_s_power(sd, 0);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int mt9m114_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct mt9m114_control *ctrl = mt9m114_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	return 0;
+}
+
+/* Horizontal flip the image. */
+static int mt9m114_t_hflip(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	int err;
+	/* set for direct mode */
+	err = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC850);
+	if (value) {
+		/* enable H flip ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x01, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x01, 0x01);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x01, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x01, 0x01);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_HFLIP_MASK, MISENSOR_FLIP_EN);
+
+		dev->bpat = MT9M114_BPAT_GRGRBGBG;
+	} else {
+		/* disable H flip ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x01, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x01, 0x00);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x01, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x01, 0x00);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_HFLIP_MASK, MISENSOR_FLIP_DIS);
+
+		dev->bpat = MT9M114_BPAT_BGBGGRGR;
+	}
+
+	err += mt9m114_write_reg(c, MISENSOR_8BIT, 0x8404, 0x06);
+	udelay(10);
+
+	return !!err;
+}
+
+/* Vertically flip the image */
+static int mt9m114_t_vflip(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int err;
+	/* set for direct mode */
+	err = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC850);
+	if (value >= 1) {
+		/* enable H flip - ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x02, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x02, 0x01);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x02, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x02, 0x01);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_VFLIP_MASK, MISENSOR_FLIP_EN);
+	} else {
+		/* disable H flip - ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x02, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x02, 0x00);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x02, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x02, 0x00);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_VFLIP_MASK, MISENSOR_FLIP_DIS);
+	}
+
+	err += mt9m114_write_reg(c, MISENSOR_8BIT, 0x8404, 0x06);
+	udelay(10);
+
+	return !!err;
+}
+
+static int mt9m114_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9m114_control *octrl = mt9m114_find_control(ctrl->id);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	ret = octrl->query(sd, &ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mt9m114_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9m114_control *octrl = mt9m114_find_control(ctrl->id);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+
+	ret = octrl->tweak(sd, ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mt9m114_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int ret;
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+
+	if (enable) {
+		ret = mt9m114_write_reg_array(c, mt9m114_chgstat_reg,
+					POST_POLLING);
+		if (ret < 0)
+			return ret;
+
+		ret = mt9m114_set_streaming(sd);
+		/*
+		 * here we wait for sensor's 3A algorithm to be
+		 * stablized, as to fix still capture bad 3A output picture
+		 */
+		if (mt9m114_wait_3a(sd))
+			v4l2_warn(c, "3A can not finish!");
+	} else {
+		ret = mt9m114_set_suspend(sd);
+	}
+
+	return ret;
+}
+
+static int
+mt9m114_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = mt9m114_res[index].width;
+	fsize->discrete.height = mt9m114_res[index].height;
+
+	/* FIXME: Wrong way to know used mode */
+	fsize->reserved[0] = mt9m114_res[index].used;
+
+	return 0;
+}
+
+static int mt9m114_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	/* find out the first equal or bigger size */
+	for (i = 0; i < N_RES; i++) {
+		if ((mt9m114_res[i].width >= fival->width) &&
+		    (mt9m114_res[i].height >= fival->height))
+			break;
+	}
+	if (i == N_RES)
+		i--;
+
+	index = i;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = mt9m114_res[index].fps;
+
+	return 0;
+}
+
+static int
+mt9m114_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_MT9M114, 0);
+}
+
+static int mt9m114_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int mt9m114_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+
+	unsigned int index = fse->index;
+
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = mt9m114_res[index].width;
+	fse->min_height = mt9m114_res[index].height;
+	fse->max_width = mt9m114_res[index].width;
+	fse->max_height = mt9m114_res[index].height;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mt9m114_get_pad_format(struct mt9m114_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,  "%s err. pad %x\n", __func__, pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+mt9m114_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9m114_device *snr = to_mt9m114_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9m114_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int
+mt9m114_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9m114_device *snr = to_mt9m114_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9m114_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int mt9m114_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	int index;
+	struct mt9m114_device *snr = to_mt9m114_sensor(sd);
+
+	if (frames == NULL)
+		return -EINVAL;
+
+	for (index = 0; index < N_RES; index++) {
+		if (mt9m114_res[index].res == snr->res)
+			break;
+	}
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	*frames = mt9m114_res[index].skip_frames;
+
+	return 0;
+}
+static const struct v4l2_subdev_video_ops mt9m114_video_ops = {
+	.try_mbus_fmt = mt9m114_try_mbus_fmt,
+	.s_mbus_fmt = mt9m114_set_mbus_fmt,
+	.g_mbus_fmt = mt9m114_get_mbus_fmt,
+	.s_stream = mt9m114_s_stream,
+	.enum_framesizes = mt9m114_enum_framesizes,
+	.enum_frameintervals = mt9m114_enum_frameintervals,
+};
+
+static struct v4l2_subdev_sensor_ops mt9m114_sensor_ops = {
+	.g_skip_frames	= mt9m114_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops mt9m114_core_ops = {
+	.g_chip_ident = mt9m114_g_chip_ident,
+	.queryctrl = mt9m114_queryctrl,
+	.g_ctrl = mt9m114_g_ctrl,
+	.s_ctrl = mt9m114_s_ctrl,
+	.s_power = mt9m114_s_power,
+};
+
+/* REVISIT: Do we need pad operations? */
+static const struct v4l2_subdev_pad_ops mt9m114_pad_ops = {
+	.enum_mbus_code = mt9m114_enum_mbus_code,
+	.enum_frame_size = mt9m114_enum_frame_size,
+	.get_fmt = mt9m114_get_pad_format,
+	.set_fmt = mt9m114_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops mt9m114_ops = {
+	.core = &mt9m114_core_ops,
+	.video = &mt9m114_video_ops,
+	.pad = &mt9m114_pad_ops,
+	.sensor = &mt9m114_sensor_ops,
+};
+
+static const struct media_entity_operations mt9m114_entity_ops = {
+	.link_setup = NULL,
+};
+
+
+static int mt9m114_remove(struct i2c_client *client)
+{
+	struct mt9m114_device *dev;
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	dev = container_of(sd, struct mt9m114_device, sd);
+	dev->platform_data->csi_cfg(sd, 0);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+	return 0;
+}
+
+static int mt9m114_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct mt9m114_device *dev;
+	int ret;
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &mt9m114_ops);
+	if (client->dev.platform_data) {
+		ret = mt9m114_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+
+	/*TODO add format code here*/
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	/* REVISIT: Do we need media controller? */
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		mt9m114_remove(client);
+		return ret;
+	}
+
+	/* set res index to be invalid */
+	dev->res = -1;
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, mt9m114_id);
+
+static struct i2c_driver mt9m114_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "mt9m114"
+	},
+	.probe = mt9m114_probe,
+	.remove = mt9m114_remove,
+	.id_table = mt9m114_id,
+};
+
+static __init int init_mt9m114(void)
+{
+	return i2c_add_driver(&mt9m114_driver);
+}
+
+static __exit void exit_mt9m114(void)
+{
+	i2c_del_driver(&mt9m114_driver);
+}
+
+module_init(init_mt9m114);
+module_exit(exit_mt9m114);
+
+MODULE_AUTHOR("Shuguang Gong <Shuguang.gong@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/mt9m114.h b/drivers/media/i2c/mt9m114.h
new file mode 100644
index 0000000..1a8a27a
--- /dev/null
+++ b/drivers/media/i2c/mt9m114.h
@@ -0,0 +1,2044 @@
+/*
+ * Support for mt9m114 Camera Sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __A1040_H__
+#define __A1040_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+#define V4L2_IDENT_MT9M114 8245
+
+#define MT9P111_REV3
+#define FULLINISUPPORT
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_FWBURST0	0x80
+#define MISENSOR_FWBURST1	0x81
+#define MISENSOR_FWBURST4	0x84
+#define MISENSOR_FWBURST	0x88
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+#define MISENSOR_TOK_RMW	0x0010  /* RMW operation */
+#define MISENSOR_TOK_MASK	0xfff0
+#define MISENSOR_AWB_STEADY	(1<<0)	/* awb steady */
+#define MISENSOR_AE_READY	(1<<3)	/* ae status ready */
+
+/* mask to set sensor read_mode via misensor_rmw_reg */
+#define MISENSOR_R_MODE_MASK	0x0330
+/* mask to set sensor vert_flip and horz_mirror */
+#define MISENSOR_VFLIP_MASK	0x0002
+#define MISENSOR_HFLIP_MASK	0x0001
+#define MISENSOR_FLIP_EN	1
+#define MISENSOR_FLIP_DIS	0
+
+/* bits set to set sensor read_mode via misensor_rmw_reg */
+#define MISENSOR_SKIPPING_SET	0x0011
+#define MISENSOR_SUMMING_SET	0x0033
+#define MISENSOR_NORMAL_SET	0x0000
+
+/* sensor register that control sensor read-mode and mirror */
+#define MISENSOR_READ_MODE	0xC834
+/* sensor ae-track status register */
+#define MISENSOR_AE_TRACK_STATUS	0xA800
+/* sensor awb status register */
+#define MISENSOR_AWB_STATUS	0xAC00
+
+/*Sensor mode data related registers*/
+#define MISENSOR_FINE_INTG_TIME_MIN 0xC80E
+#define MISENSOR_FINE_INTG_TIME_MAX 0xC810
+#define MISENSOR_FRAME_LENGTH_LINES 0xC812
+#define MISENSOR_LINE_LENGTH_PCK 0xC814
+#define MISENSOR_PIX_CLK 0xC808
+#define MISENSOR_CROP_HORZ_START 0xC854
+#define MISENSOR_CROP_VERT_START 0xC856
+#define MISENSOR_CROP_HORZ_END 0xC858
+#define MISENSOR_CROP_VERT_END 0xC85A
+#define MISENSOR_OUTPUT_WIDTH 0xC868
+#define MISENSOR_OUTPUT_HEIGHT 0xC86A
+//Coarse integration and binning factor registers are not available
+
+#define SENSOR_DETECTED		1
+#define SENSOR_NOT_DETECTED	0
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+#define MAX_FMTS		1
+
+#ifndef MIPI_CONTROL
+#define MIPI_CONTROL		0x3400	/* MIPI_Control */
+#endif
+
+/* GPIO pin on Moorestown */
+#define GPIO_SCLK_25		44
+#define GPIO_STB_PIN		47
+
+#define GPIO_STDBY_PIN		49   /* ab:new */
+#define GPIO_RESET_PIN		50
+
+/* System control register for Aptina A-1040SOC*/
+#define MT9M114_PID		0x0
+
+/* MT9P111_DEVICE_ID */
+#define MT9M114_MOD_ID		0x2481
+
+/* ulBPat; */
+
+#define MT9M114_BPAT_RGRGGBGB	(1 << 0)
+#define MT9M114_BPAT_GRGRBGBG	(1 << 1)
+#define MT9M114_BPAT_GBGBRGRG	(1 << 2)
+#define MT9M114_BPAT_BGBGGRGR	(1 << 3)
+
+#define MT9M114_FOCAL_LENGTH_NUM	208	/*2.08mm*/
+#define MT9M114_FOCAL_LENGTH_DEM	100
+#define MT9M114_F_NUMBER_DEFAULT_NUM	24
+#define MT9M114_F_NUMBER_DEM	10
+#define MT9M114_WAIT_STAT_TIMEOUT	100
+#define MT9M114_FLICKER_MODE_50HZ	1
+#define MT9M114_FLICKER_MODE_60HZ	2
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9M114_FOCAL_LENGTH_DEFAULT 0xD00064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9M114_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define MT9M114_F_NUMBER_RANGE 0x180a180a
+
+/* Supported resolutions */
+enum {
+	MT9M114_RES_QCIF,
+	MT9M114_RES_QVGA,
+	MT9M114_RES_VGA,
+	MT9M114_RES_480P,
+	MT9M114_RES_720P,
+	MT9M114_RES_960P,
+	MT9M114_RES_PAL,
+	MT9M114_RES_800x480,
+	MT9M114_RES_960x540,
+	MT9M114_RES_720x480,
+	MT9M114_RES_736x480,
+	MT9M114_RES_736x576,
+	MT9M114_RES_1280x768,
+	MT9M114_RES_1280x800,
+};
+#define MT9M114_RES_960P_SIZE_H		1280
+#define MT9M114_RES_960P_SIZE_V		960
+#define MT9M114_RES_720P_SIZE_H		1280
+#define MT9M114_RES_720P_SIZE_V		720
+#define MT9M114_RES_480P_SIZE_H		768
+#define MT9M114_RES_480P_SIZE_V		480
+#define MT9M114_RES_VGA_SIZE_H		640
+#define MT9M114_RES_VGA_SIZE_V		480
+#define MT9M114_RES_QVGA_SIZE_H		320
+#define MT9M114_RES_QVGA_SIZE_V		240
+#define MT9M114_RES_QCIF_SIZE_H		176
+#define MT9M114_RES_QCIF_SIZE_V		144
+#define MT9M114_RES_PAL_SIZE_H		720
+#define MT9M114_RES_PAL_SIZE_V		576
+#define MT9M114_RES_800x480_SIZE_H		800
+#define MT9M114_RES_800x480_SIZE_V		480
+#define MT9M114_RES_960x540_SIZE_H		960
+#define MT9M114_RES_960x540_SIZE_V		540
+#define MT9M114_RES_720x480_SIZE_H		720
+#define MT9M114_RES_720x480_SIZE_V		480
+#define MT9M114_RES_736x480_SIZE_H		736
+#define MT9M114_RES_736x480_SIZE_V		480
+#define MT9M114_RES_736x576_SIZE_H		736
+#define MT9M114_RES_736x576_SIZE_V		576
+#define MT9M114_RES_1280x768_SIZE_H		1280
+#define MT9M114_RES_1280x768_SIZE_V		768
+#define MT9M114_RES_1280x800_SIZE_H		1280
+#define MT9M114_RES_1280x800_SIZE_V		800
+
+/* completion status polling requirements, usage based on Aptina .INI Rev2 */
+enum poll_reg {
+	NO_POLLING,
+	PRE_POLLING,
+	POST_POLLING,
+};
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u32 length;
+	u32 reg;
+	u32 val;	/* value or for read/mod/write, AND mask */
+	u32 val2;	/* optional; for rmw, OR mask */
+};
+
+/*
+ * struct misensor_fwreg - Firmware burst command
+ * @type: FW burst or 8/16 bit register
+ * @addr: 16-bit offset to register or other values depending on type
+ * @valx: data value for burst (or other commands)
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_fwreg {
+	u32	type;	/* type of value, register or FW burst string */
+	u32	addr;	/* target address */
+	u32	val0;
+	u32	val1;
+	u32	val2;
+	u32	val3;
+	u32	val4;
+	u32	val5;
+	u32	val6;
+	u32	val7;
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct mt9m114_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+
+	struct camera_sensor_platform_data *platform_data;
+	int real_model_id;
+	int nctx;
+	int power;
+
+	unsigned int bus_width;
+	unsigned int mode;
+	unsigned int field_inv;
+	unsigned int field_sel;
+	unsigned int ycseq;
+	unsigned int conv422;
+	unsigned int bpat;
+	unsigned int hpol;
+	unsigned int vpol;
+	unsigned int edge;
+	unsigned int bls;
+	unsigned int gamma;
+	unsigned int cconv;
+	unsigned int res;
+	unsigned int dwn_sz;
+	unsigned int blc;
+	unsigned int agc;
+	unsigned int awb;
+	unsigned int aec;
+	/* extention SENSOR version 2 */
+	unsigned int cie_profile;
+
+	/* extention SENSOR version 3 */
+	unsigned int flicker_freq;
+
+	/* extension SENSOR version 4 */
+	unsigned int smia_mode;
+	unsigned int mipi_mode;
+
+	/* Add name here to load shared library */
+	unsigned int type;
+
+	/*Number of MIPI lanes*/
+	unsigned int mipi_lanes;
+	char name[32];
+
+	u8 lightfreq;
+};
+
+struct mt9m114_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct mt9m114_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int skip_frames;
+	bool used;
+	struct regval_list *regs;
+};
+
+struct mt9m114_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+#define MT9M114_MAX_WRITE_BUF_SIZE	32
+struct mt9m114_write_buffer {
+	u16 addr;
+	u8 data[MT9M114_MAX_WRITE_BUF_SIZE];
+};
+
+struct mt9m114_write_ctrl {
+	int index;
+	struct mt9m114_write_buffer buffer;
+};
+
+/*
+ * Modes supported by the mt9m114 driver.
+ * IMPORTANT: keep them in ascending order.
+ */
+static struct mt9m114_res_struct mt9m114_res[] = {
+	{
+	.desc	= "QCIF",
+	.res	= MT9M114_RES_QCIF,
+	.width	= 176,
+	.height	= 144,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "QVGA",
+	.res	= MT9M114_RES_QVGA,
+	.width	= 320,
+	.height	= 240,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "VGA",
+	.res	= MT9M114_RES_VGA,
+	.width	= 640,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "720x480",
+	.res	= MT9M114_RES_720x480,
+	.width	= 720,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "736x480",
+	.res	= MT9M114_RES_736x480,
+	.width	= 736,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "736x576",
+	.res	= MT9M114_RES_736x576,
+	.width	= 736,
+	.height	= 576,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "480p",
+	.res	= MT9M114_RES_480P,
+	.width	= 768,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "800x480",
+	.res	= MT9M114_RES_800x480,
+	.width	= 800,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "PAL",
+	.res	= MT9M114_RES_PAL,
+	.width	= 720,
+	.height	= 576,
+	.fps	= 25,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "960x540",
+	.res	= MT9M114_RES_960x540,
+	.width	= 960,
+	.height	= 540,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "720p",
+	.res	= MT9M114_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "1280x768",
+	.res	= MT9M114_RES_1280x768,
+	.width	= 1280,
+	.height	= 768,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+		.desc	= "1280x800",
+		.res	= MT9M114_RES_1280x800,
+		.width	= 1280,
+		.height	= 800,
+		.fps	= 30,
+		.used	= 0,
+		.regs	= NULL,
+		.skip_frames = 1,
+	},
+	{
+	.desc	= "960P",
+	.res	= MT9M114_RES_960P,
+	.width	= 1280,
+	.height	= 960,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+};
+#define N_RES (ARRAY_SIZE(mt9m114_res))
+
+static const struct i2c_device_id mt9m114_id[] = {
+	{"mt9m114", 0},
+	{}
+};
+
+static struct misensor_reg const mt9m114_suspend[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x40},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_streaming[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x34},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_standby_reg[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x50},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_wakeup_reg[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x54},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_chgstat_reg[] = {
+	{MISENSOR_16BIT,  0x098E, 0xDC00},
+	{MISENSOR_8BIT,  0xDC00, 0x28},
+	{MISENSOR_16BIT,  0x0080, 0x8002},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+static struct misensor_reg const mt9m114_qcif_init[] = {
+
+	{MISENSOR_16BIT,  0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x0034},
+	{MISENSOR_16BIT,  0xC802, 0x0074},
+	{MISENSOR_16BIT,  0xC804, 0x039B},
+	{MISENSOR_16BIT,  0xC806, 0x049B},
+	{MISENSOR_32BIT,  MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT,  MISENSOR_FINE_INTG_TIME_MAX, 0x04D1},
+	{MISENSOR_16BIT,  MISENSOR_FRAME_LENGTH_LINES, 0x0495},
+	{MISENSOR_16BIT,  MISENSOR_LINE_LENGTH_PCK, 0x0554},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x0363},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT,  MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT,  MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT,  MISENSOR_CROP_HORZ_END, 0x0420},
+	{MISENSOR_16BIT,  MISENSOR_CROP_VERT_END, 0x0360},
+	{MISENSOR_8BIT,  0xC85C, 0x03},
+	{MISENSOR_16BIT,  MISENSOR_OUTPUT_WIDTH, 0x00B0},
+	{MISENSOR_16BIT,  MISENSOR_OUTPUT_HEIGHT, 0x0090},
+	{MISENSOR_8BIT,  0xC878, 0x0E},
+	{MISENSOR_16BIT,  0xC88C, 0x1E00},
+	{MISENSOR_16BIT,  0xC88E, 0x1E00},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x00AF},
+	{MISENSOR_16BIT,  0xC91A, 0x008F},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x0022},
+	{MISENSOR_16BIT,  0xC922, 0x001B},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_qvga_init[] = {
+
+	{MISENSOR_16BIT,  0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x0000},
+	{MISENSOR_16BIT,  0xC802, 0x0000},
+	{MISENSOR_16BIT,  0xC804, 0x03CD},
+	{MISENSOR_16BIT,  0xC806, 0x050D},
+	{MISENSOR_32BIT,  MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT,  MISENSOR_FINE_INTG_TIME_MAX, 0x05B3},
+	{MISENSOR_16BIT,  MISENSOR_FRAME_LENGTH_LINES, 0x03E8},
+	{MISENSOR_16BIT,  MISENSOR_LINE_LENGTH_PCK, 0x0640},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x01E3},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0x11},
+	{MISENSOR_16BIT,  MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT,  MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT,  MISENSOR_CROP_HORZ_END, 0x0280},
+	{MISENSOR_16BIT,  MISENSOR_CROP_VERT_END, 0x01E0},
+	{MISENSOR_8BIT,  0xC85C, 0x03},
+	{MISENSOR_16BIT,  MISENSOR_OUTPUT_WIDTH, 0x0140},
+	{MISENSOR_16BIT,  MISENSOR_OUTPUT_HEIGHT, 0x00F0},
+	{MISENSOR_8BIT,  0xC878, 0xE},
+	{MISENSOR_16BIT,  0xC88C, 0x1E03},
+	{MISENSOR_16BIT,  0xC88E, 0x1E03},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x013F},
+	{MISENSOR_16BIT,  0xC91A, 0x00EF},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x003F},
+	{MISENSOR_16BIT,  0xC922, 0x002F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_720p_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x007C},
+	{MISENSOR_16BIT,  0xC802, 0x0004},
+	{MISENSOR_16BIT,  0xC804, 0x0353},
+	{MISENSOR_16BIT,  0xC806, 0x050B},
+	{MISENSOR_32BIT,  MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT,  MISENSOR_FINE_INTG_TIME_MAX, 0x05BD},
+	{MISENSOR_16BIT,  MISENSOR_FRAME_LENGTH_LINES, 0x03E8},
+	{MISENSOR_16BIT,  MISENSOR_LINE_LENGTH_PCK, 0x0640},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x02D3},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT,  MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT,  MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT,  MISENSOR_CROP_HORZ_END, 0x0500},
+	{MISENSOR_16BIT,  MISENSOR_CROP_VERT_END, 0x02D0},
+	{MISENSOR_8BIT,   0xC85C, 0x03},
+	{MISENSOR_16BIT,  MISENSOR_OUTPUT_WIDTH, 0x0500},
+	{MISENSOR_16BIT,  MISENSOR_OUTPUT_HEIGHT, 0x02D0},
+	{MISENSOR_16BIT,  0xC88C, 0x1E00},
+	{MISENSOR_16BIT,  0xC88E, 0x1E00},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x04FF},
+	{MISENSOR_16BIT,  0xC91A, 0x02CF},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x00FF},
+	{MISENSOR_16BIT,  0xC922, 0x008F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_480p_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x0054},
+	{MISENSOR_16BIT,  0xC802, 0x0004},
+	{MISENSOR_16BIT,  0xC804, 0x037B},
+	{MISENSOR_16BIT,  0xC806, 0x050B},
+	{MISENSOR_32BIT,  MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT,  MISENSOR_FINE_INTG_TIME_MAX, 0x05B1},
+	{MISENSOR_16BIT,  MISENSOR_FRAME_LENGTH_LINES, 0x03EF},
+	{MISENSOR_16BIT,  MISENSOR_LINE_LENGTH_PCK, 0x0634},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x0323},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT,  MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT,  MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT,  MISENSOR_CROP_HORZ_END, 0x0500},
+	{MISENSOR_16BIT,  MISENSOR_CROP_VERT_END, 0x0320},
+	{MISENSOR_8BIT,   0xC85C, 0x03},
+	{MISENSOR_16BIT,  MISENSOR_OUTPUT_WIDTH, 0x0300},
+	{MISENSOR_16BIT,  MISENSOR_OUTPUT_HEIGHT, 0x01E0},
+	{MISENSOR_16BIT,  0xC88C, 0x1E04},
+	{MISENSOR_16BIT,  0xC88E, 0x1E04},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x02FF},
+	{MISENSOR_16BIT,  0xC91A, 0x01DF},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x0098},
+	{MISENSOR_16BIT,  0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_vga_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,   0xC800, 0x0000},
+	{MISENSOR_16BIT,   0xC802, 0x0000},
+	{MISENSOR_16BIT,   0xC804, 0x03CD},
+	{MISENSOR_16BIT,   0xC806, 0x050D},
+	{MISENSOR_32BIT,   MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT,   0xC80C, 0x0001},
+	{MISENSOR_16BIT,   MISENSOR_FINE_INTG_TIME_MIN, 0x01C3},
+	{MISENSOR_16BIT,   MISENSOR_FINE_INTG_TIME_MAX, 0x03B3},
+	{MISENSOR_16BIT,   MISENSOR_FRAME_LENGTH_LINES, 0x0549},
+	{MISENSOR_16BIT,   MISENSOR_LINE_LENGTH_PCK, 0x049E},
+	{MISENSOR_16BIT,   0xC816, 0x00E0},
+	{MISENSOR_16BIT,   0xC818, 0x01E3},
+	{MISENSOR_16BIT,   0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0x0},
+	{MISENSOR_16BIT,   MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT,   MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT,   MISENSOR_CROP_HORZ_END, 0x0280},
+	{MISENSOR_16BIT,   MISENSOR_CROP_VERT_END, 0x01E0},
+	{MISENSOR_8BIT,   0xC85C, 0x03},
+	{MISENSOR_16BIT,   MISENSOR_OUTPUT_WIDTH, 0x0280},
+	{MISENSOR_16BIT,   MISENSOR_OUTPUT_HEIGHT, 0x01E0},
+	{MISENSOR_8BIT,   0xC878, 0x00},
+	{MISENSOR_16BIT,   0xC88C, 0x1E04},
+	{MISENSOR_16BIT,   0xC88E, 0x1E04},
+	{MISENSOR_16BIT,   0xC914, 0x0000},
+	{MISENSOR_16BIT,   0xC916, 0x0000},
+	{MISENSOR_16BIT,   0xC918, 0x027F},
+	{MISENSOR_16BIT,   0xC91A, 0x01DF},
+	{MISENSOR_16BIT,   0xC91C, 0x0000},
+	{MISENSOR_16BIT,   0xC91E, 0x0000},
+	{MISENSOR_16BIT,   0xC920, 0x007F},
+	{MISENSOR_16BIT,   0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_960P_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MAX, 0x062E},
+	{MISENSOR_16BIT, MISENSOR_FRAME_LENGTH_LINES, 0x074C},
+	{MISENSOR_16BIT, MISENSOR_LINE_LENGTH_PCK, 0x06B1},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_END, 0x0500},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_END, 0x03C0},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_WIDTH, 0x0500},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_HEIGHT, 0x03C0},
+	{MISENSOR_8BIT, 0xC878, 0x0E},
+	{MISENSOR_16BIT, 0xC88C, 0x0F00},
+	{MISENSOR_16BIT, 0xC88E, 0x0F00},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x04FF},
+	{MISENSOR_16BIT, 0xC91A, 0x03BF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x00FF},
+	{MISENSOR_16BIT, 0xC922, 0x00BF},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_pal_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,   0xC800, 0x0004},
+	{MISENSOR_16BIT,   0xC802, 0x0004},
+	{MISENSOR_16BIT,   0xC804, 0x03CB},
+	{MISENSOR_16BIT,   0xC806, 0x050B},
+	{MISENSOR_32BIT,   MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT,   0xC80C, 0x0001},
+	{MISENSOR_16BIT,   MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT,   MISENSOR_FINE_INTG_TIME_MAX, 0x05BD},
+	{MISENSOR_16BIT,   MISENSOR_FRAME_LENGTH_LINES, 0x04B0},
+	{MISENSOR_16BIT,   MISENSOR_LINE_LENGTH_PCK, 0x0640},
+	{MISENSOR_16BIT,   0xC816, 0x0060},
+	{MISENSOR_16BIT,   0xC818, 0x03C3},
+	{MISENSOR_16BIT,   0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT,   MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT,   MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT,   MISENSOR_CROP_HORZ_END, 0x0500},
+	{MISENSOR_16BIT,   MISENSOR_CROP_VERT_END, 0x03C0},
+	{MISENSOR_8BIT,    0xC85C, 0x03},
+	{MISENSOR_16BIT,   MISENSOR_OUTPUT_WIDTH, 0x02D0},
+	{MISENSOR_16BIT,   MISENSOR_OUTPUT_HEIGHT, 0x0240},
+	{MISENSOR_8BIT,    0xC878, 0x00},
+	{MISENSOR_16BIT,   0xC88C, 0x1900},
+	{MISENSOR_16BIT,   0xC88E, 0x1900},
+	{MISENSOR_16BIT,   0xC914, 0x0000},
+	{MISENSOR_16BIT,   0xC916, 0x0000},
+	{MISENSOR_16BIT,   0xC918, 0x02CF},
+	{MISENSOR_16BIT,   0xC91A, 0x023F},
+	{MISENSOR_16BIT,   0xC91C, 0x0000},
+	{MISENSOR_16BIT,   0xC91E, 0x0000},
+	{MISENSOR_16BIT,   0xC920, 0x008F},
+	{MISENSOR_16BIT,   0xC922, 0x0072},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_800x480_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MAX, 0x05B3},
+	{MISENSOR_16BIT, MISENSOR_FRAME_LENGTH_LINES, 0x03EE},
+	{MISENSOR_16BIT, MISENSOR_LINE_LENGTH_PCK, 0x0636},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_END, 0x0500},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_END, 0x0300},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_WIDTH, 0x0320},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_HEIGHT, 0x01E0},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E02},
+	{MISENSOR_16BIT, 0xC88E, 0x1E02},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x031F},
+	{MISENSOR_16BIT, 0xC91A, 0x01DF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x009F},
+	{MISENSOR_16BIT, 0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_960x540_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MAX, 0x05B3},
+	{MISENSOR_16BIT, MISENSOR_FRAME_LENGTH_LINES, 0x03EE},
+	{MISENSOR_16BIT, MISENSOR_LINE_LENGTH_PCK, 0x0636},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_START, 0x0078},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_END, 0x0500},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_END, 0x02D0},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_WIDTH, 0x03C0},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_HEIGHT, 0x021C},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E02},
+	{MISENSOR_16BIT, 0xC88E, 0x1E02},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x03BF},
+	{MISENSOR_16BIT, 0xC91A, 0x021B},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x00BF},
+	{MISENSOR_16BIT, 0xC922, 0x006B},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_720x480_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MAX, 0x05B3},
+	{MISENSOR_16BIT, MISENSOR_FRAME_LENGTH_LINES, 0x03EE},
+	{MISENSOR_16BIT, MISENSOR_LINE_LENGTH_PCK, 0x0636},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_START, 0x0001},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_START, 0x0036},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_END, 0x04FE},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_END, 0x0354},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_WIDTH, 0x02D0},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_HEIGHT, 0x01E0},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E02},
+	{MISENSOR_16BIT, 0xC88E, 0x1E02},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x02CF},
+	{MISENSOR_16BIT, 0xC91A, 0x01DF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x008F},
+	{MISENSOR_16BIT, 0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_736x480_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0064},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x036B},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MAX, 0x05BD},
+	{MISENSOR_16BIT, MISENSOR_FRAME_LENGTH_LINES, 0x03E8},
+	{MISENSOR_16BIT, MISENSOR_LINE_LENGTH_PCK, 0x0640},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x0303},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_END, 0x049A},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_END, 0x0300},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_WIDTH, 736},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_HEIGHT, 480},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E00},
+	{MISENSOR_16BIT, 0xC88E, 0x1E00},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x02DF},
+	{MISENSOR_16BIT, 0xC91A, 0x01DF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x0092},
+	{MISENSOR_16BIT, 0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_736x576_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MAX, 0x05B3},
+	{MISENSOR_16BIT, MISENSOR_FRAME_LENGTH_LINES, 0x03EE},
+	{MISENSOR_16BIT, MISENSOR_LINE_LENGTH_PCK, 0x0636},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_START, 0x001B},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_END, 0x04CA},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_END, 0x03C0},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_WIDTH, 736},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_HEIGHT, 576},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E02},
+	{MISENSOR_16BIT, 0xC88E, 0x1E02},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x02DF},
+	{MISENSOR_16BIT, 0xC91A, 0x023F},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x0092},
+	{MISENSOR_16BIT, 0xC922, 0x0072},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_1280x768_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0064},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x036B},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MAX, 0x05B1},
+	{MISENSOR_16BIT, MISENSOR_FRAME_LENGTH_LINES, 0x03EF},
+	{MISENSOR_16BIT, MISENSOR_LINE_LENGTH_PCK, 0x0634},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x0303},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0330, 0},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_END, 0x0500},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_END, 0x0300},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_WIDTH, 0x0500},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_HEIGHT, 0x0300},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E04},
+	{MISENSOR_16BIT, 0xC88E, 0x1E04},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x04FF},
+	{MISENSOR_16BIT, 0xC91A, 0x02FF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x00FF},
+	{MISENSOR_16BIT, 0xC922, 0x0098},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_1280x800_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0054},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x037B},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, MISENSOR_PIX_CLK, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MIN, 0x00DB},
+	{MISENSOR_16BIT, MISENSOR_FINE_INTG_TIME_MAX, 0x05BD},
+	{MISENSOR_16BIT, MISENSOR_FRAME_LENGTH_LINES, 0x03E8},
+	{MISENSOR_16BIT, MISENSOR_LINE_LENGTH_PCK, 0x0640},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x0323},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, MISENSOR_READ_MODE, 0x0000, 0},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_START, 0x0000},
+	{MISENSOR_16BIT, MISENSOR_CROP_HORZ_END, 0x0500},
+	{MISENSOR_16BIT, MISENSOR_CROP_VERT_END, 0x0320},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_WIDTH, 0x0500},
+	{MISENSOR_16BIT, MISENSOR_OUTPUT_HEIGHT, 0x0320},
+	{MISENSOR_8BIT, 0xC878, 0x00},
+	{MISENSOR_16BIT, 0xC88C, 0x1E00},
+	{MISENSOR_16BIT, 0xC88E, 0x1E00},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x04FF},
+	{MISENSOR_16BIT, 0xC91A, 0x031F},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x00FF},
+	{MISENSOR_16BIT, 0xC922, 0x009F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_common[] = {
+	/* reset */
+	{MISENSOR_16BIT,  0x301A, 0x0234},
+	/* pll settings for MT9M114 */
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_8BIT,   0xC97E, 0x01},
+	{MISENSOR_16BIT,   0xC980, 0x0128},
+	{MISENSOR_16BIT,   0xC982, 0x0700},
+	/*MIPI settings for MT9M114*/
+	{MISENSOR_16BIT,  0xC984, 0x8041},
+	{MISENSOR_16BIT,  0xC988, 0x0F00},
+	{MISENSOR_16BIT,  0xC98A, 0x0B07},
+	{MISENSOR_16BIT,  0xC98C, 0x0D01},
+	{MISENSOR_16BIT,  0xC98E, 0x071D},
+	{MISENSOR_16BIT,  0xC990, 0x0006},
+	{MISENSOR_16BIT,  0xC992, 0x0A0C},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_antiflicker_50hz[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xC88B},
+	 {MISENSOR_8BIT,  0xC88B, 0x32},
+	 {MISENSOR_8BIT,  0xDC00, 0x28},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_antiflicker_60hz[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xC88B},
+	 {MISENSOR_8BIT,  0xC88B, 0x3C},
+	 {MISENSOR_8BIT,  0xDC00, 0x28},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_iq[] = {
+	/* [Step3-Recommended] [Sensor optimization] */
+	{MISENSOR_16BIT,	0x316A, 0x8270},
+	{MISENSOR_16BIT,	0x316C, 0x8270},
+	{MISENSOR_16BIT,	0x3ED0, 0x2305},
+	{MISENSOR_16BIT,	0x3ED2, 0x77CF},
+	{MISENSOR_16BIT,	0x316E, 0x8202},
+	{MISENSOR_16BIT,	0x3180, 0x87FF},
+	{MISENSOR_16BIT,	0x30D4, 0x6080},
+	{MISENSOR_16BIT,	0xA802, 0x0008},
+
+	/* LOAD=Errata item 1 */
+	{MISENSOR_16BIT,	0x3E14, 0xFF39},
+
+	/* LOAD=Errata item 2 */
+	{MISENSOR_16BIT,	0x301A, 0x8234},
+
+	/*
+	 * LOAD=Errata item 3
+	 * LOAD=Patch 0202;
+	 * Feature Recommended; Black level correction fix
+	 */
+	{MISENSOR_16BIT,	0x0982, 0x0001},
+	{MISENSOR_16BIT,	0x098A, 0x5000},
+	{MISENSOR_16BIT,	0xD000, 0x70CF},
+	{MISENSOR_16BIT,	0xD002, 0xFFFF},
+	{MISENSOR_16BIT,	0xD004, 0xC5D4},
+	{MISENSOR_16BIT,	0xD006, 0x903A},
+	{MISENSOR_16BIT,	0xD008, 0x2144},
+	{MISENSOR_16BIT,	0xD00A, 0x0C00},
+	{MISENSOR_16BIT,	0xD00C, 0x2186},
+	{MISENSOR_16BIT,	0xD00E, 0x0FF3},
+	{MISENSOR_16BIT,	0xD010, 0xB844},
+	{MISENSOR_16BIT,	0xD012, 0xB948},
+	{MISENSOR_16BIT,	0xD014, 0xE082},
+	{MISENSOR_16BIT,	0xD016, 0x20CC},
+	{MISENSOR_16BIT,	0xD018, 0x80E2},
+	{MISENSOR_16BIT,	0xD01A, 0x21CC},
+	{MISENSOR_16BIT,	0xD01C, 0x80A2},
+	{MISENSOR_16BIT,	0xD01E, 0x21CC},
+	{MISENSOR_16BIT,	0xD020, 0x80E2},
+	{MISENSOR_16BIT,	0xD022, 0xF404},
+	{MISENSOR_16BIT,	0xD024, 0xD801},
+	{MISENSOR_16BIT,	0xD026, 0xF003},
+	{MISENSOR_16BIT,	0xD028, 0xD800},
+	{MISENSOR_16BIT,	0xD02A, 0x7EE0},
+	{MISENSOR_16BIT,	0xD02C, 0xC0F1},
+	{MISENSOR_16BIT,	0xD02E, 0x08BA},
+
+	{MISENSOR_16BIT,	0xD030, 0x0600},
+	{MISENSOR_16BIT,	0xD032, 0xC1A1},
+	{MISENSOR_16BIT,	0xD034, 0x76CF},
+	{MISENSOR_16BIT,	0xD036, 0xFFFF},
+	{MISENSOR_16BIT,	0xD038, 0xC130},
+	{MISENSOR_16BIT,	0xD03A, 0x6E04},
+	{MISENSOR_16BIT,	0xD03C, 0xC040},
+	{MISENSOR_16BIT,	0xD03E, 0x71CF},
+	{MISENSOR_16BIT,	0xD040, 0xFFFF},
+	{MISENSOR_16BIT,	0xD042, 0xC790},
+	{MISENSOR_16BIT,	0xD044, 0x8103},
+	{MISENSOR_16BIT,	0xD046, 0x77CF},
+	{MISENSOR_16BIT,	0xD048, 0xFFFF},
+	{MISENSOR_16BIT,	0xD04A, 0xC7C0},
+	{MISENSOR_16BIT,	0xD04C, 0xE001},
+	{MISENSOR_16BIT,	0xD04E, 0xA103},
+	{MISENSOR_16BIT,	0xD050, 0xD800},
+	{MISENSOR_16BIT,	0xD052, 0x0C6A},
+	{MISENSOR_16BIT,	0xD054, 0x04E0},
+	{MISENSOR_16BIT,	0xD056, 0xB89E},
+	{MISENSOR_16BIT,	0xD058, 0x7508},
+	{MISENSOR_16BIT,	0xD05A, 0x8E1C},
+	{MISENSOR_16BIT,	0xD05C, 0x0809},
+	{MISENSOR_16BIT,	0xD05E, 0x0191},
+
+	{MISENSOR_16BIT,	0xD060, 0xD801},
+	{MISENSOR_16BIT,	0xD062, 0xAE1D},
+	{MISENSOR_16BIT,	0xD064, 0xE580},
+	{MISENSOR_16BIT,	0xD066, 0x20CA},
+	{MISENSOR_16BIT,	0xD068, 0x0022},
+	{MISENSOR_16BIT,	0xD06A, 0x20CF},
+	{MISENSOR_16BIT,	0xD06C, 0x0522},
+	{MISENSOR_16BIT,	0xD06E, 0x0C5C},
+	{MISENSOR_16BIT,	0xD070, 0x04E2},
+	{MISENSOR_16BIT,	0xD072, 0x21CA},
+	{MISENSOR_16BIT,	0xD074, 0x0062},
+	{MISENSOR_16BIT,	0xD076, 0xE580},
+	{MISENSOR_16BIT,	0xD078, 0xD901},
+	{MISENSOR_16BIT,	0xD07A, 0x79C0},
+	{MISENSOR_16BIT,	0xD07C, 0xD800},
+	{MISENSOR_16BIT,	0xD07E, 0x0BE6},
+	{MISENSOR_16BIT,	0xD080, 0x04E0},
+	{MISENSOR_16BIT,	0xD082, 0xB89E},
+	{MISENSOR_16BIT,	0xD084, 0x70CF},
+	{MISENSOR_16BIT,	0xD086, 0xFFFF},
+	{MISENSOR_16BIT,	0xD088, 0xC8D4},
+	{MISENSOR_16BIT,	0xD08A, 0x9002},
+	{MISENSOR_16BIT,	0xD08C, 0x0857},
+	{MISENSOR_16BIT,	0xD08E, 0x025E},
+
+	{MISENSOR_16BIT,	0xD090, 0xFFDC},
+	{MISENSOR_16BIT,	0xD092, 0xE080},
+	{MISENSOR_16BIT,	0xD094, 0x25CC},
+	{MISENSOR_16BIT,	0xD096, 0x9022},
+	{MISENSOR_16BIT,	0xD098, 0xF225},
+	{MISENSOR_16BIT,	0xD09A, 0x1700},
+	{MISENSOR_16BIT,	0xD09C, 0x108A},
+	{MISENSOR_16BIT,	0xD09E, 0x73CF},
+	{MISENSOR_16BIT,	0xD0A0, 0xFF00},
+	{MISENSOR_16BIT,	0xD0A2, 0x3174},
+	{MISENSOR_16BIT,	0xD0A4, 0x9307},
+	{MISENSOR_16BIT,	0xD0A6, 0x2A04},
+	{MISENSOR_16BIT,	0xD0A8, 0x103E},
+	{MISENSOR_16BIT,	0xD0AA, 0x9328},
+	{MISENSOR_16BIT,	0xD0AC, 0x2942},
+	{MISENSOR_16BIT,	0xD0AE, 0x7140},
+	{MISENSOR_16BIT,	0xD0B0, 0x2A04},
+	{MISENSOR_16BIT,	0xD0B2, 0x107E},
+	{MISENSOR_16BIT,	0xD0B4, 0x9349},
+	{MISENSOR_16BIT,	0xD0B6, 0x2942},
+	{MISENSOR_16BIT,	0xD0B8, 0x7141},
+	{MISENSOR_16BIT,	0xD0BA, 0x2A04},
+	{MISENSOR_16BIT,	0xD0BC, 0x10BE},
+	{MISENSOR_16BIT,	0xD0BE, 0x934A},
+
+	{MISENSOR_16BIT,	0xD0C0, 0x2942},
+	{MISENSOR_16BIT,	0xD0C2, 0x714B},
+	{MISENSOR_16BIT,	0xD0C4, 0x2A04},
+	{MISENSOR_16BIT,	0xD0C6, 0x10BE},
+	{MISENSOR_16BIT,	0xD0C8, 0x130C},
+	{MISENSOR_16BIT,	0xD0CA, 0x010A},
+	{MISENSOR_16BIT,	0xD0CC, 0x2942},
+	{MISENSOR_16BIT,	0xD0CE, 0x7142},
+	{MISENSOR_16BIT,	0xD0D0, 0x2250},
+	{MISENSOR_16BIT,	0xD0D2, 0x13CA},
+	{MISENSOR_16BIT,	0xD0D4, 0x1B0C},
+	{MISENSOR_16BIT,	0xD0D6, 0x0284},
+	{MISENSOR_16BIT,	0xD0D8, 0xB307},
+	{MISENSOR_16BIT,	0xD0DA, 0xB328},
+	{MISENSOR_16BIT,	0xD0DC, 0x1B12},
+	{MISENSOR_16BIT,	0xD0DE, 0x02C4},
+	{MISENSOR_16BIT,	0xD0E0, 0xB34A},
+	{MISENSOR_16BIT,	0xD0E2, 0xED88},
+	{MISENSOR_16BIT,	0xD0E4, 0x71CF},
+	{MISENSOR_16BIT,	0xD0E6, 0xFF00},
+	{MISENSOR_16BIT,	0xD0E8, 0x3174},
+	{MISENSOR_16BIT,	0xD0EA, 0x9106},
+	{MISENSOR_16BIT,	0xD0EC, 0xB88F},
+	{MISENSOR_16BIT,	0xD0EE, 0xB106},
+
+	{MISENSOR_16BIT,	0xD0F0, 0x210A},
+	{MISENSOR_16BIT,	0xD0F2, 0x8340},
+	{MISENSOR_16BIT,	0xD0F4, 0xC000},
+	{MISENSOR_16BIT,	0xD0F6, 0x21CA},
+	{MISENSOR_16BIT,	0xD0F8, 0x0062},
+	{MISENSOR_16BIT,	0xD0FA, 0x20F0},
+	{MISENSOR_16BIT,	0xD0FC, 0x0040},
+	{MISENSOR_16BIT,	0xD0FE, 0x0B02},
+	{MISENSOR_16BIT,	0xD100, 0x0320},
+	{MISENSOR_16BIT,	0xD102, 0xD901},
+	{MISENSOR_16BIT,	0xD104, 0x07F1},
+	{MISENSOR_16BIT,	0xD106, 0x05E0},
+	{MISENSOR_16BIT,	0xD108, 0xC0A1},
+	{MISENSOR_16BIT,	0xD10A, 0x78E0},
+	{MISENSOR_16BIT,	0xD10C, 0xC0F1},
+	{MISENSOR_16BIT,	0xD10E, 0x71CF},
+	{MISENSOR_16BIT,	0xD110, 0xFFFF},
+	{MISENSOR_16BIT,	0xD112, 0xC7C0},
+	{MISENSOR_16BIT,	0xD114, 0xD840},
+	{MISENSOR_16BIT,	0xD116, 0xA900},
+	{MISENSOR_16BIT,	0xD118, 0x71CF},
+	{MISENSOR_16BIT,	0xD11A, 0xFFFF},
+	{MISENSOR_16BIT,	0xD11C, 0xD02C},
+	{MISENSOR_16BIT,	0xD11E, 0xD81E},
+
+	{MISENSOR_16BIT,	0xD120, 0x0A5A},
+	{MISENSOR_16BIT,	0xD122, 0x04E0},
+	{MISENSOR_16BIT,	0xD124, 0xDA00},
+	{MISENSOR_16BIT,	0xD126, 0xD800},
+	{MISENSOR_16BIT,	0xD128, 0xC0D1},
+	{MISENSOR_16BIT,	0xD12A, 0x7EE0},
+
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xE000, 0x010C},
+	{MISENSOR_16BIT,	0xE002, 0x0202},
+	{MISENSOR_16BIT,	0xE004, 0x4103},
+	{MISENSOR_16BIT,	0xE006, 0x0202},
+	{MISENSOR_16BIT,	0x0080, 0xFFF0},
+	{MISENSOR_16BIT,	0x0080, 0xFFF1},
+
+	/* LOAD=Patch 0302; Feature Recommended; Adaptive Sensitivity */
+	{MISENSOR_16BIT,	0x0982, 0x0001},
+	{MISENSOR_16BIT,	0x098A, 0x512C},
+	{MISENSOR_16BIT,	0xD12C, 0x70CF},
+	{MISENSOR_16BIT,	0xD12E, 0xFFFF},
+	{MISENSOR_16BIT,	0xD130, 0xC5D4},
+	{MISENSOR_16BIT,	0xD132, 0x903A},
+	{MISENSOR_16BIT,	0xD134, 0x2144},
+	{MISENSOR_16BIT,	0xD136, 0x0C00},
+	{MISENSOR_16BIT,	0xD138, 0x2186},
+	{MISENSOR_16BIT,	0xD13A, 0x0FF3},
+	{MISENSOR_16BIT,	0xD13C, 0xB844},
+	{MISENSOR_16BIT,	0xD13E, 0x262F},
+	{MISENSOR_16BIT,	0xD140, 0xF008},
+	{MISENSOR_16BIT,	0xD142, 0xB948},
+	{MISENSOR_16BIT,	0xD144, 0x21CC},
+	{MISENSOR_16BIT,	0xD146, 0x8021},
+	{MISENSOR_16BIT,	0xD148, 0xD801},
+	{MISENSOR_16BIT,	0xD14A, 0xF203},
+	{MISENSOR_16BIT,	0xD14C, 0xD800},
+	{MISENSOR_16BIT,	0xD14E, 0x7EE0},
+	{MISENSOR_16BIT,	0xD150, 0xC0F1},
+	{MISENSOR_16BIT,	0xD152, 0x71CF},
+	{MISENSOR_16BIT,	0xD154, 0xFFFF},
+	{MISENSOR_16BIT,	0xD156, 0xC610},
+	{MISENSOR_16BIT,	0xD158, 0x910E},
+	{MISENSOR_16BIT,	0xD15A, 0x208C},
+	{MISENSOR_16BIT,	0xD15C, 0x8014},
+	{MISENSOR_16BIT,	0xD15E, 0xF418},
+	{MISENSOR_16BIT,	0xD160, 0x910F},
+	{MISENSOR_16BIT,	0xD162, 0x208C},
+	{MISENSOR_16BIT,	0xD164, 0x800F},
+	{MISENSOR_16BIT,	0xD166, 0xF414},
+	{MISENSOR_16BIT,	0xD168, 0x9116},
+	{MISENSOR_16BIT,	0xD16A, 0x208C},
+	{MISENSOR_16BIT,	0xD16C, 0x800A},
+	{MISENSOR_16BIT,	0xD16E, 0xF410},
+	{MISENSOR_16BIT,	0xD170, 0x9117},
+	{MISENSOR_16BIT,	0xD172, 0x208C},
+	{MISENSOR_16BIT,	0xD174, 0x8807},
+	{MISENSOR_16BIT,	0xD176, 0xF40C},
+	{MISENSOR_16BIT,	0xD178, 0x9118},
+	{MISENSOR_16BIT,	0xD17A, 0x2086},
+	{MISENSOR_16BIT,	0xD17C, 0x0FF3},
+	{MISENSOR_16BIT,	0xD17E, 0xB848},
+	{MISENSOR_16BIT,	0xD180, 0x080D},
+	{MISENSOR_16BIT,	0xD182, 0x0090},
+	{MISENSOR_16BIT,	0xD184, 0xFFEA},
+	{MISENSOR_16BIT,	0xD186, 0xE081},
+	{MISENSOR_16BIT,	0xD188, 0xD801},
+	{MISENSOR_16BIT,	0xD18A, 0xF203},
+	{MISENSOR_16BIT,	0xD18C, 0xD800},
+	{MISENSOR_16BIT,	0xD18E, 0xC0D1},
+	{MISENSOR_16BIT,	0xD190, 0x7EE0},
+	{MISENSOR_16BIT,	0xD192, 0x78E0},
+	{MISENSOR_16BIT,	0xD194, 0xC0F1},
+	{MISENSOR_16BIT,	0xD196, 0x71CF},
+	{MISENSOR_16BIT,	0xD198, 0xFFFF},
+	{MISENSOR_16BIT,	0xD19A, 0xC610},
+	{MISENSOR_16BIT,	0xD19C, 0x910E},
+	{MISENSOR_16BIT,	0xD19E, 0x208C},
+	{MISENSOR_16BIT,	0xD1A0, 0x800A},
+	{MISENSOR_16BIT,	0xD1A2, 0xF418},
+	{MISENSOR_16BIT,	0xD1A4, 0x910F},
+	{MISENSOR_16BIT,	0xD1A6, 0x208C},
+	{MISENSOR_16BIT,	0xD1A8, 0x8807},
+	{MISENSOR_16BIT,	0xD1AA, 0xF414},
+	{MISENSOR_16BIT,	0xD1AC, 0x9116},
+	{MISENSOR_16BIT,	0xD1AE, 0x208C},
+	{MISENSOR_16BIT,	0xD1B0, 0x800A},
+	{MISENSOR_16BIT,	0xD1B2, 0xF410},
+	{MISENSOR_16BIT,	0xD1B4, 0x9117},
+	{MISENSOR_16BIT,	0xD1B6, 0x208C},
+	{MISENSOR_16BIT,	0xD1B8, 0x8807},
+	{MISENSOR_16BIT,	0xD1BA, 0xF40C},
+	{MISENSOR_16BIT,	0xD1BC, 0x9118},
+	{MISENSOR_16BIT,	0xD1BE, 0x2086},
+	{MISENSOR_16BIT,	0xD1C0, 0x0FF3},
+	{MISENSOR_16BIT,	0xD1C2, 0xB848},
+	{MISENSOR_16BIT,	0xD1C4, 0x080D},
+	{MISENSOR_16BIT,	0xD1C6, 0x0090},
+	{MISENSOR_16BIT,	0xD1C8, 0xFFD9},
+	{MISENSOR_16BIT,	0xD1CA, 0xE080},
+	{MISENSOR_16BIT,	0xD1CC, 0xD801},
+	{MISENSOR_16BIT,	0xD1CE, 0xF203},
+	{MISENSOR_16BIT,	0xD1D0, 0xD800},
+	{MISENSOR_16BIT,	0xD1D2, 0xF1DF},
+	{MISENSOR_16BIT,	0xD1D4, 0x9040},
+	{MISENSOR_16BIT,	0xD1D6, 0x71CF},
+	{MISENSOR_16BIT,	0xD1D8, 0xFFFF},
+	{MISENSOR_16BIT,	0xD1DA, 0xC5D4},
+	{MISENSOR_16BIT,	0xD1DC, 0xB15A},
+	{MISENSOR_16BIT,	0xD1DE, 0x9041},
+	{MISENSOR_16BIT,	0xD1E0, 0x73CF},
+	{MISENSOR_16BIT,	0xD1E2, 0xFFFF},
+	{MISENSOR_16BIT,	0xD1E4, 0xC7D0},
+	{MISENSOR_16BIT,	0xD1E6, 0xB140},
+	{MISENSOR_16BIT,	0xD1E8, 0x9042},
+	{MISENSOR_16BIT,	0xD1EA, 0xB141},
+	{MISENSOR_16BIT,	0xD1EC, 0x9043},
+	{MISENSOR_16BIT,	0xD1EE, 0xB142},
+	{MISENSOR_16BIT,	0xD1F0, 0x9044},
+	{MISENSOR_16BIT,	0xD1F2, 0xB143},
+	{MISENSOR_16BIT,	0xD1F4, 0x9045},
+	{MISENSOR_16BIT,	0xD1F6, 0xB147},
+	{MISENSOR_16BIT,	0xD1F8, 0x9046},
+	{MISENSOR_16BIT,	0xD1FA, 0xB148},
+	{MISENSOR_16BIT,	0xD1FC, 0x9047},
+	{MISENSOR_16BIT,	0xD1FE, 0xB14B},
+	{MISENSOR_16BIT,	0xD200, 0x9048},
+	{MISENSOR_16BIT,	0xD202, 0xB14C},
+	{MISENSOR_16BIT,	0xD204, 0x9049},
+	{MISENSOR_16BIT,	0xD206, 0x1958},
+	{MISENSOR_16BIT,	0xD208, 0x0084},
+	{MISENSOR_16BIT,	0xD20A, 0x904A},
+	{MISENSOR_16BIT,	0xD20C, 0x195A},
+	{MISENSOR_16BIT,	0xD20E, 0x0084},
+	{MISENSOR_16BIT,	0xD210, 0x8856},
+	{MISENSOR_16BIT,	0xD212, 0x1B36},
+	{MISENSOR_16BIT,	0xD214, 0x8082},
+	{MISENSOR_16BIT,	0xD216, 0x8857},
+	{MISENSOR_16BIT,	0xD218, 0x1B37},
+	{MISENSOR_16BIT,	0xD21A, 0x8082},
+	{MISENSOR_16BIT,	0xD21C, 0x904C},
+	{MISENSOR_16BIT,	0xD21E, 0x19A7},
+	{MISENSOR_16BIT,	0xD220, 0x009C},
+	{MISENSOR_16BIT,	0xD222, 0x881A},
+	{MISENSOR_16BIT,	0xD224, 0x7FE0},
+	{MISENSOR_16BIT,	0xD226, 0x1B54},
+	{MISENSOR_16BIT,	0xD228, 0x8002},
+	{MISENSOR_16BIT,	0xD22A, 0x78E0},
+	{MISENSOR_16BIT,	0xD22C, 0x71CF},
+	{MISENSOR_16BIT,	0xD22E, 0xFFFF},
+	{MISENSOR_16BIT,	0xD230, 0xC350},
+	{MISENSOR_16BIT,	0xD232, 0xD828},
+	{MISENSOR_16BIT,	0xD234, 0xA90B},
+	{MISENSOR_16BIT,	0xD236, 0x8100},
+	{MISENSOR_16BIT,	0xD238, 0x01C5},
+	{MISENSOR_16BIT,	0xD23A, 0x0320},
+	{MISENSOR_16BIT,	0xD23C, 0xD900},
+	{MISENSOR_16BIT,	0xD23E, 0x78E0},
+	{MISENSOR_16BIT,	0xD240, 0x220A},
+	{MISENSOR_16BIT,	0xD242, 0x1F80},
+	{MISENSOR_16BIT,	0xD244, 0xFFFF},
+	{MISENSOR_16BIT,	0xD246, 0xD4E0},
+	{MISENSOR_16BIT,	0xD248, 0xC0F1},
+	{MISENSOR_16BIT,	0xD24A, 0x0811},
+	{MISENSOR_16BIT,	0xD24C, 0x0051},
+	{MISENSOR_16BIT,	0xD24E, 0x2240},
+	{MISENSOR_16BIT,	0xD250, 0x1200},
+	{MISENSOR_16BIT,	0xD252, 0xFFE1},
+	{MISENSOR_16BIT,	0xD254, 0xD801},
+	{MISENSOR_16BIT,	0xD256, 0xF006},
+	{MISENSOR_16BIT,	0xD258, 0x2240},
+	{MISENSOR_16BIT,	0xD25A, 0x1900},
+	{MISENSOR_16BIT,	0xD25C, 0xFFDE},
+	{MISENSOR_16BIT,	0xD25E, 0xD802},
+	{MISENSOR_16BIT,	0xD260, 0x1A05},
+	{MISENSOR_16BIT,	0xD262, 0x1002},
+	{MISENSOR_16BIT,	0xD264, 0xFFF2},
+	{MISENSOR_16BIT,	0xD266, 0xF195},
+	{MISENSOR_16BIT,	0xD268, 0xC0F1},
+	{MISENSOR_16BIT,	0xD26A, 0x0E7E},
+	{MISENSOR_16BIT,	0xD26C, 0x05C0},
+	{MISENSOR_16BIT,	0xD26E, 0x75CF},
+	{MISENSOR_16BIT,	0xD270, 0xFFFF},
+	{MISENSOR_16BIT,	0xD272, 0xC84C},
+	{MISENSOR_16BIT,	0xD274, 0x9502},
+	{MISENSOR_16BIT,	0xD276, 0x77CF},
+	{MISENSOR_16BIT,	0xD278, 0xFFFF},
+	{MISENSOR_16BIT,	0xD27A, 0xC344},
+	{MISENSOR_16BIT,	0xD27C, 0x2044},
+	{MISENSOR_16BIT,	0xD27E, 0x008E},
+	{MISENSOR_16BIT,	0xD280, 0xB8A1},
+	{MISENSOR_16BIT,	0xD282, 0x0926},
+	{MISENSOR_16BIT,	0xD284, 0x03E0},
+	{MISENSOR_16BIT,	0xD286, 0xB502},
+	{MISENSOR_16BIT,	0xD288, 0x9502},
+	{MISENSOR_16BIT,	0xD28A, 0x952E},
+	{MISENSOR_16BIT,	0xD28C, 0x7E05},
+	{MISENSOR_16BIT,	0xD28E, 0xB5C2},
+	{MISENSOR_16BIT,	0xD290, 0x70CF},
+	{MISENSOR_16BIT,	0xD292, 0xFFFF},
+	{MISENSOR_16BIT,	0xD294, 0xC610},
+	{MISENSOR_16BIT,	0xD296, 0x099A},
+	{MISENSOR_16BIT,	0xD298, 0x04A0},
+	{MISENSOR_16BIT,	0xD29A, 0xB026},
+	{MISENSOR_16BIT,	0xD29C, 0x0E02},
+	{MISENSOR_16BIT,	0xD29E, 0x0560},
+	{MISENSOR_16BIT,	0xD2A0, 0xDE00},
+	{MISENSOR_16BIT,	0xD2A2, 0x0A12},
+	{MISENSOR_16BIT,	0xD2A4, 0x0320},
+	{MISENSOR_16BIT,	0xD2A6, 0xB7C4},
+	{MISENSOR_16BIT,	0xD2A8, 0x0B36},
+	{MISENSOR_16BIT,	0xD2AA, 0x03A0},
+	{MISENSOR_16BIT,	0xD2AC, 0x70C9},
+	{MISENSOR_16BIT,	0xD2AE, 0x9502},
+	{MISENSOR_16BIT,	0xD2B0, 0x7608},
+	{MISENSOR_16BIT,	0xD2B2, 0xB8A8},
+	{MISENSOR_16BIT,	0xD2B4, 0xB502},
+	{MISENSOR_16BIT,	0xD2B6, 0x70CF},
+	{MISENSOR_16BIT,	0xD2B8, 0x0000},
+	{MISENSOR_16BIT,	0xD2BA, 0x5536},
+	{MISENSOR_16BIT,	0xD2BC, 0x7860},
+	{MISENSOR_16BIT,	0xD2BE, 0x2686},
+	{MISENSOR_16BIT,	0xD2C0, 0x1FFB},
+	{MISENSOR_16BIT,	0xD2C2, 0x9502},
+	{MISENSOR_16BIT,	0xD2C4, 0x78C5},
+	{MISENSOR_16BIT,	0xD2C6, 0x0631},
+	{MISENSOR_16BIT,	0xD2C8, 0x05E0},
+	{MISENSOR_16BIT,	0xD2CA, 0xB502},
+	{MISENSOR_16BIT,	0xD2CC, 0x72CF},
+	{MISENSOR_16BIT,	0xD2CE, 0xFFFF},
+	{MISENSOR_16BIT,	0xD2D0, 0xC5D4},
+	{MISENSOR_16BIT,	0xD2D2, 0x923A},
+	{MISENSOR_16BIT,	0xD2D4, 0x73CF},
+	{MISENSOR_16BIT,	0xD2D6, 0xFFFF},
+	{MISENSOR_16BIT,	0xD2D8, 0xC7D0},
+	{MISENSOR_16BIT,	0xD2DA, 0xB020},
+	{MISENSOR_16BIT,	0xD2DC, 0x9220},
+	{MISENSOR_16BIT,	0xD2DE, 0xB021},
+	{MISENSOR_16BIT,	0xD2E0, 0x9221},
+	{MISENSOR_16BIT,	0xD2E2, 0xB022},
+	{MISENSOR_16BIT,	0xD2E4, 0x9222},
+	{MISENSOR_16BIT,	0xD2E6, 0xB023},
+	{MISENSOR_16BIT,	0xD2E8, 0x9223},
+	{MISENSOR_16BIT,	0xD2EA, 0xB024},
+	{MISENSOR_16BIT,	0xD2EC, 0x9227},
+	{MISENSOR_16BIT,	0xD2EE, 0xB025},
+	{MISENSOR_16BIT,	0xD2F0, 0x9228},
+	{MISENSOR_16BIT,	0xD2F2, 0xB026},
+	{MISENSOR_16BIT,	0xD2F4, 0x922B},
+	{MISENSOR_16BIT,	0xD2F6, 0xB027},
+	{MISENSOR_16BIT,	0xD2F8, 0x922C},
+	{MISENSOR_16BIT,	0xD2FA, 0xB028},
+	{MISENSOR_16BIT,	0xD2FC, 0x1258},
+	{MISENSOR_16BIT,	0xD2FE, 0x0101},
+	{MISENSOR_16BIT,	0xD300, 0xB029},
+	{MISENSOR_16BIT,	0xD302, 0x125A},
+	{MISENSOR_16BIT,	0xD304, 0x0101},
+	{MISENSOR_16BIT,	0xD306, 0xB02A},
+	{MISENSOR_16BIT,	0xD308, 0x1336},
+	{MISENSOR_16BIT,	0xD30A, 0x8081},
+	{MISENSOR_16BIT,	0xD30C, 0xA836},
+	{MISENSOR_16BIT,	0xD30E, 0x1337},
+	{MISENSOR_16BIT,	0xD310, 0x8081},
+	{MISENSOR_16BIT,	0xD312, 0xA837},
+	{MISENSOR_16BIT,	0xD314, 0x12A7},
+	{MISENSOR_16BIT,	0xD316, 0x0701},
+	{MISENSOR_16BIT,	0xD318, 0xB02C},
+	{MISENSOR_16BIT,	0xD31A, 0x1354},
+	{MISENSOR_16BIT,	0xD31C, 0x8081},
+	{MISENSOR_16BIT,	0xD31E, 0x7FE0},
+	{MISENSOR_16BIT,	0xD320, 0xA83A},
+	{MISENSOR_16BIT,	0xD322, 0x78E0},
+	{MISENSOR_16BIT,	0xD324, 0xC0F1},
+	{MISENSOR_16BIT,	0xD326, 0x0DC2},
+	{MISENSOR_16BIT,	0xD328, 0x05C0},
+	{MISENSOR_16BIT,	0xD32A, 0x7608},
+	{MISENSOR_16BIT,	0xD32C, 0x09BB},
+	{MISENSOR_16BIT,	0xD32E, 0x0010},
+	{MISENSOR_16BIT,	0xD330, 0x75CF},
+	{MISENSOR_16BIT,	0xD332, 0xFFFF},
+	{MISENSOR_16BIT,	0xD334, 0xD4E0},
+	{MISENSOR_16BIT,	0xD336, 0x8D21},
+	{MISENSOR_16BIT,	0xD338, 0x8D00},
+	{MISENSOR_16BIT,	0xD33A, 0x2153},
+	{MISENSOR_16BIT,	0xD33C, 0x0003},
+	{MISENSOR_16BIT,	0xD33E, 0xB8C0},
+	{MISENSOR_16BIT,	0xD340, 0x8D45},
+	{MISENSOR_16BIT,	0xD342, 0x0B23},
+	{MISENSOR_16BIT,	0xD344, 0x0000},
+	{MISENSOR_16BIT,	0xD346, 0xEA8F},
+	{MISENSOR_16BIT,	0xD348, 0x0915},
+	{MISENSOR_16BIT,	0xD34A, 0x001E},
+	{MISENSOR_16BIT,	0xD34C, 0xFF81},
+	{MISENSOR_16BIT,	0xD34E, 0xE808},
+	{MISENSOR_16BIT,	0xD350, 0x2540},
+	{MISENSOR_16BIT,	0xD352, 0x1900},
+	{MISENSOR_16BIT,	0xD354, 0xFFDE},
+	{MISENSOR_16BIT,	0xD356, 0x8D00},
+	{MISENSOR_16BIT,	0xD358, 0xB880},
+	{MISENSOR_16BIT,	0xD35A, 0xF004},
+	{MISENSOR_16BIT,	0xD35C, 0x8D00},
+	{MISENSOR_16BIT,	0xD35E, 0xB8A0},
+	{MISENSOR_16BIT,	0xD360, 0xAD00},
+	{MISENSOR_16BIT,	0xD362, 0x8D05},
+	{MISENSOR_16BIT,	0xD364, 0xE081},
+	{MISENSOR_16BIT,	0xD366, 0x20CC},
+	{MISENSOR_16BIT,	0xD368, 0x80A2},
+	{MISENSOR_16BIT,	0xD36A, 0xDF00},
+	{MISENSOR_16BIT,	0xD36C, 0xF40A},
+	{MISENSOR_16BIT,	0xD36E, 0x71CF},
+	{MISENSOR_16BIT,	0xD370, 0xFFFF},
+	{MISENSOR_16BIT,	0xD372, 0xC84C},
+	{MISENSOR_16BIT,	0xD374, 0x9102},
+	{MISENSOR_16BIT,	0xD376, 0x7708},
+	{MISENSOR_16BIT,	0xD378, 0xB8A6},
+	{MISENSOR_16BIT,	0xD37A, 0x2786},
+	{MISENSOR_16BIT,	0xD37C, 0x1FFE},
+	{MISENSOR_16BIT,	0xD37E, 0xB102},
+	{MISENSOR_16BIT,	0xD380, 0x0B42},
+	{MISENSOR_16BIT,	0xD382, 0x0180},
+	{MISENSOR_16BIT,	0xD384, 0x0E3E},
+	{MISENSOR_16BIT,	0xD386, 0x0180},
+	{MISENSOR_16BIT,	0xD388, 0x0F4A},
+	{MISENSOR_16BIT,	0xD38A, 0x0160},
+	{MISENSOR_16BIT,	0xD38C, 0x70C9},
+	{MISENSOR_16BIT,	0xD38E, 0x8D05},
+	{MISENSOR_16BIT,	0xD390, 0xE081},
+	{MISENSOR_16BIT,	0xD392, 0x20CC},
+	{MISENSOR_16BIT,	0xD394, 0x80A2},
+	{MISENSOR_16BIT,	0xD396, 0xF429},
+	{MISENSOR_16BIT,	0xD398, 0x76CF},
+	{MISENSOR_16BIT,	0xD39A, 0xFFFF},
+	{MISENSOR_16BIT,	0xD39C, 0xC84C},
+	{MISENSOR_16BIT,	0xD39E, 0x082D},
+	{MISENSOR_16BIT,	0xD3A0, 0x0051},
+	{MISENSOR_16BIT,	0xD3A2, 0x70CF},
+	{MISENSOR_16BIT,	0xD3A4, 0xFFFF},
+	{MISENSOR_16BIT,	0xD3A6, 0xC90C},
+	{MISENSOR_16BIT,	0xD3A8, 0x8805},
+	{MISENSOR_16BIT,	0xD3AA, 0x09B6},
+	{MISENSOR_16BIT,	0xD3AC, 0x0360},
+	{MISENSOR_16BIT,	0xD3AE, 0xD908},
+	{MISENSOR_16BIT,	0xD3B0, 0x2099},
+	{MISENSOR_16BIT,	0xD3B2, 0x0802},
+	{MISENSOR_16BIT,	0xD3B4, 0x9634},
+	{MISENSOR_16BIT,	0xD3B6, 0xB503},
+	{MISENSOR_16BIT,	0xD3B8, 0x7902},
+	{MISENSOR_16BIT,	0xD3BA, 0x1523},
+	{MISENSOR_16BIT,	0xD3BC, 0x1080},
+	{MISENSOR_16BIT,	0xD3BE, 0xB634},
+	{MISENSOR_16BIT,	0xD3C0, 0xE001},
+	{MISENSOR_16BIT,	0xD3C2, 0x1D23},
+	{MISENSOR_16BIT,	0xD3C4, 0x1002},
+	{MISENSOR_16BIT,	0xD3C6, 0xF00B},
+	{MISENSOR_16BIT,	0xD3C8, 0x9634},
+	{MISENSOR_16BIT,	0xD3CA, 0x9503},
+	{MISENSOR_16BIT,	0xD3CC, 0x6038},
+	{MISENSOR_16BIT,	0xD3CE, 0xB614},
+	{MISENSOR_16BIT,	0xD3D0, 0x153F},
+	{MISENSOR_16BIT,	0xD3D2, 0x1080},
+	{MISENSOR_16BIT,	0xD3D4, 0xE001},
+	{MISENSOR_16BIT,	0xD3D6, 0x1D3F},
+	{MISENSOR_16BIT,	0xD3D8, 0x1002},
+	{MISENSOR_16BIT,	0xD3DA, 0xFFA4},
+	{MISENSOR_16BIT,	0xD3DC, 0x9602},
+	{MISENSOR_16BIT,	0xD3DE, 0x7F05},
+	{MISENSOR_16BIT,	0xD3E0, 0xD800},
+	{MISENSOR_16BIT,	0xD3E2, 0xB6E2},
+	{MISENSOR_16BIT,	0xD3E4, 0xAD05},
+	{MISENSOR_16BIT,	0xD3E6, 0x0511},
+	{MISENSOR_16BIT,	0xD3E8, 0x05E0},
+	{MISENSOR_16BIT,	0xD3EA, 0xD800},
+	{MISENSOR_16BIT,	0xD3EC, 0xC0F1},
+	{MISENSOR_16BIT,	0xD3EE, 0x0CFE},
+	{MISENSOR_16BIT,	0xD3F0, 0x05C0},
+	{MISENSOR_16BIT,	0xD3F2, 0x0A96},
+	{MISENSOR_16BIT,	0xD3F4, 0x05A0},
+	{MISENSOR_16BIT,	0xD3F6, 0x7608},
+	{MISENSOR_16BIT,	0xD3F8, 0x0C22},
+	{MISENSOR_16BIT,	0xD3FA, 0x0240},
+	{MISENSOR_16BIT,	0xD3FC, 0xE080},
+	{MISENSOR_16BIT,	0xD3FE, 0x20CA},
+	{MISENSOR_16BIT,	0xD400, 0x0F82},
+	{MISENSOR_16BIT,	0xD402, 0x0000},
+	{MISENSOR_16BIT,	0xD404, 0x190B},
+	{MISENSOR_16BIT,	0xD406, 0x0C60},
+	{MISENSOR_16BIT,	0xD408, 0x05A2},
+	{MISENSOR_16BIT,	0xD40A, 0x21CA},
+	{MISENSOR_16BIT,	0xD40C, 0x0022},
+	{MISENSOR_16BIT,	0xD40E, 0x0C56},
+	{MISENSOR_16BIT,	0xD410, 0x0240},
+	{MISENSOR_16BIT,	0xD412, 0xE806},
+	{MISENSOR_16BIT,	0xD414, 0x0E0E},
+	{MISENSOR_16BIT,	0xD416, 0x0220},
+	{MISENSOR_16BIT,	0xD418, 0x70C9},
+	{MISENSOR_16BIT,	0xD41A, 0xF048},
+	{MISENSOR_16BIT,	0xD41C, 0x0896},
+	{MISENSOR_16BIT,	0xD41E, 0x0440},
+	{MISENSOR_16BIT,	0xD420, 0x0E96},
+	{MISENSOR_16BIT,	0xD422, 0x0400},
+	{MISENSOR_16BIT,	0xD424, 0x0966},
+	{MISENSOR_16BIT,	0xD426, 0x0380},
+	{MISENSOR_16BIT,	0xD428, 0x75CF},
+	{MISENSOR_16BIT,	0xD42A, 0xFFFF},
+	{MISENSOR_16BIT,	0xD42C, 0xD4E0},
+	{MISENSOR_16BIT,	0xD42E, 0x8D00},
+	{MISENSOR_16BIT,	0xD430, 0x084D},
+	{MISENSOR_16BIT,	0xD432, 0x001E},
+	{MISENSOR_16BIT,	0xD434, 0xFF47},
+	{MISENSOR_16BIT,	0xD436, 0x080D},
+	{MISENSOR_16BIT,	0xD438, 0x0050},
+	{MISENSOR_16BIT,	0xD43A, 0xFF57},
+	{MISENSOR_16BIT,	0xD43C, 0x0841},
+	{MISENSOR_16BIT,	0xD43E, 0x0051},
+	{MISENSOR_16BIT,	0xD440, 0x8D04},
+	{MISENSOR_16BIT,	0xD442, 0x9521},
+	{MISENSOR_16BIT,	0xD444, 0xE064},
+	{MISENSOR_16BIT,	0xD446, 0x790C},
+	{MISENSOR_16BIT,	0xD448, 0x702F},
+	{MISENSOR_16BIT,	0xD44A, 0x0CE2},
+	{MISENSOR_16BIT,	0xD44C, 0x05E0},
+	{MISENSOR_16BIT,	0xD44E, 0xD964},
+	{MISENSOR_16BIT,	0xD450, 0x72CF},
+	{MISENSOR_16BIT,	0xD452, 0xFFFF},
+	{MISENSOR_16BIT,	0xD454, 0xC700},
+	{MISENSOR_16BIT,	0xD456, 0x9235},
+	{MISENSOR_16BIT,	0xD458, 0x0811},
+	{MISENSOR_16BIT,	0xD45A, 0x0043},
+	{MISENSOR_16BIT,	0xD45C, 0xFF3D},
+	{MISENSOR_16BIT,	0xD45E, 0x080D},
+	{MISENSOR_16BIT,	0xD460, 0x0051},
+	{MISENSOR_16BIT,	0xD462, 0xD801},
+	{MISENSOR_16BIT,	0xD464, 0xFF77},
+	{MISENSOR_16BIT,	0xD466, 0xF025},
+	{MISENSOR_16BIT,	0xD468, 0x9501},
+	{MISENSOR_16BIT,	0xD46A, 0x9235},
+	{MISENSOR_16BIT,	0xD46C, 0x0911},
+	{MISENSOR_16BIT,	0xD46E, 0x0003},
+	{MISENSOR_16BIT,	0xD470, 0xFF49},
+	{MISENSOR_16BIT,	0xD472, 0x080D},
+	{MISENSOR_16BIT,	0xD474, 0x0051},
+	{MISENSOR_16BIT,	0xD476, 0xD800},
+	{MISENSOR_16BIT,	0xD478, 0xFF72},
+	{MISENSOR_16BIT,	0xD47A, 0xF01B},
+	{MISENSOR_16BIT,	0xD47C, 0x0886},
+	{MISENSOR_16BIT,	0xD47E, 0x03E0},
+	{MISENSOR_16BIT,	0xD480, 0xD801},
+	{MISENSOR_16BIT,	0xD482, 0x0EF6},
+	{MISENSOR_16BIT,	0xD484, 0x03C0},
+	{MISENSOR_16BIT,	0xD486, 0x0F52},
+	{MISENSOR_16BIT,	0xD488, 0x0340},
+	{MISENSOR_16BIT,	0xD48A, 0x0DBA},
+	{MISENSOR_16BIT,	0xD48C, 0x0200},
+	{MISENSOR_16BIT,	0xD48E, 0x0AF6},
+	{MISENSOR_16BIT,	0xD490, 0x0440},
+	{MISENSOR_16BIT,	0xD492, 0x0C22},
+	{MISENSOR_16BIT,	0xD494, 0x0400},
+	{MISENSOR_16BIT,	0xD496, 0x0D72},
+	{MISENSOR_16BIT,	0xD498, 0x0440},
+	{MISENSOR_16BIT,	0xD49A, 0x0DC2},
+	{MISENSOR_16BIT,	0xD49C, 0x0200},
+	{MISENSOR_16BIT,	0xD49E, 0x0972},
+	{MISENSOR_16BIT,	0xD4A0, 0x0440},
+	{MISENSOR_16BIT,	0xD4A2, 0x0D3A},
+	{MISENSOR_16BIT,	0xD4A4, 0x0220},
+	{MISENSOR_16BIT,	0xD4A6, 0xD820},
+	{MISENSOR_16BIT,	0xD4A8, 0x0BFA},
+	{MISENSOR_16BIT,	0xD4AA, 0x0260},
+	{MISENSOR_16BIT,	0xD4AC, 0x70C9},
+	{MISENSOR_16BIT,	0xD4AE, 0x0451},
+	{MISENSOR_16BIT,	0xD4B0, 0x05C0},
+	{MISENSOR_16BIT,	0xD4B2, 0x78E0},
+	{MISENSOR_16BIT,	0xD4B4, 0xD900},
+	{MISENSOR_16BIT,	0xD4B6, 0xF00A},
+	{MISENSOR_16BIT,	0xD4B8, 0x70CF},
+	{MISENSOR_16BIT,	0xD4BA, 0xFFFF},
+	{MISENSOR_16BIT,	0xD4BC, 0xD520},
+	{MISENSOR_16BIT,	0xD4BE, 0x7835},
+	{MISENSOR_16BIT,	0xD4C0, 0x8041},
+	{MISENSOR_16BIT,	0xD4C2, 0x8000},
+	{MISENSOR_16BIT,	0xD4C4, 0xE102},
+	{MISENSOR_16BIT,	0xD4C6, 0xA040},
+	{MISENSOR_16BIT,	0xD4C8, 0x09F1},
+	{MISENSOR_16BIT,	0xD4CA, 0x8114},
+	{MISENSOR_16BIT,	0xD4CC, 0x71CF},
+	{MISENSOR_16BIT,	0xD4CE, 0xFFFF},
+	{MISENSOR_16BIT,	0xD4D0, 0xD4E0},
+	{MISENSOR_16BIT,	0xD4D2, 0x70CF},
+	{MISENSOR_16BIT,	0xD4D4, 0xFFFF},
+	{MISENSOR_16BIT,	0xD4D6, 0xC594},
+	{MISENSOR_16BIT,	0xD4D8, 0xB03A},
+	{MISENSOR_16BIT,	0xD4DA, 0x7FE0},
+	{MISENSOR_16BIT,	0xD4DC, 0xD800},
+	{MISENSOR_16BIT,	0xD4DE, 0x0000},
+	{MISENSOR_16BIT,	0xD4E0, 0x0000},
+	{MISENSOR_16BIT,	0xD4E2, 0x0500},
+	{MISENSOR_16BIT,	0xD4E4, 0x0500},
+	{MISENSOR_16BIT,	0xD4E6, 0x0200},
+	{MISENSOR_16BIT,	0xD4E8, 0x0330},
+	{MISENSOR_16BIT,	0xD4EA, 0x0000},
+	{MISENSOR_16BIT,	0xD4EC, 0x0000},
+	{MISENSOR_16BIT,	0xD4EE, 0x03CD},
+	{MISENSOR_16BIT,	0xD4F0, 0x050D},
+	{MISENSOR_16BIT,	0xD4F2, 0x01C5},
+	{MISENSOR_16BIT,	0xD4F4, 0x03B3},
+	{MISENSOR_16BIT,	0xD4F6, 0x00E0},
+	{MISENSOR_16BIT,	0xD4F8, 0x01E3},
+	{MISENSOR_16BIT,	0xD4FA, 0x0280},
+	{MISENSOR_16BIT,	0xD4FC, 0x01E0},
+	{MISENSOR_16BIT,	0xD4FE, 0x0109},
+	{MISENSOR_16BIT,	0xD500, 0x0080},
+	{MISENSOR_16BIT,	0xD502, 0x0500},
+	{MISENSOR_16BIT,	0xD504, 0x0000},
+	{MISENSOR_16BIT,	0xD506, 0x0000},
+	{MISENSOR_16BIT,	0xD508, 0x0000},
+	{MISENSOR_16BIT,	0xD50A, 0x0000},
+	{MISENSOR_16BIT,	0xD50C, 0x0000},
+	{MISENSOR_16BIT,	0xD50E, 0x0000},
+	{MISENSOR_16BIT,	0xD510, 0x0000},
+	{MISENSOR_16BIT,	0xD512, 0x0000},
+	{MISENSOR_16BIT,	0xD514, 0x0000},
+	{MISENSOR_16BIT,	0xD516, 0x0000},
+	{MISENSOR_16BIT,	0xD518, 0x0000},
+	{MISENSOR_16BIT,	0xD51A, 0x0000},
+	{MISENSOR_16BIT,	0xD51C, 0x0000},
+	{MISENSOR_16BIT,	0xD51E, 0x0000},
+	{MISENSOR_16BIT,	0xD520, 0xFFFF},
+	{MISENSOR_16BIT,	0xD522, 0xC9B4},
+	{MISENSOR_16BIT,	0xD524, 0xFFFF},
+	{MISENSOR_16BIT,	0xD526, 0xD324},
+	{MISENSOR_16BIT,	0xD528, 0xFFFF},
+	{MISENSOR_16BIT,	0xD52A, 0xCA34},
+	{MISENSOR_16BIT,	0xD52C, 0xFFFF},
+	{MISENSOR_16BIT,	0xD52E, 0xD3EC},
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xE000, 0x04B4},
+	{MISENSOR_16BIT,	0xE002, 0x0302},
+	{MISENSOR_16BIT,	0xE004, 0x4103},
+	{MISENSOR_16BIT,	0xE006, 0x0202},
+	{MISENSOR_16BIT,	0x0080, 0xFFF0},
+	{MISENSOR_16BIT,	0x0080, 0xFFF1},
+
+	/* PGA parameter and APGA
+	 * [Step4-APGA] [TP101_MT9M114_APGA]
+	 */
+	{MISENSOR_16BIT,	0x098E, 0x495E},
+	{MISENSOR_16BIT,	0xC95E, 0x0000},
+	{MISENSOR_16BIT,	0x3640, 0x02B0},
+	{MISENSOR_16BIT,	0x3642, 0x8063},
+	{MISENSOR_16BIT,	0x3644, 0x78D0},
+	{MISENSOR_16BIT,	0x3646, 0x50CC},
+	{MISENSOR_16BIT,	0x3648, 0x3511},
+	{MISENSOR_16BIT,	0x364A, 0x0110},
+	{MISENSOR_16BIT,	0x364C, 0xBD8A},
+	{MISENSOR_16BIT,	0x364E, 0x0CD1},
+	{MISENSOR_16BIT,	0x3650, 0x24ED},
+	{MISENSOR_16BIT,	0x3652, 0x7C11},
+	{MISENSOR_16BIT,	0x3654, 0x0150},
+	{MISENSOR_16BIT,	0x3656, 0x124C},
+	{MISENSOR_16BIT,	0x3658, 0x3130},
+	{MISENSOR_16BIT,	0x365A, 0x508C},
+	{MISENSOR_16BIT,	0x365C, 0x21F1},
+	{MISENSOR_16BIT,	0x365E, 0x0090},
+	{MISENSOR_16BIT,	0x3660, 0xBFCA},
+	{MISENSOR_16BIT,	0x3662, 0x0A11},
+	{MISENSOR_16BIT,	0x3664, 0x4F4B},
+	{MISENSOR_16BIT,	0x3666, 0x28B1},
+	{MISENSOR_16BIT,	0x3680, 0x50A9},
+	{MISENSOR_16BIT,	0x3682, 0xA04B},
+	{MISENSOR_16BIT,	0x3684, 0x0E2D},
+	{MISENSOR_16BIT,	0x3686, 0x73EC},
+	{MISENSOR_16BIT,	0x3688, 0x164F},
+	{MISENSOR_16BIT,	0x368A, 0xF829},
+	{MISENSOR_16BIT,	0x368C, 0xC1A8},
+	{MISENSOR_16BIT,	0x368E, 0xB0EC},
+	{MISENSOR_16BIT,	0x3690, 0xE76A},
+	{MISENSOR_16BIT,	0x3692, 0x69AF},
+	{MISENSOR_16BIT,	0x3694, 0x378C},
+	{MISENSOR_16BIT,	0x3696, 0xA70D},
+	{MISENSOR_16BIT,	0x3698, 0x884F},
+	{MISENSOR_16BIT,	0x369A, 0xEE8B},
+	{MISENSOR_16BIT,	0x369C, 0x5DEF},
+	{MISENSOR_16BIT,	0x369E, 0x27CC},
+	{MISENSOR_16BIT,	0x36A0, 0xCAAC},
+	{MISENSOR_16BIT,	0x36A2, 0x840E},
+	{MISENSOR_16BIT,	0x36A4, 0xDAA9},
+	{MISENSOR_16BIT,	0x36A6, 0xF00C},
+	{MISENSOR_16BIT,	0x36C0, 0x1371},
+	{MISENSOR_16BIT,	0x36C2, 0x272F},
+	{MISENSOR_16BIT,	0x36C4, 0x2293},
+	{MISENSOR_16BIT,	0x36C6, 0xE6D0},
+	{MISENSOR_16BIT,	0x36C8, 0xEC32},
+	{MISENSOR_16BIT,	0x36CA, 0x11B1},
+	{MISENSOR_16BIT,	0x36CC, 0x7BAF},
+	{MISENSOR_16BIT,	0x36CE, 0x5813},
+	{MISENSOR_16BIT,	0x36D0, 0xB871},
+	{MISENSOR_16BIT,	0x36D2, 0x8913},
+	{MISENSOR_16BIT,	0x36D4, 0x4610},
+	{MISENSOR_16BIT,	0x36D6, 0x7EEE},
+	{MISENSOR_16BIT,	0x36D8, 0x0DF3},
+	{MISENSOR_16BIT,	0x36DA, 0xB84F},
+	{MISENSOR_16BIT,	0x36DC, 0xB532},
+	{MISENSOR_16BIT,	0x36DE, 0x1171},
+	{MISENSOR_16BIT,	0x36E0, 0x13CF},
+	{MISENSOR_16BIT,	0x36E2, 0x22F3},
+	{MISENSOR_16BIT,	0x36E4, 0xE090},
+	{MISENSOR_16BIT,	0x36E6, 0x8133},
+	{MISENSOR_16BIT,	0x3700, 0x88AE},
+	{MISENSOR_16BIT,	0x3702, 0x00EA},
+	{MISENSOR_16BIT,	0x3704, 0x344F},
+	{MISENSOR_16BIT,	0x3706, 0xEC88},
+	{MISENSOR_16BIT,	0x3708, 0x3E91},
+	{MISENSOR_16BIT,	0x370A, 0xF12D},
+	{MISENSOR_16BIT,	0x370C, 0xB0EF},
+	{MISENSOR_16BIT,	0x370E, 0x77CD},
+	{MISENSOR_16BIT,	0x3710, 0x7930},
+	{MISENSOR_16BIT,	0x3712, 0x5C12},
+	{MISENSOR_16BIT,	0x3714, 0x500C},
+	{MISENSOR_16BIT,	0x3716, 0x22CE},
+	{MISENSOR_16BIT,	0x3718, 0x2370},
+	{MISENSOR_16BIT,	0x371A, 0x258F},
+	{MISENSOR_16BIT,	0x371C, 0x3D30},
+	{MISENSOR_16BIT,	0x371E, 0x370C},
+	{MISENSOR_16BIT,	0x3720, 0x03ED},
+	{MISENSOR_16BIT,	0x3722, 0x9AD0},
+	{MISENSOR_16BIT,	0x3724, 0x7ECF},
+	{MISENSOR_16BIT,	0x3726, 0x1093},
+	{MISENSOR_16BIT,	0x3740, 0x2391},
+	{MISENSOR_16BIT,	0x3742, 0xAAD0},
+	{MISENSOR_16BIT,	0x3744, 0x28F2},
+	{MISENSOR_16BIT,	0x3746, 0xBA4F},
+	{MISENSOR_16BIT,	0x3748, 0xC536},
+	{MISENSOR_16BIT,	0x374A, 0x1472},
+	{MISENSOR_16BIT,	0x374C, 0xD110},
+	{MISENSOR_16BIT,	0x374E, 0x2933},
+	{MISENSOR_16BIT,	0x3750, 0xD0D1},
+	{MISENSOR_16BIT,	0x3752, 0x9F37},
+	{MISENSOR_16BIT,	0x3754, 0x34D1},
+	{MISENSOR_16BIT,	0x3756, 0x1C6C},
+	{MISENSOR_16BIT,	0x3758, 0x3FD2},
+	{MISENSOR_16BIT,	0x375A, 0xCB72},
+	{MISENSOR_16BIT,	0x375C, 0xBA96},
+	{MISENSOR_16BIT,	0x375E, 0x1551},
+	{MISENSOR_16BIT,	0x3760, 0xB74F},
+	{MISENSOR_16BIT,	0x3762, 0x1672},
+	{MISENSOR_16BIT,	0x3764, 0x84F1},
+	{MISENSOR_16BIT,	0x3766, 0xC2D6},
+	{MISENSOR_16BIT,	0x3782, 0x01E0},
+	{MISENSOR_16BIT,	0x3784, 0x0280},
+	{MISENSOR_16BIT,	0x37C0, 0xA6EA},
+	{MISENSOR_16BIT,	0x37C2, 0x874B},
+	{MISENSOR_16BIT,	0x37C4, 0x85CB},
+	{MISENSOR_16BIT,	0x37C6, 0x968A},
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xC960, 0x0AF0},
+	{MISENSOR_16BIT,	0xC962, 0x79E2},
+	{MISENSOR_16BIT,	0xC964, 0x5EC8},
+	{MISENSOR_16BIT,	0xC966, 0x791F},
+	{MISENSOR_16BIT,	0xC968, 0x76EE},
+	{MISENSOR_16BIT,	0xC96A, 0x0FA0},
+	{MISENSOR_16BIT,	0xC96C, 0x7DFA},
+	{MISENSOR_16BIT,	0xC96E, 0x7DAF},
+	{MISENSOR_16BIT,	0xC970, 0x7E02},
+	{MISENSOR_16BIT,	0xC972, 0x7E0A},
+	{MISENSOR_16BIT,	0xC974, 0x1964},
+	{MISENSOR_16BIT,	0xC976, 0x7CDC},
+	{MISENSOR_16BIT,	0xC978, 0x7838},
+	{MISENSOR_16BIT,	0xC97A, 0x7C2F},
+	{MISENSOR_16BIT,	0xC97C, 0x7792},
+	{MISENSOR_16BIT,	0xC95E, 0x0003},
+
+	/* [Step4-APGA] */
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xC95E, 0x0003},
+
+	/* [Step5-AWB_CCM]1: LOAD=CCM */
+	{MISENSOR_16BIT,	0xC892, 0x0267},
+	{MISENSOR_16BIT,	0xC894, 0xFF1A},
+	{MISENSOR_16BIT,	0xC896, 0xFFB3},
+	{MISENSOR_16BIT,	0xC898, 0xFF80},
+	{MISENSOR_16BIT,	0xC89A, 0x0166},
+	{MISENSOR_16BIT,	0xC89C, 0x0003},
+	{MISENSOR_16BIT,	0xC89E, 0xFF9A},
+	{MISENSOR_16BIT,	0xC8A0, 0xFEB4},
+	{MISENSOR_16BIT,	0xC8A2, 0x024D},
+	{MISENSOR_16BIT,	0xC8A4, 0x01BF},
+	{MISENSOR_16BIT,	0xC8A6, 0xFF01},
+	{MISENSOR_16BIT,	0xC8A8, 0xFFF3},
+	{MISENSOR_16BIT,	0xC8AA, 0xFF75},
+	{MISENSOR_16BIT,	0xC8AC, 0x0198},
+	{MISENSOR_16BIT,	0xC8AE, 0xFFFD},
+	{MISENSOR_16BIT,	0xC8B0, 0xFF9A},
+	{MISENSOR_16BIT,	0xC8B2, 0xFEE7},
+	{MISENSOR_16BIT,	0xC8B4, 0x02A8},
+	{MISENSOR_16BIT,	0xC8B6, 0x01D9},
+	{MISENSOR_16BIT,	0xC8B8, 0xFF26},
+	{MISENSOR_16BIT,	0xC8BA, 0xFFF3},
+	{MISENSOR_16BIT,	0xC8BC, 0xFFB3},
+	{MISENSOR_16BIT,	0xC8BE, 0x0132},
+	{MISENSOR_16BIT,	0xC8C0, 0xFFE8},
+	{MISENSOR_16BIT,	0xC8C2, 0xFFDA},
+	{MISENSOR_16BIT,	0xC8C4, 0xFECD},
+	{MISENSOR_16BIT,	0xC8C6, 0x02C2},
+	{MISENSOR_16BIT,	0xC8C8, 0x0075},
+	{MISENSOR_16BIT,	0xC8CA, 0x011C},
+	{MISENSOR_16BIT,	0xC8CC, 0x009A},
+	{MISENSOR_16BIT,	0xC8CE, 0x0105},
+	{MISENSOR_16BIT,	0xC8D0, 0x00A4},
+	{MISENSOR_16BIT,	0xC8D2, 0x00AC},
+	{MISENSOR_16BIT,	0xC8D4, 0x0A8C},
+	{MISENSOR_16BIT,	0xC8D6, 0x0F0A},
+	{MISENSOR_16BIT,	0xC8D8, 0x1964},
+
+	/* LOAD=AWB */
+	{MISENSOR_16BIT,	0xC914, 0x0000},
+	{MISENSOR_16BIT,	0xC916, 0x0000},
+	{MISENSOR_16BIT,	0xC918, 0x04FF},
+	{MISENSOR_16BIT,	0xC91A, 0x02CF},
+	{MISENSOR_16BIT,	0xC904, 0x0033},
+	{MISENSOR_16BIT,	0xC906, 0x0040},
+	{MISENSOR_8BIT,   0xC8F2, 0x03},
+	{MISENSOR_8BIT,   0xC8F3, 0x02},
+	{MISENSOR_16BIT,	0xC906, 0x003C},
+	{MISENSOR_16BIT,	0xC8F4, 0x0000},
+	{MISENSOR_16BIT,	0xC8F6, 0x0000},
+	{MISENSOR_16BIT,	0xC8F8, 0x0000},
+	{MISENSOR_16BIT,	0xC8FA, 0xE724},
+	{MISENSOR_16BIT,	0xC8FC, 0x1583},
+	{MISENSOR_16BIT,	0xC8FE, 0x2045},
+	{MISENSOR_16BIT,	0xC900, 0x05DC},
+	{MISENSOR_16BIT,	0xC902, 0x007C},
+	{MISENSOR_8BIT,   0xC90C, 0x80},
+	{MISENSOR_8BIT,   0xC90D, 0x80},
+	{MISENSOR_8BIT,   0xC90E, 0x80},
+	{MISENSOR_8BIT,   0xC90F, 0x88},
+	{MISENSOR_8BIT,   0xC910, 0x80},
+	{MISENSOR_8BIT,   0xC911, 0x80},
+
+	/* LOAD=Step7-CPIPE_Preference */
+	{MISENSOR_16BIT,	0xC926, 0x0020},
+	{MISENSOR_16BIT,	0xC928, 0x009A},
+	{MISENSOR_16BIT,	0xC946, 0x0070},
+	{MISENSOR_16BIT,	0xC948, 0x00F3},
+	{MISENSOR_16BIT,	0xC952, 0x0020},
+	{MISENSOR_16BIT,	0xC954, 0x009A},
+	{MISENSOR_8BIT,   0xC92A, 0x80},
+	{MISENSOR_8BIT,   0xC92B, 0x4B},
+	{MISENSOR_8BIT,   0xC92C, 0x00},
+	{MISENSOR_8BIT,   0xC92D, 0xFF},
+	{MISENSOR_8BIT,   0xC92E, 0x3C},
+	{MISENSOR_8BIT,   0xC92F, 0x02},
+	{MISENSOR_8BIT,   0xC930, 0x06},
+	{MISENSOR_8BIT,   0xC931, 0x64},
+	{MISENSOR_8BIT,   0xC932, 0x01},
+	{MISENSOR_8BIT,   0xC933, 0x0C},
+	{MISENSOR_8BIT,   0xC934, 0x3C},
+	{MISENSOR_8BIT,   0xC935, 0x3C},
+	{MISENSOR_8BIT,   0xC936, 0x3C},
+	{MISENSOR_8BIT,   0xC937, 0x0F},
+	{MISENSOR_8BIT,   0xC938, 0x64},
+	{MISENSOR_8BIT,   0xC939, 0x64},
+	{MISENSOR_8BIT,   0xC93A, 0x64},
+	{MISENSOR_8BIT,   0xC93B, 0x32},
+	{MISENSOR_16BIT,	0xC93C, 0x0020},
+	{MISENSOR_16BIT,	0xC93E, 0x009A},
+	{MISENSOR_16BIT,	0xC940, 0x00DC},
+	{MISENSOR_8BIT,   0xC942, 0x38},
+	{MISENSOR_8BIT,   0xC943, 0x30},
+	{MISENSOR_8BIT,   0xC944, 0x50},
+	{MISENSOR_8BIT,   0xC945, 0x19},
+	{MISENSOR_16BIT,	0xC94A, 0x0230},
+	{MISENSOR_16BIT,	0xC94C, 0x0010},
+	{MISENSOR_16BIT,	0xC94E, 0x01CD},
+	{MISENSOR_8BIT,   0xC950, 0x05},
+	{MISENSOR_8BIT,   0xC951, 0x40},
+	{MISENSOR_8BIT,   0xC87B, 0x1B},
+	{MISENSOR_8BIT,   0xC878, 0x0E},
+	{MISENSOR_16BIT,	0xC890, 0x0080},
+	{MISENSOR_16BIT,	0xC886, 0x0100},
+	{MISENSOR_16BIT,	0xC87C, 0x005A},
+	{MISENSOR_8BIT,   0xB42A, 0x05},
+	{MISENSOR_8BIT,   0xA80A, 0x20},
+
+	/* Speed up AE/AWB */
+	{MISENSOR_16BIT,	0x098E, 0x2802},
+	{MISENSOR_16BIT,	0xA802, 0x0008},
+	{MISENSOR_8BIT,   0xC908, 0x01},
+	{MISENSOR_8BIT,   0xC879, 0x01},
+	{MISENSOR_8BIT,   0xC909, 0x02},
+	{MISENSOR_8BIT,   0xA80A, 0x18},
+	{MISENSOR_8BIT,   0xA80B, 0x18},
+	{MISENSOR_8BIT,   0xAC16, 0x18},
+	{MISENSOR_8BIT,   0xC878, 0x0E},
+
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+#endif
diff --git a/drivers/media/i2c/ov5640_1.c b/drivers/media/i2c/ov5640_1.c
new file mode 100644
index 0000000..3fdbf64
--- /dev/null
+++ b/drivers/media/i2c/ov5640_1.c
@@ -0,0 +1,2388 @@
+/*
+ * Support for ov5640_1 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/firmware.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "ov5640_1.h"
+
+#define OV5640_OLD_STILL_CAPTURE 0
+
+#define to_ov5640_1_sensor(sd) container_of(sd, struct ov5640_1_device, sd)
+
+/* #define DEBUG_I2C_COMMAND */
+#define ovprintk(args...)
+
+static int ov5640_1_set_i2c_addr = 0;
+
+static int
+ov5640_1_read_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg >> 8);
+	data[1] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err < 0) {
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == MISENSOR_8BIT)
+		*val = (u8)data[0];
+	else if (data_length == MISENSOR_16BIT)
+		*val = be16_to_cpu(*(u16 *)&data[0]);
+	else
+		*val = be32_to_cpu(*(u32 *)&data[0]);
+
+	return 0;
+}
+
+static int
+ov5640_1_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data_length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16((u16)val);
+	} else {
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = cpu_to_be32(val);
+	}
+
+
+#ifdef DEBUG_I2C_COMMAND
+	printk("%x %02x%02x %02x\n",msg.addr, data[0], data[1], data[2]);
+#endif
+
+
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_err(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+
+	return num_msg;
+}
+
+static int ov5640_1_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	int ret;
+	int retry = 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (ret == 1)
+		return 0;
+
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying i2c write transfer... %d",
+			retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return ret;
+}
+
+/*
+ * __ov5640_1_flush_reg_array() is internal function to make writing reg
+ * faster and should be not used anywhere else.
+ */
+static int __ov5640_1_flush_reg_array(struct i2c_client *client,
+				     struct ov5640_1_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov5640_1_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+/*
+ * ov5640_1_write_reg_array - Initializes a list of MT9T111 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * Initializes a list of MT9T111 registers. The list of registers is
+ * terminated by MISENSOR_TOK_TERM.
+ */
+static int ov5640_1_write_reg_array(struct i2c_client *client,
+			    const struct misensor_reg *reglist)
+{
+	const struct misensor_reg *next = reglist;
+	int err;
+
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		if (next->length == MISENSOR_TOK_DELAY) {
+			msleep(next->val);
+		} else {
+			err = ov5640_1_write_reg(client, next->length, next->reg,
+						next->val);
+			/* REVISIT: Do we need this delay? */
+			udelay(10);
+			if (err) {
+				dev_err(&client->dev, "%s err. aborted\n",
+					__func__);
+				return err;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static const struct firmware *
+load_firmware(struct device *dev)
+{
+	const struct firmware *fw;
+	int rc;
+
+	rc = request_firmware(&fw, AF_FW_PATH, dev);
+	if (rc) {
+		if (rc == -ENOENT)
+			dev_err(dev, "Error AF firmware %s not found.\n",
+					AF_FW_PATH);
+		else
+			dev_err(dev,
+				"Error %d while requesting firmware %s\n",
+				rc, AF_FW_PATH);
+		return NULL;
+	}
+
+	return fw;
+}
+
+static int ov5640_1_af_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	const struct firmware *firmware;
+	struct ov5640_1_write_ctrl ctrl;
+	int err;
+	int i;
+	int group_length;
+
+	return 0;
+
+
+	/* reset MCU */
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+				OV5640_1_REG_SYS_RESET, OV5640_1_MCU_RESET);
+	if (err)
+		return err;
+
+	/* download firmware */
+	if (dev->firmware) {
+		firmware = dev->firmware;
+	} else {
+		firmware = load_firmware(&client->dev);
+		if (!firmware) {
+			dev_err(&client->dev, "Load firmwares failed\n");
+			return -EINVAL;
+		}
+		dev->firmware = firmware;
+	}
+
+	/* download firmware in group */
+	group_length = (firmware->size) / (OV5640_1_MAX_WRITE_BUF_SIZE - 2);
+	for (i = 0; i < group_length; i++) {
+		ctrl.buffer.addr = OV5640_1_REG_FW_START
+				    + i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2);
+		memcpy(ctrl.buffer.data,
+			&firmware->data[i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2)],
+			(OV5640_1_MAX_WRITE_BUF_SIZE - 2));
+		ctrl.index = (OV5640_1_MAX_WRITE_BUF_SIZE - 2);
+		err = __ov5640_1_flush_reg_array(client, &ctrl);
+		if (err) {
+			dev_err(&client->dev, "write firmwares reg failed\n");
+			return err;
+		}
+	}
+
+	/* download firmware less than 1 group */
+	ctrl.buffer.addr = OV5640_1_REG_FW_START +
+				i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2);
+	memcpy(ctrl.buffer.data,
+		&firmware->data[i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2)],
+		firmware->size - i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2));
+	ctrl.index = firmware->size - i * (OV5640_1_MAX_WRITE_BUF_SIZE - 2);
+	err = __ov5640_1_flush_reg_array(client, &ctrl);
+	if (err) {
+		dev_err(&client->dev, "write firmwares reg failed\n");
+		return err;
+	}
+
+
+	return ov5640_1_write_reg_array(client, ov5640_1_focus_init);
+}
+
+static int ov5640_1_s_focus_mode(struct v4l2_subdev *sd, int mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int err = 0;
+
+
+	/*
+	 * if sensor streamoff, writing focus mode reg is invalid.
+	 * only writing focus mode reg is valid after streamon.
+	 */
+	if (dev->streaming == false) {
+		dev->focus_mode = mode;
+		dev->focus_mode_change = true;
+		return 0;
+	}
+
+	switch (mode) {
+	case V4L2_CID_AUTO_FOCUS_START:
+		/* start single focus */
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_FOCUS_MODE,
+						OV5640_1_SINGLE_FOCUS);
+		break;
+	case V4L2_CID_FOCUS_AUTO:
+		/* start continuous focus */
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_FOCUS_MODE,
+						OV5640_1_CONTINUE_FOCUS);
+		break;
+	case V4L2_CID_3A_LOCK:
+		/* pause focus */
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_FOCUS_MODE,
+						OV5640_1_PAUSE_FOCUS);
+		break;
+	case V4L2_CID_AUTO_FOCUS_STOP:
+		/* release focus to infinity */
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_FOCUS_MODE,
+						OV5640_1_RELEASE_FOCUS);
+		break;
+	default:
+		dev_err(&client->dev, "invalid mode.\n");
+		return -EINVAL;
+	}
+	if (err) {
+		dev_err(&client->dev, "setting focus mode fails.\n");
+		return err;
+	}
+
+	dev->focus_mode = mode;
+	dev->focus_mode_change = false;
+
+	return 0;
+}
+
+static int ov5640_1_s_single_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_1_s_focus_mode(sd, V4L2_CID_AUTO_FOCUS_START);
+}
+
+static int ov5640_1_s_cont_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_1_s_focus_mode(sd, V4L2_CID_FOCUS_AUTO);
+}
+
+static int ov5640_1_pause_focus(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (value != V4L2_LOCK_FOCUS) {
+		dev_err(&client->dev, "invalid focus cmd.\n");
+		return -EINVAL;
+	}
+
+	return ov5640_1_s_focus_mode(sd, V4L2_CID_3A_LOCK);
+}
+
+static int ov5640_1_release_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_1_s_focus_mode(sd, V4L2_CID_AUTO_FOCUS_STOP);
+}
+
+static int ov5640_1_s_color_effect(struct v4l2_subdev *sd, int effect)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int err = 0;
+
+	if (dev->color_effect == effect)
+		return 0;
+
+	switch (effect) {
+	case V4L2_COLORFX_NONE:
+		err = ov5640_1_write_reg_array(client, ov5640_1_normal_effect);
+		break;
+	case V4L2_COLORFX_SEPIA:
+		err = ov5640_1_write_reg_array(client, ov5640_1_sepia_effect);
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		err = ov5640_1_write_reg_array(client, ov5640_1_negative_effect);
+		break;
+	case V4L2_COLORFX_BW:
+		err = ov5640_1_write_reg_array(client, ov5640_1_bw_effect);
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		err = ov5640_1_write_reg_array(client, ov5640_1_blue_effect);
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		err = ov5640_1_write_reg_array(client, ov5640_1_green_effect);
+		break;
+	default:
+		dev_err(&client->dev, "invalid color effect.\n");
+		return -ERANGE;
+	}
+	if (err) {
+		dev_err(&client->dev, "setting color effect fails.\n");
+		return err;
+	}
+
+	dev->color_effect = effect;
+
+	return 0;
+}
+
+static int ov5640_1_g_color_effect(struct v4l2_subdev *sd, int *effect)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+
+	*effect = dev->color_effect;
+
+	return 0;
+}
+
+static int ov5640_1_g_focus_status(struct v4l2_subdev *sd, int *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val = 0;
+
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_FOCUS_STATUS, &val);
+	if (err)
+		return err;
+
+	switch (val & 0xff) {
+	case OV5640_1_FOCUS_FW_DL:
+		/* firmware is downloaded and not to be initialized */
+		*status = V4L2_AUTO_FOCUS_STATUS_FAILED;
+		break;
+	case OV5640_1_FOCUS_FW_INIT:
+		/* firmware is initializing */
+	case OV5640_1_FOCUS_FW_IDLE:
+		/* firmware is idle */
+		*status = V4L2_AUTO_FOCUS_STATUS_IDLE;
+		break;
+	case OV5640_1_FOCUS_FW_RUN:
+		/* focus is running */
+		*status = V4L2_AUTO_FOCUS_STATUS_BUSY;
+		break;
+	case OV5640_1_FOCUS_FW_FINISH:
+		/* focus is finished */
+		*status = V4L2_AUTO_FOCUS_STATUS_REACHED;
+		break;
+	default:
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/* calculate sysclk */
+static int ov5640_1_get_sysclk(struct v4l2_subdev *sd, unsigned int *sysclk)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp1 = 0, temp2 = 0;
+	u32 multiplier = 0, prediv = 0, vco = 0, sysdiv = 0;
+	u32 pll_rdiv = 0, bit_div2x = 0, sclk_rdiv = 0;
+
+	static int sclk_rdiv_map[] = {1, 2, 4, 8};
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_PLL_CTRL_0, &temp1);
+	if (err)
+		return err;
+	temp2 = temp1 & 0x0f;
+	if (temp2 == 8 || temp2 == 10)
+		bit_div2x = temp2 >> 1;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_PLL_CTRL_1, &temp1);
+	if (err)
+		return err;
+	sysdiv = temp1 >> 4;
+	if (sysdiv == 0)
+		sysdiv = 16;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_PLL_CTRL_2, &temp1);
+	if (err)
+		return err;
+	multiplier = temp1;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_PLL_CTRL_3, &temp1);
+	if (err)
+		return err;
+	prediv = temp1 & 0x0f;
+	pll_rdiv = ((temp1 >> 4) & 0x01) + 1;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_CLK_DIVIDER, &temp1);
+	if (err)
+		return err;
+	temp2 = temp1 & 0x03;
+	sclk_rdiv = sclk_rdiv_map[temp2];
+
+	if ((prediv && sclk_rdiv && bit_div2x) == 0)
+		return -EINVAL;
+
+	vco = OV5640_1_XVCLK * multiplier / prediv;
+
+	*sysclk = vco / sysdiv / pll_rdiv * 2 / bit_div2x / sclk_rdiv;
+
+	if (*sysclk < MIN_SYSCLK)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* read HTS from register settings */
+static int ov5640_1_get_hts(struct v4l2_subdev *sd, unsigned int *hts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_1_read_reg(client, MISENSOR_16BIT,
+				OV5640_1_REG_TIMING_HTS, hts);
+	if (err)
+		return err;
+
+	if (*hts < MIN_HTS)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* read VTS from register settings */
+static int ov5640_1_get_vts(struct v4l2_subdev *sd, unsigned int *vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_1_read_reg(client, MISENSOR_16BIT,
+				OV5640_1_REG_TIMING_VTS, vts);
+	if (err)
+		return err;
+
+	if (*vts < MIN_VTS)
+		return -EINVAL;
+
+	return 0;
+}
+
+#if OV5640_OLD_STILL_CAPTURE
+/* write VTS to registers */
+static int ov5640_1_set_vts(struct v4l2_subdev *sd, unsigned int vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_1_write_reg(client, MISENSOR_16BIT,
+					OV5640_1_REG_TIMING_VTS, vts);
+}
+#endif /* OV5640_OLD_STILL_CAPTURE */
+
+/* read shutter, in number of line period */
+static int ov5640_1_get_shutter(struct v4l2_subdev *sd, s32 *shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val, temp;
+
+	err = ov5640_1_read_reg(client, MISENSOR_16BIT,
+					OV5640_1_REG_EXPOSURE_0, &val);
+	if (err)
+		return err;
+	temp = (val & 0x0fff);
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_EXPOSURE_1, &val);
+	if (err)
+		return err;
+
+	*shutter = (temp << 4) + (val >> 4);
+
+	if(*shutter < MIN_SHUTTER)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write shutter, in number of line period */
+static int ov5640_1_set_shutter(struct v4l2_subdev *sd, unsigned int shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp;
+
+	shutter = shutter & 0xffff;
+	temp = shutter & 0x0f;
+	temp = temp << 4;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_EXPOSURE_1, temp);
+	if (err)
+		return err;
+
+	temp = shutter >> 4;
+
+	return ov5640_1_write_reg(client, MISENSOR_16BIT,
+					OV5640_1_REG_EXPOSURE_0, temp);
+}
+
+/* read gain, 16 = 1x */
+static int ov5640_1_get_gain16(struct v4l2_subdev *sd, unsigned int *gain16)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val;
+
+	err = ov5640_1_read_reg(client, MISENSOR_16BIT,
+					OV5640_1_REG_GAIN, &val);
+	if (err)
+		return err;
+
+	*gain16 = val & 0x3ff;
+
+	if(*gain16 < MIN_GAIN)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write gain, 16 = 1x */
+static int ov5640_1_set_gain16(struct v4l2_subdev *sd, unsigned int gain16)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	gain16 = gain16 & 0x3ff;
+
+	return ov5640_1_write_reg(client, MISENSOR_16BIT,
+					OV5640_1_REG_GAIN, gain16);
+}
+
+/*
+ * This returns the exposure compensation value, which is expressed in
+ * terms of EV. The default EV value is 0, and driver don't support
+ * adjust EV value.
+ */
+static int ov5640_1_get_exposure_bias(struct v4l2_subdev *sd, s32 *value)
+{
+	*value = 0;
+
+	return 0;
+}
+
+/*
+ * This returns ISO sensitivity.
+ */
+static int ov5640_1_get_iso(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 gain;
+	int err;
+
+	err = ov5640_1_get_gain16(sd, &gain);
+	if (err)
+		return err;
+
+	*value = gain / 16 * 100;
+
+	return 0;
+}
+
+#if OV5640_OLD_STILL_CAPTURE
+/* get banding filter value */
+static int ov5640_1_get_light_frequency(struct v4l2_subdev *sd,
+				unsigned int *light_frequency)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_LIGHT_CTRL_0, &temp);
+	if (err)
+		return err;
+
+	if (temp & OV5640_1_AUTO_BAND) {
+		/* manual */
+		err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_LIGHT_CTRL_1, &temp);
+		if (err)
+			return err;
+		if (temp & 0x04)
+			/* 50Hz */
+			*light_frequency = OV5640_1_LIGHT_50HZ;
+		else
+			/* 60Hz */
+			*light_frequency = OV5640_1_LIGHT_60HZ;
+	} else {
+		/* auto */
+		err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_LIGHT_CTRL_2, &temp);
+		if (err)
+			return err;
+		if (temp & 0x01)
+			/* 50Hz */
+			*light_frequency = OV5640_1_LIGHT_50HZ;
+		else
+			/* 60Hz */
+			*light_frequency = OV5640_1_LIGHT_60HZ;
+	}
+
+	return 0;
+}
+#endif /* OV5640_OLD_STILL_CAPTURE */
+
+static int ov5640_1_set_bandingfilter(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	u32 band_step60, max_band60, band_step50, max_band50;
+	int err;
+
+	/* read preview PCLK */
+	err = ov5640_1_get_sysclk(sd, &dev->preview_sysclk);
+	if (err)
+		return err;
+
+	/* read preview HTS */
+	err = ov5640_1_get_hts(sd, &dev->preview_hts);
+	if (err)
+		return err;
+
+	/* read preview VTS */
+	err = ov5640_1_get_vts(sd, &dev->preview_vts);
+	if (err)
+		return err;
+
+	/* calculate banding filter */
+	/* 60Hz */
+	band_step60 = dev->preview_sysclk * 100 / dev->preview_hts * 100 / 120;
+	if (band_step60 == 0)
+		return -EINVAL;
+
+	err = ov5640_1_write_reg(client, MISENSOR_16BIT, OV5640_1_REG_B60_STEP,
+								band_step60);
+	if (err)
+		return err;
+
+	max_band60 = (dev->preview_vts - 4) / band_step60;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_B60_MAX, max_band60);
+	if (err)
+		return err;
+
+	/* 50Hz */
+	band_step50 = dev->preview_sysclk * 100 / dev->preview_hts;
+	if (band_step50 == 0)
+		return -EINVAL;
+
+	err = ov5640_1_write_reg(client, MISENSOR_16BIT, OV5640_1_REG_B50_STEP,
+								band_step50);
+	if (err)
+		return err;
+
+	max_band50 = (dev->preview_vts - 4) / band_step50;
+
+	return ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_B50_MAX, max_band50);
+}
+
+/* stable in high */
+static int ov5640_1_set_ae_target(struct v4l2_subdev *sd, unsigned int target)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int err;
+	u32 fast_high, fast_low;
+	dev->ae_low = target * 23 / 25;	 /* 0.92 */
+	dev->ae_high = target * 27 / 25; /* 1.08 */
+
+
+	fast_high = dev->ae_high << 1;
+	if (fast_high > 255)
+		fast_high = 255;
+
+	fast_low = dev->ae_low >> 1;
+
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_STAB_IN_H, dev->ae_high);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_STAB_IN_L, dev->ae_low);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_STAB_OUT_H, dev->ae_high);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_STAB_OUT_L, dev->ae_low);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_FAST_H, fast_high);
+	if (err)
+		return err;
+
+	return ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_FAST_L, fast_low);
+}
+
+static int
+ov5640_1_set_ag_ae(struct i2c_client *client, int enable)
+{
+	return ov5640_1_write_reg(client, MISENSOR_8BIT,
+			OV5640_1_REG_AE_MODE_CTRL,
+			enable ? OV5640_1_AUTO_AG_AE : OV5640_1_MANUAL_AG_AE);
+}
+
+static int ov5640_1_set_night_mode(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int temp;
+	int err;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_SYS_CTRL, &temp);
+	if (err)
+		return err;
+
+	if (enable) {
+		temp = temp | 0x04;
+		return ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_SYS_CTRL, temp);
+	} else {
+		temp = temp & 0xfb;
+		return ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AE_SYS_CTRL, temp);
+	}
+}
+
+static int ov5640_1_set_awb_gain_mode(struct v4l2_subdev *sd, int mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int temp;
+	int err;
+
+	err = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_AWB_CTRL, &temp);
+	if (err)
+		return err;
+
+	switch (mode) {
+	case OV5640_1_AWB_GAIN_AUTO:
+		/* set awb gain to auto */
+		temp = temp & 0xfe;
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_AWB_CTRL, temp);
+		break;
+	case OV5640_1_AWB_GAIN_MANUAL:
+		/* set awb gain to manual */
+		temp = temp | 0x01;
+		err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_AWB_CTRL, temp);
+		break;
+	default:
+		dev_err(&client->dev, "invalid awb gain mode.\n");
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5640_1_start_preview(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int ret;
+
+	dev->preview_ag_ae = false;
+
+	ret = ov5640_1_set_awb_gain_mode(sd, OV5640_1_AWB_GAIN_AUTO);
+	if (ret)
+		return ret;
+
+	ret = ov5640_1_set_gain16(sd, dev->preview_gain16);
+	if (ret)
+		return ret;
+
+	ret = ov5640_1_set_shutter(sd, dev->preview_shutter);
+	if (ret)
+		return ret;
+
+	ret = ov5640_1_set_ag_ae(client, 1);
+	if (ret)
+		return ret;
+
+	ret = ov5640_1_set_bandingfilter(sd);
+	if (ret)
+		return ret;
+
+	ret = ov5640_1_set_ae_target(sd, OV5640_1_AE_TARGET);
+	if (ret)
+		return ret;
+
+	return ov5640_1_set_night_mode(sd, dev->night_mode);
+}
+
+static int ov5640_1_stop_preview(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int err;
+
+	/* read preview shutter */
+	err = ov5640_1_get_shutter(sd, &dev->preview_shutter);
+	if (err)
+		return err;
+
+	err = ov5640_1_get_gain16(sd, &dev->preview_gain16);
+	if (err)
+		return err;
+
+	err = ov5640_1_get_hts(sd, &dev->preview_hts);
+	if (err)
+		return err;
+
+	dev->preview_ag_ae = true;
+
+	err = ov5640_1_set_awb_gain_mode(sd, OV5640_1_AWB_GAIN_MANUAL);
+	if (err)
+		return err;
+
+	/* get average */
+	return ov5640_1_read_reg(client, MISENSOR_8BIT,
+				OV5640_1_REG_AE_AVERAGE, &dev->average);
+}
+
+
+
+#if 0
+static int ov5640_1_start_raw_capture(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	ovprintk("write ov5640_1_800x480_yuv_2lane_192MCLK_30fps to ov5640_1\n");
+	return ov5640_1_write_reg_array(client, ov5640_1_800x480_yuv_2lane_192MCLK_30fps);
+
+
+}
+#endif
+static int ov5640_1_start_video(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_1_set_awb_gain_mode(sd, OV5640_1_AWB_GAIN_AUTO);
+	if (err)
+		return err;
+
+	err = ov5640_1_set_ag_ae(client, 1);
+	if (err)
+		return err;
+
+	err = ov5640_1_set_bandingfilter(sd);
+	if (err)
+		return err;
+
+	err = ov5640_1_set_ae_target(sd, OV5640_1_AE_TARGET);
+	if (err)
+		return err;
+
+	return ov5640_1_set_night_mode(sd, 0);
+
+}
+
+#if OV5640_OLD_STILL_CAPTURE
+static int ov5640_1_start_capture(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	u32 capture_sysclk, capture_hts, capture_vts;
+	u32 capture_shutter, capture_gain16;
+	u32 light_frequency, capture_bandingfilter, capture_max_band;
+	long capture_gain16_shutter;
+	int err;
+
+
+	if (!dev->preview_ag_ae) {
+		dev_err(&client->dev, "preview gain and shutter are not available.\n");
+		return -EINVAL;
+	}
+
+	err = ov5640_1_set_awb_gain_mode(sd, OV5640_1_AWB_GAIN_AUTO);
+	if (err)
+		return err;
+
+	err = ov5640_1_set_ag_ae(client, 0);
+	if (err)
+		return err;
+
+	/* read capture VTS */
+	err = ov5640_1_get_vts(sd, &capture_vts);
+	if (err)
+		return err;
+
+	err = ov5640_1_get_hts(sd, &capture_hts);
+	if (err)
+		return err;
+
+	err = ov5640_1_get_sysclk(sd, &capture_sysclk);
+	if (err)
+		return err;
+
+	/* calculate capture banding filter */
+	err = ov5640_1_get_light_frequency(sd, &light_frequency);
+	if (err)
+		return err;
+
+	if (light_frequency == OV5640_1_LIGHT_60HZ) {
+		/* 60Hz */
+		capture_bandingfilter = capture_sysclk * 100 /
+						capture_hts * 100 / 120;
+	} else {
+		/* 50Hz */
+		capture_bandingfilter = capture_sysclk * 100 / capture_hts;
+	}
+
+	if (capture_bandingfilter == 0)
+		return -EINVAL;
+
+	capture_max_band = (int)((capture_vts - 4) / capture_bandingfilter);
+	if (capture_max_band == 0)
+		return -EINVAL;
+
+	/* calculate capture shutter/gain16 */
+	if (dev->average > dev->ae_low && dev->average < dev->ae_high) {
+		/* in stable range */
+		capture_gain16_shutter = dev->preview_gain16 *
+					dev->preview_shutter *
+					capture_sysclk / dev->preview_sysclk *
+					dev->preview_hts / capture_hts *
+					OV5640_1_AE_TARGET / dev->average;
+	} else {
+		capture_gain16_shutter = dev->preview_gain16 *
+					dev->preview_shutter *
+					capture_sysclk / dev->preview_sysclk *
+					dev->preview_hts / capture_hts;
+	}
+	/* gain to shutter */
+	if (capture_gain16_shutter < (capture_bandingfilter * 16)) {
+		/* shutter < 1/100 */
+		capture_shutter = capture_gain16_shutter / 16;
+		if (capture_shutter < 1)
+			capture_shutter = 1;
+		capture_gain16 = capture_gain16_shutter / capture_shutter;
+		if (capture_gain16 < 16)
+			capture_gain16 = 16;
+	} else {
+		if (capture_gain16_shutter >
+			(capture_bandingfilter * capture_max_band * 16)) {
+			/* exposure reach max */
+			capture_shutter = capture_bandingfilter *
+							capture_max_band;
+			capture_gain16 = capture_gain16_shutter /
+							capture_shutter;
+		} else {
+			/*
+			 * 1/100 < capture_shutter =< max,
+			 * capture_shutter = n/100
+			 */
+			capture_shutter = ((int)(capture_gain16_shutter / 16 /
+						capture_bandingfilter)) *
+						capture_bandingfilter;
+			if (capture_shutter == 0)
+				return -EINVAL;
+
+			capture_gain16 = capture_gain16_shutter /
+						capture_shutter;
+		}
+	}
+
+	/* write capture gain */
+	err = ov5640_1_set_gain16(sd, capture_gain16);
+	if (err)
+		return err;
+
+	/* write capture shutter */
+	if (capture_shutter > (capture_vts - 4)) {
+		capture_vts = capture_shutter + 4;
+		err = ov5640_1_set_vts(sd, capture_vts);
+		if (err)
+			return err;
+	}
+
+	return ov5640_1_set_shutter(sd, capture_shutter);
+
+}
+#endif /* OV5640_OLD_STILL_CAPTURE */
+
+static int ov5640_1_standby(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_1_write_reg_array(client, ov5640_1_standby_reg);
+}
+
+static int ov5640_1_wakeup(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_1_write_reg_array(client, ov5640_1_wakeup_reg);
+}
+
+
+static int ov5640_1_set_new_addr(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret, err, val;
+	int addr_to_use = client->addr;
+
+	if(client->addr == OV5640_FACTORY_DEFAULT_ADDR) return 0;
+	if(ov5640_1_set_i2c_addr) return 0;
+
+	client->addr =  OV5640_FACTORY_DEFAULT_ADDR;
+	ret = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_SCCB_ID, &val);
+	ovprintk("ov5640_1_set_new_addr: default address is 0x%0x\n", val);
+
+	if (ret) return ret;
+
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+				OV5640_1_REG_SCCB_ID, (addr_to_use << 1));
+	if (err) return err;
+
+	client->addr = addr_to_use;
+
+	ret = ov5640_1_read_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_SCCB_ID, &val);
+	if (ret) return ret;
+	ovprintk("ov5640_1: the new address =0x%x client addr=0x%x\n",val, client->addr);
+
+	ov5640_1_set_i2c_addr = 1;
+
+	return 0;
+}
+
+
+static int __ov5640_1_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if(client->addr != OV5640_FACTORY_DEFAULT_ADDR)
+	{
+	  ret = ov5640_1_set_new_addr(sd);
+	  if (ret)
+			return ret;
+	  ovprintk("ov5640_1_init: the client addr=0x%x\n", client->addr);
+	}
+
+	ret = ov5640_1_write_reg_array(client, ov5640_1_init);
+	if (ret)
+		return ret;
+
+	/*
+	 * delay 5ms to wait for sensor initialization finish.
+	 */
+	usleep_range(5000, 6000);
+
+	ret = ov5640_1_af_init(sd);
+	if (ret)
+		return ret;
+	msleep(20);
+
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		{
+		goto fail_power;
+		}
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/*
+	 * according to DS, 20ms is needed between power up and first i2c
+	 * commend
+	 */
+	msleep(20);
+
+	return 0;
+
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	/*according to DS, 20ms is needed after power down*/
+	msleep(20);
+
+	return ret;
+}
+
+static int ov5640_1_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+	else {
+	ovprintk("power on ov5640_1_s_power\n");
+
+	if(power_up(sd))
+		return -EINVAL;
+	}
+
+	return __ov5640_1_init(sd);
+}
+
+static int ov5640_1_try_res(u32 *w, u32 *h, u32 *code)
+{
+	int i;
+
+	if(*code == 0x8003)
+		*code = MEDIA_BUS_FMT_UYVY8_1X16;
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if (ov5640_1_res[i].width == *w &&
+		    ov5640_1_res[i].height == *h &&
+		    ov5640_1_res[i].code == *code)
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = ov5640_1_res[i].width;
+	*h = ov5640_1_res[i].height;
+	*code = ov5640_1_res[i].code;
+
+	return 0;
+}
+
+static struct ov5640_1_res_struct *ov5640_1_to_res(u32 w, u32 h, u32 code)
+{
+	int  index;
+
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov5640_1_res[index].width == w &&
+		    ov5640_1_res[index].height == h &&
+		    ov5640_1_res[index].code == code)
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		return NULL;
+
+	return &ov5640_1_res[index];
+}
+
+static int ov5640_1_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	int count = 0;
+
+	return ov5640_1_try_res(&fmt->width, &fmt->height, &fmt->code);
+}
+
+static int ov5640_1_res2size(unsigned int res, int *h_size, int *v_size)
+{
+	unsigned short hsize;
+	unsigned short vsize;
+
+	switch (res) {
+	case OV5640_1_RES_QVGA:
+		hsize = OV5640_1_RES_QVGA_SIZE_H;
+		vsize = OV5640_1_RES_QVGA_SIZE_V;
+		break;
+	case OV5640_1_RES_DVGA:
+		hsize = OV5640_1_RES_DVGA_SIZE_H;
+		vsize = OV5640_1_RES_DVGA_SIZE_V;
+		break;
+	case OV5640_1_RES_320P:
+		hsize = OV5640_1_RES_320P_SIZE_H;
+		vsize = OV5640_1_RES_320P_SIZE_V;
+		break;
+	case OV5640_1_RES_360P:
+		hsize = OV5640_1_RES_360P_SIZE_H;
+		vsize = OV5640_1_RES_360P_SIZE_V;
+		break;
+	case OV5640_1_RES_VGA:
+		hsize = OV5640_1_RES_VGA_SIZE_H;
+		vsize = OV5640_1_RES_VGA_SIZE_V;
+		break;
+	case OV5640_1_RES_RGB_VGA:
+		hsize = OV5640_1_RES_VGA_SIZE_H;
+		vsize = OV5640_1_RES_VGA_SIZE_V;
+		break;
+	case OV5640_1_RES_RAW_10_VGA:
+		hsize = OV5640_1_RES_VGA_SIZE_H;
+		vsize = OV5640_1_RES_VGA_SIZE_V;
+		break;
+	case OV5640_1_RES_480P:
+		hsize = OV5640_1_RES_480P_SIZE_H;
+		vsize = OV5640_1_RES_480P_SIZE_V;
+		break;
+	case OV5640_1_RES_736x480P:
+		hsize = OV5640_1_RES_736x480P_SIZE_H;
+		vsize = OV5640_1_RES_736x480P_SIZE_V;
+		break;
+	case OV5640_1_RES_800x480P:
+		hsize = OV5640_1_RES_800x480P_SIZE_H;
+		vsize = OV5640_1_RES_800x480P_SIZE_V;
+		break;
+	case OV5640_1_RES_720P:
+	case OV5640_1_RGB565_RES_720P:
+		hsize = OV5640_1_RES_720P_SIZE_H;
+		vsize = OV5640_1_RES_720P_SIZE_V;
+		break;
+	case OV5640_1_RES_1440X720P:
+		hsize = OV5640_1_RES_1440X720P_SIZE_H;
+		vsize = OV5640_1_RES_1440X720P_SIZE_V;
+		break;
+	case OV5640_1_RES_1080P:
+		hsize = OV5640_1_RES_1080P_SIZE_H;
+		vsize = OV5640_1_RES_1080P_SIZE_V;
+		break;
+	case OV5640_1_RES_1080P_RGB:
+			hsize = OV5640_1_RES_1080P_SIZE_H;
+			vsize = OV5640_1_RES_1080P_SIZE_V;
+			break;
+	case OV5640_1_RES_1088P:
+		hsize = OV5640_1_RES_1088P_SIZE_H;
+		vsize = OV5640_1_RES_1088P_SIZE_V;
+		break;
+	case OV5640_1_RES_D3M:
+		hsize = OV5640_1_RES_D3M_SIZE_H;
+		vsize = OV5640_1_RES_D3M_SIZE_V;
+		break;
+	case OV5640_1_RES_3M:
+		hsize = OV5640_1_RES_3M_SIZE_H;
+		vsize = OV5640_1_RES_3M_SIZE_V;
+		break;
+	case OV5640_1_RES_D5M:
+		hsize = OV5640_1_RES_D5M_SIZE_H;
+		vsize = OV5640_1_RES_D5M_SIZE_V;
+		break;
+	case OV5640_1_RES_5M:
+		hsize = OV5640_1_RES_5M_SIZE_H;
+		vsize = OV5640_1_RES_5M_SIZE_V;
+		break;
+
+	default:
+		/* QVGA mode is still unsupported */
+		WARN(1, "%s: Resolution 0x%08x unknown\n", __func__, res);
+		return -EINVAL;
+	}
+
+	if (h_size != NULL)
+		*h_size = hsize;
+	if (v_size != NULL)
+		*v_size = vsize;
+
+	return 0;
+}
+
+static int ov5640_1_g_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int width, height;
+	int ret;
+
+	ret = ov5640_1_res2size(dev->res, &width, &height);
+	if (ret)
+		return ret;
+	fmt->width = width;
+	fmt->height = height;
+
+
+
+	return 0;
+}
+
+static int ov5640_1_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	struct ov5640_1_res_struct *res_index;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	u32 code = fmt->code;
+	int ret;
+
+	ovprintk("ov5640_1_s_mbus_fmt w=%d h=%d code=0x%x\n", fmt->width, fmt->height, fmt->code);
+
+	ov5640_1_try_res(&width, &height, &code);
+
+	res_index = ov5640_1_to_res(width, height, code);
+
+	/* Sanity check */
+	if (unlikely(!res_index)) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+	ovprintk("ov5640_1_s_mbus_fmt res_index->res=%d\n", res_index->res);
+
+	switch (res_index->res) {
+	case OV5640_1_RES_QVGA:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_qvga_init);
+		break;
+	case OV5640_1_RES_DVGA:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_dvga_init);
+		break;
+	case OV5640_1_RES_320P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_320p_init);
+		break;
+	case OV5640_1_RES_360P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_360p_init);
+		break;
+	case OV5640_1_RES_VGA:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_vga_init);
+		break;
+	case OV5640_1_RES_RGB_VGA:
+			ret = ov5640_1_write_reg_array(c, ov5640_1_vga_rgb_init);
+			break;
+	case OV5640_1_RES_RAW_10_VGA:
+			ret = ov5640_1_write_reg_array(c, ov5640_1_vga_raw_10_init);
+			break;
+	case OV5640_1_RES_480P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_480p_init);
+		break;
+	case OV5640_1_RES_736x480P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_736x480p_init);
+		break;
+	case OV5640_1_RES_800x480P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_800x480p_init);
+		break;
+
+	case OV5640_1_RES_720P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_720p_init);
+		break;
+	case OV5640_1_RGB565_RES_720P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_rgb565_1280x720p_init);
+		break;
+	case OV5640_1_RES_1440X720P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_1440x720p_init);
+		break;
+
+	case OV5640_1_RES_1080P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_1080p_init);
+		break;
+	case OV5640_1_RES_1080P_RGB:
+			ret = ov5640_1_write_reg_array(c, ov5640_1_1080p_rgb);
+			break;
+	case OV5640_1_RES_1088P:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_1088p_init);
+		break;
+	case OV5640_1_RES_D3M:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_D3M_init);
+		break;
+	case OV5640_1_RES_3M:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_3M_init);
+		break;
+	case OV5640_1_RES_D5M:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_D5M_init);
+		break;
+	case OV5640_1_RES_5M:
+		ret = ov5640_1_write_reg_array(c, ov5640_1_5M_init);
+		break;
+	default:
+		/* QVGA is not implemented yet */
+		dev_err(&c->dev, "set resolution: %d failed!\n",
+							res_index->res);
+		return -EINVAL;
+	}
+	if (ret)
+		return -EINVAL;
+
+
+	if (dev->res != res_index->res) {
+		int index;
+
+		/*
+		 * Marked current sensor res as being "used"
+		 *
+		 * REVISIT: We don't need to use an "used" field on each mode
+		 * list entry to know which mode is selected. If this
+		 * information is really necessary, how about to use a single
+		 * variable on sensor dev struct?
+		 */
+		for (index = 0; index < N_RES; index++) {
+			if (width == ov5640_1_res[index].width &&
+			    height == ov5640_1_res[index].height &&
+			    code == ov5640_1_res[index].code) {
+				ov5640_1_res[index].used = 1;
+				continue;
+			}
+			ov5640_1_res[index].used = 0;
+		}
+	}
+
+	/*
+	 * ov5640_1 - we don't poll for context switch
+	 * because it does not happen with streaming disabled.
+	 */
+	dev->res = res_index->res;
+
+	fmt->width = width;
+	fmt->height = height;
+	fmt->code = code;
+
+	ovprintk("ov5640_1_s_mbus_fmt width = %d height = %d code =0x%x dev->res=%d\n",
+	       width, height, code, dev->res);
+	/* relaunch default focus zone */
+
+	ret = ov5640_1_write_reg(c, MISENSOR_8BIT,
+					OV5640_1_REG_FOCUS_MODE,
+					OV5640_1_RELAUNCH_FOCUS);
+	if (ret) return -EINVAL;
+
+	return ov5640_1_wakeup(sd);
+
+
+}
+
+static int ov5640_1_detect(struct i2c_client *client,  u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 retvalue;
+
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+
+	if (ov5640_1_read_reg(client, MISENSOR_16BIT,
+		OV5640_1_REG_PID, &retvalue)) {
+		dev_err(&client->dev, "sensor_id_high = 0x%x\n", retvalue);
+		return -ENODEV;
+	}
+
+	dev_info(&client->dev, "sensor_id = 0x%x\n", retvalue);
+	if (retvalue != OV5640_1_MOD_ID) {
+		dev_err(&client->dev, "%s: failed: client->addr = %x\n",
+			__func__, client->addr);
+		return -ENODEV;
+	}
+
+	*id = retvalue;
+	/* REVISIT: HACK: Driver is currently forcing revision to 0 */
+	*revision = 0;
+
+	return 0;
+}
+
+static int
+ov5640_1_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+	ret = ov5640_1_s_power(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "power_ctrl failed");
+		return ret;
+	}
+
+
+	/* config & detect sensor */
+	ret = ov5640_1_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		dev_err(&client->dev, "ov5640_1_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = ov5640_1_s_power(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "sensor power-gating failed\n");
+
+	return ret;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	ov5640_1_s_power(sd, 0);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+
+static int ov5640_1_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5640_1_FOCAL_LENGTH_NUM << 16) | OV5640_1_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int ov5640_1_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/* const f number for OV5640_1 */
+	*val = (OV5640_1_F_NUMBER_DEFAULT_NUM << 16) | OV5640_1_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov5640_1_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5640_1_F_NUMBER_DEFAULT_NUM << 24) |
+		(OV5640_1_F_NUMBER_DEM << 16) |
+		(OV5640_1_F_NUMBER_DEFAULT_NUM << 8) | OV5640_1_F_NUMBER_DEM;
+	return 0;
+}
+
+static struct ov5640_1_control ov5640_1_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_1_get_shutter,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_EXPOSURE_BIAS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure bias",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_1_get_exposure_bias,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_ISO_SENSITIVITY,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "iso",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_1_get_iso,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_START,
+			.type = V4L2_CTRL_TYPE_BUTTON,
+			.name = "single focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_1_s_single_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_AUTO,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "continuous focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_1_s_cont_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_3A_LOCK,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "pause focus",
+			.minimum = 0,
+			.maximum = 1 << 2,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_1_pause_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_STOP,
+			.type = V4L2_CTRL_TYPE_BUTTON,
+			.name = "release focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_1_release_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_STATUS,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "focus status",
+			.minimum = 0,
+			.maximum = 0x07,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = ov5640_1_g_focus_status,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_COLORFX,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "color effect",
+			.minimum = 0,
+			.maximum = 9,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_1_s_color_effect,
+		.query = ov5640_1_g_color_effect,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = 0,
+			.maximum = OV5640_1_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5640_1_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5640_1_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = 0,
+			.maximum = OV5640_1_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5640_1_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5640_1_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = 0,
+			.maximum =  OV5640_1_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = OV5640_1_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = ov5640_1_g_fnumber_range,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(ov5640_1_controls))
+
+static struct ov5640_1_control *ov5640_1_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (ov5640_1_controls[i].qc.id == id)
+			return &ov5640_1_controls[i];
+	}
+	return NULL;
+}
+
+static int ov5640_1_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct ov5640_1_control *ctrl = ov5640_1_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	return 0;
+}
+
+static int ov5640_1_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5640_1_control *octrl = ov5640_1_find_control(ctrl->id);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	ret = octrl->query(sd, &ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov5640_1_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5640_1_control *octrl = ov5640_1_find_control(ctrl->id);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+
+	ret = octrl->tweak(sd, ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov5640_1_mipi_stream(struct i2c_client *client, int enable)
+{
+	return ov5640_1_write_reg(client, MISENSOR_8BIT,
+			OV5640_1_REG_FRAME_CTRL,
+			enable ? OV5640_1_FRAME_START : OV5640_1_FRAME_STOP);
+}
+
+static int ov5640_1_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int err;
+
+	if (enable) {
+		switch (dev->run_mode) {
+		case CI_MODE_PREVIEW:
+			err = ov5640_1_start_preview(sd);
+			break;
+		case CI_MODE_VIDEO:
+			err = ov5640_1_start_video(sd);
+			break;
+		case CI_MODE_STILL_CAPTURE:
+#if OV5640_OLD_STILL_CAPTURE
+			err = ov5640_1_start_capture(sd);
+#else
+			err = ov5640_1_start_video(sd);
+#endif
+			break;
+		default:
+			dev_err(&client->dev,
+				"invalid run mode = 0x%x\n", dev->run_mode);
+			return -EINVAL;
+		}
+		if (err)
+			dev_warn(&client->dev,
+				"fail to start preview/video/capture.\n");
+
+		err = ov5640_1_mipi_stream(client, enable);
+		if (err)
+			return err;
+
+		dev->streaming = true;
+
+		if (dev->focus_mode_change) {
+			err = ov5640_1_s_focus_mode(sd, dev->focus_mode);
+			if (err) {
+				dev_err(&client->dev,
+					"writing focus mode reg fails.\n");
+				return err;
+			}
+			dev->focus_mode_change = false;
+		}
+
+	} else {
+
+
+		if (dev->run_mode == CI_MODE_PREVIEW) {
+			err = ov5640_1_stop_preview(sd);
+			if (err)
+				dev_warn(&client->dev,
+					"fail to stop preview\n");
+		}
+		err = ov5640_1_mipi_stream(client, enable);
+		if (err)
+			return err;
+
+		err = ov5640_1_standby(sd);
+		if (err)
+			return err;
+		dev->streaming = false;
+		dev->focus_mode = V4L2_CID_3A_LOCK;
+	}
+
+
+	return 0;
+}
+
+static int
+ov5640_1_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = ov5640_1_res[index].width;
+	fsize->discrete.height = ov5640_1_res[index].height;
+
+	fsize->reserved[0] = ov5640_1_res[index].used;
+
+	return 0;
+}
+
+static int ov5640_1_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	/* find out the first equal or bigger size */
+	for (i = 0; i < N_RES; i++) {
+		if (ov5640_1_res[i].width >= fival->width &&
+		    ov5640_1_res[i].height >= fival->height)
+			break;
+	}
+	if (i == N_RES)
+		i--;
+
+	index = i;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = ov5640_1_res[index].fps;
+
+	return 0;
+}
+
+static int
+ov5640_1_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV5640_1, 0);
+}
+
+static int ov5640_1_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov5640_1_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+	unsigned int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = ov5640_1_res[index].width;
+	fse->min_height = ov5640_1_res[index].height;
+	fse->max_width = ov5640_1_res[index].width;
+	fse->max_height = ov5640_1_res[index].height;
+
+	return 0;
+}
+
+static int
+ov5640_1_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov5640_1_device *snr = to_ov5640_1_sensor(sd);
+
+	switch (fmt->which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		fmt->format = *v4l2_subdev_get_try_format(fh, fmt->pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		fmt->format = snr->format;
+	}
+
+	return 0;
+}
+
+static int
+ov5640_1_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov5640_1_device *snr = to_ov5640_1_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+/* set focus zone */
+static int
+ov5640_1_set_selection(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			     struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+	int focus_width_step, focus_height_step;
+	u32 x_center, y_center;
+	int width = 0, height = 0;
+	int err, index;
+
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE) {
+		dev_err(&client->dev,
+				"invalid selection format.\n");
+		return -EINVAL;
+	}
+
+	if (sel->target != V4L2_SEL_TGT_COMPOSE) {
+		dev_err(&client->dev,
+				"invalid selection compose.\n");
+		return -EINVAL;
+	}
+
+	for (index = 0; index < N_RES; index++) {
+		if (dev->res == ov5640_1_res[index].res) {
+			width = ov5640_1_res[index].width;
+			height = ov5640_1_res[index].height;
+			break;
+		}
+	}
+
+	focus_width_step = width / OV5640_1_FOCUS_ZONE_ARRAY_WIDTH;
+	focus_height_step = height / OV5640_1_FOCUS_ZONE_ARRAY_HEIGHT;
+
+	/* calculate the center coordinate of selection rectangle */
+	x_center = DIV_ROUND_UP((sel->r.left + sel->r.width / 2),
+						focus_width_step);
+	y_center = DIV_ROUND_UP((sel->r.top + sel->r.height / 2),
+						focus_height_step);
+
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_FOCUS_ZONE_X,
+					x_center);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+					OV5640_1_REG_FOCUS_ZONE_Y,
+					y_center);
+	if (err)
+		return err;
+	err = ov5640_1_write_reg(client, MISENSOR_8BIT,
+						OV5640_1_REG_FOCUS_MODE,
+						OV5640_1_S_FOCUS_ZONE);
+	if (err)
+		return err;
+
+	return ov5640_1_s_focus_mode(sd, dev->focus_mode);
+}
+
+
+
+static int
+ov5640_1_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+
+//	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->res >= 0 && dev->res < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			ov5640_1_res[dev->res].fps;
+	}
+	return 0;
+}
+
+static int
+ov5640_1_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov5640_1_device *dev = to_ov5640_1_sensor(sd);
+
+	dev->run_mode = param->parm.capture.capturemode;
+	ovprintk("ov5640_1_s_parm dev->run_mode=0x%x\n", dev->run_mode);
+
+	return ov5640_1_g_parm(sd, param);
+}
+
+static int
+ov5640_1_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	int index;
+	struct ov5640_1_device *snr = to_ov5640_1_sensor(sd);
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov5640_1_res[index].res == snr->res) {
+			*frames = ov5640_1_res[index].skip_frames;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static const struct v4l2_subdev_video_ops ov5640_1_video_ops = {
+	.try_mbus_fmt = ov5640_1_try_mbus_fmt,
+	.g_mbus_fmt = ov5640_1_g_mbus_fmt,
+	.s_mbus_fmt = ov5640_1_s_mbus_fmt,
+	.s_parm = ov5640_1_s_parm,
+	.g_parm = ov5640_1_g_parm,
+	.s_stream = ov5640_1_s_stream,
+	.enum_framesizes = ov5640_1_enum_framesizes,
+	.enum_frameintervals = ov5640_1_enum_frameintervals,
+};
+
+static const struct v4l2_subdev_sensor_ops ov5640_1_sensor_ops = {
+	.g_skip_frames	= ov5640_1_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops ov5640_1_core_ops = {
+	.g_chip_ident = ov5640_1_g_chip_ident,
+	.queryctrl = ov5640_1_queryctrl,
+	.g_ctrl = ov5640_1_g_ctrl,
+	.s_ctrl = ov5640_1_s_ctrl,
+	.s_power = ov5640_1_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops ov5640_1_pad_ops = {
+	.enum_mbus_code = ov5640_1_enum_mbus_code,
+	.enum_frame_size = ov5640_1_enum_frame_size,
+	.get_fmt = ov5640_1_get_pad_format,
+	.set_fmt = ov5640_1_set_pad_format,
+	.set_selection = ov5640_1_set_selection,
+};
+
+static const struct v4l2_subdev_ops ov5640_1_ops = {
+	.core = &ov5640_1_core_ops,
+	.video = &ov5640_1_video_ops,
+	.sensor = &ov5640_1_sensor_ops,
+	.pad = &ov5640_1_pad_ops,
+};
+
+static const struct media_entity_operations ov5640_1_entity_ops;
+
+static int ov5640_1_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov5640_1_device *dev = container_of(sd,
+					struct ov5640_1_device, sd);
+
+	dev->platform_data->csi_cfg(sd, 0);
+
+	release_firmware(dev->firmware);
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	power_down(sd);
+	kfree(dev);
+
+	return 0;
+}
+
+static int ov5640_1_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct ov5640_1_device *dev;
+	int ret;
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &ov5640_1_ops);
+	if (client->dev.platform_data) {
+		ovprintk("ov5640_1_probe has platform data\n");
+		ret = ov5640_1_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+	else {
+		ovprintk("ov5640_1_probe NOOON platform data\n");
+	}
+	/*TODO add format code here*/
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.ops = &ov5640_1_entity_ops;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		ov5640_1_remove(client);
+		return ret;
+	}
+
+	/* set res index to be invalid */
+	dev->res = -1;
+
+	/* set focus mode to be invalid */
+	dev->focus_mode = -1;
+
+	/* set color_effect to be invalid */
+	dev->color_effect = -1;
+	dev->preview_gain16 = OV5640_1_DEFAULT_GAIN;
+	dev->preview_shutter = OV5640_1_DEFAULT_SHUTTER;
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, ov5640_1_id);
+static struct i2c_driver ov5640_1_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV5640_1_NAME,
+	},
+	.probe = ov5640_1_probe,
+	.remove = __exit_p(ov5640_1_remove),
+	.id_table = ov5640_1_id,
+};
+
+static __init int ov5640_1_init_mod(void)
+{
+	return i2c_add_driver(&ov5640_1_driver);
+}
+
+static __exit void ov5640_1_exit_mod(void)
+{
+	i2c_del_driver(&ov5640_1_driver);
+}
+
+module_init(ov5640_1_init_mod);
+module_exit(ov5640_1_exit_mod);
+
+MODULE_DESCRIPTION("A low-level driver for Omnivision OV5640_1 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/ov5640_1.h b/drivers/media/i2c/ov5640_1.h
new file mode 100644
index 0000000..b7863a4
--- /dev/null
+++ b/drivers/media/i2c/ov5640_1.h
@@ -0,0 +1,3623 @@
+/*
+ * Support for ov5640_1 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV5640_1_H__
+#define __OV5640_1_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+#define OV5640_1_NAME	"ov5640-1"
+
+#define V4L2_IDENT_OV5640_1 1111
+#define	LAST_REG_SETING	{0xffff, 0xff}
+
+#define OV5640_1_FOCAL_LENGTH_NUM	439	/*4.39mm*/
+#define OV5640_1_FOCAL_LENGTH_DEM	100
+#define OV5640_1_F_NUMBER_DEFAULT_NUM	24
+#define OV5640_1_F_NUMBER_DEM	10
+#define OV5640_1_FOCUS_ZONE_ARRAY_WIDTH	80
+#define OV5640_1_FOCUS_ZONE_ARRAY_HEIGHT	60
+
+#define OV5640_1_XVCLK		1920
+#define OV5640_1_AE_TARGET	45
+#define OV5640_1_DEFAULT_GAIN	50
+#define OV5640_1_DEFAULT_SHUTTER	1000
+
+#define OV5640_FACTORY_DEFAULT_ADDR 0x3c
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5640_1_FOCAL_LENGTH_DEFAULT 0xD00064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5640_1_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define OV5640_1_F_NUMBER_RANGE 0x180a180a
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+
+#define OV5640_1_REG_SCCB_ID	0x3100
+
+#define OV5640_1_REG_PID		0x300a
+#define OV5640_1_REG_SYS_RESET	0x3000
+#define OV5640_1_REG_FW_START	0x8000
+#define OV5640_1_REG_FOCUS_MODE	0x3022	/* focus mode reg */
+#define OV5640_1_REG_FOCUS_ZONE_X	0x3024	/* X coordinate of focus zone center */
+#define OV5640_1_REG_FOCUS_ZONE_Y	0x3025	/* Y coordinate of focus zone center */
+#define OV5640_1_REG_FOCUS_STATUS	0x3029	/* focus status reg */
+
+/* system pll control reg */
+#define OV5640_1_REG_PLL_CTRL_0	0x3034
+#define OV5640_1_REG_PLL_CTRL_1	0x3035
+#define OV5640_1_REG_PLL_CTRL_2	0x3036
+#define OV5640_1_REG_PLL_CTRL_3	0x3037
+
+/* pad clock divider for SCCB clock */
+#define OV5640_1_REG_CLK_DIVIDER	0x3108
+
+/* total horizontal size reg */
+#define OV5640_1_REG_TIMING_HTS	0x380c
+
+/* total vertical size reg */
+#define OV5640_1_REG_TIMING_VTS	0x380e
+
+/* exposure output reg */
+#define OV5640_1_REG_EXPOSURE_0	0x3500
+#define OV5640_1_REG_EXPOSURE_1	0x3502
+
+/* gain reg */
+#define OV5640_1_REG_GAIN	0x350a
+
+/* light frequency control reg */
+#define OV5640_1_REG_LIGHT_CTRL_0	0x3c01
+#define OV5640_1_REG_LIGHT_CTRL_1	0x3c00
+#define OV5640_1_REG_LIGHT_CTRL_2	0x3c0c
+
+/* light frequency */
+#define OV5640_1_LIGHT_50HZ	50
+#define OV5640_1_LIGHT_60HZ	60
+
+/* automatic banding filter */
+#define OV5640_1_AUTO_BAND	0x80
+
+/* 60HZ band step reg and 60HZ max bands */
+#define OV5640_1_REG_B60_STEP	0x3a0a
+#define OV5640_1_REG_B60_MAX	0x3a0d
+
+/* 50HZ band step reg and 50HZ max bands */
+#define OV5640_1_REG_B50_STEP	0x3a08
+#define OV5640_1_REG_B50_MAX	0x3a0e
+
+/* AEC domain control reg */
+#define OV5640_1_REG_AE_STAB_IN_H	0x3a0f	/* stable in high */
+#define OV5640_1_REG_AE_STAB_IN_L	0x3a10	/* stable in low */
+#define OV5640_1_REG_AE_STAB_OUT_H	0x3a1b	/* stable out high */
+#define OV5640_1_REG_AE_STAB_OUT_L	0x3a1e	/* stable out low */
+#define OV5640_1_REG_AE_FAST_H	0x3a11	/* fast zone high */
+#define OV5640_1_REG_AE_FAST_L	0x3a1f	/* fast zone low */
+
+/* AEC mode control reg */
+#define OV5640_1_REG_AE_MODE_CTRL	0x3503
+
+#define OV5640_1_AUTO_AG_AE	0x00	/* auto AG&AE */
+#define OV5640_1_MANUAL_AG_AE	0x03	/* manual AG&AE */
+
+/* AEC system control reg */
+#define OV5640_1_REG_AE_SYS_CTRL	0x3a00
+
+/* image exposure average readout reg */
+#define OV5640_1_REG_AE_AVERAGE	0x56a1
+
+/* frame control reg */
+#define OV5640_1_REG_FRAME_CTRL	0x4202
+
+#define OV5640_1_FRAME_START	0x00
+#define OV5640_1_FRAME_STOP	0x0f
+
+#define OV5640_1_MCU_RESET	0x20
+#define OV5640_1_SINGLE_FOCUS	0x03
+#define OV5640_1_CONTINUE_FOCUS	0x04
+#define OV5640_1_PAUSE_FOCUS	0x06
+#define OV5640_1_RELEASE_FOCUS	0x08
+#define OV5640_1_RELAUNCH_FOCUS	0x12
+#define OV5640_1_S_FOCUS_ZONE	0x81
+
+/* focus firmware is downloaded but not to be initialized */
+#define OV5640_1_FOCUS_FW_DL	0x7f
+#define OV5640_1_FOCUS_FW_INIT	0x7e	/* focus firmware is initializing */
+#define OV5640_1_FOCUS_FW_IDLE	0x70	/* focus firmware is idle */
+#define OV5640_1_FOCUS_FW_RUN	0x00	/* focus firmware is running */
+#define OV5640_1_FOCUS_FW_FINISH	0x10	/* focus is finished */
+
+#define OV5640_1_REG_AWB_CTRL	0x3406
+
+#define OV5640_1_AWB_GAIN_AUTO	0
+#define OV5640_1_AWB_GAIN_MANUAL	1
+
+#define MIN_SYSCLK		10
+#define MIN_VTS			8
+#define MIN_HTS			8
+#define MIN_SHUTTER		0
+#define MIN_GAIN		0
+
+/* OV5640_1_DEVICE_ID */
+#define OV5640_1_MOD_ID		0x5640
+
+#define AF_FW_PATH	"OV5640_AF_FW.bin"
+
+/* Supported resolutions */
+enum {
+	OV5640_1_RES_QVGA,
+	OV5640_1_RES_DVGA,
+	OV5640_1_RES_320P,
+	OV5640_1_RES_360P,
+	OV5640_1_RES_VGA,
+	OV5640_1_RES_RGB_VGA,
+	OV5640_1_RES_RAW_10_VGA,
+	OV5640_1_RES_480P,
+	OV5640_1_RES_736x480P,
+	OV5640_1_RES_800x480P,
+	OV5640_1_RES_720P,
+	OV5640_1_RGB565_RES_720P,
+	OV5640_1_RES_1440X720P,
+	OV5640_1_RES_1080P,
+	OV5640_1_RES_1080P_RGB,
+	OV5640_1_RES_1088P,
+	OV5640_1_RES_D3M,
+	OV5640_1_RES_3M,
+	OV5640_1_RES_D5M,
+	OV5640_1_RES_5M,
+};
+#define OV5640_1_RES_5M_SIZE_H		2560
+#define OV5640_1_RES_5M_SIZE_V		1920
+#define OV5640_1_RES_D5M_SIZE_H		2496
+#define OV5640_1_RES_D5M_SIZE_V		1664
+#define OV5640_1_RES_D3M_SIZE_H		2112
+#define OV5640_1_RES_D3M_SIZE_V		1408
+#define OV5640_1_RES_3M_SIZE_H		2048
+#define OV5640_1_RES_3M_SIZE_V		1536
+#define OV5640_1_RES_1088P_SIZE_H		1920
+#define OV5640_1_RES_1088P_SIZE_V		1088
+#define OV5640_1_RES_1080P_SIZE_H		1920
+#define OV5640_1_RES_1080P_SIZE_V		1080
+#define OV5640_1_RES_720P_SIZE_H		1280
+#define OV5640_1_RES_720P_SIZE_V		720
+
+#define OV5640_1_RGB565_RES_720P_SIZE_H		1280
+#define OV5640_1_RGB565_RES_720P_SIZE_V		720
+
+#define OV5640_1_RES_1440X720P_SIZE_H		1440
+#define OV5640_1_RES_1440X720P_SIZE_V		720
+
+#define OV5640_1_RES_480P_SIZE_H		720
+#define OV5640_1_RES_480P_SIZE_V		480
+
+#define OV5640_1_RES_736x480P_SIZE_H		736
+#define OV5640_1_RES_736x480P_SIZE_V		480
+
+
+#define OV5640_1_RES_VGA_SIZE_H		640
+#define OV5640_1_RES_VGA_SIZE_V		480
+#define OV5640_1_RES_360P_SIZE_H		640
+#define OV5640_1_RES_360P_SIZE_V		360
+#define OV5640_1_RES_320P_SIZE_H		480
+#define OV5640_1_RES_320P_SIZE_V		320
+#define OV5640_1_RES_DVGA_SIZE_H		416
+#define OV5640_1_RES_DVGA_SIZE_V		312
+#define OV5640_1_RES_QVGA_SIZE_H		320
+#define OV5640_1_RES_QVGA_SIZE_V		240
+
+#define OV5640_1_RES_800x480P_SIZE_H		800
+#define OV5640_1_RES_800x480P_SIZE_V		480
+
+
+/* TODO: Definition not available in kernel 3.5 */
+/* Current composing area */
+#define V4L2_SEL_TGT_COMPOSE            0x0100
+
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u16 length;
+	u16 reg;
+	u32 val;	/* value or for read/mod/write */
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct ov5640_1_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	const struct firmware *firmware;
+
+	struct camera_sensor_platform_data *platform_data;
+	int run_mode;
+	int focus_mode;
+	int night_mode;
+	bool focus_mode_change;
+	int color_effect;
+	bool streaming;
+	bool preview_ag_ae;
+	u16 sensor_id;
+	u8 sensor_revision;
+	unsigned int ae_high;
+	unsigned int ae_low;
+	unsigned int preview_shutter;
+	unsigned int preview_gain16;
+	unsigned int average;
+	unsigned int preview_sysclk;
+	unsigned int preview_hts;
+	unsigned int preview_vts;
+	unsigned int res;
+};
+
+struct ov5640_1_priv_data {
+	u32 port;
+	u32 num_of_lane;
+	u32 input_format;
+	u32 raw_bayer_order;
+};
+
+struct ov5640_1_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct ov5640_1_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int code;
+	int fps;
+	int skip_frames;
+	bool used;
+	struct regval_list *regs;
+};
+
+#define OV5640_1_MAX_WRITE_BUF_SIZE	32
+struct ov5640_1_write_buffer {
+	u16 addr;
+	u8 data[OV5640_1_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov5640_1_write_ctrl {
+	int index;
+	struct ov5640_1_write_buffer buffer;
+};
+
+struct ov5640_1_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+#define N_ov5640_1_FMTS ARRAY_SIZE(ov5640_1_formats)
+
+/*
+ * Modes supported by the mt9m114 driver.
+ * Please, keep them in ascending order.
+ */
+static struct ov5640_1_res_struct ov5640_1_res[] = {
+	{
+	.desc	= "QVGA",
+	.res	= OV5640_1_RES_QVGA,
+	.width	= 320,
+	.height	= 240,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "DVGA",
+	.res	= OV5640_1_RES_DVGA,
+	.width	= 416,
+	.height	= 312,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "320P",
+	.res	= OV5640_1_RES_320P,
+	.width	= 480,
+	.height	= 320,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "360P",
+	.res	= OV5640_1_RES_360P,
+	.width	= 640,
+	.height	= 360,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 5,
+	},
+	{
+	.desc	= "VGA",
+	.res	= OV5640_1_RES_VGA,
+	.width	= 640,
+	.height	= 480,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "VGA_RGB",
+	.res	= OV5640_1_RES_RGB_VGA,
+	.width	= 640,
+	.height	= 480,
+	.code = 0x1008,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "VGA_RAW_10",
+	.res	= OV5640_1_RES_RAW_10_VGA,
+	.width	= 640,
+	.height	= 480,
+	.code = MEDIA_BUS_FMT_SBGGR10_1X10,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+		},
+	{
+	.desc	= "480P",
+	.res	= OV5640_1_RES_480P,
+	.width	= 720,
+	.height	= 480,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "736x480P",
+	.res	= OV5640_1_RES_736x480P,
+	.width	= 736,
+	.height	= 480,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "800x480p",
+	.res	= OV5640_1_RES_800x480P,
+	.width	= 800,
+	.height = 480,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "720p",
+	.res	= OV5640_1_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+
+	{
+	.desc	= "RGB565_720p",
+	.res	= OV5640_1_RGB565_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.code = 0x1008,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+
+	{
+	.desc	= "1440x720p",
+	.res	= OV5640_1_RES_1440X720P,
+	.width	= 1440,
+	.height	= 720,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "1080P",
+	.res	= OV5640_1_RES_1080P,
+	.width	= 1920,
+	.height	= 1080,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+		.desc	= "1080P",
+		.res	= OV5640_1_RES_1080P_RGB,
+		.width	= 1920,
+		.height	= 1080,
+		.code = 0x1008,
+		.fps	= 30,
+		.used	= 0,
+		.regs	= NULL,
+		.skip_frames = 4,
+		},
+	{
+	.desc	= "1088P",
+	.res	= OV5640_1_RES_1088P,
+	.width	= 1920,
+	.height	= 1088,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "D3M",
+	.res	= OV5640_1_RES_D3M,
+	.width	= 2112,
+	.height	= 1408,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "3M",
+	.res	= OV5640_1_RES_3M,
+	.width	= 2048,
+	.height	= 1536,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "D5M",
+	.res	= OV5640_1_RES_D5M,
+	.width	= 2496,
+	.height	= 1664,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "5M",
+	.res	= OV5640_1_RES_5M,
+	.width	= 2560,
+	.height	= 1920,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+
+};
+#define N_RES (ARRAY_SIZE(ov5640_1_res))
+
+static const struct i2c_device_id ov5640_1_id[] = {
+	{"ov5640-1", 0},
+	{}
+};
+
+static struct misensor_reg const ov5640_1_standby_reg[] = {
+	 {MISENSOR_8BIT,  0x300e, 0x5d},
+	 {MISENSOR_8BIT,  0x3008, 0x42},	/* software powerdown */
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_wakeup_reg[] = {
+	{MISENSOR_8BIT,  0x3008, 0x02},
+	{MISENSOR_8BIT,  0x300e, 0x45},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_normal_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x06},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_sepia_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0xA0},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_negative_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x46},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_bw_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x80},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x80},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_blue_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0xA0},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x40},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_green_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x60},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x60},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* 5M, yuv422, 2lanes, mipi, 12fps */
+static struct misensor_reg const ov5640_1_5M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of input size. value is 2591 */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1927 */
+	{MISENSOR_8BIT, 0x3808, 0x0A},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width, value is 2560 */
+	{MISENSOR_8BIT, 0x380A, 0x07},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1920 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x06},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x08},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0x83},	/* isp ctrl */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0A},
+	{MISENSOR_8BIT, 0x380D, 0xB4},	/* total H-size is 2740 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0xE8},	/* total v-size is 2024 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xE4},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xE4},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x2F},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xFD},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x08},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* D5M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_1_D5M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},	/* X end of input size. value is 2527 */
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1671 */
+	{MISENSOR_8BIT, 0x3808, 0x09},
+	{MISENSOR_8BIT, 0x3809, 0xC0},	/* DVP output H_width, value is 2496 */
+	{MISENSOR_8BIT, 0x380A, 0x06},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1664 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0x83},	/* isp ctrl */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0B},
+	{MISENSOR_8BIT, 0x380D, 0x1C},	/* total H-size is 2844 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0x95},	/* total v-size is 1941 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0x91},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0x91},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x07},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* 3M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_1_3M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of input size. value is 2591 */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1927 */
+	{MISENSOR_8BIT, 0x3808, 0x08},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width, value is 2048 */
+	{MISENSOR_8BIT, 0x380A, 0x06},
+	{MISENSOR_8BIT, 0x380B, 0x00},	/* DVP output V_heigh, value is 1536 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0A},
+	{MISENSOR_8BIT, 0x380D, 0xA0},	/* total H-size is 2720 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0xF6},	/* total v-size is 2038 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xF2},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xF2},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x31},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xFE},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x08},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* D3M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_1_D3M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},	/* X end of input size. value is 2527 */
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1671 */
+	{MISENSOR_8BIT, 0x3808, 0x08},
+	{MISENSOR_8BIT, 0x3809, 0x40},	/* DVP output H_width, value is 2112 */
+	{MISENSOR_8BIT, 0x380A, 0x05},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1408 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xB0},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xB0},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0B},
+	{MISENSOR_8BIT, 0x380D, 0x1C},	/* total H-size is 2844 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0x95},	/* total v-size is 1941 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0x91},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0x91},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x07},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1088p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_1088p_init[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06}, /* disable binning */
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of isp input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF9},	/* Y end of isp input size */
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* 1920 */
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x40},	/* 1088 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0x60},
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0x60},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},
+	{MISENSOR_8BIT, 0x501F, 0x00},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1080p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_1080p_init[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x38},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x06},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},
+	{MISENSOR_8BIT, 0x501F, 0x00},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1080p, rgb565, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_1080p_rgb[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x38},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x06},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x6f},
+	{MISENSOR_8BIT, 0x501F, 0x01},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 720p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_720p_init[] = {
+#ifdef ORIGINAL_SETTINGS
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},	/* X start of input size */
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},	/* Y start of input size */
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},	/* Y end of input size */
+	{MISENSOR_8BIT, 0x3808, 0x05},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width */
+	{MISENSOR_8BIT, 0x380A, 0x02},
+	{MISENSOR_8BIT, 0x380B, 0xD0},	/* DVP output V_heigh */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x97},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x53},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling*/
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},	/* same with 1080p */
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x18},	/* total H-size is 2328 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xA8},	/* total v-size is 1192 */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x66},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x2A},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xA4},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xA4},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+#else  /* FROM JOSH @OV.COM */
+	/* YUV 1280x720, mclk 19.2mhz 60 fps */
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*for mclk=19.2MHz,0x54 */
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0xfa},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x06},
+	{MISENSOR_8BIT,0x3807,0xa9},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0x00},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x64},
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x02},
+	{MISENSOR_8BIT,0x3a03,0xe4},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0xbc},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x72},
+	{MISENSOR_8BIT,0x3a0e,0x01},
+	{MISENSOR_8BIT,0x3a0d,0x02},
+	{MISENSOR_8BIT,0x3a14,0x02},
+	{MISENSOR_8BIT,0x3a15,0xe4},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x0a*/}, /* 0x16 */
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+#endif
+
+};
+
+/* camera: 480p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_480p_init[] = {
+#ifdef ORIGINAL_SETTINGS
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x04},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x3F},
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0xD9},
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xD0},
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x0B},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+#else
+#if 0
+	/* from josh @ov.com */
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x22},/*0x21*/
+	{MISENSOR_8BIT,0x3036,0x8c},/*mclk=19.2MHz,0x70*/
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0x3a},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x07},
+	{MISENSOR_8BIT,0x3807,0x67},
+	{MISENSOR_8BIT,0x3808,0x02},
+	{MISENSOR_8BIT,0x3809,0xd0},
+	{MISENSOR_8BIT,0x380a,0x01},
+	{MISENSOR_8BIT,0x380b,0xe0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x68},
+	{MISENSOR_8BIT,0x380e,0x03},
+	{MISENSOR_8BIT,0x380f,0xd8},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x06},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x03},
+	{MISENSOR_8BIT,0x3a03,0xd8},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0x27},
+	{MISENSOR_8BIT,0x3a0a,0x00},
+	{MISENSOR_8BIT,0x3a0b,0xf6},
+	{MISENSOR_8BIT,0x3a0e,0x03},
+	{MISENSOR_8BIT,0x3a0d,0x04},
+	{MISENSOR_8BIT,0x3a14,0x03},
+	{MISENSOR_8BIT,0x3a15,0xd8},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x22, *0x10*/},
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0xa3},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+#endif
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xD0},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+
+#endif
+
+};
+
+
+/* camera: 480p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_736x480p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};
+
+
+/* camera: 320p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_320p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0xE0},
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x40},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x0B},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x68},	/* total h_size is 1896 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/* camera: 360p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1_360p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},	/* X start of input size */
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},	/* Y start of input size */
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},	/* Y end of input size */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output H_width */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x68},	/* DVP output V_heigh */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x02},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x4837, 0x2C},	/* PCLK PERIOD */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x05},	/* total H-size is 2309 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total v-size is 1200*/
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x68},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x2C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/* camera vga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_1_vga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera vga 30fps, rgb(640x480),----- 2lanes */
+static struct misensor_reg const ov5640_1_vga_rgb_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x6f},
+		{MISENSOR_8BIT, 0x501F, 0x01},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+//10-bit RAW VGA format 30fps 2 Lane
+static struct misensor_reg const ov5640_1_vga_raw_10_init[] = {
+		{MISENSOR_8BIT, 0x3103,0x11},
+		{MISENSOR_8BIT, 0x3008,0x82},
+		{MISENSOR_8BIT, 0x3008,0x42},
+		{MISENSOR_8BIT, 0x3103,0x03},
+		{MISENSOR_8BIT, 0x3017,0x00},
+		{MISENSOR_8BIT, 0x3018,0x00},
+		{MISENSOR_8BIT, 0x3034,0x1a},
+		{MISENSOR_8BIT, 0x3035,0x14}, //;21
+		{MISENSOR_8BIT, 0x3036,0x58}, //;mclk=19.2MHz 70
+		{MISENSOR_8BIT, 0x3037,0x13},
+		{MISENSOR_8BIT, 0x3108,0x01},
+		{MISENSOR_8BIT, 0x303b,0x14},
+		{MISENSOR_8BIT, 0x303c,0x11},
+		{MISENSOR_8BIT, 0x303d,0x17},
+		{MISENSOR_8BIT, 0x3108,0x01},
+		{MISENSOR_8BIT, 0x3630,0x36},
+		{MISENSOR_8BIT, 0x3631,0x0e},
+		{MISENSOR_8BIT, 0x3632,0xe2},
+		{MISENSOR_8BIT, 0x3633,0x12},
+		{MISENSOR_8BIT, 0x3621,0xe0},
+		{MISENSOR_8BIT, 0x3704,0xa0},
+		{MISENSOR_8BIT, 0x3703,0x5a},
+		{MISENSOR_8BIT, 0x3715,0x78},
+		{MISENSOR_8BIT, 0x3717,0x01},
+		{MISENSOR_8BIT, 0x370b,0x60},
+		{MISENSOR_8BIT, 0x3705,0x1a},
+		{MISENSOR_8BIT, 0x3905,0x02},
+		{MISENSOR_8BIT, 0x3906,0x10},
+		{MISENSOR_8BIT, 0x3901,0x0a},
+		{MISENSOR_8BIT, 0x3731,0x12},
+		{MISENSOR_8BIT, 0x3600,0x08},
+		{MISENSOR_8BIT, 0x3601,0x33},
+		{MISENSOR_8BIT, 0x302d,0x60},
+		{MISENSOR_8BIT, 0x3620,0x52},
+		{MISENSOR_8BIT, 0x371b,0x20},
+		{MISENSOR_8BIT, 0x471c,0x50},
+		{MISENSOR_8BIT, 0x3a13,0x43},
+		{MISENSOR_8BIT, 0x3a18,0x00},
+		{MISENSOR_8BIT, 0x3a19,0xf8},
+		{MISENSOR_8BIT, 0x3635,0x13},
+		{MISENSOR_8BIT, 0x3636,0x03},
+		{MISENSOR_8BIT, 0x3634,0x40},
+		{MISENSOR_8BIT, 0x3622,0x01},
+		{MISENSOR_8BIT, 0x3c01,0x34},
+		{MISENSOR_8BIT, 0x3c04,0x28},
+		{MISENSOR_8BIT, 0x3c05,0x98},
+		{MISENSOR_8BIT, 0x3c06,0x00},
+		{MISENSOR_8BIT, 0x3c07,0x08},
+		{MISENSOR_8BIT, 0x3c08,0x00},
+		{MISENSOR_8BIT, 0x3c09,0x1c},
+		{MISENSOR_8BIT, 0x3c0a,0x9c},
+		{MISENSOR_8BIT, 0x3c0b,0x40},
+		{MISENSOR_8BIT, 0x3820,0x41},
+		{MISENSOR_8BIT, 0x3821,0x07},
+		{MISENSOR_8BIT, 0x3814,0x71},//;31
+		{MISENSOR_8BIT, 0x3815,0x35},//;31
+		{MISENSOR_8BIT, 0x3800,0x00},
+		{MISENSOR_8BIT, 0x3801,0x00},
+		{MISENSOR_8BIT, 0x3802,0x00},
+		{MISENSOR_8BIT, 0x3803,0x04},
+		{MISENSOR_8BIT, 0x3804,0x0a},
+		{MISENSOR_8BIT, 0x3805,0x3f},
+		{MISENSOR_8BIT, 0x3806,0x07},
+		{MISENSOR_8BIT, 0x3807,0x9b},
+		{MISENSOR_8BIT, 0x3808,0x02},
+		{MISENSOR_8BIT, 0x3809,0x80},
+		{MISENSOR_8BIT, 0x380a,0x01},
+		{MISENSOR_8BIT, 0x380b,0xe0},
+		{MISENSOR_8BIT, 0x380c,0x07},
+		{MISENSOR_8BIT, 0x380d,0x70},// ;68
+		{MISENSOR_8BIT, 0x380e,0x03},
+		{MISENSOR_8BIT, 0x380f,0xd8},
+		{MISENSOR_8BIT, 0x3810,0x00},
+		{MISENSOR_8BIT, 0x3811,0x08},//;10
+		{MISENSOR_8BIT, 0x3812,0x00},
+		{MISENSOR_8BIT, 0x3813,0x06},
+		{MISENSOR_8BIT, 0x3618,0x00},
+		{MISENSOR_8BIT, 0x3612,0x29},
+		{MISENSOR_8BIT, 0x3708,0x64},// ;62
+		{MISENSOR_8BIT, 0x3709,0xf2},// ;52
+		{MISENSOR_8BIT, 0x370c,0x03},
+		{MISENSOR_8BIT, 0x3a02,0x03},
+		{MISENSOR_8BIT, 0x3a03,0xd8},
+		{MISENSOR_8BIT, 0x3a08,0x01},
+		{MISENSOR_8BIT, 0x3a09,0x27},
+		{MISENSOR_8BIT, 0x3a0a,0x00},
+		{MISENSOR_8BIT, 0x3a0b,0xf6},
+		{MISENSOR_8BIT, 0x3a0e,0x03},
+		{MISENSOR_8BIT, 0x3a0d,0x04},
+		{MISENSOR_8BIT, 0x3a14,0x03},
+		{MISENSOR_8BIT, 0x3a15,0xd8},
+		{MISENSOR_8BIT, 0x4001,0x02},
+		{MISENSOR_8BIT, 0x4004,0x02},
+		{MISENSOR_8BIT, 0x3000,0x00},
+		{MISENSOR_8BIT, 0x3002,0x1c},
+		{MISENSOR_8BIT, 0x3004,0xff},
+		{MISENSOR_8BIT, 0x3006,0xc3},
+		{MISENSOR_8BIT, 0x300e,0x45},// ;25
+		{MISENSOR_8BIT, 0x302e,0x08},
+		{MISENSOR_8BIT, 0x4300,0xf8},
+		{MISENSOR_8BIT, 0x501f,0x03},
+		{MISENSOR_8BIT, 0x4713,0x03},
+		{MISENSOR_8BIT, 0x4407,0x04},
+		{MISENSOR_8BIT, 0x440e,0x00},
+		{MISENSOR_8BIT, 0x460b,0x37},
+		{MISENSOR_8BIT, 0x460c,0x20},
+		{MISENSOR_8BIT, 0x4837,0x44},
+		{MISENSOR_8BIT, 0x3824,0x04},
+		{MISENSOR_8BIT, 0x5000,0x06},
+		{MISENSOR_8BIT, 0x5001,0x00},
+		{MISENSOR_8BIT, 0x3a0f,0x30},
+		{MISENSOR_8BIT, 0x3a10,0x28},
+		{MISENSOR_8BIT, 0x3a1b,0x30},
+		{MISENSOR_8BIT, 0x3a1e,0x26},
+		{MISENSOR_8BIT, 0x3a11,0x60},
+		{MISENSOR_8BIT, 0x3a1f,0x14},
+		{MISENSOR_8BIT, 0x3008,0x02},
+		{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera qvga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_1_qvga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0x40},
+	{MISENSOR_8BIT, 0x380A, 0x00},
+	{MISENSOR_8BIT, 0x380B, 0xF0},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x68},	/* total h_size is 1896 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera dvga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_1_dvga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0xA0},	/* DVP output, value is 416 */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x38},	/* DVP output, value is 312 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x31},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_common[] = {
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_iq[] = {
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_init[] = {
+	/* init software */
+	{MISENSOR_8BIT, 0x3103, 0x11},
+	{MISENSOR_TOK_DELAY, 0, 5},
+	{MISENSOR_8BIT, 0x3008, 0x82},
+	{MISENSOR_TOK_DELAY, 0, 5},
+	{MISENSOR_8BIT, 0x3008, 0x42},	/* software power down */
+	{MISENSOR_8BIT, 0x3103, 0x03},	/* SCCB system control */
+	/* set Frex Vsync href PCLK D[9:6} input */
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},	/* set d[5:0] GPIO[1:0] input */
+	{MISENSOR_8BIT, 0x3034, 0x18},	/* MIPI 8-bit mode*/
+	{MISENSOR_8BIT, 0x3037, 0x13},	/* PLL */
+	{MISENSOR_8BIT, 0x3108, 0x01},	/* system divider */
+	{MISENSOR_8BIT, 0x3630, 0x36},
+	{MISENSOR_8BIT, 0x3631, 0x0E},
+	{MISENSOR_8BIT, 0x3632, 0xE2},
+	{MISENSOR_8BIT, 0x3633, 0x12},
+	{MISENSOR_8BIT, 0x3621, 0xE0},
+	{MISENSOR_8BIT, 0x3704, 0xA0},
+	{MISENSOR_8BIT, 0x3703, 0x5A},
+	{MISENSOR_8BIT, 0x3715, 0x78},
+	{MISENSOR_8BIT, 0x3717, 0x01},
+	{MISENSOR_8BIT, 0x370B, 0x60},
+	{MISENSOR_8BIT, 0x3705, 0x1A},
+	{MISENSOR_8BIT, 0x3905, 0x02},
+	{MISENSOR_8BIT, 0x3906, 0x10},
+	{MISENSOR_8BIT, 0x3901, 0x0A},
+	{MISENSOR_8BIT, 0x3731, 0x12},
+	{MISENSOR_8BIT, 0x3600, 0x08},	/* VCM debug mode */
+	{MISENSOR_8BIT, 0x3601, 0x33},	/* VCM debug mode */
+	{MISENSOR_8BIT, 0x302D, 0x60},	/* system control */
+	{MISENSOR_8BIT, 0x3620, 0x52},
+	{MISENSOR_8BIT, 0x371B, 0x20},
+	{MISENSOR_8BIT, 0x471C, 0x50},
+	{MISENSOR_8BIT, 0x3A13, 0x43},	/* AGC pre-gain 40 = 1x */
+	{MISENSOR_8BIT, 0x3A18, 0x00},	/* gain ceiling */
+	{MISENSOR_8BIT, 0x3A19, 0xF8},	/* gain ceiling */
+	{MISENSOR_8BIT, 0x3635, 0x13},
+	{MISENSOR_8BIT, 0x3636, 0x03},
+	{MISENSOR_8BIT, 0x3634, 0x40},
+	{MISENSOR_8BIT, 0x3622, 0x01},
+	{MISENSOR_8BIT, 0x3C00, 0x04},	/* 50Hz/60Hz */
+	{MISENSOR_8BIT, 0x3C01, 0xB4},	/* 50/60Hz */
+	{MISENSOR_8BIT, 0x3C04, 0x28},	/* threshold for low sum */
+	{MISENSOR_8BIT, 0x3C05, 0x98},	/* threshold for high sum */
+	{MISENSOR_8BIT, 0x3C06, 0x00},	/* light meter 1 threshold high */
+	{MISENSOR_8BIT, 0x3C08, 0x00},	/* light meter 2 threshold high */
+	{MISENSOR_8BIT, 0x3C09, 0x1C},	/* light meter 2 threshold low */
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},	/* sample number high */
+	{MISENSOR_8BIT, 0x3C0B, 0x40},	/* sample number low */
+	/* timing */
+	{MISENSOR_8BIT, 0x3800, 0x00},	/* HS */
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* HS */
+	{MISENSOR_8BIT, 0x3802, 0x00},	/* VS */
+	{MISENSOR_8BIT, 0x3804, 0x0A},	/* HW */
+	{MISENSOR_8BIT, 0x3805, 0x3F},	/* HW */
+	{MISENSOR_8BIT, 0x3810, 0x00},	/* H offset high */
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* H offset low */
+	{MISENSOR_8BIT, 0x3812, 0x00},	/* V offset high */
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3A08, 0x01},	/* B50 */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset 0 */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},	/* system reset 2 */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* clock enable 00 */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* clock enable 2 */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI control 2 lane MIPI on */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},	/* YUV 422 UYVY */
+	{MISENSOR_8BIT, 0x501F, 0x00},	/* ISP YUV 422 */
+	{MISENSOR_8BIT, 0x4407, 0x04},	/* JPEG QS */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	/* ISP control LENC on GAMMA on BPC on WPC on CIP on */
+	{MISENSOR_8BIT, 0x5000, 0xA7},
+	/* AWB */
+	{MISENSOR_8BIT, 0x5180, 0xFF},
+	{MISENSOR_8BIT, 0x5181, 0xF2},
+	{MISENSOR_8BIT, 0x5182, 0x00},
+	{MISENSOR_8BIT, 0x5183, 0x14},
+	{MISENSOR_8BIT, 0x5184, 0x25},
+	{MISENSOR_8BIT, 0x5185, 0x24},
+	{MISENSOR_8BIT, 0x5189, 0x8D},
+	{MISENSOR_8BIT, 0x518A, 0x61},
+	{MISENSOR_8BIT, 0x518C, 0x94},
+	{MISENSOR_8BIT, 0x518B, 0xAF},
+	{MISENSOR_8BIT, 0x5187, 0x17},
+	{MISENSOR_8BIT, 0x5188, 0x0F},
+	{MISENSOR_8BIT, 0x518D, 0x41},
+	{MISENSOR_8BIT, 0x518F, 0x75},
+	{MISENSOR_8BIT, 0x518E, 0x34},
+	{MISENSOR_8BIT, 0x5190, 0x43},
+	{MISENSOR_8BIT, 0x5191, 0xF5},
+	{MISENSOR_8BIT, 0x5192, 0x0A},
+	{MISENSOR_8BIT, 0x5186, 0x16},
+	{MISENSOR_8BIT, 0x5193, 0x70},
+	{MISENSOR_8BIT, 0x5194, 0xF0},
+	{MISENSOR_8BIT, 0x5195, 0xF0},
+	{MISENSOR_8BIT, 0x5196, 0x03},
+	{MISENSOR_8BIT, 0x5197, 0x01},
+	{MISENSOR_8BIT, 0x5198, 0x05},
+	{MISENSOR_8BIT, 0x5199, 0xDB},
+	{MISENSOR_8BIT, 0x519A, 0x04},
+	{MISENSOR_8BIT, 0x519B, 0x00},
+	{MISENSOR_8BIT, 0x519C, 0x08},
+	{MISENSOR_8BIT, 0x519D, 0x20},
+	{MISENSOR_8BIT, 0x519E, 0x38},
+	/* color matrix */
+	{MISENSOR_8BIT, 0x5381, 0x1F},
+	{MISENSOR_8BIT, 0x5382, 0x5C},
+	{MISENSOR_8BIT, 0x5383, 0x05},
+	{MISENSOR_8BIT, 0x5384, 0x03},
+	{MISENSOR_8BIT, 0x5385, 0x6C},
+	{MISENSOR_8BIT, 0x5386, 0x6F},
+	{MISENSOR_8BIT, 0x5387, 0x6E},
+	{MISENSOR_8BIT, 0x5388, 0x62},
+	{MISENSOR_8BIT, 0x5389, 0x0C},
+	{MISENSOR_8BIT, 0x538A, 0x01},
+	{MISENSOR_8BIT, 0x538B, 0x98},
+	/* CIP */
+	{MISENSOR_8BIT, 0x5300, 0x08},	/* sharpen MT th1 */
+	{MISENSOR_8BIT, 0x5301, 0x30},	/* sharpen MT th2 */
+	{MISENSOR_8BIT, 0x5302, 0x18},	/* sharpen MT offset 1 */
+	{MISENSOR_8BIT, 0x5303, 0x0E},	/* sharpen MT offset 2 */
+	{MISENSOR_8BIT, 0x5304, 0x08},	/* DNS threshold 1 */
+	{MISENSOR_8BIT, 0x5305, 0x30},	/* DNS threshold 2 */
+	{MISENSOR_8BIT, 0x5306, 0x08},	/* DNS offset 1 */
+	{MISENSOR_8BIT, 0x5307, 0x16},	/* DNS offset 2 */
+	{MISENSOR_8BIT, 0x5308, 0x00},	/* auto de-noise */
+	{MISENSOR_8BIT, 0x5309, 0x08},	/* sharpen TH th1 */
+	{MISENSOR_8BIT, 0x530A, 0x30},	/* sharpen TH th2 */
+	{MISENSOR_8BIT, 0x530B, 0x04},	/* sharpen TH offset 1 */
+	{MISENSOR_8BIT, 0x530C, 0x06},	/* sharpen TH offset 2 */
+	/* gamma */
+	{MISENSOR_8BIT, 0x5480, 0x01},
+	{MISENSOR_8BIT, 0x5481, 0x08},
+	{MISENSOR_8BIT, 0x5482, 0x14},
+	{MISENSOR_8BIT, 0x5483, 0x28},
+	{MISENSOR_8BIT, 0x5484, 0x51},
+	{MISENSOR_8BIT, 0x5485, 0x65},
+	{MISENSOR_8BIT, 0x5486, 0x71},
+	{MISENSOR_8BIT, 0x5487, 0x7D},
+	{MISENSOR_8BIT, 0x5488, 0x87},
+	{MISENSOR_8BIT, 0x5489, 0x91},
+	{MISENSOR_8BIT, 0x548A, 0x9A},
+	{MISENSOR_8BIT, 0x548B, 0xAA},
+	{MISENSOR_8BIT, 0x548C, 0xB8},
+	{MISENSOR_8BIT, 0x548D, 0xCD},
+	{MISENSOR_8BIT, 0x548E, 0xDD},
+	{MISENSOR_8BIT, 0x548F, 0xEA},
+	{MISENSOR_8BIT, 0x5490, 0x1D},
+	/* UV adjust */
+	{MISENSOR_8BIT, 0x5580, 0x06},	/* sat on contrast on */
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat VV */
+	{MISENSOR_8BIT, 0x5589, 0x10},	/* UV adjust th1 */
+	{MISENSOR_8BIT, 0x558A, 0x00},	/* UV adjust th2[8] */
+	{MISENSOR_8BIT, 0x558B, 0xF8},	/* UV adjust th2[7:0] */
+	{MISENSOR_8BIT, 0x501D, 0x40},	/* enable manual offset of contrast */
+	/* lens correction */
+	{MISENSOR_8BIT, 0x5800, 0x3D},
+	{MISENSOR_8BIT, 0x5801, 0x1E},
+	{MISENSOR_8BIT, 0x5802, 0x15},
+	{MISENSOR_8BIT, 0x5803, 0x17},
+	{MISENSOR_8BIT, 0x5804, 0x1E},
+	{MISENSOR_8BIT, 0x5805, 0x3F},
+	{MISENSOR_8BIT, 0x5806, 0x10},
+	{MISENSOR_8BIT, 0x5807, 0x0A},
+	{MISENSOR_8BIT, 0x5808, 0x07},
+	{MISENSOR_8BIT, 0x5809, 0x07},
+	{MISENSOR_8BIT, 0x580A, 0x0B},
+	{MISENSOR_8BIT, 0x580B, 0x13},
+	{MISENSOR_8BIT, 0x580C, 0x0A},
+	{MISENSOR_8BIT, 0x580D, 0x04},
+	{MISENSOR_8BIT, 0x580E, 0x00},
+	{MISENSOR_8BIT, 0x580F, 0x00},
+	{MISENSOR_8BIT, 0x5810, 0x04},
+	{MISENSOR_8BIT, 0x5811, 0x0C},
+	{MISENSOR_8BIT, 0x5812, 0x0A},
+	{MISENSOR_8BIT, 0x5813, 0x04},
+	{MISENSOR_8BIT, 0x5814, 0x00},
+	{MISENSOR_8BIT, 0x5815, 0x00},
+	{MISENSOR_8BIT, 0x5816, 0x04},
+	{MISENSOR_8BIT, 0x5817, 0x0C},
+	{MISENSOR_8BIT, 0x5818, 0x10},
+	{MISENSOR_8BIT, 0x5819, 0x0B},
+	{MISENSOR_8BIT, 0x581A, 0x07},
+	{MISENSOR_8BIT, 0x581B, 0x07},
+	{MISENSOR_8BIT, 0x581C, 0x0A},
+	{MISENSOR_8BIT, 0x581D, 0x14},
+	{MISENSOR_8BIT, 0x581E, 0x37},
+	{MISENSOR_8BIT, 0x581F, 0x1F},
+	{MISENSOR_8BIT, 0x5820, 0x18},
+	{MISENSOR_8BIT, 0x5821, 0x18},
+	{MISENSOR_8BIT, 0x5822, 0x1F},
+	{MISENSOR_8BIT, 0x5823, 0x2F},
+	{MISENSOR_8BIT, 0x5824, 0x48},
+	{MISENSOR_8BIT, 0x5825, 0x2A},
+	{MISENSOR_8BIT, 0x5826, 0x2C},
+	{MISENSOR_8BIT, 0x5827, 0x08},
+	{MISENSOR_8BIT, 0x5828, 0x66},
+	{MISENSOR_8BIT, 0x5829, 0x0A},
+	{MISENSOR_8BIT, 0x582A, 0x26},
+	{MISENSOR_8BIT, 0x582B, 0x24},
+	{MISENSOR_8BIT, 0x582C, 0x26},
+	{MISENSOR_8BIT, 0x582D, 0x08},
+	{MISENSOR_8BIT, 0x582E, 0x08},
+	{MISENSOR_8BIT, 0x582F, 0x42},
+	{MISENSOR_8BIT, 0x5830, 0x40},
+	{MISENSOR_8BIT, 0x5831, 0x22},
+	{MISENSOR_8BIT, 0x5832, 0x06},
+	{MISENSOR_8BIT, 0x5833, 0x0A},
+	{MISENSOR_8BIT, 0x5834, 0x24},
+	{MISENSOR_8BIT, 0x5835, 0x24},
+	{MISENSOR_8BIT, 0x5836, 0x26},
+	{MISENSOR_8BIT, 0x5837, 0x06},
+	{MISENSOR_8BIT, 0x5838, 0x48},
+	{MISENSOR_8BIT, 0x5839, 0x08},
+	{MISENSOR_8BIT, 0x583A, 0x28},
+	{MISENSOR_8BIT, 0x583B, 0x06},
+	{MISENSOR_8BIT, 0x583C, 0x4A},
+	{MISENSOR_8BIT, 0x583D, 0xCE},
+	/* AE */
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	{MISENSOR_8BIT, 0x3A0F, 0x30},	/* stable in high */
+	{MISENSOR_8BIT, 0x3A10, 0x28},	/* stable in low */
+	{MISENSOR_8BIT, 0x3A1B, 0x30},	/* stable out high */
+	{MISENSOR_8BIT, 0x3A1E, 0x26},	/* stable out low */
+	{MISENSOR_8BIT, 0x3A11, 0x60},	/* fast zone high */
+	{MISENSOR_8BIT, 0x3A1F, 0x14},	/* fast zone low */
+	{MISENSOR_8BIT, 0x350A, 0x00},
+	{MISENSOR_8BIT, 0x350B, 0x32},	/* default gain 50 */
+	{MISENSOR_8BIT, 0x3500, 0x00},
+	{MISENSOR_8BIT, 0x3501, 0x03},
+	{MISENSOR_8BIT, 0x3502, 0xE8},	/* default shutter 1000 */
+	/* BLC */
+	{MISENSOR_8BIT, 0x4000, 0x89},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4002, 0x45},
+	{MISENSOR_8BIT, 0x4003, 0x08},
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	{MISENSOR_8BIT, 0x4009, 0x10},
+	{MISENSOR_8BIT, 0x4202, 0x00},	/* stream on */
+	{MISENSOR_8BIT, 0x4202, 0x0F},	/* stream off */
+	{MISENSOR_8BIT, 0x3008, 0x02},	/* wake up */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_1_focus_init[] = {
+	{MISENSOR_8BIT, 0x3022, 0x00},
+	{MISENSOR_8BIT, 0x3023, 0x00},
+	{MISENSOR_8BIT, 0x3024, 0x00},
+	{MISENSOR_8BIT, 0x3025, 0x00},
+	{MISENSOR_8BIT, 0x3026, 0x00},
+	{MISENSOR_8BIT, 0x3027, 0x00},
+	{MISENSOR_8BIT, 0x3028, 0x00},
+	{MISENSOR_8BIT, 0x3029, 0x7F},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_1_800x480p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x03},
+	{MISENSOR_8BIT, 0x3809, 0x20},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_1_rgb565_1280x720p_init[] = {
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*for mclk=19.2MHz,0x54 */
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0xfa},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x06},
+	{MISENSOR_8BIT,0x3807,0xa9},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0x00},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x64},
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x02},
+	{MISENSOR_8BIT,0x3a03,0xe4},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0xbc},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x72},
+	{MISENSOR_8BIT,0x3a0e,0x01},
+	{MISENSOR_8BIT,0x3a0d,0x02},
+	{MISENSOR_8BIT,0x3a14,0x02},
+	{MISENSOR_8BIT,0x3a15,0xe4},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x6f /*0x32*/},
+	{MISENSOR_8BIT,0x501f,0x01 /*0x00*/},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x0a*/}, /* 0x16 */
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_1_1440x720p_init[] = {
+
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*mclk=19.2MHz*/
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x40},
+	{MISENSOR_8BIT,0x3821,0x06},
+	{MISENSOR_8BIT,0x3814,0x11},
+	{MISENSOR_8BIT,0x3815,0x11},
+	{MISENSOR_8BIT,0x3800,0x02},
+	{MISENSOR_8BIT,0x3801,0x40},
+	{MISENSOR_8BIT,0x3802,0x02},
+	{MISENSOR_8BIT,0x3803,0x66},
+	{MISENSOR_8BIT,0x3804,0x07},
+	{MISENSOR_8BIT,0x3805,0xff},
+	{MISENSOR_8BIT,0x3806,0x05},
+	{MISENSOR_8BIT,0x3807,0x3d},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0xa0},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x0a}, /*09*/
+	{MISENSOR_8BIT,0x380d,0x58}, /*c8*/
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x04},
+	{MISENSOR_8BIT,0x3612,0x2b},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x12},
+	{MISENSOR_8BIT,0x370c,0x00},
+	{MISENSOR_8BIT,0x3a02,0x04},
+	{MISENSOR_8BIT,0x3a03,0x60},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0x50},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x18},
+	{MISENSOR_8BIT,0x3a0e,0x03},
+	{MISENSOR_8BIT,0x3a0d,0x04},
+	{MISENSOR_8BIT,0x3a14,0x04},
+	{MISENSOR_8BIT,0x3a15,0x60},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x06},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0a},
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};
+#endif
diff --git a/drivers/media/i2c/ov5640_2.c b/drivers/media/i2c/ov5640_2.c
new file mode 100644
index 0000000..e9731d7
--- /dev/null
+++ b/drivers/media/i2c/ov5640_2.c
@@ -0,0 +1,2386 @@
+/*
+ * Support for ov5640_2 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/firmware.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "ov5640_2.h"
+
+#define OV5640_OLD_STILL_CAPTURE 0
+
+#define to_ov5640_2_sensor(sd) container_of(sd, struct ov5640_2_device, sd)
+
+/* #define DEBUG_I2C_COMMAND */
+#define ov2printk(args...)
+
+static int ov5640_2_set_i2c_addr = 0;
+
+static int
+ov5640_2_read_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg >> 8);
+	data[1] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err < 0) {
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == MISENSOR_8BIT)
+		*val = (u8)data[0];
+	else if (data_length == MISENSOR_16BIT)
+		*val = be16_to_cpu(*(u16 *)&data[0]);
+	else
+		*val = be32_to_cpu(*(u32 *)&data[0]);
+
+	return 0;
+}
+
+static int
+ov5640_2_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data_length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16((u16)val);
+	} else {
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = cpu_to_be32(val);
+	}
+
+
+#ifdef DEBUG_I2C_COMMAND
+	printk("%x %02x%02x %02x\n",msg.addr, data[0], data[1], data[2]);
+#endif
+
+
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_err(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+
+	return num_msg;
+}
+
+static int ov5640_2_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	int ret;
+	int retry = 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (ret == 1)
+		return 0;
+
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying i2c write transfer... %d",
+			retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return ret;
+}
+
+/*
+ * __ov5640_2_flush_reg_array() is internal function to make writing reg
+ * faster and should be not used anywhere else.
+ */
+static int __ov5640_2_flush_reg_array(struct i2c_client *client,
+				      struct ov5640_2_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov5640_2_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+/*
+ * ov5640_2_write_reg_array - Initializes a list of MT9T111 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * Initializes a list of MT9T111 registers. The list of registers is
+ * terminated by MISENSOR_TOK_TERM.
+ */
+static int ov5640_2_write_reg_array(struct i2c_client *client,
+			    const struct misensor_reg *reglist)
+{
+	const struct misensor_reg *next = reglist;
+	int err;
+
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		if (next->length == MISENSOR_TOK_DELAY) {
+			msleep(next->val);
+		} else {
+			err = ov5640_2_write_reg(client, next->length, next->reg,
+						next->val);
+			/* REVISIT: Do we need this delay? */
+			udelay(10);
+			if (err) {
+				dev_err(&client->dev, "%s err. aborted\n",
+					__func__);
+				return err;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static const struct firmware *
+load_firmware(struct device *dev)
+{
+	const struct firmware *fw;
+	int rc;
+
+	rc = request_firmware(&fw, AF_FW_PATH, dev);
+	if (rc) {
+		if (rc == -ENOENT)
+			dev_err(dev, "Error AF firmware %s not found.\n",
+					AF_FW_PATH);
+		else
+			dev_err(dev,
+				"Error %d while requesting firmware %s\n",
+				rc, AF_FW_PATH);
+		return NULL;
+	}
+
+	return fw;
+}
+
+static int ov5640_2_af_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	const struct firmware *firmware;
+	struct ov5640_2_write_ctrl ctrl;
+	int err;
+	int i;
+	int group_length;
+
+	return 0;
+
+
+	/* reset MCU */
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+				OV5640_2_REG_SYS_RESET, OV5640_2_MCU_RESET);
+	if (err)
+		return err;
+
+	/* download firmware */
+	if (dev->firmware) {
+		firmware = dev->firmware;
+	} else {
+		firmware = load_firmware(&client->dev);
+		if (!firmware) {
+			dev_err(&client->dev, "Load firmwares failed\n");
+			return -EINVAL;
+		}
+		dev->firmware = firmware;
+	}
+
+	/* download firmware in group */
+	group_length = (firmware->size) / (OV5640_2_MAX_WRITE_BUF_SIZE - 2);
+	for (i = 0; i < group_length; i++) {
+		ctrl.buffer.addr = OV5640_2_REG_FW_START
+				    + i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2);
+		memcpy(ctrl.buffer.data,
+			&firmware->data[i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2)],
+			(OV5640_2_MAX_WRITE_BUF_SIZE - 2));
+		ctrl.index = (OV5640_2_MAX_WRITE_BUF_SIZE - 2);
+		err = __ov5640_2_flush_reg_array(client, &ctrl);
+		if (err) {
+			dev_err(&client->dev, "write firmwares reg failed\n");
+			return err;
+		}
+	}
+
+	/* download firmware less than 1 group */
+	ctrl.buffer.addr = OV5640_2_REG_FW_START +
+				i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2);
+	memcpy(ctrl.buffer.data,
+		&firmware->data[i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2)],
+		firmware->size - i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2));
+	ctrl.index = firmware->size - i * (OV5640_2_MAX_WRITE_BUF_SIZE - 2);
+	err = __ov5640_2_flush_reg_array(client, &ctrl);
+	if (err) {
+		dev_err(&client->dev, "write firmwares reg failed\n");
+		return err;
+	}
+
+
+	return ov5640_2_write_reg_array(client, ov5640_2_focus_init);
+}
+
+static int ov5640_2_s_focus_mode(struct v4l2_subdev *sd, int mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int err = 0;
+
+
+	/*
+	 * if sensor streamoff, writing focus mode reg is invalid.
+	 * only writing focus mode reg is valid after streamon.
+	 */
+	if (dev->streaming == false) {
+		dev->focus_mode = mode;
+		dev->focus_mode_change = true;
+		return 0;
+	}
+
+	switch (mode) {
+	case V4L2_CID_AUTO_FOCUS_START:
+		/* start single focus */
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_FOCUS_MODE,
+						OV5640_2_SINGLE_FOCUS);
+		break;
+	case V4L2_CID_FOCUS_AUTO:
+		/* start continuous focus */
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_FOCUS_MODE,
+						OV5640_2_CONTINUE_FOCUS);
+		break;
+	case V4L2_CID_3A_LOCK:
+		/* pause focus */
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_FOCUS_MODE,
+						OV5640_2_PAUSE_FOCUS);
+		break;
+	case V4L2_CID_AUTO_FOCUS_STOP:
+		/* release focus to infinity */
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_FOCUS_MODE,
+						OV5640_2_RELEASE_FOCUS);
+		break;
+	default:
+		dev_err(&client->dev, "invalid mode.\n");
+		return -EINVAL;
+	}
+	if (err) {
+		dev_err(&client->dev, "setting focus mode fails.\n");
+		return err;
+	}
+
+	dev->focus_mode = mode;
+	dev->focus_mode_change = false;
+
+	return 0;
+}
+
+static int ov5640_2_s_single_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_2_s_focus_mode(sd, V4L2_CID_AUTO_FOCUS_START);
+}
+
+static int ov5640_2_s_cont_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_2_s_focus_mode(sd, V4L2_CID_FOCUS_AUTO);
+}
+
+static int ov5640_2_pause_focus(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (value != V4L2_LOCK_FOCUS) {
+		dev_err(&client->dev, "invalid focus cmd.\n");
+		return -EINVAL;
+	}
+
+	return ov5640_2_s_focus_mode(sd, V4L2_CID_3A_LOCK);
+}
+
+static int ov5640_2_release_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_2_s_focus_mode(sd, V4L2_CID_AUTO_FOCUS_STOP);
+}
+
+static int ov5640_2_s_color_effect(struct v4l2_subdev *sd, int effect)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int err = 0;
+
+	if (dev->color_effect == effect)
+		return 0;
+
+	switch (effect) {
+	case V4L2_COLORFX_NONE:
+		err = ov5640_2_write_reg_array(client, ov5640_2_normal_effect);
+		break;
+	case V4L2_COLORFX_SEPIA:
+		err = ov5640_2_write_reg_array(client, ov5640_2_sepia_effect);
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		err = ov5640_2_write_reg_array(client, ov5640_2_negative_effect);
+		break;
+	case V4L2_COLORFX_BW:
+		err = ov5640_2_write_reg_array(client, ov5640_2_bw_effect);
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		err = ov5640_2_write_reg_array(client, ov5640_2_blue_effect);
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		err = ov5640_2_write_reg_array(client, ov5640_2_green_effect);
+		break;
+	default:
+		dev_err(&client->dev, "invalid color effect.\n");
+		return -ERANGE;
+	}
+	if (err) {
+		dev_err(&client->dev, "setting color effect fails.\n");
+		return err;
+	}
+
+	dev->color_effect = effect;
+
+	return 0;
+}
+
+static int ov5640_2_g_color_effect(struct v4l2_subdev *sd, int *effect)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+
+	*effect = dev->color_effect;
+
+	return 0;
+}
+
+static int ov5640_2_g_focus_status(struct v4l2_subdev *sd, int *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val = 0;
+
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_FOCUS_STATUS, &val);
+	if (err)
+		return err;
+
+	switch (val & 0xff) {
+	case OV5640_2_FOCUS_FW_DL:
+		/* firmware is downloaded and not to be initialized */
+		*status = V4L2_AUTO_FOCUS_STATUS_FAILED;
+		break;
+	case OV5640_2_FOCUS_FW_INIT:
+		/* firmware is initializing */
+	case OV5640_2_FOCUS_FW_IDLE:
+		/* firmware is idle */
+		*status = V4L2_AUTO_FOCUS_STATUS_IDLE;
+		break;
+	case OV5640_2_FOCUS_FW_RUN:
+		/* focus is running */
+		*status = V4L2_AUTO_FOCUS_STATUS_BUSY;
+		break;
+	case OV5640_2_FOCUS_FW_FINISH:
+		/* focus is finished */
+		*status = V4L2_AUTO_FOCUS_STATUS_REACHED;
+		break;
+	default:
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/* calculate sysclk */
+static int ov5640_2_get_sysclk(struct v4l2_subdev *sd, unsigned int *sysclk)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp1 = 0, temp2 = 0;
+	u32 multiplier = 0, prediv = 0, vco = 0, sysdiv = 0;
+	u32 pll_rdiv = 0, bit_div2x = 0, sclk_rdiv = 0;
+
+	static int sclk_rdiv_map[] = {1, 2, 4, 8};
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_PLL_CTRL_0, &temp1);
+	if (err)
+		return err;
+	temp2 = temp1 & 0x0f;
+	if (temp2 == 8 || temp2 == 10)
+		bit_div2x = temp2 >> 1;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_PLL_CTRL_1, &temp1);
+	if (err)
+		return err;
+	sysdiv = temp1 >> 4;
+	if (sysdiv == 0)
+		sysdiv = 16;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_PLL_CTRL_2, &temp1);
+	if (err)
+		return err;
+	multiplier = temp1;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_PLL_CTRL_3, &temp1);
+	if (err)
+		return err;
+	prediv = temp1 & 0x0f;
+	pll_rdiv = ((temp1 >> 4) & 0x01) + 1;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_CLK_DIVIDER, &temp1);
+	if (err)
+		return err;
+	temp2 = temp1 & 0x03;
+	sclk_rdiv = sclk_rdiv_map[temp2];
+
+	if ((prediv && sclk_rdiv && bit_div2x) == 0)
+		return -EINVAL;
+
+	vco = OV5640_2_XVCLK * multiplier / prediv;
+
+	*sysclk = vco / sysdiv / pll_rdiv * 2 / bit_div2x / sclk_rdiv;
+
+	if (*sysclk < MIN_SYSCLK)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* read HTS from register settings */
+static int ov5640_2_get_hts(struct v4l2_subdev *sd, unsigned int *hts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_2_read_reg(client, MISENSOR_16BIT,
+				OV5640_2_REG_TIMING_HTS, hts);
+	if (err)
+		return err;
+
+	if (*hts < MIN_HTS)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* read VTS from register settings */
+static int ov5640_2_get_vts(struct v4l2_subdev *sd, unsigned int *vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_2_read_reg(client, MISENSOR_16BIT,
+				OV5640_2_REG_TIMING_VTS, vts);
+	if (err)
+		return err;
+
+	if (*vts < MIN_VTS)
+		return -EINVAL;
+
+	return 0;
+}
+
+#if OV5640_OLD_STILL_CAPTURE
+/* write VTS to registers */
+static int ov5640_2_set_vts(struct v4l2_subdev *sd, unsigned int vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_2_write_reg(client, MISENSOR_16BIT,
+					OV5640_2_REG_TIMING_VTS, vts);
+}
+#endif /* OV5640_OLD_STILL_CAPTURE */
+
+/* read shutter, in number of line period */
+static int ov5640_2_get_shutter(struct v4l2_subdev *sd, s32 *shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val, temp;
+
+	err = ov5640_2_read_reg(client, MISENSOR_16BIT,
+					OV5640_2_REG_EXPOSURE_0, &val);
+	if (err)
+		return err;
+	temp = (val & 0x0fff);
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_EXPOSURE_1, &val);
+	if (err)
+		return err;
+
+	*shutter = (temp << 4) + (val >> 4);
+
+	if(*shutter < MIN_SHUTTER)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write shutter, in number of line period */
+static int ov5640_2_set_shutter(struct v4l2_subdev *sd, unsigned int shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp;
+
+	shutter = shutter & 0xffff;
+	temp = shutter & 0x0f;
+	temp = temp << 4;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_EXPOSURE_1, temp);
+	if (err)
+		return err;
+
+	temp = shutter >> 4;
+
+	return ov5640_2_write_reg(client, MISENSOR_16BIT,
+					OV5640_2_REG_EXPOSURE_0, temp);
+}
+
+/* read gain, 16 = 1x */
+static int ov5640_2_get_gain16(struct v4l2_subdev *sd, unsigned int *gain16)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val;
+
+	err = ov5640_2_read_reg(client, MISENSOR_16BIT,
+					OV5640_2_REG_GAIN, &val);
+	if (err)
+		return err;
+
+	*gain16 = val & 0x3ff;
+
+	if(*gain16 < MIN_GAIN)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write gain, 16 = 1x */
+static int ov5640_2_set_gain16(struct v4l2_subdev *sd, unsigned int gain16)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	gain16 = gain16 & 0x3ff;
+
+	return ov5640_2_write_reg(client, MISENSOR_16BIT,
+					OV5640_2_REG_GAIN, gain16);
+}
+
+/*
+ * This returns the exposure compensation value, which is expressed in
+ * terms of EV. The default EV value is 0, and driver don't support
+ * adjust EV value.
+ */
+static int ov5640_2_get_exposure_bias(struct v4l2_subdev *sd, s32 *value)
+{
+	*value = 0;
+
+	return 0;
+}
+
+/*
+ * This returns ISO sensitivity.
+ */
+static int ov5640_2_get_iso(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 gain;
+	int err;
+
+	err = ov5640_2_get_gain16(sd, &gain);
+	if (err)
+		return err;
+
+	*value = gain / 16 * 100;
+
+	return 0;
+}
+
+#if OV5640_OLD_STILL_CAPTURE
+/* get banding filter value */
+static int ov5640_2_get_light_frequency(struct v4l2_subdev *sd,
+				unsigned int *light_frequency)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_LIGHT_CTRL_0, &temp);
+	if (err)
+		return err;
+
+	if (temp & OV5640_2_AUTO_BAND) {
+		/* manual */
+		err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_LIGHT_CTRL_1, &temp);
+		if (err)
+			return err;
+		if (temp & 0x04)
+			/* 50Hz */
+			*light_frequency = OV5640_2_LIGHT_50HZ;
+		else
+			/* 60Hz */
+			*light_frequency = OV5640_2_LIGHT_60HZ;
+	} else {
+		/* auto */
+		err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_LIGHT_CTRL_2, &temp);
+		if (err)
+			return err;
+		if (temp & 0x01)
+			/* 50Hz */
+			*light_frequency = OV5640_2_LIGHT_50HZ;
+		else
+			/* 60Hz */
+			*light_frequency = OV5640_2_LIGHT_60HZ;
+	}
+
+	return 0;
+}
+#endif /* OV5640_OLD_STILL_CAPTURE */
+
+static int ov5640_2_set_bandingfilter(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	u32 band_step60, max_band60, band_step50, max_band50;
+	int err;
+
+	/* read preview PCLK */
+	err = ov5640_2_get_sysclk(sd, &dev->preview_sysclk);
+	if (err)
+		return err;
+
+	/* read preview HTS */
+	err = ov5640_2_get_hts(sd, &dev->preview_hts);
+	if (err)
+		return err;
+
+	/* read preview VTS */
+	err = ov5640_2_get_vts(sd, &dev->preview_vts);
+	if (err)
+		return err;
+
+	/* calculate banding filter */
+	/* 60Hz */
+	band_step60 = dev->preview_sysclk * 100 / dev->preview_hts * 100 / 120;
+	if (band_step60 == 0)
+		return -EINVAL;
+
+	err = ov5640_2_write_reg(client, MISENSOR_16BIT, OV5640_2_REG_B60_STEP,
+								band_step60);
+	if (err)
+		return err;
+
+	max_band60 = (dev->preview_vts - 4) / band_step60;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_B60_MAX, max_band60);
+	if (err)
+		return err;
+
+	/* 50Hz */
+	band_step50 = dev->preview_sysclk * 100 / dev->preview_hts;
+	if (band_step50 == 0)
+		return -EINVAL;
+
+	err = ov5640_2_write_reg(client, MISENSOR_16BIT, OV5640_2_REG_B50_STEP,
+								band_step50);
+	if (err)
+		return err;
+
+	max_band50 = (dev->preview_vts - 4) / band_step50;
+
+	return ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_B50_MAX, max_band50);
+}
+
+/* stable in high */
+static int ov5640_2_set_ae_target(struct v4l2_subdev *sd, unsigned int target)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int err;
+	u32 fast_high, fast_low;
+	dev->ae_low = target * 23 / 25;	 /* 0.92 */
+	dev->ae_high = target * 27 / 25; /* 1.08 */
+
+
+	fast_high = dev->ae_high << 1;
+	if (fast_high > 255)
+		fast_high = 255;
+
+	fast_low = dev->ae_low >> 1;
+
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_STAB_IN_H, dev->ae_high);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_STAB_IN_L, dev->ae_low);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_STAB_OUT_H, dev->ae_high);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_STAB_OUT_L, dev->ae_low);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_FAST_H, fast_high);
+	if (err)
+		return err;
+
+	return ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_FAST_L, fast_low);
+}
+
+static int
+ov5640_2_set_ag_ae(struct i2c_client *client, int enable)
+{
+	return ov5640_2_write_reg(client, MISENSOR_8BIT,
+			OV5640_2_REG_AE_MODE_CTRL,
+			enable ? OV5640_2_AUTO_AG_AE : OV5640_2_MANUAL_AG_AE);
+}
+
+static int ov5640_2_set_night_mode(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int temp;
+	int err;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_SYS_CTRL, &temp);
+	if (err)
+		return err;
+
+	if (enable) {
+		temp = temp | 0x04;
+		return ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_SYS_CTRL, temp);
+	} else {
+		temp = temp & 0xfb;
+		return ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AE_SYS_CTRL, temp);
+	}
+}
+
+static int ov5640_2_set_awb_gain_mode(struct v4l2_subdev *sd, int mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int temp;
+	int err;
+
+	err = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_AWB_CTRL, &temp);
+	if (err)
+		return err;
+
+	switch (mode) {
+	case OV5640_2_AWB_GAIN_AUTO:
+		/* set awb gain to auto */
+		temp = temp & 0xfe;
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_AWB_CTRL, temp);
+		break;
+	case OV5640_2_AWB_GAIN_MANUAL:
+		/* set awb gain to manual */
+		temp = temp | 0x01;
+		err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_AWB_CTRL, temp);
+		break;
+	default:
+		dev_err(&client->dev, "invalid awb gain mode.\n");
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5640_2_start_preview(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int ret;
+
+	dev->preview_ag_ae = false;
+
+	ret = ov5640_2_set_awb_gain_mode(sd, OV5640_2_AWB_GAIN_AUTO);
+	if (ret)
+		return ret;
+
+	ret = ov5640_2_set_gain16(sd, dev->preview_gain16);
+	if (ret)
+		return ret;
+
+	ret = ov5640_2_set_shutter(sd, dev->preview_shutter);
+	if (ret)
+		return ret;
+
+	ret = ov5640_2_set_ag_ae(client, 1);
+	if (ret)
+		return ret;
+
+	ret = ov5640_2_set_bandingfilter(sd);
+	if (ret)
+		return ret;
+
+	ret = ov5640_2_set_ae_target(sd, OV5640_2_AE_TARGET);
+	if (ret)
+		return ret;
+
+	return ov5640_2_set_night_mode(sd, dev->night_mode);
+}
+
+static int ov5640_2_stop_preview(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int err;
+
+	/* read preview shutter */
+	err = ov5640_2_get_shutter(sd, &dev->preview_shutter);
+	if (err)
+		return err;
+
+	err = ov5640_2_get_gain16(sd, &dev->preview_gain16);
+	if (err)
+		return err;
+
+	err = ov5640_2_get_hts(sd, &dev->preview_hts);
+	if (err)
+		return err;
+
+	dev->preview_ag_ae = true;
+
+	err = ov5640_2_set_awb_gain_mode(sd, OV5640_2_AWB_GAIN_MANUAL);
+	if (err)
+		return err;
+
+	/* get average */
+	return ov5640_2_read_reg(client, MISENSOR_8BIT,
+				OV5640_2_REG_AE_AVERAGE, &dev->average);
+}
+
+
+
+#if 0
+static int ov5640_2_start_raw_capture(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	ov2printk("write ov5640_2_800x480_yuv_2lane_192MCLK_30fps to ov5640_2\n");
+	return ov5640_2_write_reg_array(client, ov5640_2_800x480_yuv_2lane_192MCLK_30fps);
+
+
+}
+#endif
+static int ov5640_2_start_video(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_2_set_awb_gain_mode(sd, OV5640_2_AWB_GAIN_AUTO);
+	if (err)
+		return err;
+
+	err = ov5640_2_set_ag_ae(client, 1);
+	if (err)
+		return err;
+
+	err = ov5640_2_set_bandingfilter(sd);
+	if (err)
+		return err;
+
+	err = ov5640_2_set_ae_target(sd, OV5640_2_AE_TARGET);
+	if (err)
+		return err;
+
+	return ov5640_2_set_night_mode(sd, 0);
+
+}
+
+#if OV5640_OLD_STILL_CAPTURE
+static int ov5640_2_start_capture(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	u32 capture_sysclk, capture_hts, capture_vts;
+	u32 capture_shutter, capture_gain16;
+	u32 light_frequency, capture_bandingfilter, capture_max_band;
+	long capture_gain16_shutter;
+	int err;
+
+
+	if (!dev->preview_ag_ae) {
+		dev_err(&client->dev, "preview gain and shutter are not available.\n");
+		return -EINVAL;
+	}
+
+	err = ov5640_2_set_awb_gain_mode(sd, OV5640_2_AWB_GAIN_AUTO);
+	if (err)
+		return err;
+
+	err = ov5640_2_set_ag_ae(client, 0);
+	if (err)
+		return err;
+
+	/* read capture VTS */
+	err = ov5640_2_get_vts(sd, &capture_vts);
+	if (err)
+		return err;
+
+	err = ov5640_2_get_hts(sd, &capture_hts);
+	if (err)
+		return err;
+
+	err = ov5640_2_get_sysclk(sd, &capture_sysclk);
+	if (err)
+		return err;
+
+	/* calculate capture banding filter */
+	err = ov5640_2_get_light_frequency(sd, &light_frequency);
+	if (err)
+		return err;
+
+	if (light_frequency == OV5640_2_LIGHT_60HZ) {
+		/* 60Hz */
+		capture_bandingfilter = capture_sysclk * 100 /
+						capture_hts * 100 / 120;
+	} else {
+		/* 50Hz */
+		capture_bandingfilter = capture_sysclk * 100 / capture_hts;
+	}
+
+	if (capture_bandingfilter == 0)
+		return -EINVAL;
+
+	capture_max_band = (int)((capture_vts - 4) / capture_bandingfilter);
+	if (capture_max_band == 0)
+		return -EINVAL;
+
+	/* calculate capture shutter/gain16 */
+	if (dev->average > dev->ae_low && dev->average < dev->ae_high) {
+		/* in stable range */
+		capture_gain16_shutter = dev->preview_gain16 *
+					dev->preview_shutter *
+					capture_sysclk / dev->preview_sysclk *
+					dev->preview_hts / capture_hts *
+					OV5640_2_AE_TARGET / dev->average;
+	} else {
+		capture_gain16_shutter = dev->preview_gain16 *
+					dev->preview_shutter *
+					capture_sysclk / dev->preview_sysclk *
+					dev->preview_hts / capture_hts;
+	}
+	/* gain to shutter */
+	if (capture_gain16_shutter < (capture_bandingfilter * 16)) {
+		/* shutter < 1/100 */
+		capture_shutter = capture_gain16_shutter / 16;
+		if (capture_shutter < 1)
+			capture_shutter = 1;
+		capture_gain16 = capture_gain16_shutter / capture_shutter;
+		if (capture_gain16 < 16)
+			capture_gain16 = 16;
+	} else {
+		if (capture_gain16_shutter >
+			(capture_bandingfilter * capture_max_band * 16)) {
+			/* exposure reach max */
+			capture_shutter = capture_bandingfilter *
+							capture_max_band;
+			capture_gain16 = capture_gain16_shutter /
+							capture_shutter;
+		} else {
+			/*
+			 * 1/100 < capture_shutter =< max,
+			 * capture_shutter = n/100
+			 */
+			capture_shutter = ((int)(capture_gain16_shutter / 16 /
+						capture_bandingfilter)) *
+						capture_bandingfilter;
+			if (capture_shutter == 0)
+				return -EINVAL;
+
+			capture_gain16 = capture_gain16_shutter /
+						capture_shutter;
+		}
+	}
+
+	/* write capture gain */
+	err = ov5640_2_set_gain16(sd, capture_gain16);
+	if (err)
+		return err;
+
+	/* write capture shutter */
+	if (capture_shutter > (capture_vts - 4)) {
+		capture_vts = capture_shutter + 4;
+		err = ov5640_2_set_vts(sd, capture_vts);
+		if (err)
+			return err;
+	}
+
+	return ov5640_2_set_shutter(sd, capture_shutter);
+
+}
+#endif /* OV5640_OLD_STILL_CAPTURE */
+
+static int ov5640_2_standby(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_2_write_reg_array(client, ov5640_2_standby_reg);
+}
+
+static int ov5640_2_wakeup(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_2_write_reg_array(client, ov5640_2_wakeup_reg);
+}
+
+
+static int ov5640_2_set_new_addr(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret, err, val;
+	int addr_to_use = client->addr;
+
+	if(client->addr == OV5640_FACTORY_DEFAULT_ADDR) return 0;
+	if(ov5640_2_set_i2c_addr) return 0;
+
+	client->addr =  OV5640_FACTORY_DEFAULT_ADDR;
+	ret = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_SCCB_ID, &val);
+	ov2printk("ov5640_2_set_new_addr: default address is 0x%0x\n", val);
+
+	if (ret) return ret;
+
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+				OV5640_2_REG_SCCB_ID, (addr_to_use << 1));
+	if (err) return err;
+
+	client->addr = addr_to_use;
+
+	ret = ov5640_2_read_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_SCCB_ID, &val);
+	if (ret) return ret;
+	ov2printk("ov5640_2: the new address =0x%x client addr=0x%x\n",val, client->addr);
+
+	ov5640_2_set_i2c_addr = 1;
+
+	return 0;
+}
+
+
+static int __ov5640_2_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if(client->addr != OV5640_FACTORY_DEFAULT_ADDR)
+	{
+	  ret = ov5640_2_set_new_addr(sd);
+	  if (ret)
+			return ret;
+	  ov2printk("ov5640_2_init: the client addr=0x%x\n", client->addr);
+	}
+
+	ret = ov5640_2_write_reg_array(client, ov5640_2_init);
+	if (ret)
+		return ret;
+
+	/*
+	 * delay 5ms to wait for sensor initialization finish.
+	 */
+	usleep_range(5000, 6000);
+
+	ret = ov5640_2_af_init(sd);
+	if (ret)
+		return ret;
+	msleep(20);
+
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		{
+		goto fail_power;
+		}
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/*
+	 * according to DS, 20ms is needed between power up and first i2c
+	 * commend
+	 */
+	msleep(20);
+
+	return 0;
+
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	/*according to DS, 20ms is needed after power down*/
+	msleep(20);
+
+	return ret;
+}
+
+static int ov5640_2_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+	else {
+
+	ov2printk("power on ov5640_2_s_power\n");
+
+	if(power_up(sd))
+		return -EINVAL;
+	}
+
+	return __ov5640_2_init(sd);
+}
+
+static int ov5640_2_try_res(u32 *w, u32 *h, u32 *code)
+{
+	int i;
+
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if (ov5640_2_res[i].width == *w &&
+		    ov5640_2_res[i].height == *h &&
+		    ov5640_2_res[i].code == *code)
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = ov5640_2_res[i].width;
+	*h = ov5640_2_res[i].height;
+	*code = ov5640_2_res[i].code;
+
+	return 0;
+}
+
+static struct ov5640_2_res_struct *ov5640_2_to_res(u32 w, u32 h, u32 code)
+{
+	int  index;
+
+	if(code == 0x8003)
+		code = MEDIA_BUS_FMT_UYVY8_1X16;
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov5640_2_res[index].width == w &&
+		    ov5640_2_res[index].height == h &&
+		    ov5640_2_res[index].code == code)
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		return NULL;
+
+	return &ov5640_2_res[index];
+}
+
+static int ov5640_2_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	int count = 0;
+
+	return ov5640_2_try_res(&fmt->width, &fmt->height, &fmt->code);
+}
+
+
+static int ov5640_2_res2size(unsigned int res, int *h_size, int *v_size)
+{
+	unsigned short hsize;
+	unsigned short vsize;
+
+	switch (res) {
+	case OV5640_2_RES_QVGA:
+		hsize = OV5640_2_RES_QVGA_SIZE_H;
+		vsize = OV5640_2_RES_QVGA_SIZE_V;
+		break;
+	case OV5640_2_RES_DVGA:
+		hsize = OV5640_2_RES_DVGA_SIZE_H;
+		vsize = OV5640_2_RES_DVGA_SIZE_V;
+		break;
+	case OV5640_2_RES_320P:
+		hsize = OV5640_2_RES_320P_SIZE_H;
+		vsize = OV5640_2_RES_320P_SIZE_V;
+		break;
+	case OV5640_2_RES_360P:
+		hsize = OV5640_2_RES_360P_SIZE_H;
+		vsize = OV5640_2_RES_360P_SIZE_V;
+		break;
+	case OV5640_2_RES_VGA:
+		hsize = OV5640_2_RES_VGA_SIZE_H;
+		vsize = OV5640_2_RES_VGA_SIZE_V;
+		break;
+	case OV5640_2_RES_RGB_VGA:
+			hsize = OV5640_2_RES_VGA_SIZE_H;
+			vsize = OV5640_2_RES_VGA_SIZE_V;
+			break;
+	case OV5640_2_RES_480P:
+		hsize = OV5640_2_RES_480P_SIZE_H;
+		vsize = OV5640_2_RES_480P_SIZE_V;
+		break;
+	case OV5640_2_RES_736x480P:
+		hsize = OV5640_2_RES_736x480P_SIZE_H;
+		vsize = OV5640_2_RES_736x480P_SIZE_V;
+		break;
+	case OV5640_2_RES_800x480P:
+		hsize = OV5640_2_RES_800x480P_SIZE_H;
+		vsize = OV5640_2_RES_800x480P_SIZE_V;
+		break;
+	case OV5640_2_RES_720P:
+	case OV5640_2_RGB565_RES_720P:
+		hsize = OV5640_2_RES_720P_SIZE_H;
+		vsize = OV5640_2_RES_720P_SIZE_V;
+		break;
+	case OV5640_2_RES_1440X720P:
+		hsize = OV5640_2_RES_1440X720P_SIZE_H;
+		vsize = OV5640_2_RES_1440X720P_SIZE_V;
+		break;
+	case OV5640_2_RES_1080P:
+		hsize = OV5640_2_RES_1080P_SIZE_H;
+		vsize = OV5640_2_RES_1080P_SIZE_V;
+		break;
+	case OV5640_2_RES_1080P_RGB:
+			hsize = OV5640_2_RES_1080P_SIZE_H;
+			vsize = OV5640_2_RES_1080P_SIZE_V;
+			break;
+	case OV5640_2_RES_1088P:
+		hsize = OV5640_2_RES_1088P_SIZE_H;
+		vsize = OV5640_2_RES_1088P_SIZE_V;
+		break;
+	case OV5640_2_RES_D3M:
+		hsize = OV5640_2_RES_D3M_SIZE_H;
+		vsize = OV5640_2_RES_D3M_SIZE_V;
+		break;
+	case OV5640_2_RES_3M:
+		hsize = OV5640_2_RES_3M_SIZE_H;
+		vsize = OV5640_2_RES_3M_SIZE_V;
+		break;
+	case OV5640_2_RES_D5M:
+		hsize = OV5640_2_RES_D5M_SIZE_H;
+		vsize = OV5640_2_RES_D5M_SIZE_V;
+		break;
+	case OV5640_2_RES_5M:
+		hsize = OV5640_2_RES_5M_SIZE_H;
+		vsize = OV5640_2_RES_5M_SIZE_V;
+		break;
+
+	default:
+		/* QVGA mode is still unsupported */
+		WARN(1, "%s: Resolution 0x%08x unknown\n", __func__, res);
+		return -EINVAL;
+	}
+
+	if (h_size != NULL)
+		*h_size = hsize;
+	if (v_size != NULL)
+		*v_size = vsize;
+
+	return 0;
+}
+
+static int ov5640_2_g_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int width, height;
+	int ret;
+
+	ret = ov5640_2_res2size(dev->res, &width, &height);
+	if (ret)
+		return ret;
+	fmt->width = width;
+	fmt->height = height;
+
+
+
+	return 0;
+}
+
+static int ov5640_2_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	struct ov5640_2_res_struct *res_index;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	u32 code = fmt->code;
+	int ret;
+
+
+	ov2printk("ov5640_2_s_mbus_fmt w=%d h=%d code=0x%x\n", fmt->width, fmt->height, fmt->code);
+
+	ov5640_2_try_res(&width, &height, &code);
+
+	res_index = ov5640_2_to_res(width, height, code);
+
+	/* Sanity check */
+	if (unlikely(!res_index)) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+	ov2printk("ov5640_2_s_mbus_fmt res_index->res=%d\n", res_index->res);
+
+	switch (res_index->res) {
+	case OV5640_2_RES_QVGA:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_qvga_init);
+		break;
+	case OV5640_2_RES_DVGA:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_dvga_init);
+		break;
+	case OV5640_2_RES_320P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_320p_init);
+		break;
+	case OV5640_2_RES_360P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_360p_init);
+		break;
+	case OV5640_2_RES_VGA:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_vga_init);
+		break;
+	case OV5640_2_RES_RGB_VGA:
+			ret = ov5640_2_write_reg_array(c, ov5640_2_vga_rgb_init);
+			break;
+	case OV5640_2_RES_480P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_480p_init);
+		break;
+	case OV5640_2_RES_736x480P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_736x480p_init);
+		break;
+	case OV5640_2_RES_800x480P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_800x480p_init);
+		break;
+
+	case OV5640_2_RES_720P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_720p_init);
+		break;
+	case OV5640_2_RGB565_RES_720P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_rgb565_1280x720p_init);
+		break;
+	case OV5640_2_RES_1440X720P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_1440x720p_init);
+		break;
+
+	case OV5640_2_RES_1080P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_1080p_init);
+		break;
+	case OV5640_2_RES_1080P_RGB:
+			ret = ov5640_2_write_reg_array(c, ov5640_2_1080p_rgb);
+			break;
+	case OV5640_2_RES_1088P:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_1088p_init);
+		break;
+	case OV5640_2_RES_D3M:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_D3M_init);
+		break;
+	case OV5640_2_RES_3M:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_3M_init);
+		break;
+	case OV5640_2_RES_D5M:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_D5M_init);
+		break;
+	case OV5640_2_RES_5M:
+		ret = ov5640_2_write_reg_array(c, ov5640_2_5M_init);
+		break;
+	default:
+		/* QVGA is not implemented yet */
+		dev_err(&c->dev, "set resolution: %d failed!\n",
+							res_index->res);
+		return -EINVAL;
+	}
+	if (ret)
+		return -EINVAL;
+
+
+	if (dev->res != res_index->res) {
+		int index;
+
+		/*
+		 * Marked current sensor res as being "used"
+		 *
+		 * REVISIT: We don't need to use an "used" field on each mode
+		 * list entry to know which mode is selected. If this
+		 * information is really necessary, how about to use a single
+		 * variable on sensor dev struct?
+		 */
+		for (index = 0; index < N_RES; index++) {
+			if (width == ov5640_2_res[index].width &&
+			    height == ov5640_2_res[index].height &&
+			    code == ov5640_2_res[index].code) {
+				ov5640_2_res[index].used = 1;
+				continue;
+			}
+			ov5640_2_res[index].used = 0;
+		}
+	}
+
+	/*
+	 * ov5640_2 - we don't poll for context switch
+	 * because it does not happen with streaming disabled.
+	 */
+	dev->res = res_index->res;
+
+	fmt->width = width;
+	fmt->height = height;
+	fmt->code = code;
+
+	ov2printk("ov5640_2_s_mbus_fmt width = %d height = %d code =0x%x dev->res=%d\n",
+	       width, height, code, dev->res);
+	/* relaunch default focus zone */
+
+	ret = ov5640_2_write_reg(c, MISENSOR_8BIT,
+					OV5640_2_REG_FOCUS_MODE,
+					OV5640_2_RELAUNCH_FOCUS);
+	if (ret) return -EINVAL;
+
+	return ov5640_2_wakeup(sd);
+
+
+}
+
+static int ov5640_2_detect(struct i2c_client *client,  u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 retvalue;
+
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+
+	if (ov5640_2_read_reg(client, MISENSOR_16BIT,
+		OV5640_2_REG_PID, &retvalue)) {
+		dev_err(&client->dev, "sensor_id_high = 0x%x\n", retvalue);
+		return -ENODEV;
+	}
+
+	dev_info(&client->dev, "sensor_id = 0x%x\n", retvalue);
+	if (retvalue != OV5640_2_MOD_ID) {
+		dev_err(&client->dev, "%s: failed: client->addr = %x\n",
+			__func__, client->addr);
+		return -ENODEV;
+	}
+
+	*id = retvalue;
+	/* REVISIT: HACK: Driver is currently forcing revision to 0 */
+	*revision = 0;
+
+	return 0;
+}
+
+static int
+ov5640_2_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+	ret = ov5640_2_s_power(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "power_ctrl failed");
+		return ret;
+	}
+
+
+	/* config & detect sensor */
+	ret = ov5640_2_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		dev_err(&client->dev, "ov5640_2_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = ov5640_2_s_power(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "sensor power-gating failed\n");
+
+	return ret;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	ov5640_2_s_power(sd, 0);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+
+static int ov5640_2_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5640_2_FOCAL_LENGTH_NUM << 16) | OV5640_2_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int ov5640_2_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/* const f number for OV5640_2 */
+	*val = (OV5640_2_F_NUMBER_DEFAULT_NUM << 16) | OV5640_2_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov5640_2_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5640_2_F_NUMBER_DEFAULT_NUM << 24) |
+		(OV5640_2_F_NUMBER_DEM << 16) |
+		(OV5640_2_F_NUMBER_DEFAULT_NUM << 8) | OV5640_2_F_NUMBER_DEM;
+	return 0;
+}
+
+static struct ov5640_2_control ov5640_2_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_2_get_shutter,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_EXPOSURE_BIAS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure bias",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_2_get_exposure_bias,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_ISO_SENSITIVITY,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "iso",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_2_get_iso,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_START,
+			.type = V4L2_CTRL_TYPE_BUTTON,
+			.name = "single focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_2_s_single_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_AUTO,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "continuous focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_2_s_cont_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_3A_LOCK,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "pause focus",
+			.minimum = 0,
+			.maximum = 1 << 2,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_2_pause_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_STOP,
+			.type = V4L2_CTRL_TYPE_BUTTON,
+			.name = "release focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_2_release_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_STATUS,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "focus status",
+			.minimum = 0,
+			.maximum = 0x07,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = ov5640_2_g_focus_status,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_COLORFX,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "color effect",
+			.minimum = 0,
+			.maximum = 9,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_2_s_color_effect,
+		.query = ov5640_2_g_color_effect,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = 0,
+			.maximum = OV5640_2_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5640_2_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5640_2_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = 0,
+			.maximum = OV5640_2_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5640_2_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5640_2_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = 0,
+			.maximum =  OV5640_2_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = OV5640_2_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = ov5640_2_g_fnumber_range,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(ov5640_2_controls))
+
+static struct ov5640_2_control *ov5640_2_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (ov5640_2_controls[i].qc.id == id)
+			return &ov5640_2_controls[i];
+	}
+	return NULL;
+}
+
+static int ov5640_2_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct ov5640_2_control *ctrl = ov5640_2_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	return 0;
+}
+
+static int ov5640_2_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5640_2_control *octrl = ov5640_2_find_control(ctrl->id);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	ret = octrl->query(sd, &ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov5640_2_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5640_2_control *octrl = ov5640_2_find_control(ctrl->id);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+
+	ret = octrl->tweak(sd, ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov5640_2_mipi_stream(struct i2c_client *client, int enable)
+{
+	return ov5640_2_write_reg(client, MISENSOR_8BIT,
+			OV5640_2_REG_FRAME_CTRL,
+			enable ? OV5640_2_FRAME_START : OV5640_2_FRAME_STOP);
+}
+
+static int ov5640_2_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int err;
+
+	if (enable) {
+		switch (dev->run_mode) {
+		case CI_MODE_PREVIEW:
+			err = ov5640_2_start_preview(sd);
+			break;
+		case CI_MODE_VIDEO:
+			err = ov5640_2_start_video(sd);
+			break;
+		case CI_MODE_STILL_CAPTURE:
+#if OV5640_OLD_STILL_CAPTURE
+			err = ov5640_2_start_capture(sd);
+#else
+			err = ov5640_2_start_video(sd);
+#endif
+
+			break;
+		default:
+			dev_err(&client->dev,
+				"invalid run mode = 0x%x\n", dev->run_mode);
+			return -EINVAL;
+		}
+		if (err)
+			dev_warn(&client->dev,
+				"fail to start preview/video/capture.\n");
+
+		err = ov5640_2_mipi_stream(client, enable);
+		if (err)
+			return err;
+
+		dev->streaming = true;
+
+		if (dev->focus_mode_change) {
+			err = ov5640_2_s_focus_mode(sd, dev->focus_mode);
+			if (err) {
+				dev_err(&client->dev,
+					"writing focus mode reg fails.\n");
+				return err;
+			}
+			dev->focus_mode_change = false;
+		}
+
+	} else {
+
+
+		if (dev->run_mode == CI_MODE_PREVIEW) {
+			err = ov5640_2_stop_preview(sd);
+			if (err)
+				dev_warn(&client->dev,
+					"fail to stop preview\n");
+		}
+		err = ov5640_2_mipi_stream(client, enable);
+		if (err)
+			return err;
+
+		err = ov5640_2_standby(sd);
+		if (err)
+			return err;
+		dev->streaming = false;
+		dev->focus_mode = V4L2_CID_3A_LOCK;
+	}
+
+
+	return 0;
+}
+
+static int
+ov5640_2_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = ov5640_2_res[index].width;
+	fsize->discrete.height = ov5640_2_res[index].height;
+
+	fsize->reserved[0] = ov5640_2_res[index].used;
+
+	return 0;
+}
+
+static int ov5640_2_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	/* find out the first equal or bigger size */
+	for (i = 0; i < N_RES; i++) {
+		if (ov5640_2_res[i].width >= fival->width &&
+		    ov5640_2_res[i].height >= fival->height)
+			break;
+	}
+	if (i == N_RES)
+		i--;
+
+	index = i;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = ov5640_2_res[index].fps;
+
+	return 0;
+}
+
+static int
+ov5640_2_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV5640_2, 0);
+}
+
+static int ov5640_2_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov5640_2_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+	unsigned int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = ov5640_2_res[index].width;
+	fse->min_height = ov5640_2_res[index].height;
+	fse->max_width = ov5640_2_res[index].width;
+	fse->max_height = ov5640_2_res[index].height;
+
+	return 0;
+}
+
+static int
+ov5640_2_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov5640_2_device *snr = to_ov5640_2_sensor(sd);
+
+	switch (fmt->which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		fmt->format = *v4l2_subdev_get_try_format(fh, fmt->pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		fmt->format = snr->format;
+	}
+
+	return 0;
+}
+
+static int
+ov5640_2_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov5640_2_device *snr = to_ov5640_2_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+/* set focus zone */
+static int
+ov5640_2_set_selection(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			     struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+	int focus_width_step, focus_height_step;
+	u32 x_center, y_center;
+	int width = 0, height = 0;
+	int err, index;
+
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE) {
+		dev_err(&client->dev,
+				"invalid selection format.\n");
+		return -EINVAL;
+	}
+
+	if (sel->target != V4L2_SEL_TGT_COMPOSE) {
+		dev_err(&client->dev,
+				"invalid selection compose.\n");
+		return -EINVAL;
+	}
+
+	for (index = 0; index < N_RES; index++) {
+		if (dev->res == ov5640_2_res[index].res) {
+			width = ov5640_2_res[index].width;
+			height = ov5640_2_res[index].height;
+			break;
+		}
+	}
+
+	focus_width_step = width / OV5640_2_FOCUS_ZONE_ARRAY_WIDTH;
+	focus_height_step = height / OV5640_2_FOCUS_ZONE_ARRAY_HEIGHT;
+
+	/* calculate the center coordinate of selection rectangle */
+	x_center = DIV_ROUND_UP((sel->r.left + sel->r.width / 2),
+						focus_width_step);
+	y_center = DIV_ROUND_UP((sel->r.top + sel->r.height / 2),
+						focus_height_step);
+
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_FOCUS_ZONE_X,
+					x_center);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+					OV5640_2_REG_FOCUS_ZONE_Y,
+					y_center);
+	if (err)
+		return err;
+	err = ov5640_2_write_reg(client, MISENSOR_8BIT,
+						OV5640_2_REG_FOCUS_MODE,
+						OV5640_2_S_FOCUS_ZONE);
+	if (err)
+		return err;
+
+	return ov5640_2_s_focus_mode(sd, dev->focus_mode);
+}
+
+
+
+static int
+ov5640_2_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+
+//	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->res >= 0 && dev->res < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			ov5640_2_res[dev->res].fps;
+	}
+	return 0;
+}
+
+static int
+ov5640_2_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov5640_2_device *dev = to_ov5640_2_sensor(sd);
+
+//	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+
+	dev->run_mode = param->parm.capture.capturemode;
+	ov2printk("ov5640_2_s_parm dev->run_mode=0x%x\n", dev->run_mode);
+
+	return ov5640_2_g_parm(sd, param);
+}
+
+static int
+ov5640_2_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	int index;
+	struct ov5640_2_device *snr = to_ov5640_2_sensor(sd);
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov5640_2_res[index].res == snr->res) {
+			*frames = ov5640_2_res[index].skip_frames;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static const struct v4l2_subdev_video_ops ov5640_2_video_ops = {
+	.try_mbus_fmt = ov5640_2_try_mbus_fmt,
+	.g_mbus_fmt = ov5640_2_g_mbus_fmt,
+	.s_mbus_fmt = ov5640_2_s_mbus_fmt,
+	.s_parm = ov5640_2_s_parm,
+	.g_parm = ov5640_2_g_parm,
+	.s_stream = ov5640_2_s_stream,
+	.enum_framesizes = ov5640_2_enum_framesizes,
+	.enum_frameintervals = ov5640_2_enum_frameintervals,
+};
+
+static const struct v4l2_subdev_sensor_ops ov5640_2_sensor_ops = {
+	.g_skip_frames	= ov5640_2_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops ov5640_2_core_ops = {
+	.g_chip_ident = ov5640_2_g_chip_ident,
+	.queryctrl = ov5640_2_queryctrl,
+	.g_ctrl = ov5640_2_g_ctrl,
+	.s_ctrl = ov5640_2_s_ctrl,
+	.s_power = ov5640_2_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops ov5640_2_pad_ops = {
+	.enum_mbus_code = ov5640_2_enum_mbus_code,
+	.enum_frame_size = ov5640_2_enum_frame_size,
+	.get_fmt = ov5640_2_get_pad_format,
+	.set_fmt = ov5640_2_set_pad_format,
+	.set_selection = ov5640_2_set_selection,
+};
+
+static const struct v4l2_subdev_ops ov5640_2_ops = {
+	.core = &ov5640_2_core_ops,
+	.video = &ov5640_2_video_ops,
+	.sensor = &ov5640_2_sensor_ops,
+	.pad = &ov5640_2_pad_ops,
+};
+
+static const struct media_entity_operations ov5640_2_entity_ops;
+
+static int ov5640_2_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov5640_2_device *dev = container_of(sd,
+					struct ov5640_2_device, sd);
+
+	dev->platform_data->csi_cfg(sd, 0);
+
+	release_firmware(dev->firmware);
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	power_down(sd);
+	kfree(dev);
+
+	return 0;
+}
+
+static int ov5640_2_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct ov5640_2_device *dev;
+	int ret;
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &ov5640_2_ops);
+	if (client->dev.platform_data) {
+		ov2printk("ov5640_2_probe has platform data\n");
+		ret = ov5640_2_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+	else ov2printk("ov5640_2_probe NOOON platform data\n");
+	/*TODO add format code here*/
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.ops = &ov5640_2_entity_ops;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		ov5640_2_remove(client);
+		return ret;
+	}
+
+	/* set res index to be invalid */
+	dev->res = -1;
+
+	/* set focus mode to be invalid */
+	dev->focus_mode = -1;
+
+	/* set color_effect to be invalid */
+	dev->color_effect = -1;
+	dev->preview_gain16 = OV5640_2_DEFAULT_GAIN;
+	dev->preview_shutter = OV5640_2_DEFAULT_SHUTTER;
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, ov5640_2_id);
+static struct i2c_driver ov5640_2_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV5640_2_NAME,
+	},
+	.probe = ov5640_2_probe,
+	.remove = __exit_p(ov5640_2_remove),
+	.id_table = ov5640_2_id,
+};
+
+static __init int ov5640_2_init_mod(void)
+{
+	return i2c_add_driver(&ov5640_2_driver);
+}
+
+static __exit void ov5640_2_exit_mod(void)
+{
+	i2c_del_driver(&ov5640_2_driver);
+}
+
+module_init(ov5640_2_init_mod);
+module_exit(ov5640_2_exit_mod);
+
+MODULE_DESCRIPTION("A low-level driver for Omnivision OV5640_2 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/ov5640_2.h b/drivers/media/i2c/ov5640_2.h
new file mode 100644
index 0000000..c577f91
--- /dev/null
+++ b/drivers/media/i2c/ov5640_2.h
@@ -0,0 +1,3487 @@
+/*
+ * Support for ov5640_2 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV5640_2_H__
+#define __OV5640_2_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+#define OV5640_2_NAME	"ov5640-2"
+
+#define V4L2_IDENT_OV5640_2 1111
+#define	LAST_REG_SETING	{0xffff, 0xff}
+
+#define OV5640_2_FOCAL_LENGTH_NUM	439	/*4.39mm*/
+#define OV5640_2_FOCAL_LENGTH_DEM	100
+#define OV5640_2_F_NUMBER_DEFAULT_NUM	24
+#define OV5640_2_F_NUMBER_DEM	10
+#define OV5640_2_FOCUS_ZONE_ARRAY_WIDTH	80
+#define OV5640_2_FOCUS_ZONE_ARRAY_HEIGHT	60
+
+#define OV5640_2_XVCLK		1920
+#define OV5640_2_AE_TARGET	45
+#define OV5640_2_DEFAULT_GAIN	50
+#define OV5640_2_DEFAULT_SHUTTER	1000
+
+#define OV5640_FACTORY_DEFAULT_ADDR 0x3c
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5640_2_FOCAL_LENGTH_DEFAULT 0xD00064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5640_2_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define OV5640_2_F_NUMBER_RANGE 0x180a180a
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+
+#define OV5640_2_REG_SCCB_ID	0x3100
+
+#define OV5640_2_REG_PID		0x300a
+#define OV5640_2_REG_SYS_RESET	0x3000
+#define OV5640_2_REG_FW_START	0x8000
+#define OV5640_2_REG_FOCUS_MODE	0x3022	/* focus mode reg */
+#define OV5640_2_REG_FOCUS_ZONE_X	0x3024	/* X coordinate of focus zone center */
+#define OV5640_2_REG_FOCUS_ZONE_Y	0x3025	/* Y coordinate of focus zone center */
+#define OV5640_2_REG_FOCUS_STATUS	0x3029	/* focus status reg */
+
+/* system pll control reg */
+#define OV5640_2_REG_PLL_CTRL_0	0x3034
+#define OV5640_2_REG_PLL_CTRL_1	0x3035
+#define OV5640_2_REG_PLL_CTRL_2	0x3036
+#define OV5640_2_REG_PLL_CTRL_3	0x3037
+
+/* pad clock divider for SCCB clock */
+#define OV5640_2_REG_CLK_DIVIDER	0x3108
+
+/* total horizontal size reg */
+#define OV5640_2_REG_TIMING_HTS	0x380c
+
+/* total vertical size reg */
+#define OV5640_2_REG_TIMING_VTS	0x380e
+
+/* exposure output reg */
+#define OV5640_2_REG_EXPOSURE_0	0x3500
+#define OV5640_2_REG_EXPOSURE_1	0x3502
+
+/* gain reg */
+#define OV5640_2_REG_GAIN	0x350a
+
+/* light frequency control reg */
+#define OV5640_2_REG_LIGHT_CTRL_0	0x3c01
+#define OV5640_2_REG_LIGHT_CTRL_1	0x3c00
+#define OV5640_2_REG_LIGHT_CTRL_2	0x3c0c
+
+/* light frequency */
+#define OV5640_2_LIGHT_50HZ	50
+#define OV5640_2_LIGHT_60HZ	60
+
+/* automatic banding filter */
+#define OV5640_2_AUTO_BAND	0x80
+
+/* 60HZ band step reg and 60HZ max bands */
+#define OV5640_2_REG_B60_STEP	0x3a0a
+#define OV5640_2_REG_B60_MAX	0x3a0d
+
+/* 50HZ band step reg and 50HZ max bands */
+#define OV5640_2_REG_B50_STEP	0x3a08
+#define OV5640_2_REG_B50_MAX	0x3a0e
+
+/* AEC domain control reg */
+#define OV5640_2_REG_AE_STAB_IN_H	0x3a0f	/* stable in high */
+#define OV5640_2_REG_AE_STAB_IN_L	0x3a10	/* stable in low */
+#define OV5640_2_REG_AE_STAB_OUT_H	0x3a1b	/* stable out high */
+#define OV5640_2_REG_AE_STAB_OUT_L	0x3a1e	/* stable out low */
+#define OV5640_2_REG_AE_FAST_H	0x3a11	/* fast zone high */
+#define OV5640_2_REG_AE_FAST_L	0x3a1f	/* fast zone low */
+
+/* AEC mode control reg */
+#define OV5640_2_REG_AE_MODE_CTRL	0x3503
+
+#define OV5640_2_AUTO_AG_AE	0x00	/* auto AG&AE */
+#define OV5640_2_MANUAL_AG_AE	0x03	/* manual AG&AE */
+
+/* AEC system control reg */
+#define OV5640_2_REG_AE_SYS_CTRL	0x3a00
+
+/* image exposure average readout reg */
+#define OV5640_2_REG_AE_AVERAGE	0x56a1
+
+/* frame control reg */
+#define OV5640_2_REG_FRAME_CTRL	0x4202
+
+#define OV5640_2_FRAME_START	0x00
+#define OV5640_2_FRAME_STOP	0x0f
+
+#define OV5640_2_MCU_RESET	0x20
+#define OV5640_2_SINGLE_FOCUS	0x03
+#define OV5640_2_CONTINUE_FOCUS	0x04
+#define OV5640_2_PAUSE_FOCUS	0x06
+#define OV5640_2_RELEASE_FOCUS	0x08
+#define OV5640_2_RELAUNCH_FOCUS	0x12
+#define OV5640_2_S_FOCUS_ZONE	0x81
+
+/* focus firmware is downloaded but not to be initialized */
+#define OV5640_2_FOCUS_FW_DL	0x7f
+#define OV5640_2_FOCUS_FW_INIT	0x7e	/* focus firmware is initializing */
+#define OV5640_2_FOCUS_FW_IDLE	0x70	/* focus firmware is idle */
+#define OV5640_2_FOCUS_FW_RUN	0x00	/* focus firmware is running */
+#define OV5640_2_FOCUS_FW_FINISH	0x10	/* focus is finished */
+
+#define OV5640_2_REG_AWB_CTRL	0x3406
+
+#define OV5640_2_AWB_GAIN_AUTO	0
+#define OV5640_2_AWB_GAIN_MANUAL	1
+
+#define MIN_SYSCLK		10
+#define MIN_VTS			8
+#define MIN_HTS			8
+#define MIN_SHUTTER		0
+#define MIN_GAIN		0
+
+/* OV5640_2_DEVICE_ID */
+#define OV5640_2_MOD_ID		0x5640
+
+#define AF_FW_PATH	"OV5640_AF_FW.bin"
+
+/* Supported resolutions */
+enum {
+	OV5640_2_RES_QVGA,
+	OV5640_2_RES_DVGA,
+	OV5640_2_RES_320P,
+	OV5640_2_RES_360P,
+	OV5640_2_RES_VGA,
+	OV5640_2_RES_RGB_VGA,
+	OV5640_2_RES_480P,
+	OV5640_2_RES_736x480P,
+	OV5640_2_RES_800x480P,
+	OV5640_2_RES_720P,
+	OV5640_2_RGB565_RES_720P,
+	OV5640_2_RES_1440X720P,
+	OV5640_2_RES_1080P,
+	OV5640_2_RES_1080P_RGB,
+	OV5640_2_RES_1088P,
+	OV5640_2_RES_D3M,
+	OV5640_2_RES_3M,
+	OV5640_2_RES_D5M,
+	OV5640_2_RES_5M,
+};
+#define OV5640_2_RES_5M_SIZE_H		2560
+#define OV5640_2_RES_5M_SIZE_V		1920
+#define OV5640_2_RES_D5M_SIZE_H		2496
+#define OV5640_2_RES_D5M_SIZE_V		1664
+#define OV5640_2_RES_D3M_SIZE_H		2112
+#define OV5640_2_RES_D3M_SIZE_V		1408
+#define OV5640_2_RES_3M_SIZE_H		2048
+#define OV5640_2_RES_3M_SIZE_V		1536
+#define OV5640_2_RES_1088P_SIZE_H		1920
+#define OV5640_2_RES_1088P_SIZE_V		1088
+#define OV5640_2_RES_1080P_SIZE_H		1920
+#define OV5640_2_RES_1080P_SIZE_V		1080
+#define OV5640_2_RES_720P_SIZE_H		1280
+#define OV5640_2_RES_720P_SIZE_V		720
+
+#define OV5640_2_RGB565_RES_720P_SIZE_H		1280
+#define OV5640_2_RGB565_RES_720P_SIZE_V		720
+
+#define OV5640_2_RES_1440X720P_SIZE_H		1440
+#define OV5640_2_RES_1440X720P_SIZE_V		720
+
+#define OV5640_2_RES_480P_SIZE_H		720
+#define OV5640_2_RES_480P_SIZE_V		480
+
+#define OV5640_2_RES_736x480P_SIZE_H		736
+#define OV5640_2_RES_736x480P_SIZE_V		480
+
+#define OV5640_2_RES_VGA_SIZE_H		640
+#define OV5640_2_RES_VGA_SIZE_V		480
+#define OV5640_2_RES_360P_SIZE_H		640
+#define OV5640_2_RES_360P_SIZE_V		360
+#define OV5640_2_RES_320P_SIZE_H		480
+#define OV5640_2_RES_320P_SIZE_V		320
+#define OV5640_2_RES_DVGA_SIZE_H		416
+#define OV5640_2_RES_DVGA_SIZE_V		312
+#define OV5640_2_RES_QVGA_SIZE_H		320
+#define OV5640_2_RES_QVGA_SIZE_V		240
+
+#define OV5640_2_RES_800x480P_SIZE_H		800
+#define OV5640_2_RES_800x480P_SIZE_V		480
+
+
+/* TODO: Definition not available in kernel 3.5 */
+/* Current composing area */
+#define V4L2_SEL_TGT_COMPOSE            0x0100
+
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u16 length;
+	u16 reg;
+	u32 val;	/* value or for read/mod/write */
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct ov5640_2_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	const struct firmware *firmware;
+
+	struct camera_sensor_platform_data *platform_data;
+	int run_mode;
+	int focus_mode;
+	int night_mode;
+	bool focus_mode_change;
+	int color_effect;
+	bool streaming;
+	bool preview_ag_ae;
+	u16 sensor_id;
+	u8 sensor_revision;
+	unsigned int ae_high;
+	unsigned int ae_low;
+	unsigned int preview_shutter;
+	unsigned int preview_gain16;
+	unsigned int average;
+	unsigned int preview_sysclk;
+	unsigned int preview_hts;
+	unsigned int preview_vts;
+	unsigned int res;
+};
+
+struct ov5640_2_priv_data {
+	u32 port;
+	u32 num_of_lane;
+	u32 input_format;
+	u32 raw_bayer_order;
+};
+
+struct ov5640_2_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct ov5640_2_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int code;
+	int fps;
+	int skip_frames;
+	bool used;
+	struct regval_list *regs;
+};
+
+#define OV5640_2_MAX_WRITE_BUF_SIZE	32
+struct ov5640_2_write_buffer {
+	u16 addr;
+	u8 data[OV5640_2_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov5640_2_write_ctrl {
+	int index;
+	struct ov5640_2_write_buffer buffer;
+};
+
+struct ov5640_2_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+#define N_ov5640_2_FMTS ARRAY_SIZE(ov5640_2_formats)
+
+/*
+ * Modes supported by the mt9m114 driver.
+ * Please, keep them in ascending order.
+ */
+static struct ov5640_2_res_struct ov5640_2_res[] = {
+	{
+	.desc	= "QVGA",
+	.res	= OV5640_2_RES_QVGA,
+	.width	= 320,
+	.height	= 240,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "DVGA",
+	.res	= OV5640_2_RES_DVGA,
+	.width	= 416,
+	.height	= 312,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "320P",
+	.res	= OV5640_2_RES_320P,
+	.width	= 480,
+	.height	= 320,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "360P",
+	.res	= OV5640_2_RES_360P,
+	.width	= 640,
+	.height	= 360,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 5,
+	},
+	{
+	.desc	= "VGA",
+	.res	= OV5640_2_RES_VGA,
+	.width	= 640,
+	.height	= 480,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+		.desc	= "VGA_RGB",
+		.res	= OV5640_2_RES_RGB_VGA,
+		.width	= 640,
+		.height	= 480,
+		.code = 0x1008,
+		.fps	= 30,
+		.used	= 0,
+		.regs	= NULL,
+		.skip_frames = 4,
+		},
+	{
+	.desc	= "480P",
+	.res	= OV5640_2_RES_480P,
+	.width	= 720,
+	.height	= 480,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "736x480P",
+	.res	= OV5640_2_RES_736x480P,
+	.width	= 736,
+	.height	= 480,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "800x480p",
+	.res	= OV5640_2_RES_800x480P,
+	.width	= 800,
+	.height = 480,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "720p",
+	.res	= OV5640_2_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+
+	{
+	.desc	= "RGB565_720p",
+	.res	= OV5640_2_RGB565_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.code = 0x1008,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+
+	{
+	.desc	= "1440x720p",
+	.res	= OV5640_2_RES_1440X720P,
+	.width	= 1440,
+	.height	= 720,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "1080P",
+	.res	= OV5640_2_RES_1080P,
+	.width	= 1920,
+	.height	= 1080,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+		.desc	= "1080P",
+		.res	= OV5640_2_RES_1080P_RGB,
+		.width	= 1920,
+		.height	= 1080,
+		.code = 0x1008,
+		.fps	= 30,
+		.used	= 0,
+		.regs	= NULL,
+		.skip_frames = 4,
+		},
+	{
+	.desc	= "1088P",
+	.res	= OV5640_2_RES_1088P,
+	.width	= 1920,
+	.height	= 1088,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "D3M",
+	.res	= OV5640_2_RES_D3M,
+	.width	= 2112,
+	.height	= 1408,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "3M",
+	.res	= OV5640_2_RES_3M,
+	.width	= 2048,
+	.height	= 1536,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "D5M",
+	.res	= OV5640_2_RES_D5M,
+	.width	= 2496,
+	.height	= 1664,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "5M",
+	.res	= OV5640_2_RES_5M,
+	.width	= 2560,
+	.height	= 1920,
+	.code = MEDIA_BUS_FMT_UYVY8_1X16,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+
+};
+#define N_RES (ARRAY_SIZE(ov5640_2_res))
+
+static const struct i2c_device_id ov5640_2_id[] = {
+	{"ov5640-2", 0},
+	{}
+};
+
+static struct misensor_reg const ov5640_2_standby_reg[] = {
+	 {MISENSOR_8BIT,  0x300e, 0x5d},
+	 {MISENSOR_8BIT,  0x3008, 0x42},	/* software powerdown */
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_wakeup_reg[] = {
+	{MISENSOR_8BIT,  0x3008, 0x02},
+	{MISENSOR_8BIT,  0x300e, 0x45},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_normal_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x06},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_sepia_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0xA0},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_negative_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x46},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_bw_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x80},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x80},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_blue_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0xA0},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x40},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_green_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x60},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x60},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* 5M, yuv422, 2lanes, mipi, 12fps */
+static struct misensor_reg const ov5640_2_5M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of input size. value is 2591 */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1927 */
+	{MISENSOR_8BIT, 0x3808, 0x0A},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width, value is 2560 */
+	{MISENSOR_8BIT, 0x380A, 0x07},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1920 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x06},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x08},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0x83},	/* isp ctrl */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0A},
+	{MISENSOR_8BIT, 0x380D, 0xB4},	/* total H-size is 2740 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0xE8},	/* total v-size is 2024 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xE4},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xE4},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x2F},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xFD},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x08},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* D5M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_2_D5M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},	/* X end of input size. value is 2527 */
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1671 */
+	{MISENSOR_8BIT, 0x3808, 0x09},
+	{MISENSOR_8BIT, 0x3809, 0xC0},	/* DVP output H_width, value is 2496 */
+	{MISENSOR_8BIT, 0x380A, 0x06},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1664 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0x83},	/* isp ctrl */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0B},
+	{MISENSOR_8BIT, 0x380D, 0x1C},	/* total H-size is 2844 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0x95},	/* total v-size is 1941 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0x91},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0x91},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x07},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* 3M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_2_3M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of input size. value is 2591 */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1927 */
+	{MISENSOR_8BIT, 0x3808, 0x08},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width, value is 2048 */
+	{MISENSOR_8BIT, 0x380A, 0x06},
+	{MISENSOR_8BIT, 0x380B, 0x00},	/* DVP output V_heigh, value is 1536 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0A},
+	{MISENSOR_8BIT, 0x380D, 0xA0},	/* total H-size is 2720 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0xF6},	/* total v-size is 2038 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xF2},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xF2},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x31},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xFE},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x08},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* D3M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_2_D3M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},	/* X end of input size. value is 2527 */
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1671 */
+	{MISENSOR_8BIT, 0x3808, 0x08},
+	{MISENSOR_8BIT, 0x3809, 0x40},	/* DVP output H_width, value is 2112 */
+	{MISENSOR_8BIT, 0x380A, 0x05},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1408 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xB0},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xB0},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0B},
+	{MISENSOR_8BIT, 0x380D, 0x1C},	/* total H-size is 2844 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0x95},	/* total v-size is 1941 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0x91},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0x91},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x07},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1088p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_1088p_init[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06}, /* disable binning */
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of isp input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF9},	/* Y end of isp input size */
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* 1920 */
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x40},	/* 1088 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0x60},
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0x60},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},
+	{MISENSOR_8BIT, 0x501F, 0x00},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1080p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_1080p_init[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x38},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x06},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},
+	{MISENSOR_8BIT, 0x501F, 0x00},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1080p, rgb565, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_1080p_rgb[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x38},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x06},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x6f},
+	{MISENSOR_8BIT, 0x501F, 0x01},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 720p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_720p_init[] = {
+#ifdef ORIGINAL_SETTINGS
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},	/* X start of input size */
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},	/* Y start of input size */
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},	/* Y end of input size */
+	{MISENSOR_8BIT, 0x3808, 0x05},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width */
+	{MISENSOR_8BIT, 0x380A, 0x02},
+	{MISENSOR_8BIT, 0x380B, 0xD0},	/* DVP output V_heigh */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x97},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x53},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling*/
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},	/* same with 1080p */
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x18},	/* total H-size is 2328 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xA8},	/* total v-size is 1192 */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x66},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x2A},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xA4},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xA4},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+#else  /* FROM JOSH @OV.COM */
+	/* YUV 1280x720, mclk 19.2mhz 60 fps */
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*for mclk=19.2MHz,0x54 */
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0xfa},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x06},
+	{MISENSOR_8BIT,0x3807,0xa9},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0x00},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x64},
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x02},
+	{MISENSOR_8BIT,0x3a03,0xe4},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0xbc},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x72},
+	{MISENSOR_8BIT,0x3a0e,0x01},
+	{MISENSOR_8BIT,0x3a0d,0x02},
+	{MISENSOR_8BIT,0x3a14,0x02},
+	{MISENSOR_8BIT,0x3a15,0xe4},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x0a*/}, /* 0x16 */
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+#endif
+
+};
+
+/* camera: 480p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_480p_init[] = {
+#ifdef ORIGINAL_SETTINGS
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x04},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x3F},
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0xD9},
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xD0},
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x0B},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+#else
+#if 0
+	/* from josh @ov.com */
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x22},/*0x21*/
+	{MISENSOR_8BIT,0x3036,0x8c},/*mclk=19.2MHz,0x70*/
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0x3a},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x07},
+	{MISENSOR_8BIT,0x3807,0x67},
+	{MISENSOR_8BIT,0x3808,0x02},
+	{MISENSOR_8BIT,0x3809,0xd0},
+	{MISENSOR_8BIT,0x380a,0x01},
+	{MISENSOR_8BIT,0x380b,0xe0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x68},
+	{MISENSOR_8BIT,0x380e,0x03},
+	{MISENSOR_8BIT,0x380f,0xd8},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x06},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x03},
+	{MISENSOR_8BIT,0x3a03,0xd8},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0x27},
+	{MISENSOR_8BIT,0x3a0a,0x00},
+	{MISENSOR_8BIT,0x3a0b,0xf6},
+	{MISENSOR_8BIT,0x3a0e,0x03},
+	{MISENSOR_8BIT,0x3a0d,0x04},
+	{MISENSOR_8BIT,0x3a14,0x03},
+	{MISENSOR_8BIT,0x3a15,0xd8},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x22, *0x10*/},
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0xa3},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+#endif
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xD0},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+
+#endif
+
+};
+
+/* camera: 480p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_736x480p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};
+
+/* camera: 320p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_320p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0xE0},
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x40},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x0B},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x68},	/* total h_size is 1896 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/* camera: 360p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_2_360p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},	/* X start of input size */
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},	/* Y start of input size */
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},	/* Y end of input size */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output H_width */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x68},	/* DVP output V_heigh */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x02},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x4837, 0x2C},	/* PCLK PERIOD */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x05},	/* total H-size is 2309 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total v-size is 1200*/
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x68},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x2C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/* camera vga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_2_vga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera vga 30fps, rgb(640x480),----- 2lanes */
+static struct misensor_reg const ov5640_2_vga_rgb_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x6f},
+		{MISENSOR_8BIT, 0x501F, 0x01},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera qvga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_2_qvga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0x40},
+	{MISENSOR_8BIT, 0x380A, 0x00},
+	{MISENSOR_8BIT, 0x380B, 0xF0},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x68},	/* total h_size is 1896 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera dvga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_2_dvga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0xA0},	/* DVP output, value is 416 */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x38},	/* DVP output, value is 312 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x31},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_common[] = {
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_iq[] = {
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_init[] = {
+	/* init software */
+	{MISENSOR_8BIT, 0x3103, 0x11},
+	{MISENSOR_TOK_DELAY, 0, 5},
+	{MISENSOR_8BIT, 0x3008, 0x82},
+	{MISENSOR_TOK_DELAY, 0, 5},
+	{MISENSOR_8BIT, 0x3008, 0x42},	/* software power down */
+	{MISENSOR_8BIT, 0x3103, 0x03},	/* SCCB system control */
+	/* set Frex Vsync href PCLK D[9:6} input */
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},	/* set d[5:0] GPIO[1:0] input */
+	{MISENSOR_8BIT, 0x3034, 0x18},	/* MIPI 8-bit mode*/
+	{MISENSOR_8BIT, 0x3037, 0x13},	/* PLL */
+	{MISENSOR_8BIT, 0x3108, 0x01},	/* system divider */
+	{MISENSOR_8BIT, 0x3630, 0x36},
+	{MISENSOR_8BIT, 0x3631, 0x0E},
+	{MISENSOR_8BIT, 0x3632, 0xE2},
+	{MISENSOR_8BIT, 0x3633, 0x12},
+	{MISENSOR_8BIT, 0x3621, 0xE0},
+	{MISENSOR_8BIT, 0x3704, 0xA0},
+	{MISENSOR_8BIT, 0x3703, 0x5A},
+	{MISENSOR_8BIT, 0x3715, 0x78},
+	{MISENSOR_8BIT, 0x3717, 0x01},
+	{MISENSOR_8BIT, 0x370B, 0x60},
+	{MISENSOR_8BIT, 0x3705, 0x1A},
+	{MISENSOR_8BIT, 0x3905, 0x02},
+	{MISENSOR_8BIT, 0x3906, 0x10},
+	{MISENSOR_8BIT, 0x3901, 0x0A},
+	{MISENSOR_8BIT, 0x3731, 0x12},
+	{MISENSOR_8BIT, 0x3600, 0x08},	/* VCM debug mode */
+	{MISENSOR_8BIT, 0x3601, 0x33},	/* VCM debug mode */
+	{MISENSOR_8BIT, 0x302D, 0x60},	/* system control */
+	{MISENSOR_8BIT, 0x3620, 0x52},
+	{MISENSOR_8BIT, 0x371B, 0x20},
+	{MISENSOR_8BIT, 0x471C, 0x50},
+	{MISENSOR_8BIT, 0x3A13, 0x43},	/* AGC pre-gain 40 = 1x */
+	{MISENSOR_8BIT, 0x3A18, 0x00},	/* gain ceiling */
+	{MISENSOR_8BIT, 0x3A19, 0xF8},	/* gain ceiling */
+	{MISENSOR_8BIT, 0x3635, 0x13},
+	{MISENSOR_8BIT, 0x3636, 0x03},
+	{MISENSOR_8BIT, 0x3634, 0x40},
+	{MISENSOR_8BIT, 0x3622, 0x01},
+	{MISENSOR_8BIT, 0x3C00, 0x04},	/* 50Hz/60Hz */
+	{MISENSOR_8BIT, 0x3C01, 0xB4},	/* 50/60Hz */
+	{MISENSOR_8BIT, 0x3C04, 0x28},	/* threshold for low sum */
+	{MISENSOR_8BIT, 0x3C05, 0x98},	/* threshold for high sum */
+	{MISENSOR_8BIT, 0x3C06, 0x00},	/* light meter 1 threshold high */
+	{MISENSOR_8BIT, 0x3C08, 0x00},	/* light meter 2 threshold high */
+	{MISENSOR_8BIT, 0x3C09, 0x1C},	/* light meter 2 threshold low */
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},	/* sample number high */
+	{MISENSOR_8BIT, 0x3C0B, 0x40},	/* sample number low */
+	/* timing */
+	{MISENSOR_8BIT, 0x3800, 0x00},	/* HS */
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* HS */
+	{MISENSOR_8BIT, 0x3802, 0x00},	/* VS */
+	{MISENSOR_8BIT, 0x3804, 0x0A},	/* HW */
+	{MISENSOR_8BIT, 0x3805, 0x3F},	/* HW */
+	{MISENSOR_8BIT, 0x3810, 0x00},	/* H offset high */
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* H offset low */
+	{MISENSOR_8BIT, 0x3812, 0x00},	/* V offset high */
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3A08, 0x01},	/* B50 */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset 0 */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},	/* system reset 2 */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* clock enable 00 */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* clock enable 2 */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI control 2 lane MIPI on */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},	/* YUV 422 UYVY */
+	{MISENSOR_8BIT, 0x501F, 0x00},	/* ISP YUV 422 */
+	{MISENSOR_8BIT, 0x4407, 0x04},	/* JPEG QS */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	/* ISP control LENC on GAMMA on BPC on WPC on CIP on */
+	{MISENSOR_8BIT, 0x5000, 0xA7},
+	/* AWB */
+	{MISENSOR_8BIT, 0x5180, 0xFF},
+	{MISENSOR_8BIT, 0x5181, 0xF2},
+	{MISENSOR_8BIT, 0x5182, 0x00},
+	{MISENSOR_8BIT, 0x5183, 0x14},
+	{MISENSOR_8BIT, 0x5184, 0x25},
+	{MISENSOR_8BIT, 0x5185, 0x24},
+	{MISENSOR_8BIT, 0x5189, 0x8D},
+	{MISENSOR_8BIT, 0x518A, 0x61},
+	{MISENSOR_8BIT, 0x518C, 0x94},
+	{MISENSOR_8BIT, 0x518B, 0xAF},
+	{MISENSOR_8BIT, 0x5187, 0x17},
+	{MISENSOR_8BIT, 0x5188, 0x0F},
+	{MISENSOR_8BIT, 0x518D, 0x41},
+	{MISENSOR_8BIT, 0x518F, 0x75},
+	{MISENSOR_8BIT, 0x518E, 0x34},
+	{MISENSOR_8BIT, 0x5190, 0x43},
+	{MISENSOR_8BIT, 0x5191, 0xF5},
+	{MISENSOR_8BIT, 0x5192, 0x0A},
+	{MISENSOR_8BIT, 0x5186, 0x16},
+	{MISENSOR_8BIT, 0x5193, 0x70},
+	{MISENSOR_8BIT, 0x5194, 0xF0},
+	{MISENSOR_8BIT, 0x5195, 0xF0},
+	{MISENSOR_8BIT, 0x5196, 0x03},
+	{MISENSOR_8BIT, 0x5197, 0x01},
+	{MISENSOR_8BIT, 0x5198, 0x05},
+	{MISENSOR_8BIT, 0x5199, 0xDB},
+	{MISENSOR_8BIT, 0x519A, 0x04},
+	{MISENSOR_8BIT, 0x519B, 0x00},
+	{MISENSOR_8BIT, 0x519C, 0x08},
+	{MISENSOR_8BIT, 0x519D, 0x20},
+	{MISENSOR_8BIT, 0x519E, 0x38},
+	/* color matrix */
+	{MISENSOR_8BIT, 0x5381, 0x1F},
+	{MISENSOR_8BIT, 0x5382, 0x5C},
+	{MISENSOR_8BIT, 0x5383, 0x05},
+	{MISENSOR_8BIT, 0x5384, 0x03},
+	{MISENSOR_8BIT, 0x5385, 0x6C},
+	{MISENSOR_8BIT, 0x5386, 0x6F},
+	{MISENSOR_8BIT, 0x5387, 0x6E},
+	{MISENSOR_8BIT, 0x5388, 0x62},
+	{MISENSOR_8BIT, 0x5389, 0x0C},
+	{MISENSOR_8BIT, 0x538A, 0x01},
+	{MISENSOR_8BIT, 0x538B, 0x98},
+	/* CIP */
+	{MISENSOR_8BIT, 0x5300, 0x08},	/* sharpen MT th1 */
+	{MISENSOR_8BIT, 0x5301, 0x30},	/* sharpen MT th2 */
+	{MISENSOR_8BIT, 0x5302, 0x18},	/* sharpen MT offset 1 */
+	{MISENSOR_8BIT, 0x5303, 0x0E},	/* sharpen MT offset 2 */
+	{MISENSOR_8BIT, 0x5304, 0x08},	/* DNS threshold 1 */
+	{MISENSOR_8BIT, 0x5305, 0x30},	/* DNS threshold 2 */
+	{MISENSOR_8BIT, 0x5306, 0x08},	/* DNS offset 1 */
+	{MISENSOR_8BIT, 0x5307, 0x16},	/* DNS offset 2 */
+	{MISENSOR_8BIT, 0x5308, 0x00},	/* auto de-noise */
+	{MISENSOR_8BIT, 0x5309, 0x08},	/* sharpen TH th1 */
+	{MISENSOR_8BIT, 0x530A, 0x30},	/* sharpen TH th2 */
+	{MISENSOR_8BIT, 0x530B, 0x04},	/* sharpen TH offset 1 */
+	{MISENSOR_8BIT, 0x530C, 0x06},	/* sharpen TH offset 2 */
+	/* gamma */
+	{MISENSOR_8BIT, 0x5480, 0x01},
+	{MISENSOR_8BIT, 0x5481, 0x08},
+	{MISENSOR_8BIT, 0x5482, 0x14},
+	{MISENSOR_8BIT, 0x5483, 0x28},
+	{MISENSOR_8BIT, 0x5484, 0x51},
+	{MISENSOR_8BIT, 0x5485, 0x65},
+	{MISENSOR_8BIT, 0x5486, 0x71},
+	{MISENSOR_8BIT, 0x5487, 0x7D},
+	{MISENSOR_8BIT, 0x5488, 0x87},
+	{MISENSOR_8BIT, 0x5489, 0x91},
+	{MISENSOR_8BIT, 0x548A, 0x9A},
+	{MISENSOR_8BIT, 0x548B, 0xAA},
+	{MISENSOR_8BIT, 0x548C, 0xB8},
+	{MISENSOR_8BIT, 0x548D, 0xCD},
+	{MISENSOR_8BIT, 0x548E, 0xDD},
+	{MISENSOR_8BIT, 0x548F, 0xEA},
+	{MISENSOR_8BIT, 0x5490, 0x1D},
+	/* UV adjust */
+	{MISENSOR_8BIT, 0x5580, 0x06},	/* sat on contrast on */
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat VV */
+	{MISENSOR_8BIT, 0x5589, 0x10},	/* UV adjust th1 */
+	{MISENSOR_8BIT, 0x558A, 0x00},	/* UV adjust th2[8] */
+	{MISENSOR_8BIT, 0x558B, 0xF8},	/* UV adjust th2[7:0] */
+	{MISENSOR_8BIT, 0x501D, 0x40},	/* enable manual offset of contrast */
+	/* lens correction */
+	{MISENSOR_8BIT, 0x5800, 0x3D},
+	{MISENSOR_8BIT, 0x5801, 0x1E},
+	{MISENSOR_8BIT, 0x5802, 0x15},
+	{MISENSOR_8BIT, 0x5803, 0x17},
+	{MISENSOR_8BIT, 0x5804, 0x1E},
+	{MISENSOR_8BIT, 0x5805, 0x3F},
+	{MISENSOR_8BIT, 0x5806, 0x10},
+	{MISENSOR_8BIT, 0x5807, 0x0A},
+	{MISENSOR_8BIT, 0x5808, 0x07},
+	{MISENSOR_8BIT, 0x5809, 0x07},
+	{MISENSOR_8BIT, 0x580A, 0x0B},
+	{MISENSOR_8BIT, 0x580B, 0x13},
+	{MISENSOR_8BIT, 0x580C, 0x0A},
+	{MISENSOR_8BIT, 0x580D, 0x04},
+	{MISENSOR_8BIT, 0x580E, 0x00},
+	{MISENSOR_8BIT, 0x580F, 0x00},
+	{MISENSOR_8BIT, 0x5810, 0x04},
+	{MISENSOR_8BIT, 0x5811, 0x0C},
+	{MISENSOR_8BIT, 0x5812, 0x0A},
+	{MISENSOR_8BIT, 0x5813, 0x04},
+	{MISENSOR_8BIT, 0x5814, 0x00},
+	{MISENSOR_8BIT, 0x5815, 0x00},
+	{MISENSOR_8BIT, 0x5816, 0x04},
+	{MISENSOR_8BIT, 0x5817, 0x0C},
+	{MISENSOR_8BIT, 0x5818, 0x10},
+	{MISENSOR_8BIT, 0x5819, 0x0B},
+	{MISENSOR_8BIT, 0x581A, 0x07},
+	{MISENSOR_8BIT, 0x581B, 0x07},
+	{MISENSOR_8BIT, 0x581C, 0x0A},
+	{MISENSOR_8BIT, 0x581D, 0x14},
+	{MISENSOR_8BIT, 0x581E, 0x37},
+	{MISENSOR_8BIT, 0x581F, 0x1F},
+	{MISENSOR_8BIT, 0x5820, 0x18},
+	{MISENSOR_8BIT, 0x5821, 0x18},
+	{MISENSOR_8BIT, 0x5822, 0x1F},
+	{MISENSOR_8BIT, 0x5823, 0x2F},
+	{MISENSOR_8BIT, 0x5824, 0x48},
+	{MISENSOR_8BIT, 0x5825, 0x2A},
+	{MISENSOR_8BIT, 0x5826, 0x2C},
+	{MISENSOR_8BIT, 0x5827, 0x08},
+	{MISENSOR_8BIT, 0x5828, 0x66},
+	{MISENSOR_8BIT, 0x5829, 0x0A},
+	{MISENSOR_8BIT, 0x582A, 0x26},
+	{MISENSOR_8BIT, 0x582B, 0x24},
+	{MISENSOR_8BIT, 0x582C, 0x26},
+	{MISENSOR_8BIT, 0x582D, 0x08},
+	{MISENSOR_8BIT, 0x582E, 0x08},
+	{MISENSOR_8BIT, 0x582F, 0x42},
+	{MISENSOR_8BIT, 0x5830, 0x40},
+	{MISENSOR_8BIT, 0x5831, 0x22},
+	{MISENSOR_8BIT, 0x5832, 0x06},
+	{MISENSOR_8BIT, 0x5833, 0x0A},
+	{MISENSOR_8BIT, 0x5834, 0x24},
+	{MISENSOR_8BIT, 0x5835, 0x24},
+	{MISENSOR_8BIT, 0x5836, 0x26},
+	{MISENSOR_8BIT, 0x5837, 0x06},
+	{MISENSOR_8BIT, 0x5838, 0x48},
+	{MISENSOR_8BIT, 0x5839, 0x08},
+	{MISENSOR_8BIT, 0x583A, 0x28},
+	{MISENSOR_8BIT, 0x583B, 0x06},
+	{MISENSOR_8BIT, 0x583C, 0x4A},
+	{MISENSOR_8BIT, 0x583D, 0xCE},
+	/* AE */
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	{MISENSOR_8BIT, 0x3A0F, 0x30},	/* stable in high */
+	{MISENSOR_8BIT, 0x3A10, 0x28},	/* stable in low */
+	{MISENSOR_8BIT, 0x3A1B, 0x30},	/* stable out high */
+	{MISENSOR_8BIT, 0x3A1E, 0x26},	/* stable out low */
+	{MISENSOR_8BIT, 0x3A11, 0x60},	/* fast zone high */
+	{MISENSOR_8BIT, 0x3A1F, 0x14},	/* fast zone low */
+	{MISENSOR_8BIT, 0x350A, 0x00},
+	{MISENSOR_8BIT, 0x350B, 0x32},	/* default gain 50 */
+	{MISENSOR_8BIT, 0x3500, 0x00},
+	{MISENSOR_8BIT, 0x3501, 0x03},
+	{MISENSOR_8BIT, 0x3502, 0xE8},	/* default shutter 1000 */
+	/* BLC */
+	{MISENSOR_8BIT, 0x4000, 0x89},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4002, 0x45},
+	{MISENSOR_8BIT, 0x4003, 0x08},
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	{MISENSOR_8BIT, 0x4009, 0x10},
+	{MISENSOR_8BIT, 0x4202, 0x00},	/* stream on */
+	{MISENSOR_8BIT, 0x4202, 0x0F},	/* stream off */
+	{MISENSOR_8BIT, 0x3008, 0x02},	/* wake up */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_2_focus_init[] = {
+	{MISENSOR_8BIT, 0x3022, 0x00},
+	{MISENSOR_8BIT, 0x3023, 0x00},
+	{MISENSOR_8BIT, 0x3024, 0x00},
+	{MISENSOR_8BIT, 0x3025, 0x00},
+	{MISENSOR_8BIT, 0x3026, 0x00},
+	{MISENSOR_8BIT, 0x3027, 0x00},
+	{MISENSOR_8BIT, 0x3028, 0x00},
+	{MISENSOR_8BIT, 0x3029, 0x7F},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_2_800x480p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x03},
+	{MISENSOR_8BIT, 0x3809, 0x20},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x12 /*0x14*/},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0c /*0x30*/},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_2_rgb565_1280x720p_init[] = {
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*for mclk=19.2MHz,0x54 */
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x41},
+	{MISENSOR_8BIT,0x3821,0x07},
+	{MISENSOR_8BIT,0x3814,0x31},
+	{MISENSOR_8BIT,0x3815,0x31},
+	{MISENSOR_8BIT,0x3800,0x00},
+	{MISENSOR_8BIT,0x3801,0x00},
+	{MISENSOR_8BIT,0x3802,0x00},
+	{MISENSOR_8BIT,0x3803,0xfa},
+	{MISENSOR_8BIT,0x3804,0x0a},
+	{MISENSOR_8BIT,0x3805,0x3f},
+	{MISENSOR_8BIT,0x3806,0x06},
+	{MISENSOR_8BIT,0x3807,0xa9},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0x00},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x07},
+	{MISENSOR_8BIT,0x380d,0x64},
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x00},
+	{MISENSOR_8BIT,0x3612,0x29},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x52},
+	{MISENSOR_8BIT,0x370c,0x03},
+	{MISENSOR_8BIT,0x3a02,0x02},
+	{MISENSOR_8BIT,0x3a03,0xe4},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0xbc},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x72},
+	{MISENSOR_8BIT,0x3a0e,0x01},
+	{MISENSOR_8BIT,0x3a0d,0x02},
+	{MISENSOR_8BIT,0x3a14,0x02},
+	{MISENSOR_8BIT,0x3a15,0xe4},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x02},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x6f /*0x32*/},
+	{MISENSOR_8BIT,0x501f,0x01 /*0x00*/},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0c /*0x0a*/}, /* 0x16 */
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};
+
+/* yuv 30fps 19.2MHz 2-lanes */
+static struct misensor_reg const ov5640_2_1440x720p_init[] = {
+
+	{MISENSOR_8BIT,0x3103,0x11},
+	{MISENSOR_8BIT,0x3008,0x82},
+	{MISENSOR_8BIT,0x3008,0x42},
+	{MISENSOR_8BIT,0x3103,0x03},
+	{MISENSOR_8BIT,0x3017,0x00},
+	{MISENSOR_8BIT,0x3018,0x00},
+	{MISENSOR_8BIT,0x3034,0x18},
+	{MISENSOR_8BIT,0x3035,0x11},
+	{MISENSOR_8BIT,0x3036,0x69}, /*mclk=19.2MHz*/
+	{MISENSOR_8BIT,0x3037,0x13},
+	{MISENSOR_8BIT,0x3108,0x01},
+	{MISENSOR_8BIT,0x303b,0x14},
+	{MISENSOR_8BIT,0x303c,0x11},
+	{MISENSOR_8BIT,0x303d,0x17},
+	{MISENSOR_8BIT,0x3630,0x36},
+	{MISENSOR_8BIT,0x3631,0x0e},
+	{MISENSOR_8BIT,0x3632,0xe2},
+	{MISENSOR_8BIT,0x3633,0x12},
+	{MISENSOR_8BIT,0x3621,0xe0},
+	{MISENSOR_8BIT,0x3704,0xa0},
+	{MISENSOR_8BIT,0x3703,0x5a},
+	{MISENSOR_8BIT,0x3715,0x78},
+	{MISENSOR_8BIT,0x3717,0x01},
+	{MISENSOR_8BIT,0x370b,0x60},
+	{MISENSOR_8BIT,0x3705,0x1a},
+	{MISENSOR_8BIT,0x3905,0x02},
+	{MISENSOR_8BIT,0x3906,0x10},
+	{MISENSOR_8BIT,0x3901,0x0a},
+	{MISENSOR_8BIT,0x3731,0x12},
+	{MISENSOR_8BIT,0x3600,0x08},
+	{MISENSOR_8BIT,0x3601,0x33},
+	{MISENSOR_8BIT,0x302d,0x60},
+	{MISENSOR_8BIT,0x3620,0x52},
+	{MISENSOR_8BIT,0x371b,0x20},
+	{MISENSOR_8BIT,0x471c,0x50},
+	{MISENSOR_8BIT,0x3a13,0x43},
+	{MISENSOR_8BIT,0x3a18,0x00},
+	{MISENSOR_8BIT,0x3a19,0xf8},
+	{MISENSOR_8BIT,0x3635,0x13},
+	{MISENSOR_8BIT,0x3636,0x03},
+	{MISENSOR_8BIT,0x3634,0x40},
+	{MISENSOR_8BIT,0x3622,0x01},
+	{MISENSOR_8BIT,0x3c01,0x34},
+	{MISENSOR_8BIT,0x3c04,0x28},
+	{MISENSOR_8BIT,0x3c05,0x98},
+	{MISENSOR_8BIT,0x3c06,0x00},
+	{MISENSOR_8BIT,0x3c07,0x07},
+	{MISENSOR_8BIT,0x3c08,0x00},
+	{MISENSOR_8BIT,0x3c09,0x1c},
+	{MISENSOR_8BIT,0x3c0a,0x9c},
+	{MISENSOR_8BIT,0x3c0b,0x40},
+	{MISENSOR_8BIT,0x3820,0x40},
+	{MISENSOR_8BIT,0x3821,0x06},
+	{MISENSOR_8BIT,0x3814,0x11},
+	{MISENSOR_8BIT,0x3815,0x11},
+	{MISENSOR_8BIT,0x3800,0x02},
+	{MISENSOR_8BIT,0x3801,0x40},
+	{MISENSOR_8BIT,0x3802,0x02},
+	{MISENSOR_8BIT,0x3803,0x66},
+	{MISENSOR_8BIT,0x3804,0x07},
+	{MISENSOR_8BIT,0x3805,0xff},
+	{MISENSOR_8BIT,0x3806,0x05},
+	{MISENSOR_8BIT,0x3807,0x3d},
+	{MISENSOR_8BIT,0x3808,0x05},
+	{MISENSOR_8BIT,0x3809,0xa0},
+	{MISENSOR_8BIT,0x380a,0x02},
+	{MISENSOR_8BIT,0x380b,0xd0},
+	{MISENSOR_8BIT,0x380c,0x0a}, /*09*/
+	{MISENSOR_8BIT,0x380d,0x58}, /*c8*/
+	{MISENSOR_8BIT,0x380e,0x02},
+	{MISENSOR_8BIT,0x380f,0xe4},
+	{MISENSOR_8BIT,0x3810,0x00},
+	{MISENSOR_8BIT,0x3811,0x10},
+	{MISENSOR_8BIT,0x3812,0x00},
+	{MISENSOR_8BIT,0x3813,0x04},
+	{MISENSOR_8BIT,0x3618,0x04},
+	{MISENSOR_8BIT,0x3612,0x2b},
+	{MISENSOR_8BIT,0x3708,0x64},
+	{MISENSOR_8BIT,0x3709,0x12},
+	{MISENSOR_8BIT,0x370c,0x00},
+	{MISENSOR_8BIT,0x3a02,0x04},
+	{MISENSOR_8BIT,0x3a03,0x60},
+	{MISENSOR_8BIT,0x3a08,0x01},
+	{MISENSOR_8BIT,0x3a09,0x50},
+	{MISENSOR_8BIT,0x3a0a,0x01},
+	{MISENSOR_8BIT,0x3a0b,0x18},
+	{MISENSOR_8BIT,0x3a0e,0x03},
+	{MISENSOR_8BIT,0x3a0d,0x04},
+	{MISENSOR_8BIT,0x3a14,0x04},
+	{MISENSOR_8BIT,0x3a15,0x60},
+	{MISENSOR_8BIT,0x4001,0x02},
+	{MISENSOR_8BIT,0x4004,0x06},
+	{MISENSOR_8BIT,0x3000,0x00},
+	{MISENSOR_8BIT,0x3002,0x1c},
+	{MISENSOR_8BIT,0x3004,0xff},
+	{MISENSOR_8BIT,0x3006,0xc3},
+	{MISENSOR_8BIT,0x300e,0x45},
+	{MISENSOR_8BIT,0x302e,0x08},
+	{MISENSOR_8BIT,0x4300,0x32},
+	{MISENSOR_8BIT,0x501f,0x00},
+	{MISENSOR_8BIT,0x4713,0x02},
+	{MISENSOR_8BIT,0x4407,0x04},
+	{MISENSOR_8BIT,0x440e,0x00},
+	{MISENSOR_8BIT,0x460b,0x37},
+	{MISENSOR_8BIT,0x460c,0x20},
+	{MISENSOR_8BIT,0x4837,0x0a},
+	{MISENSOR_8BIT,0x3824,0x04},
+	{MISENSOR_8BIT,0x5000,0xa7},
+	{MISENSOR_8BIT,0x5001,0x83},
+	{MISENSOR_8BIT,0x5180,0xff},
+	{MISENSOR_8BIT,0x5181,0xf2},
+	{MISENSOR_8BIT,0x5182,0x00},
+	{MISENSOR_8BIT,0x5183,0x14},
+	{MISENSOR_8BIT,0x5184,0x25},
+	{MISENSOR_8BIT,0x5185,0x24},
+	{MISENSOR_8BIT,0x5186,0x09},
+	{MISENSOR_8BIT,0x5187,0x09},
+	{MISENSOR_8BIT,0x5188,0x09},
+	{MISENSOR_8BIT,0x5189,0x75},
+	{MISENSOR_8BIT,0x518a,0x54},
+	{MISENSOR_8BIT,0x518b,0xe0},
+	{MISENSOR_8BIT,0x518c,0xb2},
+	{MISENSOR_8BIT,0x518d,0x42},
+	{MISENSOR_8BIT,0x518e,0x3d},
+	{MISENSOR_8BIT,0x518f,0x56},
+	{MISENSOR_8BIT,0x5190,0x46},
+	{MISENSOR_8BIT,0x5191,0xf8},
+	{MISENSOR_8BIT,0x5192,0x04},
+	{MISENSOR_8BIT,0x5193,0x70},
+	{MISENSOR_8BIT,0x5194,0xf0},
+	{MISENSOR_8BIT,0x5195,0xf0},
+	{MISENSOR_8BIT,0x5196,0x03},
+	{MISENSOR_8BIT,0x5197,0x01},
+	{MISENSOR_8BIT,0x5198,0x04},
+	{MISENSOR_8BIT,0x5199,0x12},
+	{MISENSOR_8BIT,0x519a,0x04},
+	{MISENSOR_8BIT,0x519b,0x00},
+	{MISENSOR_8BIT,0x519c,0x06},
+	{MISENSOR_8BIT,0x519d,0x82},
+	{MISENSOR_8BIT,0x519e,0x38},
+	{MISENSOR_8BIT,0x5381,0x1e},
+	{MISENSOR_8BIT,0x5382,0x5b},
+	{MISENSOR_8BIT,0x5383,0x08},
+	{MISENSOR_8BIT,0x5384,0x0a},
+	{MISENSOR_8BIT,0x5385,0x7e},
+	{MISENSOR_8BIT,0x5386,0x88},
+	{MISENSOR_8BIT,0x5387,0x7c},
+	{MISENSOR_8BIT,0x5388,0x6c},
+	{MISENSOR_8BIT,0x5389,0x10},
+	{MISENSOR_8BIT,0x538a,0x01},
+	{MISENSOR_8BIT,0x538b,0x98},
+	{MISENSOR_8BIT,0x5300,0x08},
+	{MISENSOR_8BIT,0x5301,0x30},
+	{MISENSOR_8BIT,0x5302,0x10},
+	{MISENSOR_8BIT,0x5303,0x00},
+	{MISENSOR_8BIT,0x5304,0x08},
+	{MISENSOR_8BIT,0x5305,0x30},
+	{MISENSOR_8BIT,0x5306,0x08},
+	{MISENSOR_8BIT,0x5307,0x16},
+	{MISENSOR_8BIT,0x5309,0x08},
+	{MISENSOR_8BIT,0x530a,0x30},
+	{MISENSOR_8BIT,0x530b,0x04},
+	{MISENSOR_8BIT,0x530c,0x06},
+	{MISENSOR_8BIT,0x5480,0x01},
+	{MISENSOR_8BIT,0x5481,0x08},
+	{MISENSOR_8BIT,0x5482,0x14},
+	{MISENSOR_8BIT,0x5483,0x28},
+	{MISENSOR_8BIT,0x5484,0x51},
+	{MISENSOR_8BIT,0x5485,0x65},
+	{MISENSOR_8BIT,0x5486,0x71},
+	{MISENSOR_8BIT,0x5487,0x7d},
+	{MISENSOR_8BIT,0x5488,0x87},
+	{MISENSOR_8BIT,0x5489,0x91},
+	{MISENSOR_8BIT,0x548a,0x9a},
+	{MISENSOR_8BIT,0x548b,0xaa},
+	{MISENSOR_8BIT,0x548c,0xb8},
+	{MISENSOR_8BIT,0x548d,0xcd},
+	{MISENSOR_8BIT,0x548e,0xdd},
+	{MISENSOR_8BIT,0x548f,0xea},
+	{MISENSOR_8BIT,0x5490,0x1d},
+	{MISENSOR_8BIT,0x5580,0x02},
+	{MISENSOR_8BIT,0x5583,0x40},
+	{MISENSOR_8BIT,0x5584,0x10},
+	{MISENSOR_8BIT,0x5589,0x10},
+	{MISENSOR_8BIT,0x558a,0x00},
+	{MISENSOR_8BIT,0x558b,0xf8},
+	{MISENSOR_8BIT,0x5800,0x23},
+	{MISENSOR_8BIT,0x5801,0x14},
+	{MISENSOR_8BIT,0x5802,0x0f},
+	{MISENSOR_8BIT,0x5803,0x0f},
+	{MISENSOR_8BIT,0x5804,0x12},
+	{MISENSOR_8BIT,0x5805,0x26},
+	{MISENSOR_8BIT,0x5806,0x0c},
+	{MISENSOR_8BIT,0x5807,0x08},
+	{MISENSOR_8BIT,0x5808,0x05},
+	{MISENSOR_8BIT,0x5809,0x05},
+	{MISENSOR_8BIT,0x580a,0x08},
+	{MISENSOR_8BIT,0x580b,0x0d},
+	{MISENSOR_8BIT,0x580c,0x08},
+	{MISENSOR_8BIT,0x580d,0x03},
+	{MISENSOR_8BIT,0x580e,0x00},
+	{MISENSOR_8BIT,0x580f,0x00},
+	{MISENSOR_8BIT,0x5810,0x03},
+	{MISENSOR_8BIT,0x5811,0x09},
+	{MISENSOR_8BIT,0x5812,0x07},
+	{MISENSOR_8BIT,0x5813,0x03},
+	{MISENSOR_8BIT,0x5814,0x00},
+	{MISENSOR_8BIT,0x5815,0x01},
+	{MISENSOR_8BIT,0x5816,0x03},
+	{MISENSOR_8BIT,0x5817,0x08},
+	{MISENSOR_8BIT,0x5818,0x0d},
+	{MISENSOR_8BIT,0x5819,0x08},
+	{MISENSOR_8BIT,0x581a,0x05},
+	{MISENSOR_8BIT,0x581b,0x06},
+	{MISENSOR_8BIT,0x581c,0x08},
+	{MISENSOR_8BIT,0x581d,0x0e},
+	{MISENSOR_8BIT,0x581e,0x29},
+	{MISENSOR_8BIT,0x581f,0x17},
+	{MISENSOR_8BIT,0x5820,0x11},
+	{MISENSOR_8BIT,0x5821,0x11},
+	{MISENSOR_8BIT,0x5822,0x15},
+	{MISENSOR_8BIT,0x5823,0x28},
+	{MISENSOR_8BIT,0x5824,0x46},
+	{MISENSOR_8BIT,0x5825,0x26},
+	{MISENSOR_8BIT,0x5826,0x08},
+	{MISENSOR_8BIT,0x5827,0x26},
+	{MISENSOR_8BIT,0x5828,0x64},
+	{MISENSOR_8BIT,0x5829,0x26},
+	{MISENSOR_8BIT,0x582a,0x24},
+	{MISENSOR_8BIT,0x582b,0x22},
+	{MISENSOR_8BIT,0x582c,0x24},
+	{MISENSOR_8BIT,0x582d,0x24},
+	{MISENSOR_8BIT,0x582e,0x06},
+	{MISENSOR_8BIT,0x582f,0x22},
+	{MISENSOR_8BIT,0x5830,0x40},
+	{MISENSOR_8BIT,0x5831,0x42},
+	{MISENSOR_8BIT,0x5832,0x24},
+	{MISENSOR_8BIT,0x5833,0x26},
+	{MISENSOR_8BIT,0x5834,0x24},
+	{MISENSOR_8BIT,0x5835,0x22},
+	{MISENSOR_8BIT,0x5836,0x22},
+	{MISENSOR_8BIT,0x5837,0x26},
+	{MISENSOR_8BIT,0x5838,0x44},
+	{MISENSOR_8BIT,0x5839,0x24},
+	{MISENSOR_8BIT,0x583a,0x26},
+	{MISENSOR_8BIT,0x583b,0x28},
+	{MISENSOR_8BIT,0x583c,0x42},
+	{MISENSOR_8BIT,0x583d,0xce},
+	{MISENSOR_8BIT,0x5025,0x00},
+	{MISENSOR_8BIT,0x3a0f,0x30},
+	{MISENSOR_8BIT,0x3a10,0x28},
+	{MISENSOR_8BIT,0x3a1b,0x30},
+	{MISENSOR_8BIT,0x3a1e,0x26},
+	{MISENSOR_8BIT,0x3a11,0x60},
+	{MISENSOR_8BIT,0x3a1f,0x14},
+	{MISENSOR_8BIT,0x3008,0x02},
+	{MISENSOR_TOK_TERM, 0, 0}
+
+};
+#endif
diff --git a/include/linux/atomisp.h b/include/linux/atomisp.h
new file mode 100644
index 0000000..1712bdb
--- /dev/null
+++ b/include/linux/atomisp.h
@@ -0,0 +1,890 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef _ATOM_ISP_H
+#define _ATOM_ISP_H
+
+#include <linux/types.h>
+#include <linux/version.h>
+
+#define ATOMISP_CSS_VERSION_15	KERNEL_VERSION(1, 5, 0)
+#define ATOMISP_CSS_VERSION_17	KERNEL_VERSION(1, 7, 0)
+#define ATOMISP_CSS_VERSION_20	KERNEL_VERSION(2, 0, 0)
+
+/*ISP binary running mode*/
+#define CI_MODE_PREVIEW		0x8000
+#define CI_MODE_VIDEO		0x4000
+#define CI_MODE_STILL_CAPTURE	0x2000
+#define CI_MODE_CONTINUOUS	0x1000
+#define CI_MODE_NONE		0x0000
+
+#define OUTPUT_MODE_FILE 0x0100
+#define OUTPUT_MODE_TEXT 0x0200
+
+//uncomment the below line to see timestamps for the important functions
+//#define TIMING
+
+#ifdef TIMING
+        #define TIMING_ENTER printk("TIMING: %s: ENTRY \n", __func__);
+        #define TIMING_END printk("TIMING: %s: EXIT \n", __func__);
+#else
+        #define TIMING_ENTER
+        #define TIMING_END
+#endif
+
+/* Configuration used by Bayer noise reduction and YCC noise reduction */
+struct atomisp_nr_config {
+	/* [gain] Strength of noise reduction for Bayer NR (Used by Bayer NR) */
+	unsigned int bnr_gain;
+	/* [gain] Strength of noise reduction for YCC NR (Used by YCC NR) */
+	unsigned int ynr_gain;
+	/* [intensity] Sensitivity of Edge (Used by Bayer NR) */
+	unsigned int direction;
+	/* [intensity] coring threshold for Cb (Used by YCC NR) */
+	unsigned int threshold_cb;
+	/* [intensity] coring threshold for Cr (Used by YCC NR) */
+	unsigned int threshold_cr;
+};
+
+/* Temporal noise reduction configuration */
+struct atomisp_tnr_config {
+	unsigned int gain;	 /* [gain] Strength of NR */
+	unsigned int threshold_y;/* [intensity] Motion sensitivity for Y */
+	unsigned int threshold_uv;/* [intensity] Motion sensitivity for U/V */
+};
+
+/* Histogram. This contains num_elements values of type unsigned int.
+ * The data pointer is a DDR pointer (virtual address).
+ */
+struct atomisp_histogram {
+	unsigned int num_elements;
+	void __user *data;
+};
+
+enum atomisp_ob_mode {
+	atomisp_ob_mode_none,
+	atomisp_ob_mode_fixed,
+	atomisp_ob_mode_raster
+};
+
+/* Optical black level configuration */
+struct atomisp_ob_config {
+	/* Obtical black level mode (Fixed / Raster) */
+	enum atomisp_ob_mode mode;
+	/* [intensity] optical black level for GR (relevant for fixed mode) */
+	unsigned int level_gr;
+	/* [intensity] optical black level for R (relevant for fixed mode) */
+	unsigned int level_r;
+	/* [intensity] optical black level for B (relevant for fixed mode) */
+	unsigned int level_b;
+	/* [intensity] optical black level for GB (relevant for fixed mode) */
+	unsigned int level_gb;
+	/* [BQ] 0..63 start position of OB area (relevant for raster mode) */
+	unsigned short start_position;
+	/* [BQ] start..63 end position of OB area (relevant for raster mode) */
+	unsigned short end_position;
+};
+
+/* Edge enhancement (sharpen) configuration */
+struct atomisp_ee_config {
+	/* [gain] The strength of sharpness. u5_11 */
+	unsigned int gain;
+	/* [intensity] The threshold that divides noises from edge. u8_8 */
+	unsigned int threshold;
+	/* [gain] The strength of sharpness in pell-mell area. u5_11 */
+	unsigned int detail_gain;
+};
+
+struct atomisp_3a_output {
+	int ae_y;
+	int awb_cnt;
+	int awb_gr;
+	int awb_r;
+	int awb_b;
+	int awb_gb;
+	int af_hpf1;
+	int af_hpf2;
+};
+
+enum atomisp_calibration_type {
+	calibration_type1,
+	calibration_type2,
+	calibration_type3
+};
+
+struct atomisp_calibration_group {
+	unsigned int size;
+	unsigned int type;
+	unsigned short *calb_grp_values;
+};
+
+struct atomisp_gc_config {
+	__u16 gain_k1;
+	__u16 gain_k2;
+};
+
+struct atomisp_3a_config {
+	unsigned int ae_y_coef_r;	/* [gain] Weight of R for Y */
+	unsigned int ae_y_coef_g;	/* [gain] Weight of G for Y */
+	unsigned int ae_y_coef_b;	/* [gain] Weight of B for Y */
+	unsigned int awb_lg_high_raw;	/* [intensity]
+					   AWB level gate high for raw */
+	unsigned int awb_lg_low;	/* [intensity] AWB level gate low */
+	unsigned int awb_lg_high;	/* [intensity] AWB level gate high */
+	int af_fir1_coef[7];	/* [factor] AF FIR coefficients of fir1 */
+	int af_fir2_coef[7];	/* [factor] AF FIR coefficients of fir2 */
+};
+
+/* structure that describes the 3A and DIS grids shared with 3A lib*/
+struct atomisp_grid_info {
+	/* ISP input size that is visible for user */
+	unsigned int isp_in_width;
+	unsigned int isp_in_height;
+	/* 3A statistics grid: */
+	unsigned int s3a_width;
+	unsigned int s3a_height;
+	unsigned int s3a_bqs_per_grid_cell;
+	/* DIS grid: */
+	unsigned int dis_width;  /* also used for vertical projections */
+	unsigned int dis_aligned_width;
+	unsigned int dis_height; /* also used for horizontal projections */
+	unsigned int dis_aligned_height;
+	unsigned int dis_bqs_per_grid_cell;
+	unsigned int dis_hor_coef_num;
+	unsigned int dis_ver_coef_num;
+};
+
+struct atomisp_dis_vector {
+	int x;
+	int y;
+};
+
+struct atomisp_dis_coefficients {
+	struct atomisp_grid_info grid_info;
+	short __user *vertical_coefficients;
+	short __user *horizontal_coefficients;
+};
+
+struct atomisp_dis_statistics {
+	struct atomisp_grid_info grid_info;
+	int __user *vertical_projections;
+	int __user *horizontal_projections;
+};
+
+struct atomisp_3a_statistics {
+	struct atomisp_grid_info  grid_info;
+	struct atomisp_3a_output __user *data;
+};
+
+/**
+ * struct atomisp_cont_capture_conf - continuous capture parameters
+ * @num_captures: number of still images to capture
+ * @skip_frames: number of frames to skip between 2 captures
+ * @offset: offset in ring buffer to start capture
+ *
+ * For example, to capture 1 frame from past, current, and 1 from future
+ * and skip one frame between each capture, parameters would be:
+ * num_captures:3
+ * skip_frames:1
+ * offset:-2
+ */
+
+struct atomisp_cont_capture_conf {
+	int num_captures;
+	unsigned int skip_frames;
+	int offset;
+	__u32 reserved[5];
+};
+
+/* White Balance (Gain Adjust) */
+struct atomisp_wb_config {
+	unsigned int integer_bits;
+	unsigned int gr;	/* unsigned <integer_bits>.<16-integer_bits> */
+	unsigned int r;		/* unsigned <integer_bits>.<16-integer_bits> */
+	unsigned int b;		/* unsigned <integer_bits>.<16-integer_bits> */
+	unsigned int gb;	/* unsigned <integer_bits>.<16-integer_bits> */
+};
+
+/* Color Space Conversion settings */
+struct atomisp_cc_config {
+	unsigned int fraction_bits;
+	int matrix[3 * 3];	/* RGB2YUV Color matrix, signed
+				   <13-fraction_bits>.<fraction_bits> */
+};
+
+/* De pixel noise configuration */
+struct atomisp_de_config {
+	unsigned int pixelnoise;
+	unsigned int c1_coring_threshold;
+	unsigned int c2_coring_threshold;
+};
+
+/* Chroma enhancement */
+struct atomisp_ce_config {
+	unsigned int uv_level_min;
+	unsigned int uv_level_max;
+};
+
+/* Defect pixel correction configuration */
+struct atomisp_dp_config {
+	/* [intensity] The threshold of defect Pixel Correction, representing
+	 * the permissible difference of intensity between one pixel and its
+	 * surrounding pixels. Smaller values result in more frequent pixel
+	 * corrections. u0_16
+	 */
+	unsigned int threshold;
+	/* [gain] The sensitivity of mis-correction. ISP will miss a lot of
+	 * defects if the value is set too large. u8_8
+	 */
+	unsigned int gain;
+};
+
+/* XNR threshold */
+struct atomisp_xnr_config {
+	unsigned int threshold;
+};
+
+struct atomisp_parm {
+	struct atomisp_grid_info info;
+	struct atomisp_wb_config wb_config;
+	struct atomisp_cc_config cc_config;
+	struct atomisp_ob_config ob_config;
+	struct atomisp_de_config de_config;
+	struct atomisp_ce_config ce_config;
+	struct atomisp_dp_config dp_config;
+	struct atomisp_nr_config nr_config;
+	struct atomisp_ee_config ee_config;
+	struct atomisp_tnr_config tnr_config;
+};
+
+struct atomisp_parameters {
+	struct atomisp_wb_config *wb_config;
+	struct atomisp_cc_config *cc_config;
+	struct atomisp_ob_config *ob_config;
+	struct atomisp_de_config *de_config;
+	struct atomisp_ce_config *ce_config;
+	struct atomisp_dp_config *dp_config;
+	struct atomisp_nr_config *nr_config;
+	struct atomisp_ee_config *ee_config;
+	struct atomisp_tnr_config *tnr_config;
+	struct atomisp_shading_table *shading_table;
+	struct atomisp_morph_table *morph_table;
+	struct atomisp_macc_config *macc_config;
+	struct atomisp_gamma_table *gamma_table;
+	struct atomisp_ctc_table *ctc_table;
+	struct atomisp_xnr_config *xnr_config;
+	struct atomisp_gc_config *gc_config;
+	struct atomisp_3a_config *a3a_config;
+};
+
+#define ATOMISP_GAMMA_TABLE_SIZE        1024
+struct atomisp_gamma_table {
+	unsigned short data[ATOMISP_GAMMA_TABLE_SIZE];
+};
+
+/* Morphing table for advanced ISP.
+ * Each line of width elements takes up COORD_TABLE_EXT_WIDTH elements
+ * in memory.
+ */
+#define ATOMISP_MORPH_TABLE_NUM_PLANES  6
+struct atomisp_morph_table {
+	unsigned int height;
+	unsigned int width;	/* number of valid elements per line */
+	unsigned short __user *coordinates_x[ATOMISP_MORPH_TABLE_NUM_PLANES];
+	unsigned short __user *coordinates_y[ATOMISP_MORPH_TABLE_NUM_PLANES];
+};
+
+#define ATOMISP_NUM_SC_COLORS	4
+#define ATOMISP_SC_FLAG_QUERY	(1 << 0)
+
+struct atomisp_shading_table {
+	/*
+	 * If flag ATOMISP_SC_FLAG_QUERY is set, IOCTL will only query current
+	 * LSC status and return, otherwise it will set LSC according to
+	 * userspace's input.
+	 */
+	__u8 flags;
+	/*
+	 * If ATOMISP_SC_FLAG_QUERY is set, enable is output parameter,
+	 * otherwise it is an input parameter and will enable/disable LSC
+	 * engine
+	 */
+	__u8 enable;
+	/* native sensor resolution */
+	__u32 sensor_width;
+	__u32 sensor_height;
+	/* number of data points per line per color (bayer quads) */
+	__u32 width;
+	/* number of lines of data points per color (bayer quads) */
+	__u32 height;
+	/* bits of fraction part for shading table values */
+	__u32 fraction_bits;
+	/* one table for each color (use sh_css_sc_color to index) */
+	__u16 __user *data[ATOMISP_NUM_SC_COLORS];
+};
+
+struct atomisp_makernote_info {
+	/* bits 31-16: numerator, bits 15-0: denominator */
+	unsigned int focal_length;
+	/* bits 31-16: numerator, bits 15-0: denominator*/
+	unsigned int f_number_curr;
+	/*
+	* bits 31-24: max f-number numerator
+	* bits 23-16: max f-number denominator
+	* bits 15-8: min f-number numerator
+	* bits 7-0: min f-number denominator
+	*/
+	unsigned int f_number_range;
+};
+
+/* parameter for MACC */
+#define ATOMISP_NUM_MACC_AXES           16
+struct atomisp_macc_table {
+	short data[4 * ATOMISP_NUM_MACC_AXES];
+};
+
+struct atomisp_macc_config {
+	int color_effect;
+	struct atomisp_macc_table table;
+};
+
+/* Parameter for ctc parameter control */
+#define ATOMISP_CTC_TABLE_SIZE          1024
+struct atomisp_ctc_table {
+	unsigned short data[ATOMISP_CTC_TABLE_SIZE];
+};
+
+/* Parameter for overlay image loading */
+struct atomisp_overlay {
+	/* the frame containing the overlay data The overlay frame width should
+	 * be the multiples of 2*ISP_VEC_NELEMS. The overlay frame height
+	 * should be the multiples of 2.
+	 */
+	struct v4l2_framebuffer *frame;
+	/* Y value of overlay background */
+	unsigned char bg_y;
+	/* U value of overlay background */
+	char bg_u;
+	/* V value of overlay background */
+	char bg_v;
+	/* the blending percent of input data for Y subpixels */
+	unsigned char blend_input_perc_y;
+	/* the blending percent of input data for U subpixels */
+	unsigned char blend_input_perc_u;
+	/* the blending percent of input data for V subpixels */
+	unsigned char blend_input_perc_v;
+	/* the blending percent of overlay data for Y subpixels */
+	unsigned char blend_overlay_perc_y;
+	/* the blending percent of overlay data for U subpixels */
+	unsigned char blend_overlay_perc_u;
+	/* the blending percent of overlay data for V subpixels */
+	unsigned char blend_overlay_perc_v;
+	/* the overlay start x pixel position on output frame It should be the
+	   multiples of 2*ISP_VEC_NELEMS. */
+	unsigned int overlay_start_x;
+	/* the overlay start y pixel position on output frame It should be the
+	   multiples of 2. */
+	unsigned int overlay_start_y;
+};
+
+/* Sensor resolution specific data for AE calculation.*/
+struct atomisp_sensor_mode_data {
+	unsigned int coarse_integration_time_min;
+	unsigned int coarse_integration_time_max_margin;
+	unsigned int fine_integration_time_min;
+	unsigned int fine_integration_time_max_margin;
+	unsigned int fine_integration_time_def;
+	unsigned int frame_length_lines;
+	unsigned int line_length_pck;
+	unsigned int read_mode;
+	unsigned int vt_pix_clk_freq_mhz;
+	unsigned int crop_horizontal_start; /* Sensor crop start cord. (x0,y0)*/
+	unsigned int crop_vertical_start;
+	unsigned int crop_horizontal_end; /* Sensor crop end cord. (x1,y1)*/
+	unsigned int crop_vertical_end;
+	unsigned int output_width; /* input size to ISP after binning/scaling */
+	unsigned int output_height;
+	uint8_t binning_factor_x; /* horizontal binning factor used */
+	uint8_t binning_factor_y; /* vertical binning factor used */
+	uint8_t reserved[2];
+};
+
+struct atomisp_exposure {
+	unsigned int integration_time[8];
+	unsigned int shutter_speed[8];
+	unsigned int gain[4];
+	unsigned int aperture;
+};
+
+/* For texture streaming. */
+struct atomisp_bc_video_package {
+	int ioctl_cmd;
+	int device_id;
+	int inputparam;
+	int outputparam;
+};
+
+enum atomisp_focus_hp {
+	ATOMISP_FOCUS_HP_IN_PROGRESS = (1U << 2),
+	ATOMISP_FOCUS_HP_COMPLETE    = (2U << 2),
+	ATOMISP_FOCUS_HP_FAILED      = (3U << 2)
+};
+
+/* Masks */
+#define ATOMISP_FOCUS_STATUS_MOVING           (1U << 0)
+#define ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE (1U << 1)
+#define ATOMISP_FOCUS_STATUS_HOME_POSITION    (3U << 2)
+
+enum atomisp_camera_port {
+	ATOMISP_CAMERA_PORT_PRIMARY,
+	ATOMISP_CAMERA_PORT_SECONDARY,
+	ATOMISP_CAMERA_PORT_THIRD,
+	ATOMISP_CAMERA_NR_PORTS
+};
+
+/* Flash modes. Default is off.
+ * Setting a flash to TORCH or INDICATOR mode will automatically
+ * turn it on. Setting it to FLASH mode will not turn on the flash
+ * until the FLASH_STROBE command is sent. */
+enum atomisp_flash_mode {
+	ATOMISP_FLASH_MODE_OFF,
+	ATOMISP_FLASH_MODE_FLASH,
+	ATOMISP_FLASH_MODE_TORCH,
+	ATOMISP_FLASH_MODE_INDICATOR,
+};
+
+/* Flash statuses, used by atomisp driver to check before starting
+ * flash and after having started flash. */
+enum atomisp_flash_status {
+	ATOMISP_FLASH_STATUS_OK,
+	ATOMISP_FLASH_STATUS_HW_ERROR,
+	ATOMISP_FLASH_STATUS_INTERRUPTED,
+	ATOMISP_FLASH_STATUS_TIMEOUT,
+};
+
+/* Frame status. This is used to detect corrupted frames and flash
+ * exposed frames. Usually, the first 2 frames coming out of the sensor
+ * are corrupted. When using flash, the frame before and the frame after
+ * the flash exposed frame may be partially exposed by flash. The ISP
+ * statistics for these frames should not be used by the 3A library.
+ * The frame status value can be found in the "reserved" field in the
+ * v4l2_buffer struct. */
+enum atomisp_frame_status {
+	ATOMISP_FRAME_STATUS_OK,
+	ATOMISP_FRAME_STATUS_CORRUPTED,
+	ATOMISP_FRAME_STATUS_FLASH_EXPOSED,
+	ATOMISP_FRAME_STATUS_FLASH_PARTIAL,
+	ATOMISP_FRAME_STATUS_FLASH_FAILED,
+};
+
+enum atomisp_acc_type {
+	ATOMISP_ACC_STANDALONE,	/* Stand-alone acceleration */
+	ATOMISP_ACC_OUTPUT,	/* Accelerator stage on output frame */
+	ATOMISP_ACC_VIEWFINDER	/* Accelerator stage on viewfinder frame */
+};
+
+enum atomisp_acc_arg_type {
+	ATOMISP_ACC_ARG_SCALAR_IN,    /* Scalar input argument */
+	ATOMISP_ACC_ARG_SCALAR_OUT,   /* Scalar output argument */
+	ATOMISP_ACC_ARG_SCALAR_IO,    /* Scalar in/output argument */
+	ATOMISP_ACC_ARG_PTR_IN,	     /* Pointer input argument */
+	ATOMISP_ACC_ARG_PTR_OUT,	     /* Pointer output argument */
+	ATOMISP_ACC_ARG_PTR_IO,	     /* Pointer in/output argument */
+	ATOMISP_ARG_PTR_NOFLUSH,  /* Pointer argument will not be flushed */
+	ATOMISP_ARG_PTR_STABLE,   /* Pointer input argument that is stable */
+	ATOMISP_ACC_ARG_FRAME	     /* Frame argument */
+};
+
+/** ISP memories, isp2300 */
+enum atomisp_acc_memory {
+	ATOMISP_ACC_MEMORY_PMEM = 0,
+	ATOMISP_ACC_MEMORY_DMEM,
+	ATOMISP_ACC_MEMORY_VMEM,
+	ATOMISP_ACC_MEMORY_VAMEM1,
+	ATOMISP_ACC_MEMORY_VAMEM2,
+	ATOMISP_ACC_NR_MEMORY		/* Must be last */
+};
+
+struct atomisp_sp_arg {
+	enum atomisp_acc_arg_type type;	/* Type  of SP argument */
+	void                    *value;	/* Value of SP argument */
+	unsigned int             size;	/* Size  of SP argument */
+};
+
+/* Acceleration API */
+
+/* For CSS 1.0 only */
+struct atomisp_acc_fw_arg {
+	unsigned int fw_handle;
+	unsigned int index;
+	void __user *value;
+	size_t size;
+};
+
+/*
+ * Set arguments after first mapping with ATOMISP_IOC_ACC_S_MAPPED_ARG.
+ * For CSS 1.5 only.
+ */
+struct atomisp_acc_s_mapped_arg {
+	unsigned int fw_handle;
+	__u32 memory;			/* one of enum atomisp_acc_memory */
+	size_t length;
+	unsigned long css_ptr;
+};
+
+struct atomisp_acc_fw_abort {
+	unsigned int fw_handle;
+	/* Timeout in us */
+	unsigned int timeout;
+};
+
+struct atomisp_acc_fw_load {
+	unsigned int size;
+	unsigned int fw_handle;
+	void __user *data;
+};
+
+/*
+ * Load firmware to specified pipeline.
+ * For CSS 1.5 only.
+ */
+struct atomisp_acc_fw_load_to_pipe {
+	__u32 flags;			/* Flags, see below for valid values */
+	unsigned int fw_handle;		/* Handle, filled by kernel. */
+	__u32 size;			/* Firmware binary size */
+	void __user *data;		/* Pointer to firmware */
+	__u32 type;			/* Binary type */
+	__u32 reserved[3];		/* Set to zero */
+};
+
+#define ATOMISP_ACC_FW_LOAD_FL_PREVIEW		(1 << 0)
+#define ATOMISP_ACC_FW_LOAD_FL_COPY		(1 << 1)
+#define ATOMISP_ACC_FW_LOAD_FL_VIDEO		(1 << 2)
+#define ATOMISP_ACC_FW_LOAD_FL_CAPTURE		(1 << 3)
+#define ATOMISP_ACC_FW_LOAD_FL_ACC		(1 << 4)
+
+#define ATOMISP_ACC_FW_LOAD_TYPE_NONE		0 /* Normal binary: don't use */
+#define ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT		1 /* Stage on output */
+#define ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER	2 /* Stage on viewfinder */
+#define ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE	3 /* Stand-alone acceleration */
+
+struct atomisp_acc_map {
+	__u32 flags;			/* Flags, see list below */
+	__u32 length;			/* Length of data in bytes */
+	void __user *user_ptr;		/* Pointer into user space */
+	unsigned long css_ptr;		/* Pointer into CSS address space */
+	__u32 reserved[4];		/* Set to zero */
+};
+
+#define ATOMISP_MAP_FLAG_NOFLUSH	0x0001	/* Do not flush cache */
+
+/*
+ * V4L2 private internal data interface.
+ * -----------------------------------------------------------------------------
+ * struct v4l2_private_int_data - request private data stored in video device
+ * internal memory.
+ * @size: sanity check to ensure userspace's buffer fits whole private data.
+ *	  If not, kernel will make partial copy (or nothing if @size == 0).
+ *	  @size is always corrected for the minimum necessary if IOCTL returns
+ *	  no error.
+ * @data: pointer to userspace buffer.
+ */
+struct v4l2_private_int_data {
+	__u32 size;
+	void __user *data;
+	__u32 reserved[2];
+};
+
+/*Private IOCTLs for ISP */
+#define ATOMISP_IOC_G_XNR \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 0, int)
+#define ATOMISP_IOC_S_XNR \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 1, int)
+#define ATOMISP_IOC_G_NR \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 2, struct atomisp_nr_config)
+#define ATOMISP_IOC_S_NR \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 3, struct atomisp_nr_config)
+#define ATOMISP_IOC_G_TNR \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 4, struct atomisp_tnr_config)
+#define ATOMISP_IOC_S_TNR \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 5, struct atomisp_tnr_config)
+#define ATOMISP_IOC_G_HISTOGRAM \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 6, struct atomisp_histogram)
+#define ATOMISP_IOC_S_HISTOGRAM \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 7, struct atomisp_histogram)
+#define ATOMISP_IOC_G_BLACK_LEVEL_COMP \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 8, struct atomisp_ob_config)
+#define ATOMISP_IOC_S_BLACK_LEVEL_COMP \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 9, struct atomisp_ob_config)
+#define ATOMISP_IOC_G_EE \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 12, struct atomisp_ee_config)
+#define ATOMISP_IOC_S_EE \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 13, struct atomisp_ee_config)
+/* Digital Image Stabilization:
+ * 1. get dis statistics: reads DIS statistics from ISP (every frame)
+ * 2. set dis coefficients: set DIS filter coefficients (one time)
+ * 3. set dis motion vecotr: set motion vector (result of DIS, every frame)
+ */
+#define ATOMISP_IOC_G_DIS_STAT \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 14, struct atomisp_dis_statistics)
+#define ATOMISP_IOC_S_DIS_COEFS \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 15, struct atomisp_dis_coefficients)
+#define ATOMISP_IOC_S_DIS_VECTOR \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 16, struct atomisp_dis_vector)
+
+#define ATOMISP_IOC_G_3A_STAT \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 17, struct atomisp_3a_statistics)
+#define ATOMISP_IOC_G_ISP_PARM \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 18, struct atomisp_parm)
+#define ATOMISP_IOC_S_ISP_PARM \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 19, struct atomisp_parm)
+#define ATOMISP_IOC_G_ISP_GAMMA \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 20, struct atomisp_gamma_table)
+#define ATOMISP_IOC_S_ISP_GAMMA \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 21, struct atomisp_gamma_table)
+#define ATOMISP_IOC_G_ISP_GDC_TAB \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 22, struct atomisp_morph_table)
+#define ATOMISP_IOC_S_ISP_GDC_TAB \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 23, struct atomisp_morph_table)
+#define ATOMISP_IOC_ISP_MAKERNOTE \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 24, struct atomisp_makernote_info)
+
+/* macc parameter control*/
+#define ATOMISP_IOC_G_ISP_MACC \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 25, struct atomisp_macc_config)
+#define ATOMISP_IOC_S_ISP_MACC \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 26, struct atomisp_macc_config)
+
+/* Defect pixel detection & Correction */
+#define ATOMISP_IOC_G_ISP_BAD_PIXEL_DETECTION \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 27, struct atomisp_dp_config)
+#define ATOMISP_IOC_S_ISP_BAD_PIXEL_DETECTION \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 28, struct atomisp_dp_config)
+
+/* False Color Correction */
+#define ATOMISP_IOC_G_ISP_FALSE_COLOR_CORRECTION \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 29, struct atomisp_de_config)
+#define ATOMISP_IOC_S_ISP_FALSE_COLOR_CORRECTION \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 30, struct atomisp_de_config)
+
+/* ctc parameter control */
+#define ATOMISP_IOC_G_ISP_CTC \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 31, struct atomisp_ctc_table)
+#define ATOMISP_IOC_S_ISP_CTC \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 32, struct atomisp_ctc_table)
+
+/* white balance Correction */
+#define ATOMISP_IOC_G_ISP_WHITE_BALANCE \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 33, struct atomisp_wb_config)
+#define ATOMISP_IOC_S_ISP_WHITE_BALANCE \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 34, struct atomisp_wb_config)
+
+/* fpn table loading */
+#define ATOMISP_IOC_S_ISP_FPN_TABLE \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 35, struct v4l2_framebuffer)
+
+/* overlay image loading */
+#define ATOMISP_IOC_G_ISP_OVERLAY \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 36, struct atomisp_overlay)
+#define ATOMISP_IOC_S_ISP_OVERLAY \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 37, struct atomisp_overlay)
+
+/* bcd driver bridge */
+#define ATOMISP_IOC_CAMERA_BRIDGE \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 38, struct atomisp_bc_video_package)
+
+/* Sensor resolution specific info for AE */
+#define ATOMISP_IOC_G_SENSOR_MODE_DATA \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 39, struct atomisp_sensor_mode_data)
+
+#define ATOMISP_IOC_S_EXPOSURE \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 40, struct atomisp_exposure)
+
+/* sensor calibration registers group */
+#define ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 41, struct atomisp_calibration_group)
+
+/* white balance Correction */
+#define ATOMISP_IOC_G_3A_CONFIG \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 42, struct atomisp_3a_config)
+#define ATOMISP_IOC_S_3A_CONFIG \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 43, struct atomisp_3a_config)
+
+/* Accelerate ioctls */
+#define ATOMISP_IOC_ACC_LOAD \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 44, struct atomisp_acc_fw_load)
+
+#define ATOMISP_IOC_ACC_UNLOAD \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 45, unsigned int)
+
+/* For CSS 1.0 only */
+#define ATOMISP_IOC_ACC_S_ARG \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 46, struct atomisp_acc_fw_arg)
+
+#define ATOMISP_IOC_ACC_START \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 47, unsigned int)
+
+#define ATOMISP_IOC_ACC_WAIT \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 48, unsigned int)
+
+#define ATOMISP_IOC_ACC_ABORT \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 49, struct atomisp_acc_fw_abort)
+
+/* sensor OTP memory read */
+#define ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 50, struct v4l2_private_int_data)
+
+/* LCS (shading) table write */
+#define ATOMISP_IOC_S_ISP_SHD_TAB \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 51, struct atomisp_shading_table)
+
+/* Gamma Correction */
+#define ATOMISP_IOC_G_ISP_GAMMA_CORRECTION \
+	_IOR('v', BASE_VIDIOC_PRIVATE + 52, struct atomisp_gc_config)
+
+#define ATOMISP_IOC_S_ISP_GAMMA_CORRECTION \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 53, struct atomisp_gc_config)
+
+#define ATOMISP_IOC_ACC_DESTAB \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 54, struct atomisp_acc_fw_arg)
+
+/*
+ * Reserved ioctls. We have customer implementing it internally.
+ * We can't use both numbers to not cause ABI conflict.
+ * Anyway, those ioctls are hacks and not implemented by us:
+ *
+ * #define ATOMISP_IOC_G_SENSOR_REG \
+ *	_IOW('v', BASE_VIDIOC_PRIVATE + 55, struct atomisp_sensor_regs)
+ * #define ATOMISP_IOC_S_SENSOR_REG \
+ *	_IOW('v', BASE_VIDIOC_PRIVATE + 56, struct atomisp_sensor_regs)
+ */
+
+/* motor internal memory read */
+#define ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 57, struct v4l2_private_int_data)
+
+/*
+ * Ioctls to map and unmap user buffers to CSS address space for acceleration.
+ * User fills fields length and user_ptr and sets other fields to zero,
+ * kernel may modify the flags and sets css_ptr.
+ */
+#define ATOMISP_IOC_ACC_MAP \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 58, struct atomisp_acc_map)
+
+/* User fills fields length, user_ptr, and css_ptr and zeroes other fields. */
+#define ATOMISP_IOC_ACC_UNMAP \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 59, struct atomisp_acc_map)
+
+#define ATOMISP_IOC_ACC_S_MAPPED_ARG \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 60, struct atomisp_acc_s_mapped_arg)
+
+#define ATOMISP_IOC_S_PARAMETERS \
+	_IOW('v', BASE_VIDIOC_PRIVATE + 61, struct atomisp_parameters)
+
+#define ATOMISP_IOC_S_CONT_CAPTURE_CONFIG \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 62, struct atomisp_cont_capture_conf)
+
+#define ATOMISP_IOC_ACC_LOAD_TO_PIPE \
+	_IOWR('v', BASE_VIDIOC_PRIVATE + 63, struct atomisp_acc_fw_load_to_pipe)
+
+#define ATOMISP_FW_LOAD \
+       _IOWR('v', BASE_VIDIOC_PRIVATE + 102, int)
+
+
+#define V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION \
+	(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC \
+	(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_CID_ATOMISP_VIDEO_STABLIZATION \
+	(V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_CID_ATOMISP_FIXED_PATTERN_NR \
+	(V4L2_CID_PRIVATE_BASE + 3)
+#define V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION \
+	(V4L2_CID_PRIVATE_BASE + 4)
+#define V4L2_CID_ATOMISP_LOW_LIGHT \
+	(V4L2_CID_PRIVATE_BASE + 5)
+
+/* Camera class:
+ * Exposure, Flash and privacy (indicator) light controls, to be upstreamed */
+#define V4L2_CID_CAMERA_LASTP1             (V4L2_CID_CAMERA_CLASS_BASE + 1024)
+
+#define V4L2_CID_FOCAL_ABSOLUTE            (V4L2_CID_CAMERA_LASTP1 + 0)
+#define V4L2_CID_FNUMBER_ABSOLUTE          (V4L2_CID_CAMERA_LASTP1 + 1)
+#define V4L2_CID_FNUMBER_RANGE             (V4L2_CID_CAMERA_LASTP1 + 2)
+
+/* Flash related CIDs, see also:
+ * http://linuxtv.org/downloads/v4l-dvb-apis/extended-controls.html\
+ * #flash-controls */
+
+/* Request a number of flash-exposed frames. The frame status can be
+ * found in the reserved field in the v4l2_buffer struct. */
+#define V4L2_CID_REQUEST_FLASH             (V4L2_CID_FLASH_CLASS_BASE + 13)
+/* Query flash driver status. See enum atomisp_flash_status above. */
+#define V4L2_CID_FLASH_STATUS              (V4L2_CID_FLASH_CLASS_BASE + 14)
+/* Set the flash mode (see enum atomisp_flash_mode) */
+#define V4L2_CID_FLASH_MODE                (V4L2_CID_FLASH_CLASS_BASE + 15)
+
+/* VCM slew control */
+#define V4L2_CID_VCM_SLEW                  (V4L2_CID_CAMERA_LASTP1 + 11)
+/* VCM step time */
+#define V4L2_CID_VCM_TIMEING               (V4L2_CID_CAMERA_LASTP1 + 12)
+/* sensor test pattern */
+//Redefiniton of v4l2-core function in kernel 3.8
+//#define V4L2_CID_TEST_PATTERN              (V4L2_CID_CAMERA_LASTP1 + 13)
+
+/* Query Focus Status */
+#define V4L2_CID_FOCUS_STATUS              (V4L2_CID_CAMERA_LASTP1 + 14)
+
+/* Query sensor's binning factor */
+#define V4L2_CID_BIN_FACTOR_HORZ	   (V4L2_CID_CAMERA_LASTP1 + 15)
+#define V4L2_CID_BIN_FACTOR_VERT	   (V4L2_CID_CAMERA_LASTP1 + 16)
+
+/* number of frames to skip at stream start */
+#define V4L2_CID_G_SKIP_FRAMES		   (V4L2_CID_CAMERA_LASTP1 + 17)
+
+/* Query sensor's 2A status */
+#define V4L2_CID_2A_STATUS                 (V4L2_CID_CAMERA_LASTP1 + 18)
+#define V4L2_2A_STATUS_AE_READY            (1 << 0)
+#define V4L2_2A_STATUS_AWB_READY           (1 << 1)
+
+#define V4L2_CID_FMT_AUTO			(V4L2_CID_CAMERA_LASTP1 + 19)
+#define V4L2_CID_RUN_MODE			(V4L2_CID_CAMERA_LASTP1 + 20)
+#define V4L2_CID_ENABLE_VFPP			(V4L2_CID_CAMERA_LASTP1 + 21)
+
+#define ATOMISP_RUN_MODE_VIDEO			1
+#define ATOMISP_RUN_MODE_STILL_CAPTURE		2
+#define ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE	3
+#define ATOMISP_RUN_MODE_PREVIEW		4
+
+#define V4L2_BUF_FLAG_BUFFER_INVALID       0x0400
+#define V4L2_BUF_FLAG_BUFFER_VALID         0x0800
+
+#define V4L2_BUF_TYPE_VIDEO_CAPTURE_ION  (V4L2_BUF_TYPE_PRIVATE + 1024)
+
+#define V4L2_EVENT_ATOMISP_3A_STATS_READY  (V4L2_EVENT_PRIVATE_START + 1)
+
+/* Nonstandard color effects for V4L2_CID_COLORFX */
+enum {
+	V4L2_COLORFX_SKIN_WHITEN_LOW = 1001,
+	V4L2_COLORFX_SKIN_WHITEN_HIGH = 1002,
+};
+
+#endif /* _ATOM_ISP_H */
diff --git a/include/linux/atomisp_platform.h b/include/linux/atomisp_platform.h
new file mode 100644
index 0000000..244aae0
--- /dev/null
+++ b/include/linux/atomisp_platform.h
@@ -0,0 +1,140 @@
+/*
+ * Support for Medifield PNW Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#ifndef ATOMISP_PLATFORM_H_
+#define ATOMISP_PLATFORM_H_
+
+#include <linux/i2c.h>
+#include <linux/sfi.h>
+#include <media/v4l2-subdev.h>
+#include "atomisp.h"
+
+enum atomisp_bayer_order {
+	atomisp_bayer_order_grbg,
+	atomisp_bayer_order_rggb,
+	atomisp_bayer_order_bggr,
+	atomisp_bayer_order_gbrg
+};
+
+enum atomisp_input_format {
+	ATOMISP_INPUT_FORMAT_YUV420_8_LEGACY,/* 8 bits per subpixel (legacy) */
+	ATOMISP_INPUT_FORMAT_YUV420_8, /* 8 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_YUV420_10,/* 10 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_YUV422_8, /* UYVY..UVYV, 8 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_YUV422_10,/* UYVY..UVYV, 10 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_444,  /* BGR..BGR, 4 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_555,  /* BGR..BGR, 5 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_565,  /* BGR..BGR, 5 bits B and $, 6 bits G */
+	ATOMISP_INPUT_FORMAT_RGB_666,  /* BGR..BGR, 6 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RGB_888,  /* BGR..BGR, 8 bits per subpixel */
+	ATOMISP_INPUT_FORMAT_RAW_6,    /* RAW data, 6 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_7,    /* RAW data, 7 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_8,    /* RAW data, 8 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_10,   /* RAW data, 10 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_12,   /* RAW data, 12 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_14,   /* RAW data, 14 bits per pixel */
+	ATOMISP_INPUT_FORMAT_RAW_16,   /* RAW data, 16 bits per pixel */
+	ATOMISP_INPUT_FORMAT_BINARY_8, /* Binary byte stream. */
+};
+
+enum intel_v4l2_subdev_type {
+	RAW_CAMERA = 1,
+	SOC_CAMERA = 2,
+	CAMERA_MOTOR = 3,
+	LED_FLASH = 4,
+	XENON_FLASH = 5,
+	FILE_INPUT = 6,
+	TEST_PATTERN = 7,
+};
+
+struct intel_v4l2_subdev_id {
+	char name[17];
+	enum intel_v4l2_subdev_type type;
+	enum atomisp_camera_port    port;
+	int num_lanes;
+};
+
+struct intel_v4l2_subdev_i2c_board_info {
+	struct i2c_board_info board_info;
+	int i2c_adapter_id;
+};
+
+struct intel_v4l2_subdev_table {
+	struct intel_v4l2_subdev_i2c_board_info v4l2_subdev;
+	enum intel_v4l2_subdev_type type;
+	enum atomisp_camera_port port;
+	int num_lanes;
+};
+
+struct atomisp_platform_data {
+	struct intel_v4l2_subdev_table *subdevs;
+};
+
+struct camera_sensor_platform_data {
+	int (*gpio_ctrl)(struct v4l2_subdev *subdev, int flag);
+	int (*power_ctrl)(struct v4l2_subdev *subdev, int flag);
+	int (*csi_cfg)(struct v4l2_subdev *subdev, int flag);
+	bool (*low_fps)(void);
+	int (*platform_init)(struct i2c_client *);
+	int (*platform_deinit)(void);
+};
+
+struct camera_af_platform_data {
+	int (*power_ctrl)(struct v4l2_subdev *subdev, int flag);
+};
+
+const struct camera_af_platform_data *camera_get_af_platform_data(void);
+
+struct camera_mipi_info {
+	enum atomisp_camera_port        port;
+	unsigned int                    num_lanes;
+	struct atomisp_sensor_mode_data data;
+};
+
+extern const struct atomisp_platform_data *atomisp_get_platform_data(void);
+
+/* NOTE: Most of below constants could come from platform data.
+ *  * To be fixed when appropriate ACPI support comes.
+ *   */
+#define VLV2_PMC_CLK_BASE_ADDRESS       0xfed03060
+#define PLT_CLK_CTL_OFFSET(x)           (0x04 * (x))
+
+#define CLK_CONFG_BIT_POS               0
+#define CLK_CONFG_BIT_LEN               2
+#define CLK_CONFG_D3_GATED              0
+#define CLK_CONFG_FORCE_ON              1
+#define CLK_CONFG_FORCE_OFF             2
+
+#define CLK_FREQ_TYPE_BIT_POS           2
+#define CLK_FREQ_TYPE_BIT_LEN           1
+#define CLK_FREQ_TYPE_XTAL              0       /* 25 MHz */
+#define CLK_FREQ_TYPE_PLL               1       /* 19.2 MHz */
+
+#define MAX_CLK_COUNT                   6
+
+extern struct atomisp_platform_data *__intel_get_v4l2_subdev_table(void);
+
+int byt_plat_set_clock_freq(int clk_num, int freq_type);
+int byt_plat_get_clock_freq(int clk_num);
+int byt_plat_configure_clock(int clk_num, u32 conf);
+int byt_plat_get_clock_status(int clk_num);
+int byt_plat_clk_init(void);
+
+#endif /* ATOMISP_PLATFORM_H_ */
